1
00:00:00,000 --> 00:00:02,910
If you're interested in learning
about blockchain, this is the

2
00:00:02,910 --> 00:00:06,840
course for you. Patrick Collins
is a veteran software engineer

3
00:00:06,960 --> 00:00:10,470
and longtime finance industry
developer. Be sure to leave a

4
00:00:10,470 --> 00:00:12,660
comment with something you
learned from this course.

5
00:00:12,870 --> 00:00:17,550
Welcome to the ultimate solidity
smart contract and blockchain

6
00:00:17,550 --> 00:00:20,940
Developer course, JavaScript
addition, we recently did a

7
00:00:20,940 --> 00:00:24,690
version of this video in Python
that has over 2 million views

8
00:00:24,690 --> 00:00:28,140
right now making it the most
watched smart contract tutorial

9
00:00:28,170 --> 00:00:31,050
on the planet. We've learned a
ton from doing that first

10
00:00:31,050 --> 00:00:34,110
course. And if you love the
Python language, definitely be

11
00:00:34,110 --> 00:00:36,600
sure to check that one out.
We've taken all the learnings

12
00:00:36,600 --> 00:00:39,810
we've got from making that first
course, wrapped it up and put it

13
00:00:39,810 --> 00:00:42,780
into this JavaScript video for
you. If you're looking to get

14
00:00:42,780 --> 00:00:46,260
started in web three blockchain
smart contracts or any of these

15
00:00:46,260 --> 00:00:50,310
terms, this is the course for
you. And it's for anybody and

16
00:00:50,310 --> 00:00:53,610
everybody, no matter your
experience level in programming

17
00:00:53,640 --> 00:00:57,240
or in blockchain. Ideally, you
know, a little bit of JavaScript

18
00:00:57,270 --> 00:01:00,900
before starting this. But if you
don't, no worries, we will help

19
00:01:00,900 --> 00:01:03,390
you along the way. And in case
you do want to learn a little

20
00:01:03,390 --> 00:01:05,880
bit of JavaScript before
starting here, there are some

21
00:01:05,880 --> 00:01:09,390
fantastic courses on Free Code
Camp to learn more, but you

22
00:01:09,390 --> 00:01:12,720
absolutely don't have to. And
really, any experience with any

23
00:01:12,720 --> 00:01:15,600
object oriented programming
language will work, right. So if

24
00:01:15,600 --> 00:01:18,510
you're brand new to coding, or
if you're brand new to

25
00:01:18,510 --> 00:01:22,080
blockchain, this is exactly
where you should be. And if you

26
00:01:22,080 --> 00:01:24,810
already know a lot about
blockchain or coding, this

27
00:01:24,810 --> 00:01:29,070
course will give you even more
deep fundamentals on the space.

28
00:01:29,250 --> 00:01:32,940
So welcome to the edge of the
rabbit hole. So for those of you

29
00:01:32,940 --> 00:01:35,430
who don't know, my name is
Patrick Collins. I'm a smart

30
00:01:35,430 --> 00:01:38,490
contract engineer, developer
advocate on the chain link

31
00:01:38,490 --> 00:01:43,560
protocol. And I live in breed
smart contracts. I also make

32
00:01:43,560 --> 00:01:46,230
YouTube videos on my own
channel, medium Twitter threads

33
00:01:46,230 --> 00:01:49,740
and more. teaching people about
smart contracts about coding and

34
00:01:49,740 --> 00:01:53,700
about this new technology. I
love helping developers learn,

35
00:01:53,730 --> 00:01:56,910
grow and learn about this new
Advent. That's blockchain and

36
00:01:56,910 --> 00:01:59,730
smart contracts. And I'll be
taking you on your journey to

37
00:01:59,730 --> 00:02:03,450
becoming a blockchain expert and
Wizard of the smart contract

38
00:02:03,450 --> 00:02:06,420
developing world. And even if
you don't want to become a

39
00:02:06,420 --> 00:02:10,710
developer, the first section our
blockchain basics, will give you

40
00:02:10,740 --> 00:02:14,040
a lot of fundamental knowledge
about how blockchain and smart

41
00:02:14,040 --> 00:02:18,030
contracts, even work. I am so
excited for you to be here. And

42
00:02:18,030 --> 00:02:21,480
I hope you enjoy the journey.
This is a data dump, passion

43
00:02:21,480 --> 00:02:24,660
educational project of
everything I've learned working

44
00:02:24,690 --> 00:02:28,560
in this space. And I am 100%
certain that if you follow

45
00:02:28,560 --> 00:02:31,650
along, you'll come out the other
side of this, armed with the

46
00:02:31,650 --> 00:02:35,130
knowledge to be a positive force
in this incredible industry,

47
00:02:35,190 --> 00:02:38,700
solidity and smart contract
developers are massively in

48
00:02:38,700 --> 00:02:43,770
demand with an average salary of
being around $145,000 a year,

49
00:02:43,980 --> 00:02:47,040
there is massive economic
opportunity from learning this

50
00:02:47,040 --> 00:02:50,820
course. And this technology has
the ability to revolutionize

51
00:02:50,940 --> 00:02:54,270
everything that we interact
with, and you can be one of the

52
00:02:54,270 --> 00:02:58,650
pioneers ushering in this new
age. In our courses. We already

53
00:02:58,650 --> 00:03:01,710
have a track record of giving
people these educational needs

54
00:03:01,830 --> 00:03:04,950
and sending them into their
careers in the blockchain and

55
00:03:04,950 --> 00:03:08,370
smart contract space. And we are
going to give you all of the

56
00:03:08,370 --> 00:03:11,880
cutting edge tools and how to
use them including working with

57
00:03:11,880 --> 00:03:16,830
things like D phi NF TS Dows,
ERC 20s upgradable, smart

58
00:03:16,830 --> 00:03:19,590
contracts and more. We're going
to teach you the skills

59
00:03:19,590 --> 00:03:22,830
necessary to build defy
applications like Ave synthetics

60
00:03:22,830 --> 00:03:27,180
and compound, billion dollar
decentralized applications, or

61
00:03:27,210 --> 00:03:30,900
massively successful NFT
projects like crypto punks, or

62
00:03:30,900 --> 00:03:35,010
board apes. Dow is like maker
Dow or developer, Dow and any of

63
00:03:35,010 --> 00:03:38,040
the amazing things you've seen
in the cryptocurrency world. In

64
00:03:38,040 --> 00:03:40,800
learning these skills, you will
have all these economic

65
00:03:40,800 --> 00:03:44,790
opportunities at your fingertips
and the ability to be a pioneer

66
00:03:44,820 --> 00:03:48,120
in completely changing the way
we interact with each other. In

67
00:03:48,120 --> 00:03:51,120
a fundamental way. Building
decentralized smart contract

68
00:03:51,120 --> 00:03:54,810
applications is building a world
that's more accountable a world

69
00:03:54,810 --> 00:03:58,260
with unbreakable promises, a
faster, more efficient,

70
00:03:58,260 --> 00:04:00,780
financially free world, a
collaborative community,

71
00:04:00,780 --> 00:04:04,080
combining the prowess of
philosophy and technology into a

72
00:04:04,080 --> 00:04:08,100
new system. We'll learn more
about the purpose and the value

73
00:04:08,130 --> 00:04:11,280
of smart contracts and
decentralized applications in

74
00:04:11,310 --> 00:04:14,490
lesson one of this course, and
why they're so exciting. Finish

75
00:04:14,490 --> 00:04:17,460
this course. And you'll be
ready. So again, I want to give

76
00:04:17,460 --> 00:04:20,580
a major thank you and a major
kudos to you because you've

77
00:04:20,580 --> 00:04:24,300
taken the first step to enter
this realm. So welcome to Web

78
00:04:24,300 --> 00:04:26,850
three. Welcome to the
blockchain. Welcome to smart

79
00:04:26,850 --> 00:04:29,850
contracts. And I'll see you at
the bottom of the rabbit hole.

80
00:04:29,880 --> 00:04:33,540
So let's jump into some best
practices for this course so

81
00:04:33,540 --> 00:04:36,330
that you can learn most
effectively and learn with this

82
00:04:36,330 --> 00:04:37,560
course as best you can.

83
00:04:40,620 --> 00:04:41,580
You do not want to skip

84
00:04:41,580 --> 00:04:44,910
this part. It'll help you solve
80% of your issue. Now, while

85
00:04:44,910 --> 00:04:48,240
going through this course be
100% certain to follow along

86
00:04:48,240 --> 00:04:51,450
with a GitHub repository
associated with this course we

87
00:04:51,450 --> 00:04:54,330
have a link in the description
of this video for you to

88
00:04:54,330 --> 00:04:58,200
absolutely click on follow along
have open in a tab as you're

89
00:04:58,200 --> 00:05:01,200
doing this because it has all
the code Sam polls, timestamps a

90
00:05:01,200 --> 00:05:04,770
community to interact with and
more, it is going to be your

91
00:05:04,770 --> 00:05:07,950
Bible for watching this course.
And yes, we have a Discussions

92
00:05:07,950 --> 00:05:10,590
tab. This Discussions tab is a
place where you can ask

93
00:05:10,590 --> 00:05:13,770
questions, engage with other
developers who are going through

94
00:05:13,770 --> 00:05:17,430
this course as well. Get some
help, and etc. Be sure to say

95
00:05:17,430 --> 00:05:20,160
hello and meet other like minded
individuals like yourselves.

96
00:05:20,190 --> 00:05:22,770
Now, blockchain and smart
contracts move really quickly.

97
00:05:22,980 --> 00:05:25,860
And things are constantly being
updated. So to make sure you're

98
00:05:25,860 --> 00:05:28,320
always up to date with the
latest, when I open up some

99
00:05:28,320 --> 00:05:31,320
documentation, try to open up
the documentation for yourself

100
00:05:31,320 --> 00:05:34,710
as well. And maybe even have the
code sample next to you. And as

101
00:05:34,710 --> 00:05:37,620
you're writing code, be sure to
refer back to make sure that you

102
00:05:37,620 --> 00:05:39,990
are keeping pace, and then you
have the most up to date

103
00:05:39,990 --> 00:05:43,230
samples, sometimes technology
might change, and there might be

104
00:05:43,260 --> 00:05:46,200
a way to do something a little
bit better. So we have this file

105
00:05:46,200 --> 00:05:49,290
called chronological updates, be
sure that this is the first

106
00:05:49,290 --> 00:05:51,720
place to check when you run into
an issue to see if maybe

107
00:05:51,720 --> 00:05:54,390
something was updated that you
missed, it'll be chronologically

108
00:05:54,390 --> 00:05:57,180
ordered. So it's easier to find
updates. Basically, this is to

109
00:05:57,180 --> 00:06:00,810
say, always refer back to the
GitHub repo first. And if you do

110
00:06:00,810 --> 00:06:02,730
to find a mistake, or something
isn't working the way you

111
00:06:02,730 --> 00:06:05,190
expected, jump into the
conversation, leave a

112
00:06:05,190 --> 00:06:09,420
discussion, leave an issue, ask
questions here, take breaks, I

113
00:06:09,420 --> 00:06:13,110
cannot tell you how many people
tried rushing through our entire

114
00:06:13,110 --> 00:06:15,780
first course in one setting and
didn't retain as much

115
00:06:15,780 --> 00:06:18,480
information, your brain
remembers information much

116
00:06:18,480 --> 00:06:21,390
better if you take breaks. So
every 25 minutes or half an

117
00:06:21,390 --> 00:06:24,420
hour, maybe take a five minute
walk. And then every two hours

118
00:06:24,450 --> 00:06:27,240
take a much longer break. And if
you really want to make sure

119
00:06:27,240 --> 00:06:30,000
something drills in, try to go
back and reflect on what you did

120
00:06:30,000 --> 00:06:32,730
for the lesson prior before
continuing to the next lesson.

121
00:06:32,940 --> 00:06:36,720
And at the same time, though,
learn at your own speed. There

122
00:06:36,720 --> 00:06:41,400
is no right speed for this
course. If it takes you a day, a

123
00:06:41,400 --> 00:06:45,300
week, a month or even a year, it
doesn't matter. Learn at the

124
00:06:45,300 --> 00:06:48,510
pace that's right for you, you
can change the speed at which I

125
00:06:48,510 --> 00:06:52,080
talked using the little gear
icon in the YouTube video. If

126
00:06:52,080 --> 00:06:55,620
I'm talking way too fast for
you, you can slow me down. And

127
00:06:55,620 --> 00:06:59,460
at the same time, if I'm talking
too slow, you can speed me up,

128
00:06:59,490 --> 00:07:02,790
you also don't even have to go
in order. You can bounce around

129
00:07:02,790 --> 00:07:05,340
topic to topic, if you don't
want to learn full stack, you

130
00:07:05,340 --> 00:07:07,680
can skip the full stack stuff.
If you don't want to learn

131
00:07:07,680 --> 00:07:10,380
coding, we can skip the coding
stuff. If you only want to go to

132
00:07:10,380 --> 00:07:13,380
the advanced stuff, go to the
advanced stuff. You are highly

133
00:07:13,380 --> 00:07:16,530
encouraged to pause, come back
and ask questions. The

134
00:07:16,530 --> 00:07:18,750
blockchain and smart contract
world is incredibly

135
00:07:18,750 --> 00:07:22,560
collaborative. So be sure to use
tools like the discussions tab

136
00:07:22,560 --> 00:07:26,640
of our GitHub repository, asking
questions on Stack Overflow and

137
00:07:26,640 --> 00:07:30,450
Aetherium Stack Exchange and
tagging relative technologies,

138
00:07:30,480 --> 00:07:33,120
making issues on different
GitHub repositories that you're

139
00:07:33,120 --> 00:07:36,450
working with jumping into
discord, Reddit, Twitter, and

140
00:07:36,450 --> 00:07:39,120
any other place that these
communities and technologies are

141
00:07:39,120 --> 00:07:41,790
congregating. And the reason I'm
putting so much emphasis on

142
00:07:41,790 --> 00:07:44,460
these community aspects is that
becoming a solidity and

143
00:07:44,460 --> 00:07:47,940
blockchain engineer is so much
more than just the solidity

144
00:07:47,940 --> 00:07:50,850
part. Being comfortable with all
the tools in this space,

145
00:07:51,000 --> 00:07:55,260
including the ones to get help
and to give help are essential

146
00:07:55,260 --> 00:07:58,320
to being successful here.
Networking is massive, and it

147
00:07:58,320 --> 00:08:01,110
makes it a ton of fun. As you
continue your journey and you

148
00:08:01,110 --> 00:08:03,600
get more advanced and you're
looking for places to meet other

149
00:08:03,600 --> 00:08:07,080
developers. Hackathons are one
of the best places to connect

150
00:08:07,080 --> 00:08:10,200
with other engineers, the
chainlink hackathons eath,

151
00:08:10,200 --> 00:08:13,650
global hackathons, and Dev folio
hackathons are three great

152
00:08:13,650 --> 00:08:16,890
hackathon suites to connect. And
no matter where you are in your

153
00:08:16,890 --> 00:08:19,680
journey, they're great places to
flex what you've learned.

154
00:08:19,740 --> 00:08:22,350
Alright, so those are some of
the best practices for this

155
00:08:22,350 --> 00:08:26,700
course. You're standing at the
edge of the rabbit hole, looking

156
00:08:26,700 --> 00:08:30,210
down, peering into the world of
web three and smart contracts

157
00:08:30,210 --> 00:08:33,390
and blockchain. If you're like
me want to jump in, you want to

158
00:08:33,390 --> 00:08:37,110
keep going further. Let's begin
our journey into the world of

159
00:08:37,110 --> 00:08:40,410
smart contracts. And it all
starts with the blockchain

160
00:08:40,410 --> 00:08:41,100
basics.

161
00:08:43,679 --> 00:08:44,939
Now, I know you're excited

162
00:08:44,940 --> 00:08:47,880
to get coding. But before we
jump in, we want to learn some

163
00:08:47,880 --> 00:08:50,910
of the fundamentals of
blockchains and smart contracts.

164
00:08:50,970 --> 00:08:53,550
Understanding these ideologies
and these basics are so

165
00:08:53,550 --> 00:08:56,790
important, because it'll dictate
how you architect your

166
00:08:56,790 --> 00:08:59,700
decentralized applications,
learning the basics of

167
00:08:59,700 --> 00:09:02,730
blockchain and solidity is
critical. But if you already

168
00:09:02,730 --> 00:09:05,490
know the basics of a blockchain,
feel free to jump into lesson

169
00:09:05,490 --> 00:09:05,850
two.

170
00:09:08,520 --> 00:09:09,480
Now, since you're here,

171
00:09:09,510 --> 00:09:12,840
you've probably heard of Bitcoin
before. Bitcoin was one of the

172
00:09:12,840 --> 00:09:16,230
first protocols to use this
revolutionary technology called

173
00:09:16,260 --> 00:09:19,530
blockchain. The Bitcoin white
paper was created by the pseudo

174
00:09:19,530 --> 00:09:23,400
anonymous Satoshi Nakamoto, and
outlined how Bitcoin can make

175
00:09:23,400 --> 00:09:26,850
peer to peer transactions. In a
decentralized network. This

176
00:09:26,850 --> 00:09:30,030
network was powered by
cryptography, decent Tality, and

177
00:09:30,030 --> 00:09:34,020
allowed people to engage in
censorship resistant finance, in

178
00:09:34,020 --> 00:09:37,320
a decentralized manner due to
its features, which we'll talk

179
00:09:37,320 --> 00:09:40,770
about in a little bit. People
took to this as a superior

180
00:09:40,800 --> 00:09:44,760
digital store of value, a better
store of value over something

181
00:09:44,760 --> 00:09:47,220
like gold, for example, and
that's why you'll also hear

182
00:09:47,220 --> 00:09:51,120
people commonly refer to it as a
digital gold similar to gold.

183
00:09:51,150 --> 00:09:54,600
There's a scarce amount or a set
amount of bitcoin available on

184
00:09:54,600 --> 00:09:57,780
the planet, only so much that
you can buy and sell. You can

185
00:09:57,780 --> 00:10:00,510
read more about the original
vision in the white A paper

186
00:10:00,540 --> 00:10:03,330
we've linked to the white paper
in the GitHub repo associated

187
00:10:03,330 --> 00:10:06,420
with this course. Now, this was
an insane breakthrough in a

188
00:10:06,420 --> 00:10:09,540
little bit, we're going to learn
exactly how this is all possible

189
00:10:09,540 --> 00:10:11,880
and how this actually works
under the hood. Some people

190
00:10:11,880 --> 00:10:15,240
though, saw this technology and
wanted to take it a little bit

191
00:10:15,240 --> 00:10:18,900
farther, and do even more with
this blockchain technology. And

192
00:10:18,930 --> 00:10:22,380
a few years later, a man named
Vitalik Buterin, released a

193
00:10:22,380 --> 00:10:26,640
white paper for a new protocol
named Aetherium, which use this

194
00:10:26,640 --> 00:10:30,330
same blockchain infrastructure
with an additional feature. And

195
00:10:30,330 --> 00:10:34,200
in 2015, him and a number of
other co founders released the

196
00:10:34,200 --> 00:10:37,050
project Aetherium, where people
could not only make

197
00:10:37,050 --> 00:10:40,350
decentralized transactions, but
decentralized agreements,

198
00:10:40,470 --> 00:10:43,800
decentralized organizations, and
all these other ways to interact

199
00:10:43,800 --> 00:10:46,740
with each other without a
centralized intermediary or

200
00:10:46,740 --> 00:10:50,190
centralized governing force.
Basically, their idea was to

201
00:10:50,190 --> 00:10:53,610
take this thing that made
Bitcoin so great, and add

202
00:10:53,640 --> 00:10:58,200
decentralized agreements to it,
or smart contracts. And in fact,

203
00:10:58,230 --> 00:11:00,810
technically, these smart
contracts weren't even really a

204
00:11:00,810 --> 00:11:05,220
new idea. Back in 1994, a man
named Nick Zabo, had actually

205
00:11:05,250 --> 00:11:08,310
originally come up with the idea
smart contracts are a set of

206
00:11:08,310 --> 00:11:12,240
instructions executed in a
decentralized autonomous way,

207
00:11:12,420 --> 00:11:16,440
without the need for a third
party or centralized body to run

208
00:11:16,440 --> 00:11:19,170
them. And they come to life on
these blockchains, or these

209
00:11:19,170 --> 00:11:22,350
smart contract platforms, like
Aetherium. And it's the smart

210
00:11:22,350 --> 00:11:24,930
contracts that are going to be
the core thing that we're going

211
00:11:24,930 --> 00:11:26,940
to be working on in this course,
and that we're going to be

212
00:11:26,940 --> 00:11:29,520
developing, you can think of
smart contracts in the same way

213
00:11:29,520 --> 00:11:31,740
you think of traditional
contracts or traditional

214
00:11:31,740 --> 00:11:34,740
agreements. They're just a set
of instructions between parties,

215
00:11:34,980 --> 00:11:37,920
except instead of written on pen
and paper or typed up in

216
00:11:37,920 --> 00:11:41,430
Microsoft Word, they are written
in code and embodied on these

217
00:11:41,430 --> 00:11:44,190
decentralized blockchain
platforms. And that's also where

218
00:11:44,190 --> 00:11:47,130
they're executed. Instead of
being executed by the two

219
00:11:47,130 --> 00:11:49,650
parties, or three parties, or
however many parties that are

220
00:11:49,650 --> 00:11:53,340
involved. This removes this
centralized issue that we'll

221
00:11:53,340 --> 00:11:55,440
talk about more in a bit. This
is one of the main

222
00:11:55,440 --> 00:11:58,200
differentiators between the
Etherium protocol and the

223
00:11:58,200 --> 00:12:01,500
Bitcoin protocol. It's these
smart contracts. Now,

224
00:12:01,530 --> 00:12:04,800
technically, bitcoin does have
smart contracts, but they're

225
00:12:04,800 --> 00:12:08,130
intentionally Turing incomplete,
which means they don't have all

226
00:12:08,130 --> 00:12:10,290
the functionality that a
programming language would give

227
00:12:10,290 --> 00:12:13,230
them. This was an intentional
move by Bitcoin developers.

228
00:12:13,590 --> 00:12:17,160
Bitcoin developers viewed
Bitcoin as a store of value

229
00:12:17,190 --> 00:12:21,150
versus Aetherium, developers
viewed Aetherium as both a store

230
00:12:21,150 --> 00:12:25,260
of value and a utility to
facilitate these decentralized

231
00:12:25,260 --> 00:12:28,230
agreements. Now, the smart
contracts on blockchains alone

232
00:12:28,260 --> 00:12:31,320
are absolutely incredible.
However, they do come with a

233
00:12:31,320 --> 00:12:34,740
huge issue. If we want these
digital agreements to replace

234
00:12:34,740 --> 00:12:37,470
the agreements in our everyday
lives, they probably are going

235
00:12:37,470 --> 00:12:40,560
to need data from the real world
blockchains by themselves

236
00:12:40,560 --> 00:12:44,280
actually can't interact with and
can't read or listen to data

237
00:12:44,340 --> 00:12:47,220
from the real world. This is
what's known as the Oracle

238
00:12:47,220 --> 00:12:50,100
problem. These blockchains are
deterministic systems and

239
00:12:50,100 --> 00:12:52,740
they're deterministic on
purpose. And we'll learn about

240
00:12:52,770 --> 00:12:55,830
more about how that works in the
sessions to come. So everything

241
00:12:55,830 --> 00:12:58,620
that happens with them happens
in their little world. But if

242
00:12:58,620 --> 00:13:00,480
they're going to be these
agreements, they need external

243
00:13:00,480 --> 00:13:03,330
data and they need external
computation. And this is where

244
00:13:03,360 --> 00:13:06,090
Oracle's come into play.
Oracle's are any device that

245
00:13:06,090 --> 00:13:09,360
delivers data to these
decentralized blockchain or runs

246
00:13:09,360 --> 00:13:12,660
external computation. However,
if we want our applications to

247
00:13:12,660 --> 00:13:17,040
stay truly decentralized, we
can't work with a single Oracle

248
00:13:17,070 --> 00:13:20,040
or a single data provider or a
single source that's running

249
00:13:20,040 --> 00:13:24,060
these external computations. So
we need a decentralized Oracle

250
00:13:24,060 --> 00:13:26,970
network. Similar to our
decentralized blockchain

251
00:13:26,970 --> 00:13:29,730
network, you're on chain logic
will be decentralized, but you

252
00:13:29,760 --> 00:13:32,610
also need your off chain data
and computation be

253
00:13:32,610 --> 00:13:36,780
decentralized, combining this on
chain decentralized logic. With

254
00:13:36,810 --> 00:13:39,300
this off chain, decentralized
data and decentralized

255
00:13:39,300 --> 00:13:42,720
computation gives rise to
something called hybrid smart

256
00:13:42,720 --> 00:13:45,930
contracts. And most of the
biggest protocols that we

257
00:13:45,930 --> 00:13:49,830
interact with today are some
type of hybrid smart contract or

258
00:13:49,830 --> 00:13:52,440
interact with hybrid smart
contracts. To some extent, this

259
00:13:52,440 --> 00:13:55,200
is where the protocol chaining
comes into play. It is a

260
00:13:55,200 --> 00:13:58,830
modular, decentralized Oracle
network that can both bring

261
00:13:58,830 --> 00:14:02,400
external data and external
computation into our smart

262
00:14:02,400 --> 00:14:05,730
contracts to make sure they're
decentralized end to end, while

263
00:14:05,730 --> 00:14:09,780
giving them the feature richness
that we need for our agreements.

264
00:14:09,810 --> 00:14:13,500
chainlink allows for us to get
data to upkeeps, get random

265
00:14:13,500 --> 00:14:16,530
numbers or really customize our
smart contracts in any

266
00:14:16,530 --> 00:14:18,900
meaningful way. Now, throughout
the course, we're going to use

267
00:14:18,900 --> 00:14:22,560
the terminology smart contract.
However, whenever we say smart

268
00:14:22,560 --> 00:14:26,010
contract, we're often using it a
little interchangeably with

269
00:14:26,160 --> 00:14:28,920
hybrid smart contracts, but just
know that when we say hybrid

270
00:14:28,920 --> 00:14:32,040
smart contract, we're talking
specifically about smart

271
00:14:32,040 --> 00:14:35,430
contracts that have some type of
off chain component. Now since

272
00:14:35,430 --> 00:14:37,890
the theorems release, a number
of different block chains or

273
00:14:37,890 --> 00:14:41,490
smart contract platforms have
come to light such as avalanche

274
00:14:41,490 --> 00:14:45,420
polygon, Phantom harmony, and
more. For the majority of this

275
00:14:45,420 --> 00:14:47,460
course, we're going to be
assuming that we're going to be

276
00:14:47,460 --> 00:14:50,580
deploying to the Ethereum
network. However, everything

277
00:14:50,580 --> 00:14:53,280
that we learned here is going to
be applicable to the vast

278
00:14:53,280 --> 00:14:56,520
majority of the blockchains out
there like polygon, avalanche,

279
00:14:56,550 --> 00:14:59,310
Phantom harmony, etc, and
understanding everything from a

280
00:14:59,310 --> 00:15:01,890
theory and funding mentals will
give you the skills that you

281
00:15:01,890 --> 00:15:05,670
need to switch chains very
easily with literally one line

282
00:15:05,670 --> 00:15:08,760
of code. So don't worry about
learning a specific tool or with

283
00:15:08,760 --> 00:15:12,600
a specific chain because most of
them work together seamlessly.

284
00:15:12,630 --> 00:15:15,090
Now, there are a couple of smart
contract platforms that don't

285
00:15:15,090 --> 00:15:18,360
use solidity. But still learning
the fundamentals here will make

286
00:15:18,360 --> 00:15:21,420
you much better at those as
well. And the Etherium by far

287
00:15:21,420 --> 00:15:24,300
has the most value locked and is
the most used blockchain and

288
00:15:24,300 --> 00:15:26,700
smart contract platform out
there. You'll also hear those

289
00:15:26,700 --> 00:15:29,190
two terms used a little bit
interchangeably as well.

290
00:15:29,250 --> 00:15:31,380
Sometimes they'll say smart
contract platform, sometimes

291
00:15:31,380 --> 00:15:33,960
they'll say blockchain, they
kind of mean the same thing.

292
00:15:34,200 --> 00:15:37,530
Obviously, blockchains could
mean store of value and smart

293
00:15:37,530 --> 00:15:41,070
contract platform, but you get
the idea. Similarly, chainlink

294
00:15:41,070 --> 00:15:44,640
is the most popular and powerful
decentralized Oracle network is

295
00:15:44,640 --> 00:15:46,950
the one that we're going to be
focusing on for this course as

296
00:15:46,950 --> 00:15:50,400
well. chainlink is also
blockchain agnostic. So to work

297
00:15:50,400 --> 00:15:54,540
on Aetherium, avalanche, Polygon
Solana Terra, or really any

298
00:15:54,540 --> 00:15:56,880
other blockchain out there. Now,
throughout this course, you'll

299
00:15:56,880 --> 00:16:00,390
hear the term DAP or
decentralized Protocol, or smart

300
00:16:00,390 --> 00:16:03,540
contract Protocol, or
decentralized application. And

301
00:16:03,540 --> 00:16:06,060
they all kind of mean the same
thing. A decentralized

302
00:16:06,060 --> 00:16:08,970
application is usually the
combination of many smart

303
00:16:08,970 --> 00:16:11,850
contracts. And when we get into
solidity, you'll see what a

304
00:16:11,850 --> 00:16:14,820
singular smart contract really
looks like. And like I said,

305
00:16:14,850 --> 00:16:17,520
learning all these core
fundamentals will make you a

306
00:16:17,520 --> 00:16:20,640
better solidity and a better
smart contract developer, you'll

307
00:16:20,640 --> 00:16:24,000
also hear the term web three a
lot in this video. And in the

308
00:16:24,000 --> 00:16:26,700
industry, web three is the idea
that blockchain and smart

309
00:16:26,700 --> 00:16:30,810
contracts are the next iteration
of the web web one being this

310
00:16:30,810 --> 00:16:34,950
permissionless open source world
with static content, web two

311
00:16:34,950 --> 00:16:37,980
being the permissioned web with
dynamic content, but all the

312
00:16:37,980 --> 00:16:41,610
agreements and logic runs off of
centralized servers where they

313
00:16:41,610 --> 00:16:44,490
control your information. And
then web three comes back to the

314
00:16:44,490 --> 00:16:48,450
permissionless web. But once
again, with dynamic content, and

315
00:16:48,450 --> 00:16:50,790
instead of centralized servers,
running your logic,

316
00:16:50,880 --> 00:16:54,480
decentralized networks, run the
logic creating these censorship

317
00:16:54,510 --> 00:16:58,080
resistant agreements, that the
smart contracts enable is also

318
00:16:58,080 --> 00:17:01,170
generally accompanied by the
idea that the users own the

319
00:17:01,170 --> 00:17:04,080
protocols that they work with,
and it's an ownership economy.

320
00:17:04,140 --> 00:17:06,390
You'll see what I mean later in
this course. And we've talked a

321
00:17:06,390 --> 00:17:09,000
lot about the history and about
the high level of these

322
00:17:09,000 --> 00:17:12,030
protocols and of the smart
contracts and what they can do.

323
00:17:12,240 --> 00:17:15,630
But what do these smart
contracts really mean? What is

324
00:17:15,630 --> 00:17:18,960
it when I say trust, minimize
agreements or unbreakable

325
00:17:18,960 --> 00:17:23,130
promises? What is the real value
add of these smart contracts?

326
00:17:23,130 --> 00:17:25,830
Before we look under the hood,
take a peek at how this all

327
00:17:25,830 --> 00:17:29,400
works. From a technical
standpoint. Let's learn what all

328
00:17:29,400 --> 00:17:32,340
the value of this is. What is
the purpose of us building all

329
00:17:32,340 --> 00:17:35,310
these technologies? Have you
taken this course? What problem

330
00:17:35,340 --> 00:17:38,850
does this technology solve? In
my mind, a technology is really

331
00:17:38,850 --> 00:17:41,910
only as good as the problem that
it solves. If it doesn't solve a

332
00:17:41,910 --> 00:17:45,960
problem, then why bother Mark
contracts, Blockchain web three

333
00:17:45,960 --> 00:17:48,750
cryptocurrencies, those are all
just different words that

334
00:17:48,750 --> 00:17:52,140
encapsulate the idea of what
we're doing in such a unique

335
00:17:52,140 --> 00:17:55,860
paradigm. I think the easiest
way to sum up what these smart

336
00:17:55,860 --> 00:17:59,970
contracts do is that they create
trust minimized agreements. And

337
00:17:59,970 --> 00:18:02,640
if you might be scratching your
head to that. A much easier way

338
00:18:02,640 --> 00:18:06,360
to think about it is just that
give rise to unbreakable

339
00:18:06,360 --> 00:18:10,410
promises. Yes, you heard that
right. Unbreakable agreements

340
00:18:10,440 --> 00:18:13,860
and promises. Additionally, they
give rise to speed, efficiency

341
00:18:13,860 --> 00:18:17,130
and transparency, and a number
of other things. I made a video

342
00:18:17,130 --> 00:18:21,150
pretty recently about exactly
this. So let's dive in and take

343
00:18:21,150 --> 00:18:24,150
a listen to the purpose the
undeniable value

344
00:18:24,510 --> 00:18:30,030
of smart contracts
cryptocurrencies, fundamentally

345
00:18:30,030 --> 00:18:33,330
re landscape markets and
agreements as we know them.

346
00:18:33,630 --> 00:18:36,060
Unfortunately, you've probably
only been bombarded with people

347
00:18:36,060 --> 00:18:38,610
screaming about empties and
money. Now, some of the memes

348
00:18:38,610 --> 00:18:41,070
are fun, but let's forget the
bullet and get down to the

349
00:18:41,070 --> 00:18:44,400
essence of the space. If you're
already in web three. This is

350
00:18:44,400 --> 00:18:47,280
the video to send to your
friends to explain why you're so

351
00:18:47,280 --> 00:18:50,550
excited about this space and
explain why we're here. And then

352
00:18:50,550 --> 00:18:53,010
if you're not into crypto,
you've come to the right place.

353
00:18:53,070 --> 00:18:55,890
And yes, there are fun memes and
markets and there's some money

354
00:18:55,890 --> 00:18:58,740
stuff in there all these things.
But outside of all that the

355
00:18:58,740 --> 00:19:02,790
purpose of blockchains relates
to the age old elementary school

356
00:19:02,820 --> 00:19:07,710
unbreakable, promise the pinky
swear, let's get Froggy. Nearly

357
00:19:07,710 --> 00:19:10,860
everything you do in life is the
result of an agreement or a

358
00:19:10,860 --> 00:19:14,100
contract. Your chair was the
result of an agreement to buy

359
00:19:14,100 --> 00:19:16,770
and sell lumber to assemble and
sell the chair to a real tailor

360
00:19:16,770 --> 00:19:19,860
on Amazon. Then you made an
agreement to buy the chair for

361
00:19:19,860 --> 00:19:23,400
$40. The lights in your house
are powered by electricity,

362
00:19:23,430 --> 00:19:25,680
which is an agreement from you
and the electric company you

363
00:19:25,680 --> 00:19:28,170
agree to pay them in return
they'll keep the lights on the

364
00:19:28,170 --> 00:19:30,810
electricity they generate it's
agreements between them and

365
00:19:30,810 --> 00:19:33,990
engineers who built turbines to
generate the electricity with

366
00:19:33,990 --> 00:19:36,570
insurance you agree to pay some
amount of money to them every

367
00:19:36,570 --> 00:19:39,870
month, and in return, they will
do nothing or I mean, they'll

368
00:19:39,870 --> 00:19:43,530
cover your medical bills, almost
everything you do and everything

369
00:19:43,530 --> 00:19:46,860
you interact with is the result
of some form of agreement or

370
00:19:46,860 --> 00:19:50,190
contract in some aspect. Now,
agreements and contracts can

371
00:19:50,190 --> 00:19:54,180
feel kind of abstract and boring
to really grasp on to simplify,

372
00:19:54,210 --> 00:19:57,120
we can also refer to them as
promises. When you get an oil

373
00:19:57,120 --> 00:19:59,760
change. They're promising that
they will faithfully change your

374
00:19:59,760 --> 00:20:03,090
oil In exchange for money, when
you put money in the bank, they

375
00:20:03,090 --> 00:20:06,390
promise to keep it safe in
exchange for them to use your

376
00:20:06,390 --> 00:20:09,240
money to give out loans. When
you buy a lottery ticket, the

377
00:20:09,240 --> 00:20:12,360
lottery promises to give you a
fair chance at winning a ton of

378
00:20:12,360 --> 00:20:15,330
money in exchange for you buying
the ticket. Whenever you make

379
00:20:15,330 --> 00:20:19,050
one of these agreements. In a
way, you're asking them to pinky

380
00:20:19,050 --> 00:20:22,590
swear to not screw you over and
to treat you fairly. But this

381
00:20:22,590 --> 00:20:25,500
doesn't always happen. Let's
look at a real world example of

382
00:20:25,500 --> 00:20:28,590
someone breaking the Pinkie
swear back in the 80s and 90s,

383
00:20:28,590 --> 00:20:30,810
McDonald's ran a promotion for
people to win money by

384
00:20:30,810 --> 00:20:33,930
collecting McDonald's Monopoly
game cards. The idea was simple.

385
00:20:33,960 --> 00:20:36,870
You buy McDonald's in return,
you get a chance to win $1

386
00:20:36,870 --> 00:20:41,130
million. You can imagine
McDonald's literally going Hey,

387
00:20:41,130 --> 00:20:44,160
everybody, I promise you if you
buy our MC food and McNuggets,

388
00:20:44,340 --> 00:20:48,450
we'll give you a fair chance of
winning this money, we ended up

389
00:20:48,450 --> 00:20:50,910
breaking this promise, instead
of having a fair chance of

390
00:20:50,910 --> 00:20:56,040
winning your chance was in fact,
zero in the mid 90s. Between 13

391
00:20:56,040 --> 00:21:00,330
and $24 million went into the
pockets of not people playing

392
00:21:00,330 --> 00:21:03,420
the game, honestly. But a group
of corrupt insiders who had

393
00:21:03,420 --> 00:21:06,270
rigged the game, meaning that
when you played the McDonald's

394
00:21:06,270 --> 00:21:09,630
Monopoly game, you were buying
into a set of lies and promises

395
00:21:09,660 --> 00:21:13,890
that were 100% always going to
be broken. And the thing is, it

396
00:21:13,890 --> 00:21:16,470
doesn't really matter if this
was McDonald's fault or not.

397
00:21:16,500 --> 00:21:19,020
They were the ones making the
promises that they ultimately

398
00:21:19,020 --> 00:21:21,540
could not keep. Another way you
could think about it is that

399
00:21:21,540 --> 00:21:26,130
that's $24 million that they
essentially stole from you and I

400
00:21:26,370 --> 00:21:30,480
now if this system was deployed
on a blockchain was something

401
00:21:30,480 --> 00:21:34,080
called a smart contract, it
would have been impossible to

402
00:21:34,080 --> 00:21:39,690
defraud this $24 million due to
smart contracts being immutable,

403
00:21:39,720 --> 00:21:42,750
decentralized and transparent.
But I'll get back to that in a

404
00:21:42,750 --> 00:21:47,430
minute. In all the agreements
and contracts we make, imagine

405
00:21:47,430 --> 00:21:51,000
making a pinky swear with a 10
year old and imagining how that

406
00:21:51,000 --> 00:21:53,280
agreement would hold up. Hey,
buddy, Could you could you

407
00:21:53,280 --> 00:21:55,500
please keep my money safe? You
can play with it if you like,

408
00:21:55,500 --> 00:21:58,680
but just please have it when I
come back. Immediately. You

409
00:21:58,680 --> 00:22:01,050
might get that worrying feeling
in your chest, something might

410
00:22:01,050 --> 00:22:03,660
go wrong. This 10 year old might
lose your money. You might be

411
00:22:03,660 --> 00:22:07,380
thinking, how could I trust
them? Will they break their

412
00:22:07,380 --> 00:22:10,770
promise and this feeling of I
can't breathe because of

413
00:22:10,770 --> 00:22:14,580
untrustworthy situations
happens? Once all the time. Can

414
00:22:14,580 --> 00:22:16,860
I trust this used car
salesperson to give me a good

415
00:22:16,860 --> 00:22:20,190
car? Can I trust this tag that
says machine washable? Or will

416
00:22:20,190 --> 00:22:22,620
it make my shirt shrink? Will my
insurance provider break their

417
00:22:22,620 --> 00:22:25,800
promise of covering my medical
bills want to get hit by a bus?

418
00:22:25,980 --> 00:22:28,830
I'm Patrick promises he'll go on
a hike with me. Well, he

419
00:22:28,830 --> 00:22:32,400
actually I actually will. But
the issue with our current

420
00:22:32,400 --> 00:22:35,430
agreements and contracts is we
have to trust the people. We're

421
00:22:35,430 --> 00:22:38,310
making them to do the right
thing. However often they're

422
00:22:38,310 --> 00:22:41,520
actually incentivized to not do
the right thing. insurance

423
00:22:41,520 --> 00:22:44,580
doesn't want to pay out money.
Sometimes salespeople just want

424
00:22:44,580 --> 00:22:47,400
to get the shit off the shelves
and with my girlfriend, I

425
00:22:47,400 --> 00:22:50,790
promised to go on a hike. But I
need hikes. Where else is has

426
00:22:50,790 --> 00:22:52,950
happened. Now you might be
thinking okay, Patrick, this

427
00:22:52,950 --> 00:22:56,370
seems cool. But like Where has
this actually affected me? Well,

428
00:22:56,370 --> 00:22:59,010
the McDonald's lottery that we
just spoke about above during

429
00:22:59,010 --> 00:23:01,710
the Great Depression with the
run of the banks banks promised

430
00:23:01,710 --> 00:23:04,560
to keep our money safe and that
when we went back to go get it

431
00:23:04,620 --> 00:23:07,920
they would actually have the
money there. And well and behold

432
00:23:07,920 --> 00:23:10,200
there were times that they
didn't have the money they're

433
00:23:10,230 --> 00:23:14,250
just last year Robin Hood
painted this amazing picture. On

434
00:23:14,250 --> 00:23:17,340
user application we will give
you access to the markets we

435
00:23:17,340 --> 00:23:22,470
promise we will give you a
retail investor a fair chance of

436
00:23:22,500 --> 00:23:24,420
interacting with the world the
finance

437
00:23:25,800 --> 00:23:29,520
side, but not this asset. This
asset, this asset or this asset,

438
00:23:29,550 --> 00:23:33,030
the 2008 financial crisis
remember that shady deals behind

439
00:23:33,030 --> 00:23:35,580
closed doors combined with lies
about financial product brought

440
00:23:35,580 --> 00:23:39,420
the world to its economic knees,
how are you? hyperinflation in

441
00:23:39,420 --> 00:23:42,600
Zimbabwe hyperinflation in
Brazil, fair enough. US history

442
00:23:42,600 --> 00:23:46,470
is a relentless lesson of
trustworthy entities being

443
00:23:46,500 --> 00:23:49,740
notorious promised breakers and
we finally have a way to fix it

444
00:23:49,980 --> 00:23:52,530
with smart contracts. Now,
before I jump into smart

445
00:23:52,530 --> 00:23:56,220
contracts, a lot of people might
be thinking, hey, cool in all,

446
00:23:56,250 --> 00:23:59,790
however, we have systems in
place to protect against a lot

447
00:23:59,790 --> 00:24:03,030
of these things, which is true,
and which is great. And that is

448
00:24:03,030 --> 00:24:06,780
a very helpful step forward. But
these systems often breaks ones

449
00:24:06,780 --> 00:24:09,570
in 2008 Definitely didn't work.
The ones with the Robin Hood

450
00:24:09,570 --> 00:24:12,870
crisis definitely didn't work.
And even if these systems apply,

451
00:24:12,930 --> 00:24:15,960
and you go to court to try to
work them out, maybe you're in

452
00:24:15,960 --> 00:24:18,990
court for years before you
actually see a resolution and by

453
00:24:18,990 --> 00:24:23,310
that time, what you needed the
money for is longer. So what is

454
00:24:23,310 --> 00:24:26,460
this technology? What is this
tool that can fix this

455
00:24:26,460 --> 00:24:30,000
fundamental problem in our
agreements today, this tool is

456
00:24:30,000 --> 00:24:33,660
smart contracts and this tool is
what the blockchain was built

457
00:24:33,660 --> 00:24:36,540
for. Now, I'm gonna give you a
quick overview of what a smart

458
00:24:36,540 --> 00:24:39,030
contract is. However, I'm
leaving some links in the

459
00:24:39,030 --> 00:24:42,420
description for more in depth
explanations, but the basics of

460
00:24:42,420 --> 00:24:46,050
them is a smart contract is an
agreement contract or a set of

461
00:24:46,050 --> 00:24:49,680
instructions deployed on a
decentralized blockchain. And

462
00:24:49,680 --> 00:24:52,830
once the contract or set of
instructions is deployed, it

463
00:24:52,920 --> 00:24:56,100
cannot be altered, it
automatically executes and

464
00:24:56,130 --> 00:24:59,340
everyone can see the terms of
the agreement. Real basics of it

465
00:24:59,370 --> 00:25:02,940
is that the code is executed by
decentralized collective like a

466
00:25:02,940 --> 00:25:05,130
group of people but a group of
people running a certain

467
00:25:05,130 --> 00:25:08,760
software. This means that no one
person or entity can actually

468
00:25:08,790 --> 00:25:11,460
alter any of these agreements or
change the terms of the

469
00:25:11,460 --> 00:25:14,760
arrangement in these traditional
agreements. Whoever owns the

470
00:25:14,760 --> 00:25:17,370
contract, whoever owns the
execution of the contract can

471
00:25:17,790 --> 00:25:20,910
flip a switch and say, We're not
going to do that anymore. In

472
00:25:20,910 --> 00:25:24,120
smart contracts and web three in
blockchain, you no longer can do

473
00:25:24,120 --> 00:25:26,880
that. Typically, these smart
contracts are on a decentralized

474
00:25:26,880 --> 00:25:29,670
blockchain, and used in
combination with a decentralized

475
00:25:29,700 --> 00:25:32,730
Oracle network to get the real
world assets and information.

476
00:25:32,820 --> 00:25:35,220
And if these words sound like
I'm conjuring up a magic spell,

477
00:25:35,250 --> 00:25:37,410
well, again, check the links in
the description. If you want to

478
00:25:37,410 --> 00:25:39,750
learn more about the technical
implications. If you're not a

479
00:25:39,750 --> 00:25:41,730
technical person, then you're
not interested in getting into

480
00:25:41,730 --> 00:25:45,330
the nitty gritty, you can kind
of think of it like HTTPS, I bet

481
00:25:45,330 --> 00:25:48,390
the vast majority of you don't
even know what HTTPS stands for.

482
00:25:48,450 --> 00:25:51,060
And yet you use it every single
day whenever you log on to the

483
00:25:51,060 --> 00:25:53,940
internet. So how does this fix
the McDonald's Monopoly issue?

484
00:25:54,120 --> 00:25:57,540
In its traditional form, the
lottery was executed behind

485
00:25:57,540 --> 00:26:01,290
closed doors, somebody operated
and owned the code and the

486
00:26:01,290 --> 00:26:03,870
contracts and the agreements
that ran the lottery, and they

487
00:26:03,870 --> 00:26:07,200
had the power to alter it. And
nobody other than the people

488
00:26:07,200 --> 00:26:10,740
internal on the lottery could
audit this altering happening.

489
00:26:10,770 --> 00:26:14,940
Now if the code for this lottery
was deployed onto a blockchain,

490
00:26:15,000 --> 00:26:18,150
every time a hacker attempted to
alter it, everyone would be

491
00:26:18,150 --> 00:26:21,300
notified. Not only that, but you
couldn't even alter it, because

492
00:26:21,300 --> 00:26:23,790
the terms of a smart contract
cannot be altered. Once

493
00:26:23,790 --> 00:26:26,670
deployed, combine that smart
contract with a chain link VRF

494
00:26:26,670 --> 00:26:30,360
Oracle to get a verifiably
random number. And presto, you

495
00:26:30,360 --> 00:26:33,120
now have a perfectly
decentralized, unalterable

496
00:26:33,120 --> 00:26:36,420
agreement that is impossible to
hack commit fraud or manipulate

497
00:26:36,450 --> 00:26:40,740
we have just saved the public
between 13,000,020 $4 million

498
00:26:41,370 --> 00:26:46,050
just by fixing the issue of
trust. How does this fix Robin

499
00:26:46,050 --> 00:26:48,480
Hood? Well, the problem with
Robin Hood is already fixed.

500
00:26:48,510 --> 00:26:51,360
Right? Again, the problem is
that there's a centralized body

501
00:26:51,360 --> 00:26:55,380
that can flip a switch at any
time and say you can't access

502
00:26:55,380 --> 00:26:58,290
these markets anymore. We're
breaking our promise of actually

503
00:26:58,290 --> 00:27:01,260
giving you access to the
markets. This is already fixed

504
00:27:01,290 --> 00:27:03,390
with something called
decentralized exchanges. And

505
00:27:03,390 --> 00:27:07,080
these exist today, one of these
exchanges is one called uniswap.

506
00:27:07,140 --> 00:27:10,320
You can swap ERC 20 tokens,
which are kind of the equivalent

507
00:27:10,320 --> 00:27:13,200
of stocks, but some are some
are, it's a little confusing. I

508
00:27:13,200 --> 00:27:15,810
won't get into that here either.
But it doesn't have that

509
00:27:15,810 --> 00:27:19,620
centralized body that can flip a
switch and ruin access to the

510
00:27:19,620 --> 00:27:22,860
markets. And had these investors
been on a decentralized

511
00:27:22,860 --> 00:27:26,730
exchange, it would have saved
them hundreds of millions of

512
00:27:26,730 --> 00:27:29,010
dollars, and it would have
prevented fraudulent market

513
00:27:29,010 --> 00:27:31,530
manipulation. How does it fix
run of the banks with

514
00:27:31,530 --> 00:27:34,470
transparency built in an
automated solvency checks, you

515
00:27:34,470 --> 00:27:37,050
can build a bank like smart
contract that has insolvency

516
00:27:37,050 --> 00:27:39,840
checks built in that make it
impossible to get there and

517
00:27:39,840 --> 00:27:44,190
solve it means brokers any
agreement or any history lesson,

518
00:27:44,430 --> 00:27:46,890
where there was a trust
assumption that was broken,

519
00:27:47,070 --> 00:27:50,850
smart contracts can be applied
to and should be applied to,

520
00:27:50,910 --> 00:27:54,480
especially in a time where big
money runs, owns and controls

521
00:27:54,480 --> 00:27:58,350
everything, we desperately need
to move to a world where some

522
00:27:58,350 --> 00:28:01,620
self interested centralized
entity can't flip a switch and

523
00:28:01,620 --> 00:28:04,680
ruin people's access to the
services that they need. We can

524
00:28:04,680 --> 00:28:08,640
move away from a world that is
brand based to a world that is

525
00:28:08,700 --> 00:28:11,940
math based. Right now, if you
interact with a service that you

526
00:28:11,940 --> 00:28:15,330
don't like, or that they break
their promise, the only thing

527
00:28:15,330 --> 00:28:18,330
you can do is walk down the
street to the next service

528
00:28:18,330 --> 00:28:20,700
that's going to make the same
set of promises. And you have to

529
00:28:20,700 --> 00:28:23,160
hope and pray that they're
actually going to keep it we can

530
00:28:23,160 --> 00:28:26,520
move from that to a world where
we can just look at the map and

531
00:28:26,520 --> 00:28:29,580
say, oh, okay, one plus one
equals two. This is what this

532
00:28:29,580 --> 00:28:33,690
agreement is going to do for me
every single time guaranteed,

533
00:28:33,750 --> 00:28:36,750
because it's a decentralized
autonomous agent has no

534
00:28:36,750 --> 00:28:39,570
incentive to be evil, and
everything is transparent and

535
00:28:39,570 --> 00:28:42,060
out in the open of a big
company. And if it was better

536
00:28:42,060 --> 00:28:45,480
for me for one plus one to equal
three, maybe I would go behind

537
00:28:45,480 --> 00:28:48,060
some closed doors and flood some
numbers and come back and be

538
00:28:48,060 --> 00:28:51,570
like, hey, one plus one equals
three with smart contracts.

539
00:28:51,600 --> 00:28:55,680
That's impossible. Doing the
right thing is infrastructural

540
00:28:55,710 --> 00:28:58,770
now, given the choice between
two agreements, one where you

541
00:28:58,770 --> 00:29:01,530
have to trust a single
centralized entity that they're

542
00:29:01,530 --> 00:29:05,400
going to do the right thing for
you, versus a decentralized

543
00:29:05,430 --> 00:29:07,170
untampered double collective,

544
00:29:07,230 --> 00:29:09,840
which one you're gonna choose.
I'm picking the one that can't

545
00:29:09,840 --> 00:29:14,010
screw me over every single time.
For every agreement I can apply

546
00:29:14,010 --> 00:29:17,160
it to now this technology is
relatively new, but we have

547
00:29:17,190 --> 00:29:20,550
already seen it relandscaping
entire markets and continue to

548
00:29:20,550 --> 00:29:23,700
do so the traditional financial
world is already getting its

549
00:29:23,700 --> 00:29:27,660
lunch eaten by defy or
decentralized finance. There's

550
00:29:27,660 --> 00:29:30,990
already over $200 billion of
people's money in these

551
00:29:30,990 --> 00:29:34,260
protocols to help have a more
fair, more accountable, more

552
00:29:34,260 --> 00:29:37,530
transparent financial system.
This defy movement is one of the

553
00:29:37,530 --> 00:29:40,530
main reasons I got into this
space because we desperately

554
00:29:40,530 --> 00:29:44,550
need to move away from where we
are right now. And and people's

555
00:29:44,550 --> 00:29:47,850
chances for wealth being sucked
up by some group that's bending

556
00:29:47,850 --> 00:29:50,700
the rules in their favor and
smart contracts are our ticket

557
00:29:50,700 --> 00:29:53,790
to that better world. More and
more industries are also coming

558
00:29:53,790 --> 00:29:56,010
over to smart contracts and
blockchain because of all the

559
00:29:56,010 --> 00:29:59,280
innovations and because of all
the advantages that it has as we

560
00:29:59,280 --> 00:30:02,220
grow and as we get better as we
get closer to this vision of

561
00:30:02,220 --> 00:30:06,690
having this concept fulfilled,
trust minimized agreements.

562
00:30:06,750 --> 00:30:09,660
These smart contracts are
minimizing the trust that we

563
00:30:09,660 --> 00:30:12,600
need to give other people in
order for these agreements to be

564
00:30:12,630 --> 00:30:15,150
executed. If trust minimized
agreements is too confusing for

565
00:30:15,150 --> 00:30:18,630
you just say unbreakable
promises. Now I gotta be honest

566
00:30:18,630 --> 00:30:21,090
with you guys. blockchains and
smart contracts and

567
00:30:21,090 --> 00:30:23,460
cryptocurrencies can actually do
more than just trust, minimize

568
00:30:23,460 --> 00:30:26,820
agreements. They have security
benefits, uptime benefits,

569
00:30:26,850 --> 00:30:29,340
execution, speed benefits, and a
whole lot more. But it's a lot

570
00:30:29,340 --> 00:30:31,620
easier to just learn about one
and learn the other ones later,

571
00:30:31,620 --> 00:30:34,260
right. It's kind of like
sprinkles on top. So this is why

572
00:30:34,260 --> 00:30:36,990
we are here. This is why we're
building this future and this is

573
00:30:36,990 --> 00:30:39,390
why we are so excited about it.

574
00:30:42,720 --> 00:30:46,440
Even in just this introduction
part, we've learned a ton. So

575
00:30:46,440 --> 00:30:49,680
let's do a quick summary of what
we've learned so far. Bitcoin

576
00:30:49,680 --> 00:30:53,070
was the first protocol to take
this blockchain technology into

577
00:30:53,070 --> 00:30:55,500
the limelight and take these
cryptocurrencies into the

578
00:30:55,500 --> 00:30:59,400
mainstream Bitcoin is a sort of
digital gold or a store of value

579
00:30:59,430 --> 00:31:02,730
able to make transactions
between users in a decentralized

580
00:31:02,730 --> 00:31:05,130
manner. Aetherium and other
smart contract platforms take

581
00:31:05,130 --> 00:31:08,640
this blockchain technology one
step further, enabling people to

582
00:31:08,640 --> 00:31:11,550
make smart contracts and
decentralized trust minimized

583
00:31:11,580 --> 00:31:14,760
agreements, the smart contracts
and decentralized applications

584
00:31:14,880 --> 00:31:18,120
can access and interact with the
real world using something

585
00:31:18,120 --> 00:31:21,090
called decentralized Oracle
networks. chain link is a

586
00:31:21,090 --> 00:31:24,060
decentralized network that
allows us to build these hybrid

587
00:31:24,060 --> 00:31:28,830
smart contracts, which combines
our on chain logic with our off

588
00:31:28,830 --> 00:31:31,950
chain, decentralized data, and
decentralized computation,

589
00:31:31,980 --> 00:31:35,220
giving rise to our logic being
completely decentralized, and

590
00:31:35,220 --> 00:31:37,890
our data and external
computation being completely

591
00:31:37,890 --> 00:31:41,280
decentralized, giving us all the
features that traditional

592
00:31:41,280 --> 00:31:44,190
agreements and traditional
contracts have. Now these

593
00:31:44,190 --> 00:31:46,860
digital currencies like
Aetherium, and Bitcoin have

594
00:31:46,860 --> 00:31:50,070
value. Even without the smart
contract part, having a

595
00:31:50,070 --> 00:31:53,310
censorship resistant,
decentralized store of value is

596
00:31:53,340 --> 00:31:56,130
naturally powerful in its own
right, we have some links in the

597
00:31:56,130 --> 00:31:58,680
GitHub repository that will
teach you how this decentralized

598
00:31:58,680 --> 00:32:02,010
store of value flips traditional
finance on its head. And it's

599
00:32:02,010 --> 00:32:04,650
another one of the great reasons
for building smart contracts.

600
00:32:04,680 --> 00:32:08,460
But again, the easiest way to
boil it down is trust minimized

601
00:32:08,490 --> 00:32:11,430
agreements, or unbreakable
promises. But let's also go into

602
00:32:11,430 --> 00:32:13,830
some of these other features
that smart contracts have over

603
00:32:13,830 --> 00:32:16,500
our traditional environment. The
first feature, of course, is

604
00:32:16,500 --> 00:32:19,230
that they are decentralized. And
they have no centralized

605
00:32:19,260 --> 00:32:21,840
intermediary, the different
individuals that run one of

606
00:32:21,840 --> 00:32:24,870
these blockchains are known as
node operators. And it's the

607
00:32:24,870 --> 00:32:28,500
combination of all these 1000s
of node operators running the

608
00:32:28,500 --> 00:32:31,260
same software running these
algorithms running these smart

609
00:32:31,260 --> 00:32:34,800
contracts that make the network
decentralized. We'll dive deeper

610
00:32:34,800 --> 00:32:38,010
into how that works later. The
next feature is transparency and

611
00:32:38,010 --> 00:32:40,890
flexibility in these
decentralized networks. Since

612
00:32:41,250 --> 00:32:44,010
all these individual node
operators run the software,

613
00:32:44,250 --> 00:32:47,010
everybody can see everything
that's happening on chain,

614
00:32:47,310 --> 00:32:49,620
meaning there's no shady deals,
there's no weird things

615
00:32:49,620 --> 00:32:53,550
happening. Anything that's going
to be unfair, people will be

616
00:32:53,550 --> 00:32:56,790
able to see and just not use,
everybody has perfect

617
00:32:56,790 --> 00:33:00,150
information and has to play by
the same rules. Now

618
00:33:00,150 --> 00:33:03,060
additionally, this doesn't mean
that there's no privacy, the

619
00:33:03,060 --> 00:33:05,820
blockchain is pseudo anonymous,
meaning that you aren't

620
00:33:05,820 --> 00:33:09,660
necessarily tied to an identity
in real life, they also have the

621
00:33:09,660 --> 00:33:12,480
feature of speed and efficiency.
For those of you who have ever

622
00:33:12,480 --> 00:33:16,020
tried to do a bank transfer or
send money across seas, you

623
00:33:16,020 --> 00:33:19,620
know, it sometimes can take two
to three weeks, when in fact,

624
00:33:19,740 --> 00:33:22,950
all these banks are really doing
is basic math. They're

625
00:33:22,950 --> 00:33:26,130
subtracting money from your
balance and adding it to some

626
00:33:26,130 --> 00:33:29,580
other balance. Why does it take
so long, in the blockchain, all

627
00:33:29,580 --> 00:33:33,030
of these transactions happen
instantly. Another instance for

628
00:33:33,030 --> 00:33:35,850
those in the financial world
today know that clearing houses

629
00:33:35,850 --> 00:33:39,090
and settlement days can take a
long time. In the blockchain,

630
00:33:39,180 --> 00:33:42,090
there's no need for any of that,
because they happen instantly.

631
00:33:42,150 --> 00:33:45,270
This obviously is much quicker,
but it also makes for much more

632
00:33:45,300 --> 00:33:48,960
efficient interactions with each
other security and immutability.

633
00:33:48,990 --> 00:33:52,800
Again, immutable means that it
can't be changed. Once a smart

634
00:33:52,800 --> 00:33:56,460
contract is deployed, that's it,
whatever is in the code is going

635
00:33:56,460 --> 00:33:59,430
to be in the code forever, they
cannot be altered or tampered

636
00:33:59,430 --> 00:34:02,550
with in any way. This means that
the security is much easier.

637
00:34:02,580 --> 00:34:04,860
Whereas in a centralized world,
somebody can hack into the

638
00:34:04,860 --> 00:34:08,010
server, jump into the database
and change some numbers. You

639
00:34:08,010 --> 00:34:10,380
can't do that in the blockchain
world. And since it's

640
00:34:10,380 --> 00:34:13,710
decentralized, in order to hack
the blockchain, you'd have to

641
00:34:14,040 --> 00:34:17,430
take over half of the nodes as
opposed to in the centralized

642
00:34:17,430 --> 00:34:20,520
world, where you only have to
take over one in the regular

643
00:34:20,520 --> 00:34:23,910
world. If your computer and your
backup computer go down, all of

644
00:34:23,910 --> 00:34:27,540
your data is gone. In the
blockchain world, if your

645
00:34:27,540 --> 00:34:30,660
computer and your backup
computer go down, all your data

646
00:34:30,690 --> 00:34:34,500
is safe, because it's being run
on all these other decentralized

647
00:34:34,500 --> 00:34:38,190
nodes. And even if a few 100
nodes or a few 1000 nodes go

648
00:34:38,190 --> 00:34:41,550
down. It doesn't matter because
as long as one node has a copy

649
00:34:41,550 --> 00:34:45,240
of the blockchain, you're good
to go hacking a blockchain is

650
00:34:45,390 --> 00:34:49,140
nearly impossible, and leaps and
bounds more difficult than

651
00:34:49,140 --> 00:34:52,290
hacking a centralized server.
Not only that, but this is safer

652
00:34:52,320 --> 00:34:56,010
in the asset sense as well. All
you need to access your

653
00:34:56,010 --> 00:34:59,760
credentials and your information
in your assets is your private

654
00:34:59,760 --> 00:35:03,300
key. Which is basically your
password for all of this. And as

655
00:35:03,300 --> 00:35:06,000
we've discussed in the video,
the smart contracts remove this

656
00:35:06,000 --> 00:35:09,540
counterparty risk, remove this
centralized intermediary, remove

657
00:35:09,540 --> 00:35:13,050
these trust gateways that we
have to do in web two. When we

658
00:35:13,050 --> 00:35:15,960
engage with users and
individuals, they don't always

659
00:35:15,960 --> 00:35:19,230
have our best interests at heart
smart contracts, remove this

660
00:35:19,230 --> 00:35:21,600
counterparty risk, because once
one of these contracts is

661
00:35:21,600 --> 00:35:24,840
created, they can't go in and
they can't alter it. And they

662
00:35:24,840 --> 00:35:27,390
can't let greed or ego or
anything else, get the better of

663
00:35:27,390 --> 00:35:30,630
them and alter the terms of the
deal. And as we said, this gives

664
00:35:30,630 --> 00:35:34,440
rise to these trust minimized
agreements or these programmatic

665
00:35:34,470 --> 00:35:38,400
unbreakable promises. We move
away from brand based agreements

666
00:35:38,460 --> 00:35:41,400
to math based agreements, where
we can look at the cryptography

667
00:35:41,400 --> 00:35:44,970
we can look right at the code
and see exactly what something

668
00:35:44,970 --> 00:35:47,880
is going to do and how it's
going to execute, versus having

669
00:35:47,880 --> 00:35:51,000
to rely on a human being doing
the right thing with smart

670
00:35:51,000 --> 00:35:54,510
contracts and decentralized
hybrid smart contracts. Doing

671
00:35:54,510 --> 00:35:57,750
the right thing is
infrastructural all these pieces

672
00:35:57,750 --> 00:36:01,020
boil down to us having the
freedom to interact the way we

673
00:36:01,020 --> 00:36:04,590
want to interact without having
to be afraid that interacting

674
00:36:04,590 --> 00:36:07,590
like that is going to screw us
over this trust minimized piece,

675
00:36:07,590 --> 00:36:12,420
these unbreakable promises, make
interactions so much better. In

676
00:36:12,420 --> 00:36:15,270
a purely web two world, we're
constantly bombarded with

677
00:36:15,270 --> 00:36:19,410
messages of projects and
protocols pushing us to move or

678
00:36:19,410 --> 00:36:22,620
act in the direction that makes
them more profitable. Versus in

679
00:36:22,620 --> 00:36:23,820
the smart contract space,

680
00:36:23,910 --> 00:36:26,460
we can see everything
transparently. And we can even

681
00:36:26,460 --> 00:36:29,970
engage in interact and be
partially owners of the

682
00:36:29,970 --> 00:36:33,360
protocols and the interactions
that we decide that we want to

683
00:36:33,360 --> 00:36:33,750
be a part

684
00:36:33,750 --> 00:36:38,700
of. So smart contracts have

685
00:36:38,700 --> 00:36:41,850
been around for a few years now.
And what did they generate for

686
00:36:41,880 --> 00:36:44,640
what industries have come about
due to these smart contract

687
00:36:44,640 --> 00:36:46,950
platforms being around? Well,
you've probably heard of some of

688
00:36:46,950 --> 00:36:49,020
these and some of these we've
already mentioned, but let's

689
00:36:49,020 --> 00:36:52,530
give you a quick refresher, d
phi d phi stands for

690
00:36:52,560 --> 00:36:56,010
decentralized finance. And it
gives users the ability to

691
00:36:56,010 --> 00:36:58,950
engage with finance and markets
without having to go through a

692
00:36:58,950 --> 00:37:01,500
centralized intermediary. For
example, like we said, with

693
00:37:01,500 --> 00:37:04,290
Robin Hood, you no longer have
to trust that Robin Hood would

694
00:37:04,290 --> 00:37:07,350
continue to give you access to
the markets, you instead would

695
00:37:07,350 --> 00:37:10,290
be able to see in the smart
contract. Yes, I have access to

696
00:37:10,290 --> 00:37:13,320
the markets or in the 2008
financial crisis. You never have

697
00:37:13,320 --> 00:37:16,530
to trust that these groups and
institutions are giving you the

698
00:37:16,530 --> 00:37:19,230
correct things on the back end.
You can see everything

699
00:37:19,230 --> 00:37:22,440
transparently right on the
blockchain, you can engage with

700
00:37:22,440 --> 00:37:25,590
things like money markets and
sophisticated financial products

701
00:37:25,830 --> 00:37:30,090
easy effectively and securely at
the time of recording. defi has

702
00:37:30,090 --> 00:37:34,500
around $200 billion in assets
under management and is quickly

703
00:37:34,500 --> 00:37:37,860
growing. If you're really
excited about defy we have a ton

704
00:37:37,860 --> 00:37:40,650
of defy examples showing you how
to build and interact with these

705
00:37:40,650 --> 00:37:43,920
protocols. In coming lessons.
Dows or decentralized.

706
00:37:43,950 --> 00:37:46,620
autonomous organizations are
another group that we've already

707
00:37:46,620 --> 00:37:49,650
mentioned. Dows are groups that
are governed completely

708
00:37:49,650 --> 00:37:52,770
decentralized by a set of
instructions or smart contracts

709
00:37:52,800 --> 00:37:56,130
on chain. There are some massive
benefits here where engagement

710
00:37:56,130 --> 00:37:58,770
is much easier. The rules are
black and white. And you can see

711
00:37:58,770 --> 00:38:01,200
everything directly on chain
voting and governance

712
00:38:01,200 --> 00:38:04,050
technologies completely
decentralized in the blockchain

713
00:38:04,050 --> 00:38:06,840
space is one of the big ones
pushing how we can evolve

714
00:38:06,840 --> 00:38:09,360
politics and how we can evolve
governance to make it more

715
00:38:09,360 --> 00:38:12,450
efficient, fair and reasonable.
And you better know it, we have

716
00:38:12,450 --> 00:38:15,120
some examples of how to build
Dows and how to work with Dows

717
00:38:15,120 --> 00:38:18,990
incoming lessons. So be sure to
watch those NF T's Stanford non

718
00:38:18,990 --> 00:38:22,860
fungible tokens and can really
be kind of described as digital

719
00:38:22,860 --> 00:38:26,850
art or just a unique asset, they
can do so much more, but we'll

720
00:38:26,850 --> 00:38:29,250
keep it high level for now.
Projects like board apes and

721
00:38:29,250 --> 00:38:32,760
crypto punks have revolutionized
the way that people get paid for

722
00:38:32,760 --> 00:38:35,670
their work, show off their
creativity, status, and so much

723
00:38:35,670 --> 00:38:38,730
more. And yes, of course, we
have lessons showing you how to

724
00:38:38,730 --> 00:38:42,060
create and interact with NF T's
as well, so many other groups

725
00:38:42,060 --> 00:38:44,880
and so many other industries are
being created as a result of

726
00:38:44,880 --> 00:38:47,850
this insane technology. And
maybe after finishing the

727
00:38:47,850 --> 00:38:51,450
journey with us here, you go out
and you'd be the one to pioneer

728
00:38:51,450 --> 00:38:54,960
the next industry or the next
billion dollar idea you've

729
00:38:54,960 --> 00:38:58,290
learned so much already. But now
that we've learned a lot of this

730
00:38:58,290 --> 00:39:02,700
high level information, let's
finally jump in, and let's make

731
00:39:02,700 --> 00:39:06,450
your first transaction and let's
get you set up to interact with

732
00:39:06,450 --> 00:39:09,120
this new world. In this next
section, we're going to get you

733
00:39:09,120 --> 00:39:12,720
a wallet and we're going to show
you exactly what a transaction

734
00:39:12,720 --> 00:39:20,310
looks like and feels like. Let's
dive in. This is the Aetherium

735
00:39:20,340 --> 00:39:24,840
website aetherium.org We are
going to make a transaction on a

736
00:39:24,840 --> 00:39:28,050
test Aetherium blockchain I'll
explain what that means in a

737
00:39:28,050 --> 00:39:31,170
little bit. This is going to be
our first transaction that's

738
00:39:31,170 --> 00:39:34,710
made on the blockchain. Now
again, this process that we're

739
00:39:34,710 --> 00:39:38,100
going to follow is going to work
the exact same with polygon,

740
00:39:38,130 --> 00:39:41,970
avalanche Phantom and all these
other EVM compatible

741
00:39:41,970 --> 00:39:44,730
blockchains. I'll explain what
that means in a bit too. For

742
00:39:44,730 --> 00:39:47,820
now, just follow along and have
fun in order to make a

743
00:39:47,820 --> 00:39:50,970
transaction on any of these
blockchains. The first thing

744
00:39:50,970 --> 00:39:55,110
that we need to do is we need to
set up a wallet. So I'm gonna go

745
00:39:55,110 --> 00:39:57,810
ahead and go to meta mask
because it's one of the most

746
00:39:57,810 --> 00:40:00,930
popular wallets and one of the
easiest to Use, we're going to

747
00:40:00,930 --> 00:40:03,870
go ahead and download it. I'm
using the brave browser, but it

748
00:40:03,870 --> 00:40:07,740
works for Chrome, Firefox or
really any other browsers. And

749
00:40:07,740 --> 00:40:11,070
it's just going to be a little
extension in the top right hand

750
00:40:11,430 --> 00:40:14,910
of your browser. This way, we
can really easily see it any

751
00:40:14,910 --> 00:40:17,730
times what we have in our
wallet, will still are all of

752
00:40:17,730 --> 00:40:21,240
our Aetherium based currencies.
So I'm gonna go ahead and

753
00:40:21,240 --> 00:40:22,950
install meta mask for brave,

754
00:40:24,030 --> 00:40:27,930
add to brave, add extension. And
now we can go ahead and get

755
00:40:27,930 --> 00:40:31,500
started with working with Brave,
this is the first step you

756
00:40:31,500 --> 00:40:34,170
absolutely need to take when
starting your journey and one of

757
00:40:34,170 --> 00:40:36,750
the easiest steps to take. So
we're gonna go ahead and get

758
00:40:36,750 --> 00:40:40,050
started. And we're going to
create a brand new wallet. So

759
00:40:40,050 --> 00:40:42,840
we're gonna go ahead and hit
create wallet. If you already

760
00:40:42,840 --> 00:40:46,830
have a wallet, you can actually
import it via I have a seed

761
00:40:46,830 --> 00:40:49,680
phrase, and we'll talk about the
seed phrase or secret phrase in

762
00:40:49,680 --> 00:40:53,460
a little bit. So let's go ahead
and create a new wallet. And

763
00:40:53,490 --> 00:40:56,640
sure, we'll agree to help out
Metamask now we will create our

764
00:40:56,640 --> 00:41:00,660
password make sure that this is
really secure. For the purpose

765
00:41:00,690 --> 00:41:03,300
of this demo, my passwords are
just gonna be password. But

766
00:41:03,450 --> 00:41:06,060
please don't have that be your
password. You may also get a

767
00:41:06,060 --> 00:41:08,760
video like this teaching you
about your secret recovery

768
00:41:08,760 --> 00:41:12,120
phrase. This is the same thing
as your pneumonic. But see your

769
00:41:12,120 --> 00:41:15,420
recovery phrase is a lot more
clear as to what it is. And

770
00:41:15,420 --> 00:41:17,820
again, to give us a ton of
different tips on how to

771
00:41:17,820 --> 00:41:21,630
actually store it and keep it
safe. The main takeaway from

772
00:41:21,630 --> 00:41:24,960
this is never shared this
absolutely never shared this. So

773
00:41:24,960 --> 00:41:28,140
we're going to go ahead and
click reveal secret words. I'm

774
00:41:28,140 --> 00:41:31,470
showing you guys here because
this is just a demo and I don't

775
00:41:31,470 --> 00:41:35,250
really care. However, if you
show this secret phrase to

776
00:41:35,250 --> 00:41:38,820
anybody else, they will have
access to all the funds in your

777
00:41:38,820 --> 00:41:41,460
application. So everything that
we're going to do in this

778
00:41:41,460 --> 00:41:43,980
tutorial, we're going to use
fake money, we're going to use

779
00:41:44,070 --> 00:41:47,340
not real money, so it doesn't
matter. Now for the purposes of

780
00:41:47,340 --> 00:41:51,270
testing and developing, I always
recommend using a completely

781
00:41:51,270 --> 00:41:54,750
separate meta mask, a completely
separate Wallet. So for going

782
00:41:54,750 --> 00:41:57,870
throughout this entire course,
if you already have a wallet, or

783
00:41:57,870 --> 00:42:01,080
if you already have a meta mask,
please just set up a new one,

784
00:42:01,080 --> 00:42:04,020
create a new profile, create a
new meta mask, and this will be

785
00:42:04,020 --> 00:42:06,600
your wallet that you use for the
duration of this course.

786
00:42:06,630 --> 00:42:09,000
However, if you're going to
actually put money in here, you

787
00:42:09,000 --> 00:42:11,310
absolutely need to have this
written down. Because if you

788
00:42:11,310 --> 00:42:14,160
lose access to this, and all
your private keys, which we'll

789
00:42:14,160 --> 00:42:17,370
talk about in a little bit, you
will lose access to your wallet,

790
00:42:17,460 --> 00:42:20,310
and you will lose access to all
your funds. So they give some

791
00:42:20,310 --> 00:42:23,190
tips like store this phrase and
a password manager like one

792
00:42:23,190 --> 00:42:26,220
password, write this phrase down
on a piece of paper, put it in a

793
00:42:26,220 --> 00:42:30,300
secure location, memorize it,
whatever you want to do, just

794
00:42:30,300 --> 00:42:32,850
make sure you have this backed
up somewhere, I'm just gonna go

795
00:42:32,850 --> 00:42:35,640
ahead and hit download this for
now, it's not best practice to

796
00:42:35,640 --> 00:42:37,890
save to your computer, it is
much better to use a password

797
00:42:37,890 --> 00:42:40,740
manager or write it down on a
piece of paper or something. So

798
00:42:40,740 --> 00:42:44,430
we're gonna go ahead and hit
next. And it's going to ask us

799
00:42:44,430 --> 00:42:49,800
to verify that we actually have
it written down. And we're gonna

800
00:42:49,800 --> 00:42:52,920
go ahead and hit confirm, and
great and gives us a couple

801
00:42:52,920 --> 00:42:55,800
other tips. Remember, definitely
take these tips very seriously,

802
00:42:55,830 --> 00:42:58,530
especially if you're gonna use
this for real money. Like I

803
00:42:58,530 --> 00:43:01,500
said, For this demo, we're just
going to use test money. So it's

804
00:43:01,500 --> 00:43:04,080
not as big of a deal. But if you
put real money in, you

805
00:43:04,080 --> 00:43:08,040
absolutely need to backup this
seed phrase or secret phrase or

806
00:43:08,160 --> 00:43:11,700
we're going to refer to it as
our pneumonic phrase. Awesome.

807
00:43:11,730 --> 00:43:16,080
Now we can see the interface of
our wallet here full screen. And

808
00:43:16,080 --> 00:43:19,410
depending on your browser, you
can actually come up and pin it

809
00:43:19,410 --> 00:43:22,080
to your browser so that you can
just click it up in the top

810
00:43:22,080 --> 00:43:25,620
right, and it'll drop down and
you can see the same interface

811
00:43:25,620 --> 00:43:29,310
here our pneumonic phrase that
secret phrase, those that secret

812
00:43:29,310 --> 00:43:33,420
12 words that they gave us have
given us access to a new

813
00:43:33,450 --> 00:43:36,810
account, the address of our
account is located right here.

814
00:43:36,870 --> 00:43:41,160
In fact, if we click it and copy
it to our clipboard, and go to a

815
00:43:41,160 --> 00:43:45,420
tool called a block explorer
called ether scan, we can

816
00:43:45,420 --> 00:43:49,020
actually paste our address in
here and see details about our

817
00:43:49,020 --> 00:43:52,050
account. Ether scan, like I
said, is what's known as a block

818
00:43:52,050 --> 00:43:55,920
Explorer. And it's a way to view
different addresses transactions

819
00:43:55,920 --> 00:43:59,550
and other happenings that happen
with a blockchain. If we look at

820
00:43:59,550 --> 00:44:02,760
this address that we just
created on ether scan for

821
00:44:02,790 --> 00:44:06,420
Etherium main net, we can see no
transactions have happened.

822
00:44:06,750 --> 00:44:09,660
There's really no analytics,
there's no comments, there's no

823
00:44:09,660 --> 00:44:13,440
balance, there's no value,
because it's a brand new wallet,

824
00:44:13,500 --> 00:44:16,800
and this address that we just
punched into ether scan

825
00:44:16,950 --> 00:44:21,450
represents our unique address
our unique wallet only

826
00:44:21,450 --> 00:44:25,080
identifiable for us. We'll talk
about ether scan a little bit

827
00:44:25,080 --> 00:44:27,510
more in a bit because it's a
tool that we're going to use

828
00:44:27,510 --> 00:44:30,840
quite often in wallets like meta
mask, you can actually even

829
00:44:30,840 --> 00:44:34,980
click right here and create even
more accounts. So let's go ahead

830
00:44:34,980 --> 00:44:37,230
and create a new account. We'll
call this

831
00:44:38,400 --> 00:44:39,570
account two.

832
00:44:41,370 --> 00:44:44,850
As you can see, this one has a
different address. So if we

833
00:44:44,850 --> 00:44:49,020
click this one, we go back to
ether scan. We paste the address

834
00:44:49,020 --> 00:44:53,460
in here. We hit Enter. We can
see another address again that's

835
00:44:53,460 --> 00:44:57,930
uniquely identifiable to us,
right here. It is zero balance,

836
00:44:57,960 --> 00:45:01,530
no value, no transactions now If
we go back to our Metamask, and

837
00:45:01,530 --> 00:45:04,500
we click the little button, we
can see we have two different

838
00:45:04,530 --> 00:45:07,710
accounts in here, it's the same.
If we hit the extension in the

839
00:45:07,710 --> 00:45:12,600
top right, click the button, we
have two different accounts. The

840
00:45:12,600 --> 00:45:16,920
12 word secret recovery phrase
allows us to create multiple

841
00:45:16,920 --> 00:45:20,640
accounts, all with the same
secret recovery phrase. So that

842
00:45:20,640 --> 00:45:24,090
secret recovery phrase will give
us access to both account one

843
00:45:24,360 --> 00:45:28,350
and account two and any other
accounts that we create by

844
00:45:28,350 --> 00:45:30,990
hitting this Create Account
button, because it gives you

845
00:45:30,990 --> 00:45:34,770
access to all the accounts in
your meta mask. Now, these

846
00:45:34,770 --> 00:45:38,490
addresses of both of our
accounts are the public unique

847
00:45:38,490 --> 00:45:43,380
identifiers, but they also have
a private unique identifier only

848
00:45:43,410 --> 00:45:48,000
identifiable to us. Similar to
the pneumonic, these are private

849
00:45:48,000 --> 00:45:51,330
identifiers we never want to
share and we never want to give

850
00:45:51,330 --> 00:45:55,470
out their private This is known
as your accounts private key. So

851
00:45:55,470 --> 00:45:58,050
the mnemonic will give you
access over many of these

852
00:45:58,050 --> 00:46:01,140
accounts, the private key will
give you access to just one of

853
00:46:01,140 --> 00:46:04,500
these accounts, we can see it by
hitting these little three dots,

854
00:46:04,560 --> 00:46:08,520
going to account details and
export private key, you'll just

855
00:46:08,520 --> 00:46:12,090
have to punch in your password
here. And you'll be able to see

856
00:46:12,120 --> 00:46:16,920
your private key. This is going
to be your private key for your

857
00:46:16,920 --> 00:46:19,890
account, you can think of your
private key as a password for

858
00:46:19,890 --> 00:46:23,100
your account that lets you
create transactions. Now the

859
00:46:23,100 --> 00:46:26,400
reason that I'm showing mine on
screen is because I'm not going

860
00:46:26,400 --> 00:46:28,770
to put any real money in here.
And this is just going to be a

861
00:46:28,770 --> 00:46:32,430
burner account for this
tutorial. And I highly recommend

862
00:46:32,430 --> 00:46:35,580
once again, you use a burner
account, you use accounts that

863
00:46:35,580 --> 00:46:38,850
you never put any real money
into. And along the way, I'll

864
00:46:38,850 --> 00:46:42,240
show you how to make sure that
you don't do that. But normally,

865
00:46:42,240 --> 00:46:45,600
it's not a good idea to show or
share your private keys or your

866
00:46:45,600 --> 00:46:49,110
secret recovery phrase, if
somebody gets a hold of this

867
00:46:49,110 --> 00:46:52,830
private key, they will have
access to my account one.

868
00:46:53,220 --> 00:46:57,090
However, they won't have access
to my account to if they get a

869
00:46:57,090 --> 00:47:00,960
hold of my 12 word recovery
phrase or pneumonic they'll have

870
00:47:00,960 --> 00:47:04,560
access to both accounts. And
this is why when people say keep

871
00:47:04,560 --> 00:47:07,860
your private keys safe, your
keys, your Bitcoin, your keys,

872
00:47:07,860 --> 00:47:11,190
your Aetherium, they're talking
about both your mnemonics or

873
00:47:11,190 --> 00:47:15,090
your secret recovery phrases.
And your private keys keep those

874
00:47:15,090 --> 00:47:19,080
private, your public addresses
are totally public. And anybody

875
00:47:19,080 --> 00:47:22,350
can view your accounts on
something like ether scan, or

876
00:47:22,350 --> 00:47:25,860
any other explore. And it's
totally okay for people to share

877
00:47:25,860 --> 00:47:28,740
their public addresses. If you
lose your private key, you lose

878
00:47:28,740 --> 00:47:31,320
access to one of your accounts.
If you lose your mnemonic, you

879
00:47:31,320 --> 00:47:34,470
could potentially lose access to
all your accounts. Basically,

880
00:47:34,470 --> 00:47:37,710
what I'm trying to say is back
these up and keep them in safe

881
00:47:37,710 --> 00:47:41,430
places for this course it's okay
if you lose one, since we're not

882
00:47:41,430 --> 00:47:44,430
putting any real money in them.
But in the real world, be sure

883
00:47:44,430 --> 00:47:46,710
to do this. And great. Those are
some of the main security

884
00:47:46,710 --> 00:47:49,890
considerations here. Now, if you
look up in the top right, right

885
00:47:49,890 --> 00:47:52,590
next to that account button that
we've been clicking, you also

886
00:47:52,590 --> 00:47:57,240
see this thing saying Etherium
main net, this is our networks

887
00:47:57,240 --> 00:48:00,930
tab. And if we click it, we can
see a list of all the different

888
00:48:00,930 --> 00:48:05,520
networks that we currently have
access to a Etherium main net is

889
00:48:05,550 --> 00:48:09,630
the main network of Aetherium.
And this is where real money is

890
00:48:09,660 --> 00:48:13,440
spent and used for transactions.
For this course, we're not going

891
00:48:13,440 --> 00:48:15,930
to be working with the Etherium
main net, we're instead going to

892
00:48:15,930 --> 00:48:18,570
be working with something called
a test net. Since we're

893
00:48:18,570 --> 00:48:22,380
engineers, oftentimes, we're
going to want to test and see

894
00:48:22,650 --> 00:48:25,410
what our code is actually going
to do and how to interact with

895
00:48:25,410 --> 00:48:28,650
it. We're going to use a
combination of local networks

896
00:48:28,650 --> 00:48:32,460
and test networks to actually do
this to actually test our smart

897
00:48:32,460 --> 00:48:35,370
contracts. We're mainly going to
use local networks. But we'll

898
00:48:35,370 --> 00:48:38,400
get to that in a little bit to
see some of the test networks

899
00:48:38,400 --> 00:48:42,240
that come default with meta
mask, we hit show slash hide

900
00:48:42,270 --> 00:48:45,360
test networks, this will bring
us into the settings page. And

901
00:48:45,360 --> 00:48:48,690
we just hit select this to show
test networks in the list. And

902
00:48:48,690 --> 00:48:52,590
we just hit on Now if we scroll
back up, we'll close out of the

903
00:48:52,590 --> 00:48:57,060
settings, we hit the network's
tab again. Now we can see all of

904
00:48:57,060 --> 00:49:01,590
these other networks here like
ropsten, Koven, Rinkeby, and

905
00:49:01,590 --> 00:49:04,800
Garelli. These test networks or
networks that resemble

906
00:49:04,830 --> 00:49:08,190
Aetherium, or polygon, or
Avalanche or phantom or any of

907
00:49:08,190 --> 00:49:11,430
these other blockchains. And we
can actually switch our accounts

908
00:49:11,460 --> 00:49:15,000
to one of these other test
networks. Let's click rink B,

909
00:49:15,000 --> 00:49:18,390
for example, we can see that on
the Rinkeby test network. We

910
00:49:18,420 --> 00:49:22,500
also have zero Aetherium we have
no money or nothing in here, we

911
00:49:22,500 --> 00:49:26,220
have a blank Rinkeby wallet.
These test nets work nearly

912
00:49:26,220 --> 00:49:29,580
identical to how Aetherium main
networks except for they run

913
00:49:29,580 --> 00:49:33,150
with not real money. They run
with fake money as a way for us

914
00:49:33,150 --> 00:49:36,270
to learn and interact and see
how these different smart

915
00:49:36,270 --> 00:49:39,780
contracts actually work together
at the time of filming. rink B

916
00:49:39,780 --> 00:49:43,740
is one of the most popular test
networks along with COVID. So

917
00:49:43,770 --> 00:49:47,670
we're going to work a lot with
Rigby In this tutorial, however,

918
00:49:47,700 --> 00:49:51,720
be absolutely sure to check our
GitHub repository to make sure

919
00:49:51,720 --> 00:49:55,380
that you're always up to date
with the best test network for

920
00:49:55,380 --> 00:49:57,870
following along with the
tutorial here since their test

921
00:49:57,870 --> 00:50:00,360
networks people are running them
out of the goodness of their

922
00:50:00,360 --> 00:50:03,810
hearts. And sometimes the best
ones actually change so, so be

923
00:50:03,810 --> 00:50:06,720
sure to follow along with the
GitHub repository. We might also

924
00:50:06,720 --> 00:50:10,050
use COVID From time to time or
maybe even Grilli. So we're

925
00:50:10,050 --> 00:50:12,360
going to show you how to use a
couple of these different test

926
00:50:12,360 --> 00:50:15,720
nets. In fact, if we go to the
GitHub repo associated with this

927
00:50:15,720 --> 00:50:19,740
course, we can see recommended
test net is indeed currently

928
00:50:19,770 --> 00:50:22,170
ranking. So that's what we're
going to work with should this

929
00:50:22,170 --> 00:50:25,020
change, you should be able to
follow along with another test.

930
00:50:25,020 --> 00:50:28,500
And we'll leave notes as to how
to continue. Now what we can do

931
00:50:28,500 --> 00:50:32,850
actually is we can go to Rigby
ether scan, we can go to,

932
00:50:34,530 --> 00:50:37,020
you can look up Rinku ether
scan, and it looks like it's the

933
00:50:37,020 --> 00:50:41,640
first thing that shows up
Rinkeby dot ether scan.io, we

934
00:50:41,640 --> 00:50:47,070
can punch in this same address,
copy and paste it. And we can

935
00:50:47,070 --> 00:50:50,610
see some of the details of this
address on the Rinkeby ether

936
00:50:50,610 --> 00:50:53,970
scan. Like I said, right now,
it's totally blank. This

937
00:50:53,970 --> 00:50:57,300
networks interface later on is
also how we're going to be able

938
00:50:57,300 --> 00:51:00,810
to work with polygon, avalanche,
etc, we'll just have to add

939
00:51:00,810 --> 00:51:03,840
networks. But we'll get to that
in a bit. And just to reiterate,

940
00:51:03,840 --> 00:51:06,990
test nets are free and for
testing our smart contracts and

941
00:51:06,990 --> 00:51:11,250
main net networks cost money and
are considered live. Now I also

942
00:51:11,250 --> 00:51:14,460
do want to put a caveat here
that we do want to keep in mind

943
00:51:14,460 --> 00:51:17,700
that these test nets are being
run at the goodness of people's

944
00:51:17,700 --> 00:51:20,700
hearts. So we don't want to
abuse them, we want to use them

945
00:51:20,700 --> 00:51:23,940
to learn and then move on. So
try not to send a billion

946
00:51:23,940 --> 00:51:26,790
transactions on one of these
test nets. In fact, what we're

947
00:51:26,790 --> 00:51:30,000
going to do right now is we're
going to send a transaction on

948
00:51:30,030 --> 00:51:33,750
the Rinkeby test net. And this
will show us exactly what it

949
00:51:33,750 --> 00:51:36,630
would look like on a main
network. In order for us to

950
00:51:36,630 --> 00:51:39,150
simulate one of these
transactions, we're going to go

951
00:51:39,150 --> 00:51:42,480
to what's called a faucet. And
if you go to the GitHub

952
00:51:42,480 --> 00:51:45,690
repository associated with this
course, right underneath the

953
00:51:45,690 --> 00:51:49,260
recommended test net is going to
be a test net faucets, which is

954
00:51:49,260 --> 00:51:53,280
going to show us where the most
up to date faucet location is

955
00:51:53,340 --> 00:51:56,250
for us getting test net
Aetherium. So here we are at

956
00:51:56,250 --> 00:51:59,910
faucets dot chain dot link,
which again is the recommended

957
00:51:59,910 --> 00:52:03,570
faucet, and what we can do is we
can actually put our wallet

958
00:52:03,570 --> 00:52:08,550
address in and get some test net
link or test net Aetherium. Now

959
00:52:08,550 --> 00:52:11,310
what we are gonna have to do is
we are gonna have to connect our

960
00:52:11,310 --> 00:52:15,180
wallet to the Rinkeby network.
So we're going to come down,

961
00:52:15,870 --> 00:52:21,630
we're going to switch from COVID
to Etherium. Rigby, and then

962
00:52:21,780 --> 00:52:25,920
we're going to make sure our
meta mask is on the Rinkeby test

963
00:52:25,920 --> 00:52:28,980
network here. Once both of those
are set up, we're gonna go ahead

964
00:52:28,980 --> 00:52:32,370
and hit Connect wallet. And
we're going to choose meta mask.

965
00:52:33,960 --> 00:52:36,720
Once we do that, our meta mask
is actually going to pop up and

966
00:52:36,720 --> 00:52:40,020
say would you like to connect to
this website, connecting to a

967
00:52:40,020 --> 00:52:43,230
website is how we give these
websites in interface to

968
00:52:43,230 --> 00:52:46,560
interact with our wallets and
interact with our meta masks.

969
00:52:46,830 --> 00:52:49,710
Don't worry, we're not sending
any transactions like this,

970
00:52:49,740 --> 00:52:52,830
we'll get to that in a bit. So
we just we can pick an account

971
00:52:52,830 --> 00:52:56,610
we want to connect. Let's choose
our account one, we'll hit Next.

972
00:52:57,000 --> 00:53:00,330
And then we'll go ahead and
connect. Now that we're

973
00:53:00,330 --> 00:53:04,200
connected, we can actually see
our account connected up here.

974
00:53:04,290 --> 00:53:07,860
And that little warning is now
gone. And our wallet address is

975
00:53:07,890 --> 00:53:10,950
automatically placed into here,
we're going to make our first

976
00:53:10,980 --> 00:53:15,030
test transaction. And for now,
we don't need test link. So

977
00:53:15,030 --> 00:53:17,610
we're going to leave that off.
But later on, we're going to

978
00:53:17,610 --> 00:53:20,520
come back and get that test
link. For now we're just going

979
00:53:20,520 --> 00:53:22,740
to need 0.1 test Aetherium.

980
00:53:24,060 --> 00:53:27,420
So let's go ahead and complete
the security by choosing the

981
00:53:27,420 --> 00:53:31,770
traffic lights. And we're going
to hit Send Request. What this

982
00:53:31,770 --> 00:53:37,290
is going to do is we're asking
this faucet to send us 0.1 test

983
00:53:37,320 --> 00:53:41,430
Aetherium test net faucets are
ways for us to get money into

984
00:53:41,430 --> 00:53:44,580
our wallets on a test net. And
this is why this test and

985
00:53:44,580 --> 00:53:47,730
Aetherium isn't worth any actual
money. Since we can get it for

986
00:53:47,730 --> 00:53:51,930
free. These don't exist on Main
net, you can't get real

987
00:53:51,930 --> 00:53:55,440
Aetherium or real money for free
on a main network. So we're on

988
00:53:55,440 --> 00:53:58,320
Rinkeby we're getting fake
Rinckey Aetherium. And we're

989
00:53:58,320 --> 00:54:00,780
gonna go ahead and hit send
request. Once we hit Send

990
00:54:00,780 --> 00:54:04,830
Request, this transaction hash
is going to pop up here, and it

991
00:54:04,830 --> 00:54:07,500
says transactions have been
initiated waiting for

992
00:54:07,500 --> 00:54:11,100
confirmation. This means that
some other wallet is actually

993
00:54:11,100 --> 00:54:15,720
going to send us 0.1 test eath.
And this is the transaction that

994
00:54:15,720 --> 00:54:18,600
it's doing to do that now we
just have to wait for our

995
00:54:18,600 --> 00:54:22,080
transaction to finish verifying
and finish going through. Now if

996
00:54:22,080 --> 00:54:24,540
this doesn't work right away, I
would recommend Wait a minute

997
00:54:24,540 --> 00:54:27,270
and then just try it again. But
what we can do is we can click

998
00:54:27,300 --> 00:54:31,020
this transaction hash. If that
transaction doesn't show up, we

999
00:54:31,020 --> 00:54:35,940
can also just close this. And we
can copy our address here. And

1000
00:54:35,940 --> 00:54:39,900
actually we already see 0.1 eath
in our wallets here. But we can

1001
00:54:39,900 --> 00:54:44,400
go back over to Rinkeby ether
scan, paste our address and and

1002
00:54:44,400 --> 00:54:49,350
we can see that we now have 0.1
ether as a balance. We can also

1003
00:54:49,350 --> 00:54:53,280
see that we have a transaction
with all this information going

1004
00:54:53,310 --> 00:54:56,520
into our wallet. That's what
this green is for. If you click

1005
00:54:56,520 --> 00:55:00,180
that transaction link, you'd get
something like this, but If you

1006
00:55:00,180 --> 00:55:03,930
didn't, don't worry, because on
the ether scan, if you click the

1007
00:55:03,930 --> 00:55:07,320
transaction hash in the
transaction list, you can also

1008
00:55:07,320 --> 00:55:10,740
see all the details like that.
So now in our meta mask, we have

1009
00:55:10,770 --> 00:55:15,300
0.1 eath. Again, this is fake
Aetherium. And we have a

1010
00:55:15,300 --> 00:55:18,930
transaction associated with our
wallet now, which is awesome.

1011
00:55:18,990 --> 00:55:22,410
Again, though, if we switch
networks, if we switch networks

1012
00:55:22,410 --> 00:55:25,890
back to Etherium main net, you
can see that we have nothing on

1013
00:55:25,890 --> 00:55:29,190
a theory main net. Or if we go
to ropsten, we also have

1014
00:55:29,190 --> 00:55:33,510
nothing, we only have this 0.1
eath. On the Rinkeby test

1015
00:55:33,540 --> 00:55:36,900
network, if you want to practice
working with another test net,

1016
00:55:37,110 --> 00:55:40,440
and the faucet that we're using,
has multiple test nets. Let's go

1017
00:55:40,440 --> 00:55:43,530
ahead and try it during this
section right now is completely

1018
00:55:43,530 --> 00:55:46,200
optional, you can watch or you
can follow along. But for

1019
00:55:46,200 --> 00:55:49,320
example, I can see in my wallet
that we already have COVID

1020
00:55:49,320 --> 00:55:53,220
supported, so maybe I'll switch
to COVID. Maybe we'll switch to

1021
00:55:53,220 --> 00:55:57,000
COVID. In the drop down here,
we'll remove test 10 Link,

1022
00:55:57,030 --> 00:56:01,080
because we only need test eath.
We'll hit I'm not a robot, and

1023
00:56:01,080 --> 00:56:04,950
we'll send request and the same
things will pop up this time,

1024
00:56:04,980 --> 00:56:08,280
this is going to be for the
COVID test net. And once our

1025
00:56:08,280 --> 00:56:11,520
transaction finishes going
through. Now, same thing on

1026
00:56:11,520 --> 00:56:14,160
COVID. Here, like what we did
with rink B, once our

1027
00:56:14,160 --> 00:56:18,450
transaction finishes going
through, we'll see 0.1 test eath

1028
00:56:18,480 --> 00:56:21,390
on the COVID network, if you
want to go ahead and try working

1029
00:56:21,390 --> 00:56:25,110
with another one of the test
nets. Like maybe, for example

1030
00:56:25,650 --> 00:56:28,830
COVID recommend you go ahead and
giving it a try. But it's

1031
00:56:28,830 --> 00:56:31,650
completely optional. And I would
always refer back to the GitHub

1032
00:56:31,650 --> 00:56:34,470
repo to make sure you're working
with the most up to date faucet

1033
00:56:34,500 --> 00:56:37,500
and test net. And if we look
back at ether scan, we can

1034
00:56:37,500 --> 00:56:41,340
actually see more details on
what actually just took place.

1035
00:56:41,340 --> 00:56:45,540
What actually just happened, how
did our Metamask get a balance

1036
00:56:45,570 --> 00:56:48,840
of 0.1 eath. All of a sudden?
Well, if we looked down in the

1037
00:56:48,840 --> 00:56:52,560
transaction section, we can see
that there's a transaction here,

1038
00:56:53,100 --> 00:56:58,590
some address sent us 0.1 ether.
And if we click the transaction

1039
00:56:58,590 --> 00:57:02,910
hash, we can see more details
about what actually went down

1040
00:57:02,940 --> 00:57:05,610
with this transaction. Now
understanding what's going on in

1041
00:57:05,610 --> 00:57:09,060
this transaction is essential to
learning and being a smart

1042
00:57:09,060 --> 00:57:12,360
contract developer or just
engaging with the ecosystem. So

1043
00:57:12,360 --> 00:57:16,200
let's learn the first bit at the
top is this transaction hash.

1044
00:57:16,470 --> 00:57:21,150
This is a unique identifier for
this blockchain or this test net

1045
00:57:21,360 --> 00:57:24,900
that identifies this exact
transaction. This transaction

1046
00:57:24,900 --> 00:57:31,260
hash identifies sending 0.1 eath
to our address, we can see that

1047
00:57:31,350 --> 00:57:34,920
the status of this transaction
was successful, it didn't break.

1048
00:57:34,920 --> 00:57:38,460
In any case, we can see the
block number that this

1049
00:57:38,460 --> 00:57:41,580
transaction was included in and
we'll get to blocks in a little

1050
00:57:41,580 --> 00:57:45,630
bit, we can see the timestamp
which of course is when this

1051
00:57:45,750 --> 00:57:49,170
transaction occurred, we can see
which account it was from which

1052
00:57:49,200 --> 00:57:54,360
if we go ahead and open in a new
tab, we can see that this is the

1053
00:57:54,360 --> 00:57:57,870
account that this transaction
came from. And it's got 3

1054
00:57:57,870 --> 00:58:01,440
million ether. Of course, this
is fake Rinckey ether. So it

1055
00:58:01,440 --> 00:58:04,860
doesn't really matter, we can
all see who it was to, which

1056
00:58:04,860 --> 00:58:10,110
again, is just us. This is our
wallet address 0x 106 X blah,

1057
00:58:10,110 --> 00:58:15,330
blah, blah, cero x 1066, blah,
blah, blah, right, the value of

1058
00:58:15,330 --> 00:58:19,200
this transaction, of course, is
0.1 ether. Now what's all this

1059
00:58:19,200 --> 00:58:22,530
that we see as the value so
obviously, the value is 0.1,

1060
00:58:22,530 --> 00:58:24,960
because that's a mode which we
sent. But we see this

1061
00:58:24,960 --> 00:58:28,440
transaction fee. In this gas
price, we hover over the

1062
00:58:28,440 --> 00:58:31,950
tooltip, we can see if you zoom
in on your ether scan, you see

1063
00:58:31,950 --> 00:58:35,790
amount paid to the miner for
processing the transaction. And

1064
00:58:35,790 --> 00:58:40,200
we see a gas price which is cost
per unit of gas specified for

1065
00:58:40,200 --> 00:58:43,590
the transaction and ether and
gray. The higher the gas price,

1066
00:58:43,620 --> 00:58:46,950
the higher the chance of getting
included in the block. Now if we

1067
00:58:46,980 --> 00:58:50,220
scroll down even more, and we
click See more, we can also see

1068
00:58:50,220 --> 00:58:53,460
a ton of other information here.
For now we're just going to

1069
00:58:53,460 --> 00:58:57,360
click to see less and just focus
on these two. I'll explain all

1070
00:58:57,360 --> 00:58:58,830
of these in a later session.

1071
00:59:01,470 --> 00:59:02,490
Let's talk about just

1072
00:59:02,490 --> 00:59:06,090
the concept of transaction fees
and gas for a second. Remember

1073
00:59:06,090 --> 00:59:08,970
how I said the blockchain is run
by all these different nodes

1074
00:59:09,180 --> 00:59:12,000
will all those different nodes
are running this blockchain

1075
00:59:12,210 --> 00:59:15,990
because they actually get paid
for all the transactions that

1076
00:59:15,990 --> 00:59:19,260
happen on these blockchains
whenever you make a transaction,

1077
00:59:19,290 --> 00:59:23,850
there's a node or a miner or or
a validator somebody running the

1078
00:59:23,850 --> 00:59:28,410
blockchain software is gonna get
paid a tiny bit of Aetherium or

1079
00:59:28,410 --> 00:59:30,960
polygon or whatever blockchain
that you're running on, they're

1080
00:59:30,960 --> 00:59:34,020
gonna get paid a tiny bit of
that native blockchain currency.

1081
00:59:34,110 --> 00:59:37,290
This payment is obviously to
incentivize people to continue

1082
00:59:37,290 --> 00:59:40,200
to run nodes and they calculate
how much you pay and how much

1083
00:59:40,200 --> 00:59:43,920
the node operators get paid
based off of how much gas you

1084
00:59:43,920 --> 00:59:48,120
use. So there's this concept of
gas. Gas is a unit of

1085
00:59:48,120 --> 00:59:52,230
computational measure. The more
computation a transaction uses,

1086
00:59:52,230 --> 00:59:56,370
the more gas you'd have to pay
for. For example, we do hit

1087
00:59:56,370 --> 01:00:00,240
click More just really quickly.
We can see this section say A

1088
01:00:00,270 --> 01:00:04,260
gas limit and gas usage by
transaction, there was a limit

1089
01:00:04,290 --> 01:00:09,780
of 60,000 units of gas on this
transaction, and 21,000 or

1090
01:00:09,780 --> 01:00:15,000
actually use. So this
transaction use 21 units of gas.

1091
01:00:15,060 --> 01:00:19,140
Now for very simple things like
sending ether, the units of gas

1092
01:00:19,170 --> 01:00:22,290
are usually pretty cheap. But
maybe for more complex things

1093
01:00:22,320 --> 01:00:25,980
like like minting NFT,
depositing to some defy

1094
01:00:25,980 --> 01:00:30,150
contract, etc, maybe those will
cost more gas because they'll be

1095
01:00:30,150 --> 01:00:33,390
more computationally expensive.
And this is a little confusing

1096
01:00:33,390 --> 01:00:35,760
right now, don't worry too much
about it. But just know that we

1097
01:00:35,760 --> 01:00:39,990
use 21,000 gas here. And if we
pull out the calculator 21,000

1098
01:00:39,990 --> 01:00:45,750
gas times this gas price right
here, times the gas price, we

1099
01:00:45,750 --> 01:00:50,610
get the exact same as we see for
the transaction fee. So gas

1100
01:00:50,610 --> 01:00:55,890
price, times how much gas you
used, is the transaction fee. So

1101
01:00:55,890 --> 01:01:04,050
whoever sent us this 0.1 ether,
also paid 0.0000525, etc Rinkeby

1102
01:01:04,080 --> 01:01:07,920
ether to make this transaction.
Now, each blockchain has a

1103
01:01:07,920 --> 01:01:11,130
different way of actually
calculating how this gas stuff

1104
01:01:11,130 --> 01:01:14,340
works. So that's basically going
to be the high level of it. So

1105
01:01:14,340 --> 01:01:16,350
we're going to focus just here
for now there's a total

1106
01:01:16,350 --> 01:01:19,590
transaction fee. And then
there's obviously the gas price.

1107
01:01:19,650 --> 01:01:22,620
After we cover how blockchain
works, I'll explain what this

1108
01:01:22,620 --> 01:01:25,680
burn stuff is these gas fees and
all these other stuff. For now,

1109
01:01:25,680 --> 01:01:28,980
just know that anytime you make
a transaction on chain, you have

1110
01:01:28,980 --> 01:01:32,490
to pay a little bit of what I
call transaction gas. So for

1111
01:01:32,490 --> 01:01:35,520
example, if we go to our
Metamask, we have two accounts

1112
01:01:35,520 --> 01:01:39,870
right here, we have account one
was 0.1, Rinckey eath, and

1113
01:01:39,870 --> 01:01:46,500
account two was zero. Rigby. If
I were to send 0.05 Rinckey

1114
01:01:46,500 --> 01:01:50,580
eath. From this account to my
other account, how much rinky

1115
01:01:50,580 --> 01:01:53,970
eath Do you think I'd have left?
Well, let's go ahead and try it,

1116
01:01:54,000 --> 01:01:56,580
this will be the first
transaction that you're actually

1117
01:01:56,580 --> 01:02:00,480
creating that you are going to
spend the gas for. So if we go

1118
01:02:00,480 --> 01:02:03,330
ahead and hit send, we'll hit
transfer between my accounts.

1119
01:02:03,600 --> 01:02:06,630
count two, we'll do 0.05.

1120
01:02:07,380 --> 01:02:09,450
Next, we can see

1121
01:02:10,620 --> 01:02:13,560
some information here about
what's actually going on

1122
01:02:13,590 --> 01:02:17,550
Metamask has some new advanced
gas for UI and settings, we're

1123
01:02:17,550 --> 01:02:20,520
also going to turn the song, so
go ahead and click that enable

1124
01:02:20,520 --> 01:02:24,480
enhanced gas UI, turn that on,
and then go back. And again,

1125
01:02:24,480 --> 01:02:27,060
this is going to be the
experimental tab. But it could

1126
01:02:27,060 --> 01:02:29,670
also just be in the General
Settings tab. Depending on when

1127
01:02:29,670 --> 01:02:32,460
you actually run this, we can
see a little notification here.

1128
01:02:32,490 --> 01:02:35,100
Again, this depends on what
version of Metamask we're using.

1129
01:02:35,640 --> 01:02:38,760
And we get this little drop down
that says Here are some of the

1130
01:02:38,760 --> 01:02:41,640
different type of gas fees that
you can actually pay. The reason

1131
01:02:41,640 --> 01:02:45,300
that gas fees might change, as
you can see here is that

1132
01:02:45,300 --> 01:02:47,940
depending on how busy the
blockchain is, you have to pay

1133
01:02:47,940 --> 01:02:52,680
more gas. If a lot of people are
sending transactions, that means

1134
01:02:52,680 --> 01:02:55,290
there's not going to be enough
space for everyone's transaction

1135
01:02:55,290 --> 01:02:58,320
to get through. That's a bit of
an oversimplification of what's

1136
01:02:58,320 --> 01:03:00,810
happening. But don't worry too
much about it for now. Now, if

1137
01:03:00,810 --> 01:03:04,620
we want to send the 0.05 ether
to our second account, we can

1138
01:03:04,620 --> 01:03:08,490
see this gas estimated section,
which is saying it's estimating,

1139
01:03:08,520 --> 01:03:15,390
we're going to pay 0.00004792
gas in addition to sending the

1140
01:03:15,390 --> 01:03:19,620
0.5 eath. So at the bottom, we
have amount plus gas fee. And

1141
01:03:19,620 --> 01:03:22,200
this is going to be the total
amount that we're going to be

1142
01:03:22,350 --> 01:03:26,310
spending on this transaction
0.05 is what we're sending. And

1143
01:03:26,310 --> 01:03:30,960
we also have this gas piece. So
we go ahead and confirm, we now

1144
01:03:30,960 --> 01:03:34,740
see we have a transaction
pending in our Rigby ether scan.

1145
01:03:34,860 --> 01:03:38,640
And if we click on it, we can
even hit View on block Explorer.

1146
01:03:39,900 --> 01:03:42,960
And a Rigby transaction hash
will pop up and depending on

1147
01:03:42,960 --> 01:03:46,200
when you click it, it might say
indexing, this means that ether

1148
01:03:46,200 --> 01:03:49,260
scan has received your
transaction and is trying to

1149
01:03:49,260 --> 01:03:52,140
place it. If you don't see
anything here, it means that

1150
01:03:52,140 --> 01:03:54,510
maybe the transaction hasn't
gone through yet. Maybe you need

1151
01:03:54,510 --> 01:03:57,090
to wait a little bit more. Or
maybe you need to go back to the

1152
01:03:57,090 --> 01:04:00,450
GitHub repo and pick the
recommended testament and

1153
01:04:00,450 --> 01:04:03,150
faucet. So you might have to
wait a minute or so for this to

1154
01:04:03,150 --> 01:04:06,750
actually finish indexing. After
a minute or so we can see that

1155
01:04:06,780 --> 01:04:09,780
this transaction has indeed
passed. And we can see a lot of

1156
01:04:09,780 --> 01:04:13,740
the same information that we saw
on our last one, this time with

1157
01:04:13,740 --> 01:04:18,030
0.05 ether. And now if we look
in our meta mask, we'll see we

1158
01:04:18,030 --> 01:04:22,020
can see account one has 0.05
It's rounding up a little bit,

1159
01:04:22,170 --> 01:04:24,270
we click on the big button, we
can see it actually has

1160
01:04:24,270 --> 01:04:30,240
0.049953, etc. And our other
account account two does have

1161
01:04:30,240 --> 01:04:35,340
exactly 0.05. This is because we
spent a little bit of Aetherium

1162
01:04:35,370 --> 01:04:39,390
on gas to send this transaction.
And now with just this little

1163
01:04:39,390 --> 01:04:42,660
bit of information, you know how
to actually interact with

1164
01:04:42,660 --> 01:04:45,570
applications that use the
blockchain, how to send

1165
01:04:45,570 --> 01:04:48,750
transactions and a lot of the
non technical details. Now

1166
01:04:48,750 --> 01:04:50,880
here's something that's
incredibly exciting with just

1167
01:04:50,880 --> 01:04:53,760
this little bit of information.
You now know how to interact

1168
01:04:53,760 --> 01:04:56,550
with blockchains and interact
with the Etherion protocol. So

1169
01:04:56,550 --> 01:05:00,120
if you don't want to learn how
to code anything, you can go If

1170
01:05:00,270 --> 01:05:02,730
you can start interacting with
Aetherium and interact with

1171
01:05:02,730 --> 01:05:06,000
protocols with just as much
information. However, I know

1172
01:05:06,000 --> 01:05:08,400
most of you guys are here to
learn how to code. So let's look

1173
01:05:08,490 --> 01:05:11,400
under the hood of Aetherium. And
what is actually going on with

1174
01:05:11,400 --> 01:05:13,830
these transactions, and what
these gas and what these

1175
01:05:13,830 --> 01:05:17,610
blockchains. And what's really
going on, let's learn all the

1176
01:05:17,610 --> 01:05:19,830
fundamentals of a blockchain.
Now, if you want to just go

1177
01:05:19,830 --> 01:05:22,590
ahead and jump into the coding,
go ahead and grab a timestamp

1178
01:05:22,620 --> 01:05:26,160
from the description. However,
learning exactly how the

1179
01:05:26,160 --> 01:05:28,920
blockchain works is going to
make you an incredibly powerful

1180
01:05:28,920 --> 01:05:29,520
developer.

1181
01:05:29,580 --> 01:05:33,990
So let's take a look at that
first. So we're going to

1182
01:05:33,990 --> 01:05:36,540
be going through this blockchain
demo on this site right here.

1183
01:05:36,540 --> 01:05:39,210
Now, the creator of the site has
a fantastic video and a

1184
01:05:39,210 --> 01:05:41,400
fantastic walk through
blockchain one on one, it is

1185
01:05:41,400 --> 01:05:44,340
right on their site. So if
you're looking for another

1186
01:05:44,340 --> 01:05:47,070
explanation, definitely check
out his video, it is absolutely

1187
01:05:47,070 --> 01:05:49,680
fantastic. But the first thing
that we really need to do in

1188
01:05:49,680 --> 01:05:52,440
order to understand blockchain
or just on really anything, and

1189
01:05:52,440 --> 01:05:54,330
everything that's going on here
working first really need to

1190
01:05:54,330 --> 01:05:58,410
understand this Sha 256, hash,
or hashing just kind of in

1191
01:05:58,410 --> 01:06:01,710
general, let's first understand
what a hash is. A hash is a

1192
01:06:01,710 --> 01:06:06,210
unique fixed length string,
meant to identify any piece of

1193
01:06:06,210 --> 01:06:09,330
data, they are created by
putting some piece of data into

1194
01:06:09,330 --> 01:06:13,890
a hash function. In this
example, the hashing algorithm

1195
01:06:13,890 --> 01:06:18,090
used is Sha 256. Now Etherium
actually uses this, this right

1196
01:06:18,090 --> 01:06:22,710
here for its hashing algorithm,
which isn't quite Sha 256, but

1197
01:06:22,710 --> 01:06:26,400
as in kind of this SHA family.
But it's really just another way

1198
01:06:26,400 --> 01:06:30,840
to hash things. And the specific
hash algorithm doesn't matter so

1199
01:06:30,840 --> 01:06:34,410
much. So this example, you just
shot up to six, but you can

1200
01:06:34,410 --> 01:06:36,540
imagine it's the same as the
Etherium. Hash, they're just

1201
01:06:36,540 --> 01:06:40,320
going to result in a different
hash. So what's going to happen

1202
01:06:40,350 --> 01:06:44,790
in this application here is
whatever data or whatever

1203
01:06:44,790 --> 01:06:48,330
information we put into this
data section here, as you can

1204
01:06:48,330 --> 01:06:54,240
see below this hash changes. So
what's happening is this data is

1205
01:06:54,240 --> 01:06:59,100
running through the Sha 256 hash
algorithm. And it's outputting,

1206
01:06:59,130 --> 01:07:04,740
this unique hash. So this hash
is a unique fixed length string,

1207
01:07:04,950 --> 01:07:07,830
that's going to identify like a
blank data piece here, right. So

1208
01:07:07,830 --> 01:07:11,520
if I put in, you know, my name
like Patrick Collins, this is

1209
01:07:11,520 --> 01:07:14,490
the hash that's going to
represent Patrick Collins,

1210
01:07:14,490 --> 01:07:18,540
right. And you can see, even
when I put, you know, tons and

1211
01:07:18,540 --> 01:07:23,640
tons of data in here, the length
of the string doesn't change,

1212
01:07:24,120 --> 01:07:29,160
right. So it's always gonna be
the same, we can put almost any

1213
01:07:29,160 --> 01:07:32,520
amount of data in here, there is
an upper limit on the max size

1214
01:07:32,520 --> 01:07:36,570
of the data. But for all intents
purposes, we can pretty much put

1215
01:07:36,570 --> 01:07:39,660
any length in here. And you'll
see to that every time I type in

1216
01:07:39,660 --> 01:07:43,290
Patrick Collins, this hash is
always gonna be this seven e

1217
01:07:43,290 --> 01:07:46,170
five D, right? I'm gonna delete
I'm gonna do Patrick Collins,

1218
01:07:46,170 --> 01:07:50,760
again, you're 75 B is always
this, this unique hash is always

1219
01:07:50,760 --> 01:07:53,610
going to be unique, right, it's
always gonna be this fixed

1220
01:07:53,640 --> 01:07:57,240
length string here. So now we
can take this idea while putting

1221
01:07:57,240 --> 01:08:01,500
this data in here, we can move
on to this concept of a block.

1222
01:08:01,620 --> 01:08:04,110
So with this block concept,
we're going to take the exact

1223
01:08:04,110 --> 01:08:06,870
same thing with this hash this
this data section, right, but

1224
01:08:06,870 --> 01:08:09,210
instead of having everything
just being in this, this

1225
01:08:09,210 --> 01:08:12,420
singular data area right here,
we're going to split this data

1226
01:08:12,420 --> 01:08:16,290
up into block, nuns, and data.
So all so what we're going to do

1227
01:08:16,290 --> 01:08:20,040
is we're actually going to hash
all three of these to get to get

1228
01:08:20,040 --> 01:08:21,570
this hash, right, we're gonna
put all three of these, we're

1229
01:08:21,570 --> 01:08:24,900
gonna say all three of these are
combined. Together, we're gonna

1230
01:08:24,930 --> 01:08:28,230
put every all three of them into
this hashing algorithm to figure

1231
01:08:28,230 --> 01:08:31,860
it out. So if I type a bunch of
stuff here, we can see that

1232
01:08:31,890 --> 01:08:36,330
block one with nonce, you know,
this nonce, and this data, we're

1233
01:08:36,330 --> 01:08:39,450
going to get this hash. And as
you can see, actually, the

1234
01:08:39,450 --> 01:08:44,250
screen turns red, this block
turned red. Now, what happens

1235
01:08:44,250 --> 01:08:47,580
when I hit this mind button?
When I hit this mind button,

1236
01:08:47,580 --> 01:08:49,410
it's actually gonna take some
time, it's gonna think for a

1237
01:08:49,410 --> 01:08:53,610
little bit. And we can see that
the nonce here actually changed,

1238
01:08:53,790 --> 01:08:56,820
right? The nonce is different
from what it was before. And

1239
01:08:57,480 --> 01:09:02,160
this hash now starts with four
zeros. Okay, and then the back

1240
01:09:02,160 --> 01:09:04,680
turn green. When we're talking
about mining, we're talking

1241
01:09:04,680 --> 01:09:08,250
about miners solving some type
of very difficult problem that

1242
01:09:08,250 --> 01:09:12,420
takes a lot of time to do now in
this example, here, the problem

1243
01:09:12,480 --> 01:09:17,160
that the miners had to solve was
they had to find a nonce, or or

1244
01:09:17,160 --> 01:09:20,790
a value in this nonce section
that when hashed with at block

1245
01:09:20,790 --> 01:09:25,380
number one with this data, it
would start with four zeros. So

1246
01:09:25,380 --> 01:09:28,050
the problem here the miners had
to solve was to start with four

1247
01:09:28,050 --> 01:09:31,440
zeros and the only way for them
to really do that is kind of

1248
01:09:31,440 --> 01:09:33,990
this brute force, you know,
trying stuff so they tried one

1249
01:09:33,990 --> 01:09:38,820
okay, one didn't work. Okay,
two, nope, two didn't work. 3456

1250
01:09:38,820 --> 01:09:40,740
Okay, five, well, that started
with one zero, but it's not

1251
01:09:40,740 --> 01:09:43,890
four. And they have to keep
trying all these numbers until

1252
01:09:43,890 --> 01:09:47,430
they get to this one where you
know, let's hit mine again.

1253
01:09:50,130 --> 01:09:54,240
Where it has four zeros at the
top at the start. Now, this

1254
01:09:54,240 --> 01:09:56,970
specific problem changes
blockchain to blockchain right

1255
01:09:56,970 --> 01:10:00,360
yet. Aetherium has a different
problem for miners to solve A

1256
01:10:00,570 --> 01:10:02,940
bitcoin is different problems
from yourself, but this concept

1257
01:10:02,940 --> 01:10:07,320
is going to be the same. So they
have to take it, one block is

1258
01:10:07,320 --> 01:10:10,530
going to be this, this, this
concept is going to be all this

1259
01:10:10,530 --> 01:10:13,890
data, it's going to be the block
number. And it's going to be

1260
01:10:13,890 --> 01:10:18,510
this nonce, right. And so this
nonce is the solution is going

1261
01:10:18,510 --> 01:10:20,940
to be the the number that they
use to get like the solution to

1262
01:10:20,940 --> 01:10:24,930
the problem, right? So if I go
to one here, you know, I do this

1263
01:10:24,930 --> 01:10:25,410
again,

1264
01:10:27,210 --> 01:10:30,630
hit mine. And the nonces
changed, right? And went from

1265
01:10:30,630 --> 01:10:35,760
one to 33,128. Because this is
the nonce that allowed this hash

1266
01:10:35,760 --> 01:10:39,810
to start with four zeros. And so
that's what's happening. When

1267
01:10:40,200 --> 01:10:42,510
blockchain miners are mining
they're going through this

1268
01:10:42,510 --> 01:10:46,410
process is very computationally
intensive process of trying to

1269
01:10:46,410 --> 01:10:50,070
find a nonce that fulfills
whatever the problem is. So

1270
01:10:50,070 --> 01:10:52,350
that's really it, actually. So
that's a block. And that's

1271
01:10:52,350 --> 01:10:54,510
really what's happening when
miners are mining. They're just

1272
01:10:54,510 --> 01:10:57,450
looking, there's trial and
error, brute force trying to

1273
01:10:57,450 --> 01:11:00,990
find this nut so so now that we
know what a block is, let's go

1274
01:11:00,990 --> 01:11:03,840
to the next step and figure out
okay, well, what's a block

1275
01:11:03,870 --> 01:11:08,190
chain. So here we have an
example of what a blockchain is

1276
01:11:08,190 --> 01:11:11,310
going to look like. Right, we
have a combination, you know, we

1277
01:11:11,310 --> 01:11:13,620
have back here in the block
section, we have one what one

1278
01:11:13,620 --> 01:11:17,460
block looks like. Now here, we
have multiple different blocks,

1279
01:11:17,460 --> 01:11:20,040
right, each one of these
represents a different block,

1280
01:11:20,040 --> 01:11:23,010
but we have an additional column
here, we have additional

1281
01:11:23,040 --> 01:11:26,850
variable here. So like before,
you know, we have block nonce

1282
01:11:26,850 --> 01:11:30,360
and data, right, we have blocked
nonce data, we also have this

1283
01:11:30,360 --> 01:11:33,780
thing called previous right, and
so this is actually gonna be

1284
01:11:33,780 --> 01:11:38,640
pointing to the previous hash of
the last block. So for example,

1285
01:11:38,640 --> 01:11:41,610
if we go to the last block in
this blockchain, it says

1286
01:11:41,610 --> 01:11:45,420
previous 008. And if we look at
the hash of block number four,

1287
01:11:45,660 --> 01:11:50,790
is 00008. And then we look at
its previous it's four zeros, B

1288
01:11:50,790 --> 01:11:54,120
nine, we have four zeros, B,
nine, and so on, all the way

1289
01:11:54,120 --> 01:11:58,110
back to our first block, which
has previous of just all zeros,

1290
01:11:58,260 --> 01:12:02,130
right. And so the block with the
previous of all zeros, is going

1291
01:12:02,130 --> 01:12:04,590
to be known as the Genesis
block. So you've probably heard

1292
01:12:04,590 --> 01:12:07,050
that before the Genesis block,
it's the first block in the

1293
01:12:07,050 --> 01:12:10,500
blockchain were the previous
hash points to a hash that

1294
01:12:10,710 --> 01:12:13,470
doesn't actually exist. Now, as
you can imagine, kind of the

1295
01:12:13,470 --> 01:12:17,070
same as how this block worked,
how the block nuts and dated all

1296
01:12:17,070 --> 01:12:20,580
go through the hashing algorithm
in the blockchain, the block

1297
01:12:20,610 --> 01:12:24,090
nonce data, and previous hash
all go through this hashing

1298
01:12:24,090 --> 01:12:28,560
algorithm to figure out what the
hashes okay? So if we go to over

1299
01:12:28,560 --> 01:12:31,890
here, you know, for example, if
I type in Patrick, obviously,

1300
01:12:31,920 --> 01:12:34,560
this is now no longer valid,
right? Because this nuns

1301
01:12:35,130 --> 01:12:37,980
combined with the block the data
in the previous hash, aren't

1302
01:12:37,980 --> 01:12:41,430
going to solve our problem of
having four zeros at the at the

1303
01:12:41,430 --> 01:12:44,460
start, right. So I'm gonna go
and fix that. And that's, that's

1304
01:12:44,460 --> 01:12:47,790
kind of an easy way to see it
being broken. But, but let's

1305
01:12:47,790 --> 01:12:51,780
take a look, if I break this
block, right here, what happens

1306
01:12:51,780 --> 01:12:54,480
if I, if I break the data in
here, if I do like Patrick in

1307
01:12:54,480 --> 01:12:59,220
here, you can see that both of
these are now read, both of

1308
01:12:59,220 --> 01:13:03,030
these are now invalid, right?
Because the block hash with the

1309
01:13:03,030 --> 01:13:06,450
nonce hash with the new data,
which is my name, Patrick has

1310
01:13:07,170 --> 01:13:11,520
hashed with the previous block
is now a brand new hash, right,

1311
01:13:11,550 --> 01:13:15,840
and this block is still pointing
to this previous hash right

1312
01:13:15,840 --> 01:13:19,920
here, right is pointing to this
previous block. And now it is

1313
01:13:19,920 --> 01:13:24,030
wrong, and it is messed up and
now, and now it's nuts with this

1314
01:13:24,030 --> 01:13:28,200
previous hash is also wrong.
Right? And this is where when we

1315
01:13:28,200 --> 01:13:32,130
talk about blockchains, being
immutable, this is exactly how

1316
01:13:32,130 --> 01:13:35,340
it's immutable, right? Because I
go back and I change anything,

1317
01:13:35,370 --> 01:13:39,060
you know, if I've just typed a
right here, the entire

1318
01:13:39,060 --> 01:13:42,420
blockchain is now invalidated.
Because none of these are going

1319
01:13:42,420 --> 01:13:47,220
to have nonces that solve this
equation anymore. So this is why

1320
01:13:47,220 --> 01:13:50,400
blockchains are immutable is
because anytime you change one

1321
01:13:50,400 --> 01:13:54,480
thing, you ruin the rest of the
blockchain, okay? So however,

1322
01:13:54,480 --> 01:13:57,330
though, you know, if it was
here, originally, we can go

1323
01:13:57,330 --> 01:14:00,420
ahead and mine these, mine all
these but as you can see, you

1324
01:14:00,420 --> 01:14:03,330
know, this is going to start
getting very computationally

1325
01:14:03,330 --> 01:14:07,170
expensive, because I have to go
redo basically the entire

1326
01:14:07,170 --> 01:14:10,500
blockchain. And the farther and
farther down the line you get,

1327
01:14:10,500 --> 01:14:13,800
the harder and harder it becomes
to, you know, rehash and redo

1328
01:14:13,830 --> 01:14:16,020
all these different block chains
here. Now, this makes a lot of

1329
01:14:16,020 --> 01:14:17,790
sense, right? So we have this
blockchain, it's really hard to

1330
01:14:17,790 --> 01:14:19,590
change something in the past,
but if we do, we can just go

1331
01:14:19,590 --> 01:14:22,800
ahead and remind it. Now if I'm
the one who controls the

1332
01:14:22,800 --> 01:14:25,020
blockchain, right, if I'm the
one who controls this, you know,

1333
01:14:25,020 --> 01:14:27,120
and I want to change something,
the past will, okay, great. All

1334
01:14:27,120 --> 01:14:30,390
I got to do is change the state
of here. And then you know,

1335
01:14:30,420 --> 01:14:32,460
mine, each one of these, you
know, obviously, it's going to

1336
01:14:32,700 --> 01:14:34,530
be very computationally
expensive, but it's something

1337
01:14:34,530 --> 01:14:37,470
that I can do right if I'm the
one who owns the blockchain.

1338
01:14:39,390 --> 01:14:42,330
Now, here's where the
decentralized nature or the

1339
01:14:42,330 --> 01:14:47,130
distributed nature really makes
it incredibly powerful. So we're

1340
01:14:47,130 --> 01:14:50,070
gonna go to the distributed tab
here, which is also referred to

1341
01:14:50,070 --> 01:14:53,190
as the decentralized tab here,
and it's going to show us what a

1342
01:14:53,190 --> 01:14:57,030
blockchain looks like in a
decentralized manner. So we have

1343
01:14:57,030 --> 01:15:00,270
this exact same initial setup
here we have to Shoot a

1344
01:15:00,270 --> 01:15:02,850
blockchain, we have our first
blockchain, which is kind of

1345
01:15:02,850 --> 01:15:06,600
exactly as the one from here.
But we also have more than once

1346
01:15:06,600 --> 01:15:10,140
we have peer, a peer beam, and
PRC and when people are talking

1347
01:15:10,140 --> 01:15:12,840
about Peer to Peer, peer to peer
transactions through the

1348
01:15:12,840 --> 01:15:15,210
talking, this is kind of that
concept that they're talking

1349
01:15:15,210 --> 01:15:18,480
about, right. So we have a
number of different peers who

1350
01:15:18,480 --> 01:15:20,820
are running this blockchain
technology, they're all weighted

1351
01:15:20,820 --> 01:15:23,910
equally, right, each one of
these peers or each one of these

1352
01:15:23,910 --> 01:15:27,300
nodes, each one of these
entities running a blockchain

1353
01:15:27,990 --> 01:15:32,310
has the exact same power as
anybody else, right. So the way

1354
01:15:32,310 --> 01:15:36,330
that we can tell very easily
which blockchain is correct, or

1355
01:15:36,330 --> 01:15:40,590
which ones are correct, or by
looking at this end, hash here,

1356
01:15:40,590 --> 01:15:44,160
right, or by looking at where we
are in the blockchain, because

1357
01:15:44,160 --> 01:15:47,670
again, remember, because again,
remember this, this hash that

1358
01:15:47,670 --> 01:15:52,290
this this in this last block
here, is going to encompass all

1359
01:15:52,290 --> 01:15:55,920
of the blocks from before,
right, because this last hash is

1360
01:15:55,920 --> 01:15:58,680
going to have the previous hash
here, which includes the

1361
01:15:58,680 --> 01:16:01,350
previous hash here, which this
hash includes the previous hash

1362
01:16:01,350 --> 01:16:05,070
here. And so this last hash is
encompasses everything in here,

1363
01:16:05,160 --> 01:16:08,730
right? And we can look, we can
look at the hash of Piercey,

1364
01:16:08,940 --> 01:16:11,760
which is four zeros, and then E
four B, we can look at the

1365
01:16:11,760 --> 01:16:15,810
latest hash appear B, which is
four zeros, E for B, and then

1366
01:16:15,810 --> 01:16:19,770
pure A, which is four zeros, E
for b. So all of these peers,

1367
01:16:19,800 --> 01:16:23,070
all of these nodes, all of these
decentralized, you know these

1368
01:16:23,070 --> 01:16:27,240
independent, all these
independent users running this

1369
01:16:27,240 --> 01:16:30,030
blockchain software, they're all
matched up, it's very easy for

1370
01:16:30,030 --> 01:16:32,970
their nodes to look at each
other and say, hey, great, we

1371
01:16:32,970 --> 01:16:37,710
are all matched up. Now, what
let's say that a decides that,

1372
01:16:37,740 --> 01:16:40,170
you know, something happened on
the blockchain that they didn't

1373
01:16:40,170 --> 01:16:43,320
like, and they wanted to go back
and change something, right. So

1374
01:16:43,320 --> 01:16:46,410
let's say they change here, you
know, obviously, the rest of

1375
01:16:46,410 --> 01:16:49,080
their blockchain is invalidated.
And they have to spend a lot of

1376
01:16:49,080 --> 01:16:52,170
computational power to catch up
to speed. So let's go ahead and

1377
01:16:52,170 --> 01:16:55,110
humor it. Let's say that they
did, they ended up catching up.

1378
01:16:55,950 --> 01:16:57,660
They ended up catching up, you
know, they ended up mining

1379
01:16:57,660 --> 01:17:01,830
everything. And now they have a
valid blockchain. Right? It

1380
01:17:01,830 --> 01:17:06,330
solves the equation. Awesome.
However, in block number three,

1381
01:17:06,840 --> 01:17:10,110
there's something new, right?
This is here, and it shouldn't

1382
01:17:10,110 --> 01:17:12,690
have been here, this is some
that Peer A put in by

1383
01:17:12,960 --> 01:17:17,820
themselves. All that happens now
is we look at all the

1384
01:17:17,820 --> 01:17:21,090
blockchains that are running the
software, and we're looking at

1385
01:17:21,120 --> 01:17:25,680
all the hashes and hash at block
number five. So pure A has this

1386
01:17:25,680 --> 01:17:31,380
new hash. Now, there's a 09 BC.
But pure B has a different hash

1387
01:17:31,440 --> 01:17:35,850
00, e for B, right? So who's
right? Is it disappear a with

1388
01:17:35,850 --> 01:17:39,300
their new stuff? Or is it pure
B? Well, that's where the

1389
01:17:39,300 --> 01:17:40,950
decentralized data comes in.
Because then we can look at

1390
01:17:40,950 --> 01:17:45,630
Piercey Piercey, also as E
forby. So if you're being

1391
01:17:45,630 --> 01:17:50,430
Piercey will say, Hey, you're a,
you're wrong, get out, right.

1392
01:17:50,640 --> 01:17:52,920
And pure A will stop being able
to participate in the mining

1393
01:17:52,920 --> 01:17:56,310
rewards because they have
essentially forked the

1394
01:17:56,310 --> 01:17:59,400
blockchain and started their own
little blockchain right with

1395
01:17:59,400 --> 01:18:02,520
their own history, because
they're the only ones with this,

1396
01:18:02,790 --> 01:18:07,290
this piece of data in block
three, whereas pure B, and pure

1397
01:18:07,290 --> 01:18:10,500
C have nothing in there. So that
really shows why in these

1398
01:18:10,500 --> 01:18:12,780
blockchain worlds in this
decentralized world, there

1399
01:18:12,780 --> 01:18:15,360
really is no centralized entity,
you know, pure A, you know,

1400
01:18:15,360 --> 01:18:18,330
might have been maliciously
motivated to change. You know,

1401
01:18:18,330 --> 01:18:21,570
there's this block number three,
however, democracy rules, right,

1402
01:18:21,570 --> 01:18:24,780
the majority rules in the
blockchain, pure vmpfc will say,

1403
01:18:24,780 --> 01:18:28,200
hey, you know, the, that's cute
and all puree. But you're wrong,

1404
01:18:28,230 --> 01:18:31,350
right? That's not right. Now, it
might be a little abstract, that

1405
01:18:31,350 --> 01:18:33,420
you just look at data and you
know, as typing kind of random

1406
01:18:33,420 --> 01:18:36,180
stuff in here and think, okay,
yeah, that's, that's data,

1407
01:18:36,180 --> 01:18:38,580
right? That makes sense, you
know, just kind of random

1408
01:18:38,580 --> 01:18:41,340
strings in here doesn't really
do anything for us. So if we

1409
01:18:41,340 --> 01:18:44,490
actually go over to the token
section here, this is where

1410
01:18:44,490 --> 01:18:47,670
everything really starts to make
a lot of sense. So we have the

1411
01:18:47,670 --> 01:18:52,170
exact same setup here with pure
a pure B Piercey. Except and the

1412
01:18:52,170 --> 01:18:55,530
difference is, instead of having
kind of this, this data section,

1413
01:18:55,530 --> 01:18:59,730
we have this TX This transaction
section, right? And this

1414
01:18:59,760 --> 01:19:03,390
represents all the transactions
that are happening in this

1415
01:19:03,390 --> 01:19:08,010
block, right? So we're sending
$25, from Darcy to Bingle, or to

1416
01:19:08,010 --> 01:19:13,830
Bingley force toward dollars and
27 cents here. 1922, right. And

1417
01:19:13,830 --> 01:19:17,010
it's the exact same thing. So
this, all these transactions are

1418
01:19:17,010 --> 01:19:20,880
gonna get hashed in the exact
same way that the data is going

1419
01:19:20,880 --> 01:19:23,400
to get hashed. And, and this is
why it's so powerful, because

1420
01:19:23,400 --> 01:19:26,850
again, you know, if I want to be
malicious, right, if, if I want

1421
01:19:26,850 --> 01:19:30,270
to say, hey, I really wanted to
give Jane a lot more money from

1422
01:19:30,270 --> 01:19:33,450
Elizabeth, so I'm puree and I go
back and I change it to 100.

1423
01:19:33,450 --> 01:19:37,860
Well, now, you know not only do
I does my whole blockchain get

1424
01:19:37,860 --> 01:19:41,250
invalidated because that was so
so long ago, but I'm not going

1425
01:19:41,250 --> 01:19:43,950
to match any of these other
chains. Right? And so my

1426
01:19:43,950 --> 01:19:46,950
blockchain is going to be
excluded from the overall

1427
01:19:46,950 --> 01:19:50,220
blockchain. So and let's let's
go ahead and fix this. And it's

1428
01:19:50,220 --> 01:19:53,400
the same thing if down here if I
become malicious, and I want to

1429
01:19:53,400 --> 01:19:55,200
send you know, I want

1430
01:19:56,730 --> 01:19:59,790
Miss Audrey to have less money.
Maybe I want to send $1 And they

1431
01:19:59,790 --> 01:20:04,560
go had in mind it the same thing
here, this hash now this two a

1432
01:20:04,560 --> 01:20:11,100
one is not going to match the
rubies rubies hash of BBA. And

1433
01:20:11,100 --> 01:20:14,610
it's not going to match Pierce's
hash of BBA as well. So the two

1434
01:20:14,610 --> 01:20:17,370
of them are gonna say, hey,
this, your blockchain is

1435
01:20:17,370 --> 01:20:20,220
invalid, it's not matching the
majority, you know, you're out,

1436
01:20:20,340 --> 01:20:25,590
right. So that's really how
these blockchains work at a low

1437
01:20:25,590 --> 01:20:28,470
level. And it all goes back to
this, this understanding this

1438
01:20:28,470 --> 01:20:32,520
hash idea, and using it in this
very sophisticated manner, to

1439
01:20:32,520 --> 01:20:36,240
kind of cryptographically prove,
you know, where, where stuff

1440
01:20:36,240 --> 01:20:39,000
lies. Now, the way the
blockchain works is, instead of

1441
01:20:39,000 --> 01:20:41,370
random stuff, put in the Status
section, it's actually going to

1442
01:20:41,370 --> 01:20:44,790
be solidity code in here to
finding ways to interact with

1443
01:20:44,790 --> 01:20:47,970
different blocks and different
protocols that are on chain, or,

1444
01:20:48,240 --> 01:20:52,350
as we've said before, different
smart contracts. Now, the next

1445
01:20:52,350 --> 01:20:56,160
question that you might be
asking is, okay, well, how do I

1446
01:20:56,160 --> 01:21:00,540
know how can I be sure that I'm
the one? You know, let's say

1447
01:21:00,540 --> 01:21:03,630
this is, let's say, I'm Darcy
right? How can I be sure that I

1448
01:21:03,630 --> 01:21:06,780
was that Darcy was the one to
actually send us money here. How

1449
01:21:06,780 --> 01:21:11,460
do we know that Darcy sent $25.
To Bingley? Well, this is where

1450
01:21:11,460 --> 01:21:15,210
we get into private keys and
public keys. And that's what

1451
01:21:15,210 --> 01:21:18,660
we're going to go into. Now.
Let's just do a quick recap of

1452
01:21:18,660 --> 01:21:20,910
what we've learned in this
section. So far, right? We've

1453
01:21:20,910 --> 01:21:25,290
learned that Aetherium actually
runs on this hit check 256. But

1454
01:21:25,410 --> 01:21:28,800
we use Sha 256. For this demo,
it doesn't really matter. We're

1455
01:21:28,800 --> 01:21:33,090
just talking about hashing
algorithms. So again, hash is a

1456
01:21:33,090 --> 01:21:39,000
unique fixed length string meant
to identify any piece of data. A

1457
01:21:39,000 --> 01:21:42,150
hash algorithm or a hash
function is a function or

1458
01:21:42,150 --> 01:21:46,650
algorithm that computes any type
of data into a unique hash.

1459
01:21:47,220 --> 01:21:50,280
Mining is going to be the
process of finding the solution

1460
01:21:50,310 --> 01:21:53,280
to the blockchain problem. In
our example, the problem was

1461
01:21:53,280 --> 01:21:57,240
finding a hash that starts with
four zeros. nodes get paid for

1462
01:21:57,240 --> 01:22:00,120
mining different blocks. And the
problem is going to be different

1463
01:22:00,120 --> 01:22:03,480
blockchain to blockchain a block
and a blockchain is basically a

1464
01:22:03,480 --> 01:22:07,080
combination of a block, nonce
transaction and previous hash to

1465
01:22:07,080 --> 01:22:11,490
create this unique hash for this
block. And again, depending on

1466
01:22:11,490 --> 01:22:13,890
the blockchain implementation,
this might have a couple other

1467
01:22:13,890 --> 01:22:16,200
fields or might have different
fields. But this is essentially

1468
01:22:16,200 --> 01:22:19,470
what's going on blockchains are
decentralized and distributed

1469
01:22:19,470 --> 01:22:22,620
because many independent users
are going to run this blockchain

1470
01:22:22,620 --> 01:22:25,050
software. And they will check
and then we'll compare against

1471
01:22:25,050 --> 01:22:27,930
each other to see which
blockchains are acting honestly,

1472
01:22:27,930 --> 01:22:30,780
and which ones are acting
maliciously, in the blockchain

1473
01:22:30,780 --> 01:22:35,490
world majority rules. The nonce
here is the answer used or the

1474
01:22:35,490 --> 01:22:39,270
number used to get this hash.
Now nonce is kind of an

1475
01:22:39,270 --> 01:22:41,850
overloaded term, it's actually
used for a number of different

1476
01:22:41,850 --> 01:22:44,700
reasons. In this case, we're
using it to solve this problem

1477
01:22:44,700 --> 01:22:48,030
of getting four or five zeros at
the stop or the hash. However,

1478
01:22:48,030 --> 01:22:51,300
in Aetherium, it will also be
often used as the number of

1479
01:22:51,300 --> 01:22:54,090
transactions from a given
address.

1480
01:22:56,700 --> 01:22:58,650
So now we're going to talk a
little bit about signing these

1481
01:22:58,650 --> 01:23:01,830
transactions and private keys
and some other cryptography

1482
01:23:01,830 --> 01:23:04,890
pieces, right? Because in this
blockchain demo here, we can see

1483
01:23:04,950 --> 01:23:06,930
we have all these these
fantastic transactions, right?

1484
01:23:06,930 --> 01:23:09,660
All these things went through,
but how do we know that it was

1485
01:23:09,690 --> 01:23:14,580
Darcy? Who was the one to send
$25? To bangli? Right? How do we

1486
01:23:14,580 --> 01:23:18,900
know that actually happened. And
this is where all those pieces

1487
01:23:18,900 --> 01:23:22,890
that we just learned about in
our test net, in our meta mask

1488
01:23:22,890 --> 01:23:25,260
account are really going to
start to, to come to life here a

1489
01:23:25,260 --> 01:23:29,280
little bit here. So here we have
an example of public and private

1490
01:23:29,340 --> 01:23:33,420
keys, okay, at the top, we have
this private key, right that was

1491
01:23:33,450 --> 01:23:37,230
that was randomly generated. A
private key is you know, as it

1492
01:23:37,230 --> 01:23:39,930
kind of states is a key that you
really want to keep secret,

1493
01:23:39,930 --> 01:23:43,050
because you're going to be using
this as kind of your your secret

1494
01:23:43,050 --> 01:23:45,690
password for all your
transactions where I can really

1495
01:23:45,690 --> 01:23:49,770
pick, you know, any, any, any
private key, anything that I

1496
01:23:49,770 --> 01:23:54,030
want. And with it, this
algorithm, or they're going to

1497
01:23:54,030 --> 01:23:56,700
use an algorithm for Aetherium.
Bitcoin, they both use this

1498
01:23:56,730 --> 01:24:00,030
elliptic curve, digital
signature algorithm, it's a

1499
01:24:00,030 --> 01:24:03,300
variant of just a digital
signature algorithm. And it's

1500
01:24:03,300 --> 01:24:05,850
going to create this this public
key, right, I'm really not going

1501
01:24:05,850 --> 01:24:09,480
to go at all into kind of this
digital signature algorithm. But

1502
01:24:09,480 --> 01:24:12,480
just know it does use some of
these, some of the hash

1503
01:24:13,020 --> 01:24:15,720
knowledge that we just learned
combined with some other pieces

1504
01:24:16,260 --> 01:24:18,990
to kind of get this this public
here. So I'm not gonna go too

1505
01:24:18,990 --> 01:24:22,380
deep into it. But we have this
private key that we create. And

1506
01:24:22,380 --> 01:24:26,070
we get this public key. Now this
public key we want everybody to

1507
01:24:26,070 --> 01:24:28,890
have access to right this is
yeah, whole world can see this,

1508
01:24:28,890 --> 01:24:32,790
this private key, we really want
it to be private, we don't want

1509
01:24:32,790 --> 01:24:35,820
people to see this, we're going
to use this private key as like

1510
01:24:35,820 --> 01:24:40,380
a password to quote unquote,
digitally sign transactions, and

1511
01:24:40,380 --> 01:24:44,640
then people can verify them with
this public key. So let's, let's

1512
01:24:44,640 --> 01:24:46,830
see what this actually looks
like. Let's pick a random key, a

1513
01:24:46,830 --> 01:24:49,590
more secure key, right? Because
the longer it is, the more

1514
01:24:49,590 --> 01:24:53,610
secure it's going to be. And if
we go to signatures now, right?

1515
01:24:54,090 --> 01:24:57,630
Let's say we have this, this
message that we want, right?

1516
01:24:57,630 --> 01:25:00,660
We'll say hi world, right? We
want this To be the message,

1517
01:25:00,900 --> 01:25:04,350
what's gonna happen is this
private key that we've created,

1518
01:25:04,650 --> 01:25:07,380
we can use to sign this data,
right? Remember how in the

1519
01:25:07,380 --> 01:25:10,350
blockchain demo, you know, we
were kind of we were hashing

1520
01:25:10,350 --> 01:25:14,970
stuff, right? We were using this
Shea 256 hash to get this hash.

1521
01:25:14,970 --> 01:25:17,400
Well, we're doing something
similar. But instead of hashing,

1522
01:25:17,400 --> 01:25:20,790
we're, we're using this digital
signature algorithm to create

1523
01:25:20,790 --> 01:25:24,810
this message signature. Now,
what's really powerful about how

1524
01:25:24,810 --> 01:25:28,950
this this algorithm works, is
that you can create this message

1525
01:25:28,950 --> 01:25:33,300
signature with your private key,
but somebody else can't derive

1526
01:25:33,300 --> 01:25:36,540
your private key from the
message signature. And that's

1527
01:25:36,540 --> 01:25:39,450
what makes this really, really
powerful. However, if we go to

1528
01:25:39,450 --> 01:25:43,920
verify using this public key,
right, and so this is the this

1529
01:25:43,920 --> 01:25:47,760
is that, Oh, 403. This is that
same public key, using this,

1530
01:25:47,940 --> 01:25:51,810
using this public key, anybody
can verify, let's go ahead and

1531
01:25:51,810 --> 01:25:57,150
sign again, anybody can verify
that the signature is yours,

1532
01:25:57,420 --> 01:26:01,680
right? So you have a public a
private key, just for you. So

1533
01:26:01,680 --> 01:26:04,920
you can sign things and a public
key that anybody can verify

1534
01:26:04,920 --> 01:26:07,860
something, right. So anybody can
verify this, and let's say

1535
01:26:07,860 --> 01:26:10,110
somebody tries to fake a
transaction from you, they say,

1536
01:26:10,110 --> 01:26:15,270
Hey, you know, this is this is
this is their transaction, all

1537
01:26:15,270 --> 01:26:19,590
they have to do is verify that
this signature against your

1538
01:26:19,620 --> 01:26:24,120
public key and very easily, this
whole thing turns red, because

1539
01:26:24,390 --> 01:26:27,780
it isn't verified, right, that
the algorithm says, hey, that's

1540
01:26:27,780 --> 01:26:31,530
wrong. So we can go ahead and
take that into transactions in

1541
01:26:31,530 --> 01:26:35,130
this exact same way. So if I
want to send money, you know, if

1542
01:26:35,130 --> 01:26:40,290
I want to send $400, from, you
know, my address to another

1543
01:26:40,290 --> 01:26:45,240
address, using my private key, I
can sign that transaction. And

1544
01:26:45,240 --> 01:26:48,930
anybody else in the world can
then verify this transaction,

1545
01:26:49,050 --> 01:26:52,110
right. And this is why when
people say Hydra keys, you know,

1546
01:26:52,110 --> 01:26:55,110
protect your keys, this is what
we're talking about in our

1547
01:26:55,110 --> 01:27:00,420
accounts here. Right? If we go
to settings, and again, the only

1548
01:27:00,420 --> 01:27:03,270
reason that I'm showing you
guys, my pneumonic, and my

1549
01:27:03,270 --> 01:27:06,660
private key is because this is
a, this is a dumpster account,

1550
01:27:06,660 --> 01:27:08,730
I'm going to throw this away at
the end of this video, or I'm

1551
01:27:08,730 --> 01:27:15,480
just not gonna put any real
money in it. But when we look at

1552
01:27:15,480 --> 01:27:19,770
our Metamask, here, we have this
pneumonic phrase, which allows

1553
01:27:19,770 --> 01:27:24,270
us to easily get these different
private keys, right? So

1554
01:27:24,720 --> 01:27:28,680
pneumonic phrase combined with,
you know, whatever account

1555
01:27:28,680 --> 01:27:31,380
number will get us a private
key. So mnemonic phrase combined

1556
01:27:31,380 --> 01:27:34,650
with one, we're gonna get this
private key. And this is when we

1557
01:27:34,650 --> 01:27:36,690
look at account details, export
private key.

1558
01:27:40,950 --> 01:27:44,310
That's where it confirm, this is
going to be the private key that

1559
01:27:44,310 --> 01:27:47,370
we're going to use to sign our
transactions, right, this, if

1560
01:27:47,400 --> 01:27:50,580
anybody else gets access to this
private key, they then can sign

1561
01:27:50,580 --> 01:27:54,090
transactions for us, and they
can send transactions for us.

1562
01:27:54,090 --> 01:27:57,480
And that's why we want to keep
these private, so that it works

1563
01:27:57,480 --> 01:28:00,300
the exact same way, right. And
so this is why it's so important

1564
01:28:00,300 --> 01:28:03,840
to hide your private keys and
hide your mnemonics now, your

1565
01:28:03,870 --> 01:28:11,940
Aetherium address is actually a
piece is actually a piece of

1566
01:28:11,940 --> 01:28:15,540
your public key. Now, to get our
address in Aetherium, all we

1567
01:28:15,540 --> 01:28:17,880
have to do is take this public
key that we've created with our

1568
01:28:17,880 --> 01:28:21,150
private key, hash it using that
same Aetherium hashing

1569
01:28:21,150 --> 01:28:23,910
algorithm, and then take the
last 20 bytes. And that's how

1570
01:28:23,910 --> 01:28:28,110
we'll actually derive to our to
our address here. Now, knowing

1571
01:28:28,110 --> 01:28:31,890
the exact methodology of how to
get the address doesn't really

1572
01:28:31,890 --> 01:28:34,050
matter, because it could change
blockchain to blockchain and

1573
01:28:34,170 --> 01:28:36,930
could even change it too. But
just know that that is

1574
01:28:36,930 --> 01:28:39,780
essentially how kind of these
addresses are derived or there's

1575
01:28:39,780 --> 01:28:43,080
some derivative of the public
key, right, because the public

1576
01:28:43,080 --> 01:28:46,590
key is public. And you know,
using the public key and kind of

1577
01:28:46,590 --> 01:28:50,820
any public way is totally fine,
but not the private key. So that

1578
01:28:50,820 --> 01:28:53,910
is how we sign our transactions.
Note though, this isn't how we

1579
01:28:53,910 --> 01:28:56,880
send the transaction. So so this
is just going to assign it

1580
01:28:56,880 --> 01:29:00,090
create a transaction for us to
send, we'll learn later on how

1581
01:29:00,090 --> 01:29:02,910
to send these transactions.
Cool. So that was a lot of

1582
01:29:02,910 --> 01:29:06,240
information there too. Let's do
a quick recap, your public key

1583
01:29:06,270 --> 01:29:10,080
is derived by using a digital
signature algorithm on your

1584
01:29:10,080 --> 01:29:13,620
private key, right, and you want
to keep your private key private

1585
01:29:13,650 --> 01:29:16,680
at all times, because you're
going to use your private key to

1586
01:29:16,680 --> 01:29:20,190
sign transactions. Signing
transactions with your private

1587
01:29:20,190 --> 01:29:23,040
key, you are the only one who
can actually do this because you

1588
01:29:23,040 --> 01:29:27,570
can't get the private key from a
message signature. However,

1589
01:29:27,780 --> 01:29:32,040
using your public key, you can
anybody can very easily verify

1590
01:29:32,040 --> 01:29:35,940
that a signature that signed by
you is in fact signed by you in

1591
01:29:35,940 --> 01:29:39,360
our meta mask. Our private keys
are located in this account

1592
01:29:39,360 --> 01:29:43,020
details section you just hit
show private keys and type in

1593
01:29:43,020 --> 01:29:46,530
your password. And you'll get
your your private key here. A

1594
01:29:46,530 --> 01:29:49,470
quick note here is oftentimes
when using your private keys

1595
01:29:49,470 --> 01:29:52,650
somewhere, they want it in
hexadecimal form. So if we're

1596
01:29:52,650 --> 01:29:56,430
going to use our private key for
something like brownie, which

1597
01:29:56,430 --> 01:29:59,550
we'll go into later, we need to
actually append a 0x to the

1598
01:29:59,550 --> 01:30:03,600
front but We'll get into that
later. And the address of your

1599
01:30:03,600 --> 01:30:07,680
account is derived from this. So
if you think about your private

1600
01:30:07,680 --> 01:30:11,190
key creates your public key,
which then can create your

1601
01:30:11,190 --> 01:30:15,960
address. And there's a little
barrier or a big barrier here.

1602
01:30:16,860 --> 01:30:18,690
Because your private key, you
want to keep private and your

1603
01:30:18,690 --> 01:30:21,060
public key and your address can
all be public information.

1604
01:30:27,930 --> 01:30:28,710
Now that we know a little

1605
01:30:28,710 --> 01:30:31,140
bit more about what's going on
underneath the hood of these

1606
01:30:31,140 --> 01:30:34,080
blockchains, let's go back at
our transactions and look at

1607
01:30:34,080 --> 01:30:36,630
this gas thing again, and we'll
look to see what's actually

1608
01:30:36,630 --> 01:30:39,390
happening here, gas in
particular can be a little bit

1609
01:30:39,390 --> 01:30:42,030
tricky to wrap your head around.
So if you don't get it right

1610
01:30:42,030 --> 01:30:45,240
away, don't worry. As we go
through examples, it'll start to

1611
01:30:45,240 --> 01:30:48,600
make more sense. So before I was
saying, let's just look at this

1612
01:30:48,600 --> 01:30:51,210
transaction fee bid, which is
the costs associated with

1613
01:30:51,210 --> 01:30:54,150
running this transaction. If I
scroll over this on ether scan,

1614
01:30:54,210 --> 01:30:57,540
I can see this thing that says
block base fee per gas plus max

1615
01:30:57,540 --> 01:31:01,440
party fee per gas times the gas
use, which might be a little bit

1616
01:31:01,440 --> 01:31:04,290
confusing here, let's actually
break down what's going on on

1617
01:31:04,290 --> 01:31:08,100
Aetherium with ERP 15, five nine
in place. And again, this is

1618
01:31:08,100 --> 01:31:10,440
going to be specific to
Aetherium, as every blockchain

1619
01:31:10,440 --> 01:31:12,360
might do it a little bit
differently. But if we click to

1620
01:31:12,360 --> 01:31:15,540
see more, we can see a number of
useful values here, we can see

1621
01:31:15,540 --> 01:31:21,030
gas limit is 21,000. And usage
is 21,000. So this transaction

1622
01:31:21,060 --> 01:31:26,370
used 21,000 gas, and we sent
21,000 gas along with it.

1623
01:31:26,730 --> 01:31:29,760
Sometimes when sending a
transaction, depending on when

1624
01:31:29,760 --> 01:31:32,700
it's sent. And depending on what
the specific instructions are,

1625
01:31:32,760 --> 01:31:35,160
it might actually use way more
gas than what you want it to

1626
01:31:35,160 --> 01:31:38,160
use. So with your transactions,
you can actually set a limit,

1627
01:31:38,190 --> 01:31:41,970
hey, I don't want to use more
than x amount of gas, I don't

1628
01:31:41,970 --> 01:31:45,180
want to do more than x
computational units. And in

1629
01:31:45,180 --> 01:31:49,080
fact, we go to our Metamask. And
we click Send to transfer

1630
01:31:49,080 --> 01:31:53,040
between accounts again, and we
pick you know, 0.01 eath, or

1631
01:31:53,040 --> 01:31:57,090
something next can actually hit
this little button here, go to

1632
01:31:57,090 --> 01:32:00,390
Advanced, and we can actually
edit some specifics of this

1633
01:32:00,390 --> 01:32:03,690
transaction, one of them is
going to be the gas limit, we

1634
01:32:03,690 --> 01:32:09,060
can change this gas limit to
maybe 2200 2300, or more or even

1635
01:32:09,060 --> 01:32:13,500
less, since sending Aetherium
takes exactly 21,000 Gas

1636
01:32:13,560 --> 01:32:16,410
Metamask just defaults to
setting into that. Well, we also

1637
01:32:16,410 --> 01:32:19,020
see these other interesting
things, we see a priority fee,

1638
01:32:19,320 --> 01:32:24,750
and a max base fee. Let's reject
this transaction. And let's look

1639
01:32:24,750 --> 01:32:27,660
back at ether scan to talk about
these. So currently in

1640
01:32:27,660 --> 01:32:32,580
Aetherium, according to EE IP
1559, every transaction on

1641
01:32:32,580 --> 01:32:36,150
Aetherium comes with something
called the base fee. This is the

1642
01:32:36,150 --> 01:32:39,960
minimum gas price you need to
set to include your transaction.

1643
01:32:40,410 --> 01:32:42,870
And you'll notice that these are
priced in something called

1644
01:32:43,170 --> 01:32:47,280
gateway. So what is a gateway?
If we come to the site eath

1645
01:32:47,280 --> 01:32:50,340
converter.com. And again,
there's a link to this in the

1646
01:32:50,340 --> 01:32:55,230
GitHub repository, we scroll
down we can see way gateway and

1647
01:32:55,230 --> 01:33:00,330
ether five put one ether in
here, I can see how much one

1648
01:33:00,360 --> 01:33:04,830
ether is in terms of way. And in
terms of way, one ether is equal

1649
01:33:04,830 --> 01:33:12,480
to 1-234-567-8990. So that's
that's 1 billion way is going to

1650
01:33:12,480 --> 01:33:18,960
be one ether. And then
1-234-567-8910 1112 1314 Did 16

1651
01:33:18,960 --> 01:33:23,550
Seven, eight team and then 18
zeros is away. These are just

1652
01:33:23,580 --> 01:33:27,180
easier ways of referring to
really, really small amounts of

1653
01:33:27,210 --> 01:33:31,410
Aetherium. So if we look at our
gas fees, we see that the base

1654
01:33:31,410 --> 01:33:38,640
fee is 0.00000004 Go away. And
this obviously would be an even

1655
01:33:38,640 --> 01:33:42,090
smaller number if this was in
units of weigh. So if we take

1656
01:33:42,090 --> 01:33:46,650
this number, and we put it into
our calculator, we can see that

1657
01:33:46,650 --> 01:33:51,780
this is equal to 40 weigh or
0.0000 a whole bunch of zeros

1658
01:33:51,780 --> 01:33:55,920
for ether. The max fee here
refers to the maximum gas fee

1659
01:33:55,920 --> 01:33:59,520
that we're willing to pay for
this transaction. And you can

1660
01:33:59,520 --> 01:34:04,230
actually see that our max fee is
a little bit higher than what we

1661
01:34:04,230 --> 01:34:08,400
actually ended up paying. Our
maximum was 2.2132 something

1662
01:34:08,400 --> 01:34:12,180
something and the gas price we
actually paid was up here. Now

1663
01:34:12,180 --> 01:34:15,090
your transaction might of course
be a little bit different than

1664
01:34:15,090 --> 01:34:18,330
Additionally we have a max
priority fee. This is going to

1665
01:34:18,330 --> 01:34:21,660
be the max gas fee that we're
willing to pay plus the max tip

1666
01:34:21,660 --> 01:34:24,000
that we're willing to give to
miners. Now currently in

1667
01:34:24,000 --> 01:34:28,710
Aetherium, this base fee ends up
getting burnt and we can see on

1668
01:34:28,710 --> 01:34:31,650
ether scan exactly how much is
getting burnt here. And if we

1669
01:34:31,650 --> 01:34:36,870
pull up our calculator again, we
can grab this gas fee, multiply

1670
01:34:36,870 --> 01:34:40,920
it by the amount of gas we used,
and we can see that this is

1671
01:34:40,920 --> 01:34:44,220
indeed how much Aetherium we
actually ended up burning. We go

1672
01:34:44,220 --> 01:34:47,070
back to Ethereum converter,
paste it in we can see that

1673
01:34:47,070 --> 01:34:51,570
these two numbers are indeed
equal. This means whenever you

1674
01:34:51,570 --> 01:34:55,500
send a transaction, a little bit
of Aetherium is removed from

1675
01:34:55,500 --> 01:34:59,640
circulation forever, or it's
considered burnt. So currently,

1676
01:34:59,640 --> 01:35:01,920
in theory As part of your
Aetherium part of your

1677
01:35:01,920 --> 01:35:05,280
transaction fee actually gets
burnt. And then the other part

1678
01:35:05,310 --> 01:35:08,880
goes directly to miners. So to
figure out exactly how much went

1679
01:35:08,880 --> 01:35:14,820
to miners, we could do this
number minus the burnt amount.

1680
01:35:14,910 --> 01:35:18,450
And this is how much Etherium
was paid to Aetherium miner for

1681
01:35:18,450 --> 01:35:21,180
this transaction, you'll see
down here your transaction type

1682
01:35:21,180 --> 01:35:26,430
to ERP 15, five, nine, this is
the eip 15 five nine version of

1683
01:35:26,430 --> 01:35:28,890
these transactions. Like I said,
every blockchain is going to

1684
01:35:28,890 --> 01:35:33,000
have a different fee burning and
fee and gas process. And they're

1685
01:35:33,000 --> 01:35:35,610
all going to be a little bit
different, but the some of it is

1686
01:35:35,640 --> 01:35:39,600
blockchains have limited block
space for transactions, the gas

1687
01:35:39,600 --> 01:35:42,510
price that costs for your
transaction to be included in

1688
01:35:42,510 --> 01:35:45,990
one of these blocks changes
based off how much demand there

1689
01:35:45,990 --> 01:35:49,320
is the base gas fee for
Aetherium will go up and down

1690
01:35:49,350 --> 01:35:53,580
depending on how many people are
sending transactions and how

1691
01:35:53,580 --> 01:35:57,210
many people want to be included
in a block. If a ton of people

1692
01:35:57,210 --> 01:36:01,080
want to be included in a block.
That means a ton of gas is

1693
01:36:01,110 --> 01:36:04,830
obviously going to get burnt.
We've left a link to a video in

1694
01:36:04,830 --> 01:36:08,610
the GitHub repository with this
section from this YouTuber who

1695
01:36:08,610 --> 01:36:12,960
does an amazing job breaking
down this EIP 15, five, nine and

1696
01:36:12,960 --> 01:36:16,080
more about how this gas model
actually works. I highly

1697
01:36:16,080 --> 01:36:18,840
recommend you pause this video
and watch that video. To

1698
01:36:18,840 --> 01:36:21,960
understand more, the base fee
gets programmatically

1699
01:36:21,960 --> 01:36:26,100
algorithmically adjusted to try
to target for all the blocks to

1700
01:36:26,100 --> 01:36:30,960
be 50% full. If they're more
than 50% full, this base fee

1701
01:36:30,990 --> 01:36:34,590
automatically goes up. If
they're less than 50% full, this

1702
01:36:34,590 --> 01:36:38,190
base fee goes down. Now this is
a lot of the basics of how this

1703
01:36:38,190 --> 01:36:40,890
transaction works. And it can be
a little confusing. So let's do

1704
01:36:40,920 --> 01:36:43,890
a quick refresher of everything
in here. There's a unique

1705
01:36:43,890 --> 01:36:48,750
transaction hash that uniquely
identifies this transaction. On

1706
01:36:48,780 --> 01:36:52,560
this blockchain, we can see the
status, we can see the block

1707
01:36:52,590 --> 01:36:56,010
number that it's confirmed on.
One other thing we want to look

1708
01:36:56,010 --> 01:36:58,890
at. If we scroll up, we see
block number and block

1709
01:36:58,890 --> 01:37:03,300
confirmations. This is how many
blocks have been mined. Since

1710
01:37:03,360 --> 01:37:06,990
this block was included. Like we
saw with our blockchain demo,

1711
01:37:07,020 --> 01:37:10,320
the longer the blockchain gets,
the harder it is to tamper with

1712
01:37:10,320 --> 01:37:12,660
and the more secure it is
typically, you'll see some

1713
01:37:12,660 --> 01:37:16,140
processes say they'll only do
something after 20 Block

1714
01:37:16,140 --> 01:37:20,310
confirmations, 30 Block
confirmations or etc. The reason

1715
01:37:20,310 --> 01:37:22,890
that they wait for these block
confirmations is because they

1716
01:37:22,890 --> 01:37:25,290
want to make sure that that
transaction is actually

1717
01:37:25,290 --> 01:37:28,830
included. And we can actually
see the block that our

1718
01:37:28,830 --> 01:37:32,100
transaction was included in and
all the other transactions with

1719
01:37:32,100 --> 01:37:35,700
it, different details about how
much gas was used, the gas

1720
01:37:35,700 --> 01:37:39,780
limit, etc. timestamp is when
the transaction happened, we can

1721
01:37:39,780 --> 01:37:44,130
see from and to we can see the
value. And then we can see the

1722
01:37:44,130 --> 01:37:47,670
transaction fee, which we see
right here is blocked base fee

1723
01:37:47,670 --> 01:37:51,540
per gas plus the max priority
fee per gas times the gas used.

1724
01:37:51,660 --> 01:37:54,870
And we see all the details of
the gas down here gas price is

1725
01:37:54,870 --> 01:38:00,090
the cost of one unit of gas gas
limit is the max amount of units

1726
01:38:00,090 --> 01:38:03,960
of gas that we're willing to pay
in this transaction, the usage

1727
01:38:03,990 --> 01:38:07,860
is how many actually got us the
base fee is going to be the base

1728
01:38:07,890 --> 01:38:13,980
network fee per gas. So 40 way
per one gas used, the max gas is

1729
01:38:13,980 --> 01:38:18,360
the max gas price we're willing
to pay. And Max priority is

1730
01:38:18,360 --> 01:38:21,720
gonna be the max gas price, plus
the tip that we give to miners,

1731
01:38:21,750 --> 01:38:23,940
and then we can see how much is
burnt. And then we see

1732
01:38:23,940 --> 01:38:27,360
transaction savings which which
is the difference between how

1733
01:38:27,360 --> 01:38:31,110
much was actually used or paid
for and then returned. So for

1734
01:38:31,110 --> 01:38:34,650
example, in this transaction,
the gas price we ended up

1735
01:38:34,650 --> 01:38:38,760
picking was a little less than
our max gas price here. So the

1736
01:38:38,760 --> 01:38:41,880
gas price we ended up using was
a little less than our max

1737
01:38:41,880 --> 01:38:45,420
priority fee here. So we had
some savings compared to that,

1738
01:38:45,510 --> 01:38:49,290
we can also see that this was an
ERP 15 five nine transaction, we

1739
01:38:49,290 --> 01:38:53,490
can see our nonce here, which
was not zero because the

1740
01:38:53,490 --> 01:38:56,460
transaction that I'm showing is
our first nones. And then of

1741
01:38:56,460 --> 01:38:59,520
course, we can see the input
data for transactions that are

1742
01:38:59,520 --> 01:39:02,670
just sending Aetherium, the
input data is going to be blank.

1743
01:39:02,700 --> 01:39:05,220
But you'll see that when we get
to smart contracts, the input

1744
01:39:05,220 --> 01:39:07,560
data is not going to be blank.
And it's going to be one of the

1745
01:39:07,560 --> 01:39:11,490
most important features of these
transactions. You'll also notice

1746
01:39:11,490 --> 01:39:15,420
that there's a state tab. This
is an advanced tab, and it shows

1747
01:39:15,450 --> 01:39:18,510
the different states that are
changed based off of this

1748
01:39:18,510 --> 01:39:21,480
transaction. We're going to
ignore this one for now. Now

1749
01:39:21,480 --> 01:39:24,570
that we know how the blockchain
itself works under the hood,

1750
01:39:24,600 --> 01:39:28,260
let's talk about some blockchain
fundamentals. And we actually

1751
01:39:28,260 --> 01:39:31,530
covered all these topics in a
previous Freako camp video. So

1752
01:39:31,530 --> 01:39:32,250
let's go to that.

1753
01:39:34,770 --> 01:39:35,760
If the first time

1754
01:39:35,760 --> 01:39:38,460
you listen to this, some of
these concepts seem a little bit

1755
01:39:38,460 --> 01:39:42,930
hard to grasp. Don't worry about
it. As we continue and as we

1756
01:39:42,930 --> 01:39:45,630
move on with this course,
they'll start to make more sense

1757
01:39:45,630 --> 01:39:48,960
when you see them used in real
examples. I definitely would

1758
01:39:48,960 --> 01:39:51,720
recommend going back and
rewatching and re listening to

1759
01:39:51,720 --> 01:39:55,350
the parts that you don't quite
get an asking questions in the

1760
01:39:55,350 --> 01:39:58,740
discussions tab of the GitHub
repository. Awesome. So now that

1761
01:39:58,740 --> 01:40:01,410
we know all the cryptography
pieces and all the little nitty

1762
01:40:01,410 --> 01:40:04,200
gritties of how the blockchain
actually works, and how our

1763
01:40:04,200 --> 01:40:06,570
signatures work and how
everything sticks together.

1764
01:40:06,960 --> 01:40:10,110
Let's talk a little bit about
how this works, in actuality,

1765
01:40:10,170 --> 01:40:12,720
and what's really going on. Now
for a lot of this, each

1766
01:40:12,720 --> 01:40:15,390
different blockchain has
slightly different algorithms

1767
01:40:15,390 --> 01:40:18,750
and slightly different metrics
and criteria for doing a lot of

1768
01:40:18,750 --> 01:40:21,720
this stuff. So when we're
talking about these specific

1769
01:40:21,750 --> 01:40:25,020
implementations, keep in mind,
the exact algorithm might be a

1770
01:40:25,020 --> 01:40:27,630
little bit different, but the
concepts are all still going to

1771
01:40:27,630 --> 01:40:30,930
be exactly the same. Hashing and
hash function is going to be the

1772
01:40:30,930 --> 01:40:34,110
same. No matter where you look
at decentralized blockchain,

1773
01:40:34,290 --> 01:40:36,600
it's going to be the same no
matter where you look, how it's

1774
01:40:36,600 --> 01:40:39,210
actually implemented, is going
to be a little bit different.

1775
01:40:39,300 --> 01:40:42,330
Now traditionally, when you run
an application, you will be

1776
01:40:42,390 --> 01:40:45,690
website or something that
connects to some server, you are

1777
01:40:45,690 --> 01:40:49,980
interacting with a centralized
entity. And unlike how we saw

1778
01:40:49,980 --> 01:40:52,980
with the blockchain with
multiple different peers, it's

1779
01:40:52,980 --> 01:40:56,070
going to be run by a single
centralized group. Now, it still

1780
01:40:56,070 --> 01:40:59,220
could be run on many different
servers, but all those servers

1781
01:40:59,250 --> 01:41:02,520
are still going to be controlled
by the same centralized group

1782
01:41:02,760 --> 01:41:07,020
blockchains, as we saw run on a
network of different independent

1783
01:41:07,020 --> 01:41:10,380
nodes. When we saw a peer, a
peer, B Piercey. Those were

1784
01:41:10,380 --> 01:41:14,370
different examples of different
independent users running the

1785
01:41:14,370 --> 01:41:17,490
blockchain technology on their
own node. Now, when I use the

1786
01:41:17,490 --> 01:41:20,640
term node, I'm usually referring
to a single instance of a

1787
01:41:20,640 --> 01:41:23,700
decentralized system. So when I
say a single node, when I'm

1788
01:41:23,700 --> 01:41:26,310
talking about a blockchain, I'm
talking about one of those pure

1789
01:41:26,310 --> 01:41:29,850
A's pure BS pure C's running
that blockchain software, I'm

1790
01:41:29,850 --> 01:41:33,330
talking about one server running
this technology. And again, it's

1791
01:41:33,330 --> 01:41:35,730
this network. It's this
combination of these nodes

1792
01:41:35,730 --> 01:41:38,280
interacting with each other,
that creates this entire

1793
01:41:38,280 --> 01:41:41,880
blockchain. What makes these so
potent too, is that anybody can

1794
01:41:41,880 --> 01:41:44,610
join the network. And that's why
there's decentralized the

1795
01:41:44,610 --> 01:41:47,220
barrier to entry is a little bit
of hardware requirements for

1796
01:41:47,220 --> 01:41:50,460
getting the correct materials to
run the software. And then you

1797
01:41:50,490 --> 01:41:52,830
running the software, anybody
can join these networks and

1798
01:41:52,830 --> 01:41:55,830
participate. And that's what
makes it truly decentralized. In

1799
01:41:55,830 --> 01:41:58,920
fact, you can go to GitHub right
now, and run your own Aetherium

1800
01:41:58,920 --> 01:42:02,070
node in a few seconds. Now in
the traditional world,

1801
01:42:02,130 --> 01:42:05,100
applications are run by
centralized entities. And if

1802
01:42:05,100 --> 01:42:09,510
that entity goes down, or is
maliciously bribed, or decides

1803
01:42:09,510 --> 01:42:12,600
that they want to shut off, they
just can't, because they are the

1804
01:42:12,600 --> 01:42:16,410
ones that control everything.
blockchains, by contrast, don't

1805
01:42:16,410 --> 01:42:20,250
have this problem. If one node
or one entity that runs several

1806
01:42:20,250 --> 01:42:24,150
nodes goes down, since there are
so many other independent nodes

1807
01:42:24,150 --> 01:42:27,570
running that it doesn't matter,
the blockchain and the system

1808
01:42:27,570 --> 01:42:30,990
will persist so long as there is
at least one node always

1809
01:42:30,990 --> 01:42:34,260
running. And luckily for us,
most of the most popular chains

1810
01:42:34,260 --> 01:42:38,550
like Bitcoin and Aetherium, have
1000s and 1000s of nodes. And as

1811
01:42:38,550 --> 01:42:42,120
we showed in our demo, if one
node acts maliciously, all the

1812
01:42:42,120 --> 01:42:46,380
other nodes will ignore that
node and kick that out or even

1813
01:42:46,380 --> 01:42:49,350
punish it in some systems,
because they can easily check

1814
01:42:49,350 --> 01:42:52,980
everybody else's node and see,
okay, this one is out of sync

1815
01:42:52,980 --> 01:42:55,500
with the majority. And yes,
majority rules when it comes to

1816
01:42:55,500 --> 01:42:58,890
the blockchain. Each blockchain
keeps a full list of every

1817
01:42:58,890 --> 01:43:01,770
transaction and interaction
that's happened on that

1818
01:43:01,770 --> 01:43:05,430
blockchain and we saw if a node
tries to act maliciously, then

1819
01:43:05,460 --> 01:43:07,530
all their hashes are going to be
way out of whack and they're not

1820
01:43:07,530 --> 01:43:10,020
going to match everybody else.
This gives blockchains this

1821
01:43:10,020 --> 01:43:13,650
incredibly potent immutability
trait where nothing can be

1822
01:43:13,650 --> 01:43:16,290
changed or corrupted. So in
essence, we can think of a

1823
01:43:16,290 --> 01:43:20,010
blockchain as a decentralized
database. And with Aetherium, it

1824
01:43:20,010 --> 01:43:24,090
has an extra additional feature
where it also can do computation

1825
01:43:24,210 --> 01:43:27,870
in a decentralized manner. Now
let's talk consensus, proof of

1826
01:43:27,870 --> 01:43:30,690
work and proof of stake because
you've probably heard these

1827
01:43:30,690 --> 01:43:33,180
before. And they're really
important to how these

1828
01:43:33,180 --> 01:43:35,670
blockchains actually work. We
went through that blockchain

1829
01:43:35,670 --> 01:43:39,420
example, and we did that mining
feature. This is what's known as

1830
01:43:39,450 --> 01:43:43,740
proof of work. Proof of Work and
proof of steak fall under this

1831
01:43:43,770 --> 01:43:47,400
umbrella of consensus and
consensus is a really important

1832
01:43:47,400 --> 01:43:49,710
topic when it comes to
blockchains. Consensus is

1833
01:43:49,710 --> 01:43:53,670
defined as the mechanism used to
reach an agreement on the state

1834
01:43:53,670 --> 01:43:56,880
or a single value on the
blockchain, especially in a

1835
01:43:56,880 --> 01:43:59,910
decentralized system. I briefly
alluded to this consensus

1836
01:43:59,910 --> 01:44:03,000
mechanism in our blockchain
example, when I said if one

1837
01:44:03,000 --> 01:44:06,600
change is something and the
other two, don't, then majority

1838
01:44:06,600 --> 01:44:09,480
will rule and kick that one out.
This is part of that consensus

1839
01:44:09,480 --> 01:44:13,080
mechanism. Now very roughly a
consensus protocol in a

1840
01:44:13,080 --> 01:44:15,930
blockchain or decentralized
system can be broken down into

1841
01:44:15,930 --> 01:44:19,080
two pieces, a chain selection
algorithm, and a civil

1842
01:44:19,080 --> 01:44:22,110
resistance mechanism, that
mining piece that we were doing,

1843
01:44:22,350 --> 01:44:25,440
or where the proof of work
algorithm is what's known as a

1844
01:44:25,440 --> 01:44:28,590
civil resistance mechanism. And
this is what Aetherium and

1845
01:44:28,590 --> 01:44:31,770
Bitcoin currently use. Please
note that depending on when

1846
01:44:31,770 --> 01:44:34,740
you're watching this, if eath
two is out, then it's no longer

1847
01:44:34,740 --> 01:44:37,020
proof of work. Now, proof of
work is known as a civil

1848
01:44:37,020 --> 01:44:40,350
resistance mechanism, because it
defines a way to figure out who

1849
01:44:40,350 --> 01:44:43,890
is the block author, which node
is going to be the node who did

1850
01:44:43,890 --> 01:44:47,460
the work to find that mine and
be the author of that block so

1851
01:44:47,580 --> 01:44:50,100
all the other nodes can verify
that it's accurate civil

1852
01:44:50,100 --> 01:44:54,000
resistance is a blockchains
ability to defend against users

1853
01:44:54,000 --> 01:44:57,330
creating a large number of
pseudo anonymous identities to

1854
01:44:57,330 --> 01:45:00,810
gain a disproportionately
advantageous influence is over

1855
01:45:00,840 --> 01:45:04,080
set system. And in layman's
terms, it's basically a way for

1856
01:45:04,080 --> 01:45:06,270
a blockchain to defend against
somebody making a bunch of fake

1857
01:45:06,270 --> 01:45:09,210
blockchains so that they can get
more and more rewards. Now,

1858
01:45:09,210 --> 01:45:11,880
there are two types of civil
resistance mechanisms that we're

1859
01:45:11,880 --> 01:45:15,090
going to talk about here. Namely
proof of work and proof of

1860
01:45:15,090 --> 01:45:18,150
stake. Let's talk about proof of
work a little bit more in depth

1861
01:45:18,150 --> 01:45:21,150
first, in proof of work. This is
civil resistant, because a

1862
01:45:21,150 --> 01:45:24,540
single node has to go through a
very computationally expensive

1863
01:45:24,750 --> 01:45:28,590
process called mining, which we
demonstrated earlier to figure

1864
01:45:28,590 --> 01:45:30,450
out the answer to the
blockchains Riddle of finding

1865
01:45:30,450 --> 01:45:32,190
that correct nonce, or, or
whatever the

1866
01:45:32,190 --> 01:45:34,830
blockchain system has in place.
And proof of work. This works

1867
01:45:34,830 --> 01:45:37,890
because no matter how many
pseudo anonymous accounts you

1868
01:45:37,890 --> 01:45:40,650
make, each one still has to
undergo this very

1869
01:45:40,650 --> 01:45:44,220
computationally expensive
activity of finding the answer

1870
01:45:44,220 --> 01:45:47,490
to the proof of work problem, or
the proof of work riddle, which

1871
01:45:47,490 --> 01:45:50,460
again, in our demonstration, it
was finding a nonce with that

1872
01:45:50,460 --> 01:45:54,030
first four zeros. But again,
each blockchain might change the

1873
01:45:54,030 --> 01:45:55,890
riddle work or change the
problem to be a little bit

1874
01:45:55,890 --> 01:45:58,110
different. In fact, some of
these blockchains make this

1875
01:45:58,110 --> 01:46:01,410
riddle intentionally hard or
intentionally easy to change

1876
01:46:01,410 --> 01:46:04,170
what's called the block time,
the block time is how long it

1877
01:46:04,170 --> 01:46:06,870
takes between blocks being
published. And it's proportional

1878
01:46:06,870 --> 01:46:10,350
to how hard these algorithms
are. So these problems actually

1879
01:46:10,350 --> 01:46:13,470
can change. Depending on how
long they want the blockchain to

1880
01:46:13,470 --> 01:46:17,130
be. If a system wants to block
time to be very, very long, they

1881
01:46:17,130 --> 01:46:20,220
just make the problem very, very
hard. If they wanted to be very

1882
01:46:20,220 --> 01:46:23,040
short, they make the problem a
lot easier. We'll talk about

1883
01:46:23,040 --> 01:46:25,500
civil attacks in a little bit
and how they can affect the

1884
01:46:25,500 --> 01:46:28,710
system. But with proof of work,
it's a verifiable way to figure

1885
01:46:28,710 --> 01:46:32,340
out who the block author is and
be civil resistant. Now, you

1886
01:46:32,340 --> 01:46:35,460
need to combine this with a
chain selection rule create this

1887
01:46:35,460 --> 01:46:37,920
consensus. Now, there's some
consensus protocols that have

1888
01:46:37,920 --> 01:46:40,560
more features, but very, very
roughly, these are the two

1889
01:46:40,560 --> 01:46:43,020
pieces that we're going to look
at. The second piece is going to

1890
01:46:43,020 --> 01:46:47,220
be a chain selection rule. How
do we know which blockchain is

1891
01:46:47,220 --> 01:46:50,070
actually the real blockchain and
the true blockchain now on

1892
01:46:50,070 --> 01:46:53,310
Bitcoin and Aetherium, they both
use a form of consensus called

1893
01:46:53,430 --> 01:46:57,120
Nakamoto consensus. And this is
a combination of proof of work

1894
01:46:57,240 --> 01:47:00,630
and longest chain rule, the
decentralized network side that

1895
01:47:00,660 --> 01:47:03,600
whichever blockchain has the
longest chain, or the most

1896
01:47:03,600 --> 01:47:06,870
number of blocks on it is going
to be the chain that they use.

1897
01:47:07,020 --> 01:47:09,780
This makes a lot of sense,
because every additional block

1898
01:47:09,780 --> 01:47:12,270
that a chain is behind, it's
going to take more and more

1899
01:47:12,270 --> 01:47:16,110
computation for it to come up.
That's why when we saw in our

1900
01:47:16,110 --> 01:47:19,500
transaction, we actually saw
confirmations. The number of

1901
01:47:19,500 --> 01:47:23,790
confirmations is the number of
additional blocks added on after

1902
01:47:23,790 --> 01:47:26,310
our transaction went through in
a block. So if we see

1903
01:47:26,310 --> 01:47:28,860
confirmations as to it means
that the block that our

1904
01:47:28,860 --> 01:47:32,460
transaction was in has two
blocks ahead of it in the

1905
01:47:32,460 --> 01:47:35,100
longest chain. Now, I do want to
point out that a lot of people

1906
01:47:35,100 --> 01:47:38,910
use proof of work as a consensus
protocol. And I do want to say

1907
01:47:38,910 --> 01:47:41,730
that this is a little bit
inaccurate, but sometimes people

1908
01:47:41,730 --> 01:47:45,690
use it interchangeably. Proof of
Work is a piece of the overall

1909
01:47:45,690 --> 01:47:48,900
consensus protocol, which in
Bitcoin and Aetherium. One

1910
01:47:48,930 --> 01:47:53,310
current case is Nakamoto
consensus, Nakamoto consensus is

1911
01:47:53,310 --> 01:47:56,490
a combination of proof of work,
and this longest chain rule,

1912
01:47:56,820 --> 01:48:00,870
both equally and very, very
important. Now, proof of work

1913
01:48:00,870 --> 01:48:03,960
also tells us where these
transaction fees and these block

1914
01:48:03,960 --> 01:48:07,440
rewards go to remember how when
we made this transaction, we had

1915
01:48:07,440 --> 01:48:10,920
to talk about gas and a
transaction fee. So who's

1916
01:48:10,920 --> 01:48:13,350
getting paid who was getting
this transaction, and this

1917
01:48:13,350 --> 01:48:16,740
transaction fee is going to the
miners or the validators in a

1918
01:48:16,740 --> 01:48:19,710
proof of work network? They're
called miners and in the proof

1919
01:48:19,710 --> 01:48:23,310
of stake network, they're called
validators there are a little

1920
01:48:23,310 --> 01:48:25,200
bit different. And we'll get
into that when we talk about

1921
01:48:25,200 --> 01:48:28,620
proof of stake in this proof of
work system. All these nodes are

1922
01:48:28,620 --> 01:48:31,680
competing against each other to
find the answer to the

1923
01:48:31,680 --> 01:48:34,860
blockchain riddle. Remember, in
our example, it was to find a

1924
01:48:34,890 --> 01:48:38,520
hash that has four zeros at the
start. And again, depending on

1925
01:48:38,520 --> 01:48:40,590
the blockchain implementation,
that riddle is going to be a

1926
01:48:40,590 --> 01:48:44,610
little bit different. But all
the nodes are trying as many as

1927
01:48:44,610 --> 01:48:48,210
possible to try to get this
answer first. Why? Because the

1928
01:48:48,210 --> 01:48:51,330
first node to figure out the
answer to the blockchain real is

1929
01:48:51,330 --> 01:48:53,850
gonna get that transaction fee,
they're gonna get paid from

1930
01:48:53,850 --> 01:48:56,160
that. Now, when a node gets
paid, they actually get paid in

1931
01:48:56,160 --> 01:48:59,490
two different ways. One is going
to be with a transaction fee.

1932
01:48:59,670 --> 01:49:02,430
And another piece is going to be
the block reward. Remember how

1933
01:49:02,430 --> 01:49:05,490
we talked about alternating the
gas price or the gray on our

1934
01:49:05,490 --> 01:49:08,370
transaction? Well, that's the
transaction fee that we're going

1935
01:49:08,370 --> 01:49:11,700
to pay to these blockchain nodes
for including our transaction,

1936
01:49:11,880 --> 01:49:15,120
the block reward is given to
these nodes from the protocol

1937
01:49:15,120 --> 01:49:18,000
from the blockchain itself.
You've probably heard of the

1938
01:49:18,000 --> 01:49:21,630
Bitcoin halving before the
halving is referring to this

1939
01:49:21,630 --> 01:49:24,720
block reward getting cut in half
and it's supposed to be cut in

1940
01:49:24,720 --> 01:49:29,370
half, roughly every four years.
This block reward increases the

1941
01:49:29,370 --> 01:49:32,190
circulating amount of whatever
cryptocurrency that is being

1942
01:49:32,190 --> 01:49:34,710
rewarded. For example, on
Aetherium the block reward is

1943
01:49:34,710 --> 01:49:37,230
giving out Aetherium and a
Bitcoin the block reward is

1944
01:49:37,230 --> 01:49:40,230
giving out Bitcoin. So these
nodes are competing against each

1945
01:49:40,230 --> 01:49:43,140
other to be the first one to
find this transaction to be the

1946
01:49:43,140 --> 01:49:46,410
first one to find the answer to
this problem, so that they can

1947
01:49:46,410 --> 01:49:49,500
be the ones to win both this
block reward and your

1948
01:49:49,500 --> 01:49:52,230
transaction fee. Some block
chains like Bitcoin, for

1949
01:49:52,230 --> 01:49:55,620
example, have a set time when
they're no longer going to give

1950
01:49:55,620 --> 01:49:58,860
out block rewards and the miners
or the nodes are only going to

1951
01:49:58,860 --> 01:50:02,610
get paid from trends. Action
fees. Now this gas fee, again is

1952
01:50:02,610 --> 01:50:06,360
paid by whoever initialize the
transaction. When we got our

1953
01:50:06,360 --> 01:50:09,810
funds from the faucet, there was
some server and somebody else

1954
01:50:09,840 --> 01:50:13,890
was paying the transaction fee
for us. However, when we sent

1955
01:50:13,920 --> 01:50:16,830
ether from one account to
another, our first account

1956
01:50:16,860 --> 01:50:20,850
actually paid some transaction
fee to send that ether. In proof

1957
01:50:20,850 --> 01:50:23,670
of steak. There's also a gas
fee, but it's paid out to

1958
01:50:23,700 --> 01:50:26,880
validators instead of miners.
And we'll talk about that in a

1959
01:50:26,880 --> 01:50:29,400
little bit. Now let's talk about
two types of attacks that can

1960
01:50:29,400 --> 01:50:31,590
happen in these blockchain
worlds. Let's talk about the

1961
01:50:31,590 --> 01:50:34,650
first one being the Sybil
attack. The Sybil attack is when

1962
01:50:34,680 --> 01:50:37,830
a user creates a whole bunch of
pseudo anonymous accounts to try

1963
01:50:37,830 --> 01:50:41,280
to influence a network. Now,
obviously, on Bitcoin and

1964
01:50:41,310 --> 01:50:44,280
Aetherium, this is really,
really difficult because user

1965
01:50:44,280 --> 01:50:47,310
needs to do all this work in
proof of work or have a ton of

1966
01:50:47,310 --> 01:50:49,860
collateral and proof of stake,
which again, we'll talk about in

1967
01:50:49,860 --> 01:50:53,700
a bit. The other more prevalent
attack is what's known as a 51%

1968
01:50:53,730 --> 01:50:57,000
attack. Now, as we saw as part
of our consensus protocol, these

1969
01:50:57,000 --> 01:51:00,540
block chains are going to agree
that the longest chain is the

1970
01:51:00,540 --> 01:51:03,210
one that they're going to go
with, so long as it matches up

1971
01:51:03,210 --> 01:51:07,050
with 51% of the rest of the
network. This means that if you

1972
01:51:07,050 --> 01:51:10,620
have the longest chain, and you
have more than 51% of the rest

1973
01:51:10,620 --> 01:51:13,200
of the network, you can do
what's called a fork in the

1974
01:51:13,200 --> 01:51:16,710
network, and bring the network
onto your now longest chain. Now

1975
01:51:16,710 --> 01:51:19,590
Sybil attacks, obviously, are
when a single node or a single

1976
01:51:19,590 --> 01:51:23,040
entity tries to affect the
decent reality of the network by

1977
01:51:23,040 --> 01:51:25,590
pretending to be multiple
different people, although

1978
01:51:25,590 --> 01:51:28,440
they're just the same person or
entity. And like I said, it's

1979
01:51:28,440 --> 01:51:31,110
really difficult to do in proof
of work and proof of steak. So

1980
01:51:31,110 --> 01:51:33,870
you can see now that blockchains
are very democratic, whichever

1981
01:51:33,870 --> 01:51:37,320
blockchain has the most buy in
and is the longest is the

1982
01:51:37,320 --> 01:51:40,500
blockchain that the whole system
is going to corroborate. When

1983
01:51:40,500 --> 01:51:43,440
nodes produce a new block and
add to the longest chain, the

1984
01:51:43,440 --> 01:51:45,810
other nodes will follow this
longest chain that the rest of

1985
01:51:45,810 --> 01:51:48,570
the network is agreeing with,
add those blocks to their chain

1986
01:51:48,600 --> 01:51:51,780
and follow up. So very small
reorganizations are actually

1987
01:51:51,780 --> 01:51:54,900
pretty common when a blockchain
picks a block from a different

1988
01:51:54,900 --> 01:51:58,410
longest chain puts it on and
then has to swap it out for

1989
01:51:58,470 --> 01:52:01,290
another block and continue with
a different blockchain. However,

1990
01:52:01,290 --> 01:52:04,290
if a group of nodes had enough
nodes or enough power, they

1991
01:52:04,290 --> 01:52:08,070
could essentially be 51% of the
network and influence the

1992
01:52:08,070 --> 01:52:10,740
network in whatever direction
that they want it. This is

1993
01:52:10,740 --> 01:52:14,100
what's known as a 51% attack.
And it's happened on blockchains

1994
01:52:14,100 --> 01:52:17,550
like Ethereum classic, which is
not Aetherium. This is why the

1995
01:52:17,550 --> 01:52:20,460
bigger a blockchain is, the more
decentralized and the more

1996
01:52:20,460 --> 01:52:21,960
secure it becomes.

1997
01:52:21,990 --> 01:52:24,120
So after you watch this video,
and you become a blockchain

1998
01:52:24,120 --> 01:52:27,000
engineering expert, I definitely
recommend you run a node as

1999
01:52:27,000 --> 01:52:29,550
well, because you are going to
increase the security of the

2000
01:52:29,550 --> 01:52:32,760
network as a whole by running a
node. So proof of work is

2001
01:52:32,760 --> 01:52:35,550
fantastic because it allows us
to very easily protect against

2002
01:52:35,550 --> 01:52:38,580
the Sybil attacks and keep our
blockchain is decentralized and

2003
01:52:38,580 --> 01:52:42,660
secure. However, it has some
drawbacks as well. Proof of Work

2004
01:52:42,660 --> 01:52:45,540
costs a lot of electricity,
because every single node is

2005
01:52:45,540 --> 01:52:48,630
running as fast as they can to
win this race to get the

2006
01:52:48,630 --> 01:52:52,440
rewards. This leads to obviously
an environmental impact. Now

2007
01:52:52,440 --> 01:52:54,960
since proof of work and Nakamoto
consensus, a lot of other

2008
01:52:54,960 --> 01:52:57,660
protocols have taken this idea
and gone in a different

2009
01:52:57,660 --> 01:53:00,780
direction with a different civil
resistance protocol, a lot of

2010
01:53:00,780 --> 01:53:03,210
them with the intention to be a
lot more environmentally

2011
01:53:03,210 --> 01:53:06,690
friendly. And the most popular
one right now is proof of stake.

2012
01:53:06,720 --> 01:53:09,060
There are some chains that are
already using this proof of

2013
01:53:09,060 --> 01:53:12,420
stake protocol, and that are
live and thriving. Some of them

2014
01:53:12,420 --> 01:53:16,350
are like avalanche, LaLana,
Polygon, polka dot and Terra and

2015
01:53:16,380 --> 01:53:20,730
additionally Aetherium is
decided to upgrade to eath. Two,

2016
01:53:20,760 --> 01:53:23,940
which will have this proof of
stake algorithm as well, it will

2017
01:53:23,940 --> 01:53:26,730
also have some other features,
which we'll talk about in a bit.

2018
01:53:26,880 --> 01:53:29,340
Now as a quick aside, all the
tools that we're going to learn

2019
01:53:29,340 --> 01:53:32,550
here are still going to work in
eath. Two, so depending on when

2020
01:53:32,550 --> 01:53:34,980
you watch this, everything here
is still valid. So let's talk

2021
01:53:34,980 --> 01:53:37,830
about proof of stake. Now,
again, this is a different civil

2022
01:53:37,830 --> 01:53:40,770
resistance mechanism. Instead of
solving this difficult problem,

2023
01:53:40,980 --> 01:53:44,100
proof of stake nodes put up some
collateral that they're going to

2024
01:53:44,100 --> 01:53:49,080
behave honestly, aka, they stake
in the example of Aetherium. two

2025
01:53:49,260 --> 01:53:52,680
nodes put up some Aetherium as a
stake that they're going to

2026
01:53:52,680 --> 01:53:55,470
behave honestly in the network,
if they misbehave to the

2027
01:53:55,470 --> 01:53:58,560
network, they are going to be
slashed or remove some of their

2028
01:53:58,560 --> 01:54:01,920
steak. Obviously, this is a very
good civil resistance mechanism.

2029
01:54:01,920 --> 01:54:04,440
Because if you try to create a
whole bunch of anonymous

2030
01:54:04,440 --> 01:54:07,500
accounts, then each one of those
accounts, you have to put up

2031
01:54:07,500 --> 01:54:10,170
some stake. And if you
misbehave, you're going to run

2032
01:54:10,170 --> 01:54:13,320
the risk of losing all the money
that you put up as collateral.

2033
01:54:13,560 --> 01:54:16,860
In this system, miners are
actually called validators

2034
01:54:16,860 --> 01:54:18,870
because they're no longer
binding anything, they're

2035
01:54:18,870 --> 01:54:21,630
actually just validating other
nodes. Now, unlike proof of

2036
01:54:21,630 --> 01:54:24,360
work, which every node is racing
to be the first one to find the

2037
01:54:24,360 --> 01:54:28,260
block, and proof of stake nodes
are actually randomly chosen to

2038
01:54:28,260 --> 01:54:31,470
propose the new block and then
the rest of the validators will

2039
01:54:31,530 --> 01:54:35,340
validate if that node has
proposed the block. Honestly, as

2040
01:54:35,340 --> 01:54:38,250
we saw with our cryptography
lesson, it's usually very easy

2041
01:54:38,250 --> 01:54:42,090
for other nodes to verify if a
proposal or a transaction is

2042
01:54:42,090 --> 01:54:45,210
honest. Now randomness is a
really important topic when

2043
01:54:45,210 --> 01:54:47,910
we're talking about blockchains.
Because keep in mind, these

2044
01:54:47,910 --> 01:54:51,120
blockchains are deterministic
systems. They're walled gardens

2045
01:54:51,120 --> 01:54:54,420
from the rest of the world. And
as you know, a deterministic

2046
01:54:54,420 --> 01:54:58,080
system by definition can't have
random numbers. So how do we

2047
01:54:58,080 --> 01:55:01,350
choose the random validators in
the system? While it changes

2048
01:55:01,350 --> 01:55:04,020
from blockchain to blockchain,
and actually choosing the node

2049
01:55:04,020 --> 01:55:07,050
will change blockchain to
blockchain, but eath two,

2050
01:55:07,200 --> 01:55:09,780
they're using what's called Rand
doubt, at least for the original

2051
01:55:09,780 --> 01:55:12,120
implementation. This is a
decentralized autonomous

2052
01:55:12,120 --> 01:55:15,270
organization that collectively
chooses the random number and

2053
01:55:15,270 --> 01:55:18,450
collectively chooses which node
is going to run. Next, we aren't

2054
01:55:18,450 --> 01:55:20,610
going to dive too deep into this
because there's a good chance

2055
01:55:20,610 --> 01:55:23,220
that this might change in the
future. But we will go into

2056
01:55:23,220 --> 01:55:25,410
randomness solutions and
blockchain later on in this

2057
01:55:25,410 --> 01:55:28,080
course. Now, proof of stake
obviously has some pros and cons

2058
01:55:28,080 --> 01:55:31,230
as well, pros are that again, it
is a great civil resistance

2059
01:55:31,230 --> 01:55:33,810
mechanism. And a great way to
figure out who the author of a

2060
01:55:33,810 --> 01:55:37,110
block should be. The other pros
are that it's way less

2061
01:55:37,110 --> 01:55:39,810
computationally expensive to
figure out the new block,

2062
01:55:40,050 --> 01:55:42,990
because instead of every single
node on the network trying to do

2063
01:55:42,990 --> 01:55:46,500
this, only one node needs to do
this. And then the rest of the

2064
01:55:46,500 --> 01:55:49,440
nodes just need to validate it.
The cons are that it's usually

2065
01:55:49,440 --> 01:55:52,440
considered a slightly less
decentralized network, due to

2066
01:55:52,440 --> 01:55:55,530
the upfront staking costs it
cost to participate. Now, this

2067
01:55:55,530 --> 01:55:58,170
gets into a little bit of a
philosophical battle on how

2068
01:55:58,170 --> 01:56:01,380
decentralized is decentralized
enough. And I think that's up to

2069
01:56:01,380 --> 01:56:04,320
the community to decide. And as
we progress, I think we'll learn

2070
01:56:04,320 --> 01:56:06,930
more and more about how
decentralized is decentralized

2071
01:56:06,960 --> 01:56:09,930
enough. The general consensus
amongst blockchain engineers,

2072
01:56:09,930 --> 01:56:13,110
though, is that proof of stake
is very, very decentralized and

2073
01:56:13,110 --> 01:56:16,290
very secure. This massive
environmental impact improvement

2074
01:56:16,320 --> 01:56:19,500
is one of the two main reasons
why eath is shifting to eath.

2075
01:56:19,500 --> 01:56:21,960
Two, it reduces the
environmental impact by up to

2076
01:56:21,960 --> 01:56:25,710
99%. Now, these are the main
pieces of proof of work and

2077
01:56:25,710 --> 01:56:28,380
proof of stake. But I did want
to talk about another concept

2078
01:56:28,380 --> 01:56:31,530
that's really important in these
ecosystems. And that is

2079
01:56:31,530 --> 01:56:34,320
scalability. When we were
talking about gas prices, we

2080
01:56:34,320 --> 01:56:37,230
were saying that the gas prices
can get really high if a lot of

2081
01:56:37,230 --> 01:56:40,260
people want to send a
transaction, because a block

2082
01:56:40,290 --> 01:56:43,200
only has so much black space,
and the nodes can only add so

2083
01:56:43,200 --> 01:56:46,560
many notes. So when a lot of
people want to use a blockchain,

2084
01:56:46,740 --> 01:56:51,630
the gas price skyrockets. This
is not very scalable, because if

2085
01:56:51,630 --> 01:56:54,240
we want to add more and more
people to these blockchains,

2086
01:56:54,360 --> 01:56:57,390
it's going to cost more and more
to use the blockchains. Because

2087
01:56:57,390 --> 01:57:00,090
more people are going to want to
get into these blocks. This

2088
01:57:00,090 --> 01:57:02,070
means that there's kind of a
ceiling to how many people can

2089
01:57:02,070 --> 01:57:04,560
use the system because of the
financial constraints that will

2090
01:57:04,560 --> 01:57:08,130
get imposed as gas prices keep
rising. Aetherium too is not

2091
01:57:08,130 --> 01:57:10,860
only attacking the environmental
impact of proof of work by

2092
01:57:10,860 --> 01:57:13,800
switching to proof of steak, but
they're also implementing this

2093
01:57:13,800 --> 01:57:18,090
new methodology called sharding.
And sharding is a solution to

2094
01:57:18,090 --> 01:57:21,510
the scalability problem, a
sharded blockchain really just

2095
01:57:21,510 --> 01:57:24,930
means that it's going to be a
blockchain of blockchains

2096
01:57:24,960 --> 01:57:27,450
there's a main chain that's
going to coordinate everything

2097
01:57:27,480 --> 01:57:32,340
amongst several chains that hook
into this main chain. This means

2098
01:57:32,370 --> 01:57:35,280
that there's more chains for
people to make transactions on

2099
01:57:35,490 --> 01:57:38,250
effectively increasing the
amount of block space that there

2100
01:57:38,250 --> 01:57:41,880
is sharding can greatly increase
the number of transactions on a

2101
01:57:41,880 --> 01:57:44,880
blockchain layer one now there's
another term that might be the

2102
01:57:44,880 --> 01:57:47,970
first time you heard it, a layer
one, we're going to talk about

2103
01:57:47,970 --> 01:57:50,580
layer one and layer twos in
terms of scalability really

2104
01:57:50,580 --> 01:57:54,720
quickly as well. A layer one
refers to any base layer

2105
01:57:54,720 --> 01:57:58,200
blockchain implementation
Bitcoins, a layer one Aetherium

2106
01:57:58,200 --> 01:58:01,830
the layer one avalanches, a
layer one, these are the base

2107
01:58:01,830 --> 01:58:06,420
layer blockchain solutions. A
layer two is any application

2108
01:58:06,450 --> 01:58:09,750
that is added on top of a layer
one added on top of the

2109
01:58:09,750 --> 01:58:12,420
blockchain. Some examples of
layer twos are going to be chain

2110
01:58:12,420 --> 01:58:16,890
link arbitrage, or optimism.
Arbitrage and optimism are very

2111
01:58:16,890 --> 01:58:19,890
interesting because they are
layer twos that also look to

2112
01:58:19,890 --> 01:58:22,860
solve this scalability issue.
Arbitrage and optimism are

2113
01:58:22,860 --> 01:58:27,180
what's known as roll ups and
they roll up their transactions

2114
01:58:27,210 --> 01:58:30,090
into a layer one like Aetherium,
we're not going to go too deep

2115
01:58:30,120 --> 01:58:32,280
into roll ups and how they
actually work. But all you

2116
01:58:32,280 --> 01:58:35,700
really need to know is that a
roll up is kind of like a

2117
01:58:35,700 --> 01:58:38,910
sharded chain, they derive their
security from the base layer

2118
01:58:38,910 --> 01:58:41,670
from the layer one like
Aetherium. And they bulk send

2119
01:58:41,670 --> 01:58:44,310
their transactions onto the
layer one, they solve some of

2120
01:58:44,310 --> 01:58:47,190
the scalability issues by being
another blockchain that people

2121
01:58:47,190 --> 01:58:51,120
can make transactions on, still
on kind of this base Aetherium

2122
01:58:51,150 --> 01:58:54,570
layer. Now they're different
from side chains. Because side

2123
01:58:54,570 --> 01:58:58,110
chains derive their security
from their own protocols, roll

2124
01:58:58,110 --> 01:59:01,620
ups, derive their security from
the base layers. So arbitrage

2125
01:59:01,620 --> 01:59:04,200
and optimism, for example, is
going to be just about as secure

2126
01:59:04,260 --> 01:59:06,810
as Aetherium. There's some
fantastic guys in there that go

2127
01:59:06,810 --> 01:59:09,210
a little bit deeper into roll
ups and I've left a link in the

2128
01:59:09,210 --> 01:59:12,570
description for you. All right,
so we just talked about a lot of

2129
01:59:12,570 --> 01:59:16,170
stuff. So let's do a quick recap
before moving on. Aetherium and

2130
01:59:16,170 --> 01:59:19,740
Bitcoin are currently both proof
of work blockchains that follow

2131
01:59:19,770 --> 01:59:23,370
Nakamoto consensus, however,
Aetherium is moving to Aetherium

2132
01:59:23,370 --> 01:59:26,610
two, which will be a proof of
stake sharded blockchain Sybil

2133
01:59:26,610 --> 01:59:29,760
attacks are prevented due to
protocols like proof of work and

2134
01:59:29,760 --> 01:59:33,780
proof of steak 51% attacks grow
increasingly harder with the

2135
01:59:33,780 --> 01:59:37,110
size of blockchain. So you
should run a node consensus is

2136
01:59:37,110 --> 01:59:39,990
the mechanism that allows a
blockchain to agree upon what

2137
01:59:39,990 --> 01:59:43,560
the state of the blockchain is
sharding and roll ups are

2138
01:59:43,560 --> 01:59:48,180
solutions to scalability issues
on layer ones. Layer One is any

2139
01:59:48,180 --> 01:59:51,330
based blockchain implementation
like Bitcoin or Aetherium. A

2140
01:59:51,330 --> 01:59:53,940
blockchain scalability problem
is that there's not always

2141
01:59:53,970 --> 01:59:56,490
enough block space for the
amount of transactions that want

2142
01:59:56,490 --> 02:00:00,000
to get in them. This leads to
very high gas prices and a

2143
02:00:00,000 --> 02:00:03,000
Again, gas prices or how much it
costs to interact with the

2144
02:00:03,000 --> 02:00:03,570
blockchain.

2145
02:00:04,680 --> 02:00:08,250
So that's it for the blockchain
basics and the blockchain

2146
02:00:08,280 --> 02:00:12,540
explainers. With just this
information, you now can go off

2147
02:00:12,540 --> 02:00:15,930
into the world and start working
with blockchains and interacting

2148
02:00:15,930 --> 02:00:19,380
with blockchains. With at least
some level of knowledge as to

2149
02:00:19,410 --> 02:00:22,770
what's going on, you should be
incredibly proud of yourself for

2150
02:00:22,770 --> 02:00:26,160
just making it this far.
Definitely be sure to give

2151
02:00:26,160 --> 02:00:29,220
yourself a pat on the back and a
round of applause. Now that

2152
02:00:29,220 --> 02:00:31,890
we've gotten a lot of the basics
and the fundamentals of the way,

2153
02:00:32,250 --> 02:00:36,000
let's start jumping into the
coding aspect. This is where

2154
02:00:36,000 --> 02:00:38,790
you're going to learn how to
actually build these smart

2155
02:00:38,790 --> 02:00:42,030
contracts, how to build these
trust minimized agreements, in

2156
02:00:42,030 --> 02:00:45,270
these blockchains. And in the
smart contract platforms. This

2157
02:00:45,270 --> 02:00:48,780
next section, this solidity
basics, the solidity

2158
02:00:48,780 --> 02:00:52,530
fundamentals section will give
you all the skills to start

2159
02:00:52,530 --> 02:00:56,160
actually coding solidity and
understanding how these smart

2160
02:00:56,160 --> 02:00:59,370
contracts work underneath the
hood. So at this point,

2161
02:00:59,490 --> 02:01:02,430
absolutely, give yourself a high
five, maybe say hi, in the

2162
02:01:02,430 --> 02:01:05,400
GitHub discussions, maybe say hi
in the community, on Twitter, on

2163
02:01:05,400 --> 02:01:09,330
Reddit, etc, and be proud of
just making it this far, the

2164
02:01:09,330 --> 02:01:11,670
journey has really only just
begun, but you've already

2165
02:01:11,670 --> 02:01:15,450
learned so much. Let's begin the
next section. And let's

2166
02:01:15,450 --> 02:01:16,560
jump into the code.

2167
02:01:19,350 --> 02:01:21,780
Now that we're getting to the
coding sections, I need to

2168
02:01:21,780 --> 02:01:25,200
stress to absolutely use the
GitHub repository associated

2169
02:01:25,200 --> 02:01:28,470
with this course. If you come to
the GitHub repo, and you scroll

2170
02:01:28,470 --> 02:01:31,500
down, and you click the lesson
that we're on right now, we're

2171
02:01:31,500 --> 02:01:35,430
on lesson two. Welcome to remix,
simple storage. If you click on

2172
02:01:35,430 --> 02:01:38,490
it, it'll give you a ton of
timestamps and, and other

2173
02:01:38,490 --> 02:01:42,060
helpful links associated with
this lesson. Additionally, the

2174
02:01:42,060 --> 02:01:45,360
biggest piece is that all the
code will be available right

2175
02:01:45,360 --> 02:01:49,260
underneath the lesson title.
This will have all the code that

2176
02:01:49,260 --> 02:01:52,230
we're going to be working with,
as well as some more additional

2177
02:01:52,230 --> 02:01:55,560
information on how to work with
the code. Please, when asking

2178
02:01:55,560 --> 02:01:58,590
questions and entering in
discussions, though, please ask

2179
02:01:58,590 --> 02:02:00,990
your questions and the full
blockchain solidity course

2180
02:02:01,020 --> 02:02:03,780
repository. Thank you. And if
we're at the top of the

2181
02:02:03,780 --> 02:02:06,780
repository, and we scroll down,
we have the resources for this

2182
02:02:06,780 --> 02:02:09,720
course section. Which brings us
to the GitHub discussions in

2183
02:02:09,840 --> 02:02:12,930
which you can ask questions in
the GitHub discussion section of

2184
02:02:12,930 --> 02:02:17,790
this course. Additionally, on
Stack Exchange, Aetherium, or at

2185
02:02:17,790 --> 02:02:21,600
Stack Overflow. I'll talk a
little bit about how to format

2186
02:02:21,600 --> 02:02:24,840
questions and ask questions the
best way so that you have the

2187
02:02:24,840 --> 02:02:28,260
highest chance of getting a good
answer in a later lesson, I

2188
02:02:28,260 --> 02:02:32,220
highly recommend you pause and
make accounts for Stack Exchange

2189
02:02:32,250 --> 02:02:36,150
Aetherium, Stack Overflow, and
GitHub right now, if you haven't

2190
02:02:36,180 --> 02:02:38,760
already, links to them, of
course, can be found in our

2191
02:02:38,760 --> 02:02:42,120
GitHub repository. Typically,
for each coding section, I'll

2192
02:02:42,120 --> 02:02:45,270
start it off by giving a quick
overview of the code of what

2193
02:02:45,270 --> 02:02:46,830
we're going to be working with
and what we're going to be

2194
02:02:46,830 --> 02:02:49,380
building towards, since
everything that we're doing is

2195
02:02:49,380 --> 02:02:51,690
going to be project based. And
that's how we're going to learn.

2196
02:02:51,990 --> 02:02:55,020
For our first one and remix
though, we're going to skip over

2197
02:02:55,020 --> 02:02:58,440
that because there's a lot of
stuff to get used to. Now, I

2198
02:02:58,440 --> 02:03:01,890
highly recommend that as I'm
coding this. And as I'm doing

2199
02:03:01,890 --> 02:03:05,250
all this in remix, you follow
along with me and you code along

2200
02:03:05,250 --> 02:03:08,250
with me. Remember, you can
change my speed if I'm coding

2201
02:03:08,250 --> 02:03:10,740
too fast, or if I'm coding too
slow. To start, we're going to

2202
02:03:10,740 --> 02:03:13,920
jump into a tool called remix.
If you're unsure how to get

2203
02:03:13,920 --> 02:03:17,880
there, there's a link to remix
in our GitHub repository. This

2204
02:03:17,910 --> 02:03:21,210
is where we're gonna be writing
all of our code. So welcome to

2205
02:03:21,210 --> 02:03:25,500
the remix IDE, or integrated
development environment. This is

2206
02:03:25,500 --> 02:03:28,230
where we're going to learn how
to code and interact with our

2207
02:03:28,230 --> 02:03:32,130
smart contracts. If you want,
you can go ahead and accept help

2208
02:03:32,130 --> 02:03:35,070
out remix. If you've never been
here before, it'll give you a

2209
02:03:35,070 --> 02:03:38,130
quick walkthrough of some of the
tools that remix actually has,

2210
02:03:38,190 --> 02:03:40,230
we're going to skip over them
for now. Because I'm gonna

2211
02:03:40,230 --> 02:03:42,990
explain everything that's going
up. Remix is such a powerful

2212
02:03:42,990 --> 02:03:46,080
tool because it has a lot of
features that allow us to really

2213
02:03:46,080 --> 02:03:49,710
see and interact with our smart
contracts. Eventually, we're

2214
02:03:49,710 --> 02:03:52,470
going to move off of remix,
actually to a local development

2215
02:03:52,470 --> 02:03:56,070
environment. However, remix is
absolutely fantastic for

2216
02:03:56,070 --> 02:03:58,740
learning the fundamentals of
solidity. And I highly recommend

2217
02:03:58,770 --> 02:04:01,680
everybody start with remix when
they're getting started. When

2218
02:04:01,680 --> 02:04:04,680
you come to the remix IDE,
there's a whole lot of different

2219
02:04:04,680 --> 02:04:07,500
things that are popping out to
us. There's a lot of different

2220
02:04:07,500 --> 02:04:09,840
plugins as well. Since we're
going to be working with

2221
02:04:09,840 --> 02:04:12,600
solidity, which is going to be
the language that we're using to

2222
02:04:12,630 --> 02:04:15,510
develop our smart contracts. We
can go ahead and get started by

2223
02:04:15,510 --> 02:04:18,840
clicking the solidity plugin,
and a couple of other tools will

2224
02:04:18,840 --> 02:04:22,140
show up on the side. Even if you
don't click the solidity plugin,

2225
02:04:22,290 --> 02:04:25,050
you'll still be able to code
solidity smart contracts, the

2226
02:04:25,050 --> 02:04:27,090
left hand side is where we're
going to start to actually

2227
02:04:27,090 --> 02:04:30,690
interact with things. The button
on the top most of the left is

2228
02:04:30,690 --> 02:04:34,140
our files or explore
directories, remix comes

2229
02:04:34,140 --> 02:04:38,070
boilerplate with some different
contracts, some different

2230
02:04:38,070 --> 02:04:42,600
scripts, some different tests,
and different dependencies. We

2231
02:04:42,600 --> 02:04:45,060
are going to minimize this a
little bit. So if you want to go

2232
02:04:45,060 --> 02:04:48,270
ahead and right click and delete
some of these folders other than

2233
02:04:48,270 --> 02:04:51,780
the contracts folders, feel free
to do so. Or if you kind of like

2234
02:04:51,780 --> 02:04:55,020
them there, feel free to leave
them as well. We're going to

2235
02:04:55,020 --> 02:04:57,660
leave our contracts folder and
we're going to delete the

2236
02:04:57,660 --> 02:05:00,240
different files inside of it
just so that we can start From a

2237
02:05:00,240 --> 02:05:07,470
blank slate. Most projects come
with something known as a

2238
02:05:07,470 --> 02:05:10,530
readme. Usually it's a
readme.md, which usually

2239
02:05:10,530 --> 02:05:13,380
explains how to actually work
with code. But for our purposes,

2240
02:05:13,410 --> 02:05:15,360
we're going to delete this as
well. And you can just follow

2241
02:05:15,360 --> 02:05:15,720
along with

2242
02:05:15,720 --> 02:05:20,400
me. Now we have a blank

2243
02:05:20,430 --> 02:05:23,400
remix Setup, click on the
contracts folder and click the

2244
02:05:23,400 --> 02:05:27,000
little page icon to create a new
file, a little box will pop up

2245
02:05:27,210 --> 02:05:30,390
and you can start typing text
into it. We're going to type in

2246
02:05:30,480 --> 02:05:37,350
simple storage dot Sol, dot Sol
tells our compilers that this is

2247
02:05:37,350 --> 02:05:39,990
going to be a solidity file, and
that we're going to code

2248
02:05:40,020 --> 02:05:43,950
solidity in this solidity is the
primary coding language of smart

2249
02:05:43,950 --> 02:05:46,590
contracts. There are a few other
smart contract languages as

2250
02:05:46,590 --> 02:05:50,280
well. But solidity by far is the
most dominant smart contract

2251
02:05:50,280 --> 02:05:53,340
coding language out there. And
now we have a simple storage dot

2252
02:05:53,340 --> 02:05:56,970
soul contract on the right that
we can actually start coding our

2253
02:05:56,970 --> 02:06:00,750
solidity with. So let's start
coding some solidity. Now if you

2254
02:06:00,750 --> 02:06:04,440
click on this button right below
the files button that looks like

2255
02:06:04,440 --> 02:06:08,070
the solidity logo, you'll see a
bunch of stuff pop up in here.

2256
02:06:08,490 --> 02:06:11,820
These are different parameters
for us to actually compile our

2257
02:06:11,820 --> 02:06:14,730
solidity code so that we can run
it. So the first thing that

2258
02:06:14,730 --> 02:06:17,910
you're going to need in any
solidity smart contract is going

2259
02:06:17,910 --> 02:06:20,790
to be the version of solidity
that you're going to use. And

2260
02:06:20,790 --> 02:06:24,000
this should always be at the top
of your solidity code, solidity

2261
02:06:24,000 --> 02:06:26,460
is a constantly changing
language, and it constantly

2262
02:06:26,490 --> 02:06:29,280
updating language. Because it's
relatively new compared to other

2263
02:06:29,280 --> 02:06:32,280
languages, we need to tell our
code, hey, this is the version

2264
02:06:32,280 --> 02:06:35,070
that I want you to use, we can
add the solidity version by

2265
02:06:35,070 --> 02:06:39,990
doing pragma. solidity. And then
the version that we want to use,

2266
02:06:40,050 --> 02:06:42,750
if we want to choose a very
specific version, we could say

2267
02:06:42,780 --> 02:06:47,820
zero, point 8.7. The most
current version to date is 0.8.

2268
02:06:48,060 --> 02:06:51,090
Point 12. But getting used to
different versions of solidity

2269
02:06:51,360 --> 02:06:54,030
is good practice, and different
versions of solidity are

2270
02:06:54,030 --> 02:06:57,990
considered more stable than
others. Zero point 8.7 is one of

2271
02:06:57,990 --> 02:07:00,510
those versions that is
considered more stable. These

2272
02:07:00,510 --> 02:07:03,660
double slashes here are what's
known as a comment, there are

2273
02:07:03,660 --> 02:07:06,810
places where you can type stuff
that won't actually get executed

2274
02:07:06,840 --> 02:07:09,720
in won't get compiled and isn't
really considered part of your

2275
02:07:09,720 --> 02:07:15,000
code. For example, I could write
Hello all. I'm Patrick. And if

2276
02:07:15,000 --> 02:07:17,550
we were going to run this code,
this part of my code would get

2277
02:07:17,550 --> 02:07:20,970
completely ignored. So this
double backslash is how we do

2278
02:07:20,970 --> 02:07:23,520
what's called comments. And as
we're coding, and as we're

2279
02:07:23,520 --> 02:07:27,480
building our projects, be sure
to use this comments tool to

2280
02:07:27,480 --> 02:07:31,440
your advantage every time you
write a new function, or you

2281
02:07:31,440 --> 02:07:34,110
learn something that you didn't
understand, or you learned

2282
02:07:34,110 --> 02:07:37,290
something new that you want to
remember, put it in a comment in

2283
02:07:37,290 --> 02:07:40,230
your code, you're going to be
most effective at taking notes

2284
02:07:40,230 --> 02:07:43,650
in this course, by making them
comments in your code and then

2285
02:07:43,650 --> 02:07:46,680
saving your code so you can
refer back to it later. So leave

2286
02:07:46,680 --> 02:07:49,440
comments in your code, leave
notes in your code. And that

2287
02:07:49,440 --> 02:07:51,870
will be one of the best ways for
you to understand what you're

2288
02:07:51,870 --> 02:07:54,420
coding when you want to refer
back to it later. Now when it

2289
02:07:54,420 --> 02:07:56,760
comes to the versions of
solidity, there's actually a few

2290
02:07:56,760 --> 02:07:59,880
different ways we can actually
write it, we can say we want to

2291
02:07:59,880 --> 02:08:04,170
use only zero point 8.7. And
this is how we would write that.

2292
02:08:04,440 --> 02:08:07,800
But maybe we're okay if we use a
more new version of solidity

2293
02:08:07,800 --> 02:08:11,520
than zero point 8.7 to tell our
code that we're okay with a more

2294
02:08:11,520 --> 02:08:15,480
new version, we can put a little
caret here. And this is how we

2295
02:08:15,480 --> 02:08:20,340
tell solidity. Hey, any version
of zero point 8.7 And above is

2296
02:08:20,370 --> 02:08:24,480
okay for this contract. This
means zero point 8.8 would work

2297
02:08:24,690 --> 02:08:29,310
zero point 8.9 0.8 point 10,
etc. But if we wanted to use

2298
02:08:29,310 --> 02:08:33,270
just 0.17, we would type in like
that if we want to use solidity

2299
02:08:33,270 --> 02:08:36,000
versions between a specific
range, we could do something

2300
02:08:36,000 --> 02:08:39,180
like this, we can say we want
our solidity version greater

2301
02:08:39,180 --> 02:08:45,510
than or equal to zero point 8.7
But less than zero point 9.0.

2302
02:08:45,570 --> 02:08:49,950
This means that any compiler
between zero point 8.7 and zero

2303
02:08:50,370 --> 02:08:55,500
point 9.0 would work. This means
zero point 8.8 would work. Zero

2304
02:08:55,950 --> 02:09:00,270
point 8.9 would work 0.8 point
10 would work. But zero point

2305
02:09:00,270 --> 02:09:06,210
9.0 would not work because it is
not strictly less than 0.9 point

2306
02:09:06,210 --> 02:09:09,660
00 point 9.1 would also not
work. To keep things simple for

2307
02:09:09,660 --> 02:09:13,500
us, we're going to use zero
point 8.8. And every line of

2308
02:09:13,500 --> 02:09:17,160
solidity that's completed, every
completed section needs to end

2309
02:09:17,160 --> 02:09:20,010
with one of these semicolons
this is how you tell solidity

2310
02:09:20,010 --> 02:09:23,490
it's the end of the line. Also
at the top of your code, you're

2311
02:09:23,490 --> 02:09:26,730
always going to want to put
what's called an spdx license

2312
02:09:26,730 --> 02:09:30,750
identifier. This is optional,
but some compilers will flag

2313
02:09:30,750 --> 02:09:33,870
your warning that you don't have
one. This is to make licensing

2314
02:09:33,870 --> 02:09:37,470
and sharing code a lot easier.
We have a link to more about how

2315
02:09:37,470 --> 02:09:40,710
licenses work in the section of
this lesson in our GitHub

2316
02:09:40,710 --> 02:09:45,210
repository to do an spdx license
identifier, we just say spdx

2317
02:09:45,900 --> 02:09:51,600
license identifier, and we're
gonna choose MIT, the MIT

2318
02:09:51,600 --> 02:09:54,870
license is one of the least
restrictive licenses out there.

2319
02:09:54,930 --> 02:09:58,320
So we use the MIT license for
most of our code samples once

2320
02:09:58,320 --> 02:10:01,410
you have a version and once you
have Is this much written, we

2321
02:10:01,410 --> 02:10:04,020
can actually go ahead and write
to our compiler tab and scroll

2322
02:10:04,020 --> 02:10:08,220
down and hit Compile, that
little turn thing will go. And

2323
02:10:08,220 --> 02:10:11,670
in a minute, we'll see, this
contract is attempted to be

2324
02:10:11,670 --> 02:10:14,700
compiled. Since we actually
don't have a contract, we see no

2325
02:10:14,700 --> 02:10:17,970
contract compiled yet, but we
see the compiler automatically

2326
02:10:17,970 --> 02:10:21,480
switched to zero point 8.8.
compiling our code means taking

2327
02:10:21,480 --> 02:10:24,660
our more human readable code
like pragma, solidity and

2328
02:10:24,900 --> 02:10:29,160
transforming it into computer
code, or very specific

2329
02:10:29,160 --> 02:10:32,310
instructions for the computer to
use. We'll go over what a lot of

2330
02:10:32,310 --> 02:10:36,360
this machine level code or this
computer level code is doing in

2331
02:10:36,390 --> 02:10:39,390
a later section. If you're using
a Mac, you can also hit command

2332
02:10:39,420 --> 02:10:42,870
S, and it will run the compiler
for you as well. On Windows, it

2333
02:10:42,870 --> 02:10:46,530
might be Ctrl S, we can actually
choose the compiler version that

2334
02:10:46,530 --> 02:10:49,950
we want to use. However, if we
tell in our code to specifically

2335
02:10:49,950 --> 02:10:53,760
use zero, point 8.8, and we hit
the compile button, it'll

2336
02:10:53,760 --> 02:10:56,850
automatically switch to zero
point 8.8. However, if we use

2337
02:10:56,850 --> 02:11:00,360
the carrot thing, we get
specifically say, hey, we want

2338
02:11:00,450 --> 02:11:05,370
0.8 point 10, we can hit
compile, and it will compile

2339
02:11:05,370 --> 02:11:09,420
with 0.8 point 10. Because
again, remember, the carrot says

2340
02:11:09,420 --> 02:11:13,740
we want to use at least zero,
point eight, all the way up to

2341
02:11:13,740 --> 02:11:18,120
the latest version of 0.8. Now
let's stay on zero point 8.8.

2342
02:11:18,240 --> 02:11:20,520
The next thing that we're going
to do in our code is define our

2343
02:11:20,520 --> 02:11:23,280
contract. And to get a full
screen view, you can go ahead

2344
02:11:23,280 --> 02:11:25,950
and hit the compiler button to
get rid of it there. To start

2345
02:11:25,950 --> 02:11:27,900
defining our contract, we're
gonna go ahead and write the

2346
02:11:27,900 --> 02:11:31,980
word contract. This tells
solidity that the next pieces of

2347
02:11:31,980 --> 02:11:35,370
code is going to be a contract
contract is a key word in

2348
02:11:35,370 --> 02:11:37,950
solidity, and it tells our
compiler that the next section

2349
02:11:37,980 --> 02:11:41,370
of this code is going to define
a contract. You can think of a

2350
02:11:41,370 --> 02:11:44,790
contract similar to a class in
any object oriented programming

2351
02:11:44,790 --> 02:11:48,180
like Java or JavaScript. Let's
go ahead and give our contract a

2352
02:11:48,180 --> 02:11:53,010
name here, we're going to call
RS simple storage. And then we

2353
02:11:53,010 --> 02:11:57,240
add this little open and close
curly brackets. Everything

2354
02:11:57,240 --> 02:12:00,330
inside this open and close curly
brackets is going to be the

2355
02:12:00,330 --> 02:12:03,450
contents of this contract.
Simple Storage. Now, if we go

2356
02:12:03,450 --> 02:12:06,930
ahead and hit command S or Ctrl
S, we can see this little green

2357
02:12:06,930 --> 02:12:09,990
checkmark show up. And if you
don't, you can always go back to

2358
02:12:09,990 --> 02:12:13,500
the compiler tab, scroll down
and hit Compile and see the

2359
02:12:13,500 --> 02:12:16,470
little green checkmark. That
little green checkmark means

2360
02:12:16,470 --> 02:12:19,260
that our code is compiling
successfully. And we don't have

2361
02:12:19,260 --> 02:12:21,750
any errors, we could
hypothetically deploy this

2362
02:12:21,750 --> 02:12:25,080
contract right now. And it would
be a valid contract. So

2363
02:12:25,080 --> 02:12:27,690
congratulations on writing your
first contract.

2364
02:12:30,270 --> 02:12:33,300
Now solidity has multiple
different types or primitive

2365
02:12:33,300 --> 02:12:36,630
data types. And if you go to the
solidity documentation, which

2366
02:12:36,660 --> 02:12:39,480
again, is in our GitHub
repository, you can read more

2367
02:12:39,480 --> 02:12:41,430
and learn more about the
different types that are in

2368
02:12:41,430 --> 02:12:44,460
here. The four most basic types
are going to be Boolean,

2369
02:12:45,480 --> 02:12:48,930
you int, int, and an address

2370
02:12:49,110 --> 02:12:52,230
or bytes, which is a lower level
type, which we'll talk about a

2371
02:12:52,230 --> 02:12:55,170
little bit later. A boolean
define some type of true false,

2372
02:12:55,860 --> 02:12:58,980
a you int is going to be an
unsigned integer, which means

2373
02:12:58,980 --> 02:13:01,800
it's going to be a whole number
that isn't positive or negative.

2374
02:13:01,830 --> 02:13:05,190
It's just positive, we have an
integer, which is going to be a

2375
02:13:05,190 --> 02:13:08,460
positive or negative whole
number. And then we have an

2376
02:13:08,460 --> 02:13:12,630
address, which is going to be an
address, like what we see in our

2377
02:13:12,630 --> 02:13:15,120
meta mask here. There are some
other types as well that you'll

2378
02:13:15,120 --> 02:13:18,330
learn later on. The reason that
we have these types is we use

2379
02:13:18,330 --> 02:13:22,080
them to define what different
variables are. Variables are

2380
02:13:22,080 --> 02:13:25,590
basically holders for different
values. For example, we could

2381
02:13:25,590 --> 02:13:31,350
create a variable called has
favorite number to represent if

2382
02:13:31,350 --> 02:13:35,850
somebody has a favorite number.
And we would put this bull

2383
02:13:35,880 --> 02:13:40,170
keyword before has to renumber
say, Okay, we have a variable

2384
02:13:40,200 --> 02:13:44,070
called has favorite number, and
it's of type boolean. So this

2385
02:13:44,070 --> 02:13:47,730
has favorite number is going to
represent a true or a false to

2386
02:13:47,730 --> 02:13:52,890
set its value, we could say has
favorite number equals true. Now

2387
02:13:52,920 --> 02:13:56,640
has favorite number is going to
be true. We could also say has

2388
02:13:56,640 --> 02:14:00,900
favorite number equals false. So
this Boolean has faded number is

2389
02:14:00,900 --> 02:14:05,460
now going to be false. For uns
we could say you went favorite

2390
02:14:05,460 --> 02:14:11,220
number equals and then set a
number 123. This means that our

2391
02:14:11,220 --> 02:14:14,910
favorite number is going to be
123 You'll enter is special

2392
02:14:14,910 --> 02:14:18,630
because we can actually specify
how many bits want to allocate

2393
02:14:18,780 --> 02:14:22,020
to this number bits and bytes
are pretty fundamental pieces of

2394
02:14:22,020 --> 02:14:24,750
information for computer
science. We're not going to go

2395
02:14:24,750 --> 02:14:27,810
over it here. However, there's a
fantastic video in the GitHub

2396
02:14:27,810 --> 02:14:30,450
repository that explains it
more. Basically, it's how much

2397
02:14:30,450 --> 02:14:34,860
storage or memory to allocate to
this number. How big can it get,

2398
02:14:34,950 --> 02:14:38,250
if we say a you int eight can
have eight bits all the way up

2399
02:14:38,250 --> 02:14:42,270
to you went to 56. If you don't
specify how big it is, it

2400
02:14:42,270 --> 02:14:46,260
automatically defaults to you
into 256. Oftentimes, it's

2401
02:14:46,260 --> 02:14:49,710
better when writing our code to
be very explicit. So usually

2402
02:14:49,710 --> 02:14:53,970
you'll see me just do you int
256 to represent a un 256. We

2403
02:14:53,970 --> 02:14:59,730
could also do an int favorite
number equals 123 or an int 256.

2404
02:14:59,790 --> 02:15:01,800
I'm just Going to go ahead and
add this Boolean back here,

2405
02:15:01,950 --> 02:15:05,460
we're going to change this back
to UNT to 36. And let's change

2406
02:15:05,460 --> 02:15:07,740
our favorite number to five
here, we could also do something

2407
02:15:07,740 --> 02:15:13,080
called strings, string, favorite
number in text

2408
02:15:14,130 --> 02:15:16,080
equals five

2409
02:15:16,560 --> 02:15:20,550
strings represent basically
words, and you can represent

2410
02:15:20,550 --> 02:15:23,190
them by putting them in these
quotes, it's going to be some

2411
02:15:23,190 --> 02:15:25,620
word or phrase, or really,
really just kind of any

2412
02:15:25,620 --> 02:15:30,930
combination of keystrokes in
here, our ends can be positive

2413
02:15:30,930 --> 02:15:34,830
or negative. So we could say,
negative five or positive five,

2414
02:15:35,640 --> 02:15:39,810
both are going to be valid,
since we can also do address my

2415
02:15:39,810 --> 02:15:45,720
address equals and grab our
address, right from Metamask.

2416
02:15:45,990 --> 02:15:48,780
And paste it in, you'll notice
that we end all of these lines

2417
02:15:48,780 --> 02:15:53,070
of code with the semicolon. We
also have bytes objects, or a

2418
02:15:53,070 --> 02:15:56,910
bytes 32, again, representing
how many bytes we want them to

2419
02:15:56,910 --> 02:16:04,110
be. And this says that we have
called favorite bytes, and we're

2420
02:16:04,110 --> 02:16:07,050
just gonna set it equal to cat.
So strings are actually really

2421
02:16:07,050 --> 02:16:11,550
interesting, because strings are
secretly just bytes objects, but

2422
02:16:11,550 --> 02:16:15,570
only for text to a cat is
actually a string, but can

2423
02:16:15,570 --> 02:16:18,750
automatically get converted into
one of these bytes object bytes,

2424
02:16:18,750 --> 02:16:23,280
objects typically look like 0x.
And then some random letters and

2425
02:16:23,280 --> 02:16:26,610
numbers that represent the bytes
object, but cat can

2426
02:16:26,610 --> 02:16:29,370
automatically get converted down
to bytes. We'll talk about bytes

2427
02:16:29,370 --> 02:16:32,880
more in coming sessions, you can
also do bytes, two bytes, three

2428
02:16:32,880 --> 02:16:37,530
bytes, five bytes 22, you get
the picture for our uns and our

2429
02:16:37,530 --> 02:16:41,340
into the sixth lowest we can go
is eight bits, because eight

2430
02:16:41,340 --> 02:16:44,430
bits is a byte. And we can go up
by steps of eight. So we can do

2431
02:16:44,430 --> 02:16:51,750
816 32, etc, all the way to 256.
For example, down here, we can't

2432
02:16:51,750 --> 02:16:58,080
do bytes 64. And if we go ahead
and try to compile this, we get

2433
02:16:58,110 --> 02:17:02,250
a little red thing here. And if
we scroll down, we get a

2434
02:17:02,250 --> 02:17:06,510
declaration error identifier not
found or not unique. Bytes 64

2435
02:17:06,540 --> 02:17:10,080
favorite bytes equals cats. And
we even got a little red warning

2436
02:17:10,080 --> 02:17:13,830
sign here in our remix. This is
remix telling us there's

2437
02:17:13,830 --> 02:17:16,500
something wrong with this line.
So we can switch back to bite

2438
02:17:16,500 --> 02:17:20,460
32. Since byte 32 is the maximum
size that a bytes can be, you

2439
02:17:20,460 --> 02:17:23,520
could also do just a bytes
object, which means it can have

2440
02:17:23,520 --> 02:17:26,970
any size, but we typically want
to be explicit. And we're going

2441
02:17:26,970 --> 02:17:29,880
to stick with bytes 32 For now
want to learn more about the

2442
02:17:29,880 --> 02:17:32,100
different types and how to use
them and all the different

2443
02:17:32,100 --> 02:17:34,350
features with them, be sure to
check out the solidity

2444
02:17:34,350 --> 02:17:37,380
documentation. For now for our
simple storage, let's say we

2445
02:17:37,380 --> 02:17:40,110
only want to store numbers. So
let's go ahead and delete

2446
02:17:40,140 --> 02:17:42,720
everything except for the
favorite number section.

2447
02:17:45,660 --> 02:17:46,710
Now in solidity,

2448
02:17:46,740 --> 02:17:50,340
if I do this, and I remove the
equals five, this favorite

2449
02:17:50,340 --> 02:17:54,240
number actually does get set to
a default value, the default

2450
02:17:54,240 --> 02:17:57,660
value for solidity is going to
be whatever the null value is,

2451
02:17:57,900 --> 02:18:01,140
which in solidity is case zero.
So saying you Intuit six

2452
02:18:01,140 --> 02:18:04,890
favorite number is going to be
the same as saying you 256

2453
02:18:04,920 --> 02:18:08,760
favorite number equals zero
since it gets initialized to

2454
02:18:08,760 --> 02:18:11,790
zero. So for now, let's not
initialize it to anything. So

2455
02:18:11,790 --> 02:18:15,030
that favorite number will
automatically start off as zero.

2456
02:18:15,060 --> 02:18:17,670
Now, if you get confused, as
you're coding along, and you're

2457
02:18:17,670 --> 02:18:21,060
following along with me, be sure
to write comments in your code

2458
02:18:21,060 --> 02:18:24,540
so you know what's going on. So
maybe, for example, a great

2459
02:18:24,540 --> 02:18:30,840
comment here would be this gets
initially alized to zero. And

2460
02:18:30,840 --> 02:18:35,490
then if that's even confusing,
you could say, this means that

2461
02:18:35,490 --> 02:18:44,160
this section is a comment. Now
let's go ahead and create a

2462
02:18:44,160 --> 02:18:48,000
function functions or methods
are self contained modules that

2463
02:18:48,000 --> 02:18:51,810
will execute some specific set
of instructions for us, when we

2464
02:18:51,810 --> 02:18:54,990
call it if you're familiar with
Java, or Python, or JavaScript

2465
02:18:54,990 --> 02:18:57,720
or anything like that functions
work the exact same way

2466
02:18:57,750 --> 02:19:01,680
functions get identified by the
keyword function, let's create a

2467
02:19:01,680 --> 02:19:06,510
function called store that will
change the value of favorite

2468
02:19:06,510 --> 02:19:10,020
number to some new value. And
the number that we're going to

2469
02:19:10,020 --> 02:19:13,440
change it to is going to be
variables that are passed to our

2470
02:19:13,440 --> 02:19:16,470
store function here. So we're
going to allow our store

2471
02:19:16,470 --> 02:19:22,020
function to take a variable of
type un 256. And we'll call it

2472
02:19:22,080 --> 02:19:24,030
underscore favorite

2473
02:19:25,320 --> 02:19:28,710
number, we'll make this a public
function, which we'll get to in

2474
02:19:28,710 --> 02:19:30,840
a minute. And all we're going to
do is we're going to set

2475
02:19:30,840 --> 02:19:34,620
favorite number equal to
whatever variable that we just

2476
02:19:34,620 --> 02:19:39,870
passed. So now we have this
function called store, that it

2477
02:19:39,870 --> 02:19:43,020
takes some parameter that we're
going to give it and it sets

2478
02:19:43,020 --> 02:19:46,260
this favorite number variable
equal to whatever number that we

2479
02:19:46,260 --> 02:19:49,110
give this function. Now to see
this actually in action, let's

2480
02:19:49,110 --> 02:19:52,530
deploy this to an even thicker
blockchain than a test net.

2481
02:19:52,590 --> 02:19:55,830
We're going to actually deploy
this to a local network or a

2482
02:19:55,830 --> 02:19:59,070
JavaScript VM. And first before
we can even do that, let's just

2483
02:19:59,070 --> 02:20:01,350
make sure that it's going
compiling correctly looks like

2484
02:20:01,350 --> 02:20:04,410
we have a green checkmark, which
is good. And we'll come down to

2485
02:20:04,410 --> 02:20:07,830
this button here, which is our
deploy and run Transactions tab.

2486
02:20:08,730 --> 02:20:11,700
Our deploy and run Transactions
tab has a ton of different

2487
02:20:11,700 --> 02:20:14,310
configuration pieces for
actually deploying this

2488
02:20:14,310 --> 02:20:18,090
contract. First, we want to make
sure we are on the JavaScript VM

2489
02:20:18,210 --> 02:20:21,330
London piece here, JavaScript VM
means we're going to be

2490
02:20:21,330 --> 02:20:26,850
deploying to a fake local
JavaScript VM. The JavaScript VM

2491
02:20:26,880 --> 02:20:30,750
is a fake local blockchain where
we can simulate transactions

2492
02:20:30,750 --> 02:20:33,750
really quickly without having to
wait for them to go through on a

2493
02:20:33,750 --> 02:20:36,630
test net, don't worry about the
London versus Berlin piece here

2494
02:20:36,630 --> 02:20:39,690
for now, injected web three and
web three provider we'll talk

2495
02:20:39,690 --> 02:20:42,750
about in a little bit. We also
have this account section here.

2496
02:20:42,840 --> 02:20:46,110
When we run on our fake
JavaScript VM, we're given a

2497
02:20:46,110 --> 02:20:49,230
whole bunch of fake accounts
from where to deploy from, and

2498
02:20:49,230 --> 02:20:53,190
we're given 100 eath. For each
one of these fake accounts, you

2499
02:20:53,190 --> 02:20:56,970
can kind of think of it similar
to our meta mask account in meta

2500
02:20:56,970 --> 02:21:01,260
mask, except for the difference
here is that this is this fake

2501
02:21:01,380 --> 02:21:04,260
JavaScript VM Aetherium that
we're given. For our

2502
02:21:04,260 --> 02:21:06,930
transactions, including
deploying contracts, we're

2503
02:21:06,930 --> 02:21:09,960
actually given a gas limit,
there's also values we can send,

2504
02:21:09,960 --> 02:21:12,900
and we can choose our contracts.
Right now we only have one

2505
02:21:12,900 --> 02:21:15,390
contract, simple storage, so
that's going to be the one that

2506
02:21:15,390 --> 02:21:18,600
we're going to deploy. So on the
left hand side, to deploy this

2507
02:21:18,630 --> 02:21:21,990
to our fake JavaScript VM, we're
gonna go ahead and hit the

2508
02:21:22,020 --> 02:21:24,660
Deploy button. And if we scroll
all the way down to the bottom,

2509
02:21:24,660 --> 02:21:30,030
now, we can see a contract was
deployed. It says simple storage

2510
02:21:30,240 --> 02:21:34,290
at x, blah, blah, blah, blah,
blah. And we see this orange

2511
02:21:34,290 --> 02:21:38,310
button store with come this
grade text you in 256,

2512
02:21:38,610 --> 02:21:42,480
underscore favorite number on
our fake local blockchain, we're

2513
02:21:42,480 --> 02:21:46,920
actually given an address every
single smart contract, it has an

2514
02:21:46,920 --> 02:21:51,090
address, just like how our
wallets have an address. So if

2515
02:21:51,090 --> 02:21:54,720
we hit this copy button here,
and we put it into a comment,

2516
02:21:55,560 --> 02:21:59,430
make this a little bit bigger,
we can see that the address of

2517
02:21:59,430 --> 02:22:02,850
this contract that we just
deployed, is located at this

2518
02:22:02,850 --> 02:22:06,060
address. Additionally, if you
pull up the slider over here,

2519
02:22:06,420 --> 02:22:08,520
you'll be able to see this
little green checkmark with all

2520
02:22:08,520 --> 02:22:11,280
this information about this
deployment. And you can hit the

2521
02:22:11,280 --> 02:22:14,340
little drop down and see a whole
lot more information about this.

2522
02:22:14,730 --> 02:22:17,340
Something you might notice is
you'll see some familiar

2523
02:22:17,340 --> 02:22:22,590
keywords like status,
transaction hash, from to gas,

2524
02:22:22,620 --> 02:22:27,540
etc. When we deploy a contract,
it's actually the same as

2525
02:22:27,540 --> 02:22:30,840
sending a transaction. Remember,
anytime we do anything on the

2526
02:22:30,840 --> 02:22:36,150
blockchain, we modify any value,
we are sending a transaction. So

2527
02:22:36,150 --> 02:22:40,020
deploying a contract is
modifying the blockchain to have

2528
02:22:40,020 --> 02:22:43,110
this contract, it's modifying
the state of the blockchain. And

2529
02:22:43,110 --> 02:22:45,930
if we had sent this on a
Rinkeby, or COVID, or main net

2530
02:22:45,930 --> 02:22:49,620
network, we would have had to
spend the gas to actually deploy

2531
02:22:49,620 --> 02:22:53,580
this contract. And this is the
simulation of how much gas and

2532
02:22:53,580 --> 02:22:56,670
the transaction hash and from
and to and all this other stuff

2533
02:22:56,940 --> 02:22:59,940
about our transaction had, we
actually deployed it to a real

2534
02:22:59,940 --> 02:23:02,370
network. But since it's
JavaScript VM, it's all fake

2535
02:23:02,370 --> 02:23:05,700
information. Now we have this
big orange button store, this

2536
02:23:05,730 --> 02:23:08,880
big orange button resembles the
store function that we just

2537
02:23:08,880 --> 02:23:12,420
created. So if we add some
number into this store, like

2538
02:23:12,420 --> 02:23:16,530
123, and we hit the Store
button, we actually call this

2539
02:23:16,560 --> 02:23:19,950
store button. And we actually
execute a transaction on our

2540
02:23:19,950 --> 02:23:24,930
fake Jasika. Blockchain to store
the number 1234 favorite number.

2541
02:23:25,020 --> 02:23:28,980
And if we scroll all the way up
to our account, now, you'll see

2542
02:23:29,010 --> 02:23:32,190
that we have a little bit less
ether in our fake account. This

2543
02:23:32,190 --> 02:23:37,050
is because we spent the gas to
actually call this contract. And

2544
02:23:37,050 --> 02:23:40,560
if we pull up this bottom bit
here, and I call this with five

2545
02:23:40,590 --> 02:23:43,950
I call store, you'll see it
flashed for a quick second, we

2546
02:23:43,950 --> 02:23:47,970
sent another transaction to
store the value five in our

2547
02:23:47,970 --> 02:23:50,580
favorite number. Now the
question might be having is,

2548
02:23:50,940 --> 02:23:53,910
that's really cool, Patrick, but
I can't see what favorite number

2549
02:23:53,910 --> 02:23:56,850
actually is, how do I know that
those transactions are actually

2550
02:23:56,850 --> 02:24:00,510
going through? Well, right now,
the visibility of our favorite

2551
02:24:00,510 --> 02:24:04,200
number is set to private, so we
actually can't see it. And we'll

2552
02:24:04,200 --> 02:24:07,290
talk about visibility in just a
second. To make it so that we

2553
02:24:07,290 --> 02:24:10,860
can see it. We'll change our
favorite numbers visibility to

2554
02:24:10,860 --> 02:24:14,610
public. So let's go ahead, we'll
recompile we'll go back to the

2555
02:24:14,610 --> 02:24:18,150
deploy tab. We'll click the
little x here, which is to say

2556
02:24:18,150 --> 02:24:21,420
let's get rid of this contract.
And it just gets rid of it from

2557
02:24:21,450 --> 02:24:23,940
our window here. It doesn't
actually get rid of it from the

2558
02:24:23,940 --> 02:24:27,300
blockchain, because again,
they're immutable, well, kind of

2559
02:24:27,300 --> 02:24:30,480
immutable, since again, this is
kind of a fake simulated chain.

2560
02:24:30,810 --> 02:24:34,440
But we go ahead and compile, and
now we hit Deploy again. And if

2561
02:24:34,440 --> 02:24:37,830
we scroll down, our new
contract, will now have two

2562
02:24:37,830 --> 02:24:41,100
buttons. One is the orange
button for store. But now we

2563
02:24:41,100 --> 02:24:45,750
have a New Favorite button. This
button represents this public

2564
02:24:45,750 --> 02:24:48,990
variable favorite number, and it
resembles a function saying,

2565
02:24:48,990 --> 02:24:52,800
Hey, show me what favorite
number is. So if I were to click

2566
02:24:52,800 --> 02:24:55,170
this favorite number button,
what do you think will show up?

2567
02:24:55,200 --> 02:24:58,320
Well, do you remember what this
gets initialized to? Well, let's

2568
02:24:58,320 --> 02:25:02,640
click it now. We do indeed See
that zero shows up, we see that

2569
02:25:02,640 --> 02:25:06,690
this is a YouTube ID six, and
the value stored in it is zero.

2570
02:25:06,870 --> 02:25:10,320
Now, if I were to change that
number to five by calling the

2571
02:25:10,320 --> 02:25:13,440
store function, and now hitting
favorite number, we do indeed

2572
02:25:13,440 --> 02:25:16,980
see, favorite number gets
updated to five functions and

2573
02:25:16,980 --> 02:25:20,670
variables can have one for
visibility specifiers, we have

2574
02:25:20,670 --> 02:25:26,370
public, private, external, and
internal. Public is visible

2575
02:25:26,370 --> 02:25:30,090
externally and internally,
meaning anybody who interacts

2576
02:25:30,090 --> 02:25:33,150
with this contract or sees this
contract can see what's stored

2577
02:25:33,150 --> 02:25:35,520
in this favorite number
function. You'll see here in the

2578
02:25:35,520 --> 02:25:38,640
solidity documentation, it says
it creates a getter function for

2579
02:25:38,640 --> 02:25:41,310
the storage slash state
variables. When we add this

2580
02:25:41,310 --> 02:25:44,160
keyword public to favorite
number, what we're actually

2581
02:25:44,160 --> 02:25:47,310
doing is we're creating what's
called a getter function for

2582
02:25:47,310 --> 02:25:50,670
favorite number, we're basically
creating a function that says to

2583
02:25:50,670 --> 02:25:54,540
return the value of favorite
number, and that's why this blue

2584
02:25:54,540 --> 02:25:57,690
button pops up. Because this
blue button is a function that

2585
02:25:57,690 --> 02:26:02,040
says, hey, return the value of
favorite number private means

2586
02:26:02,100 --> 02:26:05,730
only this specific contract can
call this function. Now for

2587
02:26:05,730 --> 02:26:09,990
storage, it doesn't mean only
this contract can read what's

2588
02:26:10,020 --> 02:26:13,140
stored here. And we'll get into
that a little bit later. But by

2589
02:26:13,140 --> 02:26:15,960
that means, this is the only
contract that can call the

2590
02:26:15,960 --> 02:26:18,660
favorite number function.
Private functions are only

2591
02:26:18,660 --> 02:26:21,840
visible to the current contract.
External functions are only

2592
02:26:21,840 --> 02:26:25,680
visible externally, meaning
somebody outside this contract

2593
02:26:25,710 --> 02:26:29,100
can call this function. And then
internal means that only this

2594
02:26:29,100 --> 02:26:32,970
contract and it's children
contracts can actually read it,

2595
02:26:32,970 --> 02:26:36,030
but we'll get into that a little
bit later, too. So oddly enough,

2596
02:26:36,060 --> 02:26:39,420
variables are just function
calls. Now, the reason that we

2597
02:26:39,420 --> 02:26:42,420
didn't see favorite numbers show
up on the left hand side, when

2598
02:26:42,420 --> 02:26:45,060
we first deployed this without
the public keyword. When we

2599
02:26:45,060 --> 02:26:47,970
don't give a visibility
specifier to functions or

2600
02:26:47,970 --> 02:26:51,180
variables, they automatically
get deployed as internal. And as

2601
02:26:51,180 --> 02:26:54,630
we know, internal functions and
variables can only be called by

2602
02:26:54,630 --> 02:26:57,870
this specific contract or
derived contracts, which again,

2603
02:26:57,870 --> 02:27:01,320
we'll get into later. So let's
just keep it public. For now,

2604
02:27:01,350 --> 02:27:04,230
the reason that we're prefixing,
our parameter here with an

2605
02:27:04,230 --> 02:27:09,450
underscore is a way to tell us,
hey, this variable here is

2606
02:27:09,450 --> 02:27:11,700
different from the favorite
number global, there are some

2607
02:27:11,700 --> 02:27:14,430
different naming conventions
that are used for parameters.

2608
02:27:14,430 --> 02:27:17,670
And as we get later into the
course, will understand more and

2609
02:27:17,670 --> 02:27:20,550
more of what good names are
parameters are, every time we

2610
02:27:20,550 --> 02:27:24,000
call this store function. And we
change the value here, we're

2611
02:27:24,000 --> 02:27:27,210
actually sending a transaction
because remember, every single

2612
02:27:27,210 --> 02:27:30,390
time we change the state of the
blockchain, we do it in a

2613
02:27:30,390 --> 02:27:33,750
transaction. And we can see all
the details here. If you go over

2614
02:27:33,750 --> 02:27:37,620
to the transaction details in
the logging area of your remix,

2615
02:27:37,830 --> 02:27:41,610
you can actually scroll down and
you can see the transaction cost

2616
02:27:41,640 --> 02:27:44,790
in units of gas, you'll see a
number of something around this.

2617
02:27:44,790 --> 02:27:48,540
And you'll notice it's more than
that 21,000 number from sending

2618
02:27:48,570 --> 02:27:50,910
Aetherium. That's because we're
doing something more

2619
02:27:50,910 --> 02:27:55,320
computationally expensive. We're
actually storing a number over

2620
02:27:55,320 --> 02:27:59,190
here. Now what do you think will
happen if we do more inside of

2621
02:27:59,190 --> 02:28:01,800
the store function as well. So
instead of just storing this

2622
02:28:01,800 --> 02:28:05,670
number, maybe what else we do is
we will store the number here.

2623
02:28:06,330 --> 02:28:08,760
And then we'll update our
favorite number will say

2624
02:28:08,760 --> 02:28:11,610
favorite number equals favorite
number plus one. Since we're

2625
02:28:11,640 --> 02:28:15,390
doing more stuff, now we should
see this store function actually

2626
02:28:15,390 --> 02:28:19,980
become more expensive. So let's
go ahead and recompile we'll do

2627
02:28:19,980 --> 02:28:24,900
delete this will redeploy. We
now have a new contract will

2628
02:28:24,900 --> 02:28:29,040
store five again. Now if we look
in the details of this

2629
02:28:29,040 --> 02:28:33,240
transaction, and we scroll down
to execution costs, we do indeed

2630
02:28:33,240 --> 02:28:36,780
see the amount of gas has
greatly increased. And that's

2631
02:28:36,780 --> 02:28:40,500
because we're doing more things,
this store function is now more

2632
02:28:40,500 --> 02:28:44,040
computationally expensive. And
like I said, each blockchain has

2633
02:28:44,070 --> 02:28:46,860
a little different way of how
they actually calculate gas. But

2634
02:28:46,860 --> 02:28:50,460
the easiest way to think about
it is, the more stuff you do,

2635
02:28:50,760 --> 02:28:54,090
the more expensive that
transaction is going to cost. So

2636
02:28:54,090 --> 02:28:57,720
let's go ahead and delete this
line to continue our example.

2637
02:28:57,750 --> 02:29:02,040
Now let's talk about scope for a
second, our favorite number is

2638
02:29:02,070 --> 02:29:05,220
basically in something called
the global scope, meaning

2639
02:29:05,250 --> 02:29:09,450
anything inside of these
brackets can access this

2640
02:29:09,480 --> 02:29:11,910
favorite number variable. But
what if I did something like

2641
02:29:11,910 --> 02:29:17,730
this? What if I made a un 256
called Test var? And I set it

2642
02:29:17,730 --> 02:29:21,480
equal to five? And then I
created a new function called

2643
02:29:21,480 --> 02:29:26,250
something will have it take no
parameters and be public? Could

2644
02:29:26,250 --> 02:29:29,700
I access the test var and then
change it to something like six?

2645
02:29:30,240 --> 02:29:33,030
Can we do that? Well, let's go
ahead and see what happens when

2646
02:29:33,030 --> 02:29:37,410
we try to compile this. We
actually run into an error. We

2647
02:29:37,410 --> 02:29:41,040
had expected primary expression
right here. Oh, well, that's

2648
02:29:41,040 --> 02:29:44,250
because I have the double
question mark. Let's try now. We

2649
02:29:44,250 --> 02:29:48,090
get undeclared identifier. Our
something function doesn't know

2650
02:29:48,120 --> 02:29:51,930
about this test var when you
create variables, they only can

2651
02:29:51,930 --> 02:29:55,110
be viewed in the scope of where
they are. Now if that's a little

2652
02:29:55,110 --> 02:29:57,900
confusing, just look for the
curly brackets. These two curly

2653
02:29:57,900 --> 02:30:01,860
brackets encompass this whole
We'll section here write, the

2654
02:30:01,860 --> 02:30:04,860
opening one is up here, the
closing one is down here. So if

2655
02:30:04,890 --> 02:30:08,820
I create a variable directly
inside of these curly brackets,

2656
02:30:08,850 --> 02:30:12,480
that means everything in here
can access it. However, test var

2657
02:30:12,510 --> 02:30:15,720
was created inside of these
curly brackets, which means that

2658
02:30:15,750 --> 02:30:19,770
only stuff inside of these curly
brackets can access test var,

2659
02:30:19,920 --> 02:30:23,970
since our functions something
isn't inside of store, or

2660
02:30:23,970 --> 02:30:27,510
something function won't know
about test var. So that's how

2661
02:30:27,510 --> 02:30:30,660
scope works, you want to look to
see if your variable that you

2662
02:30:30,660 --> 02:30:33,870
created is inside of these curly
brackets. And that's how you can

2663
02:30:33,870 --> 02:30:38,100
know if other functions can work
with them. So this is why this

2664
02:30:38,130 --> 02:30:41,310
fails. Now, like what we saw in
the documentation, when we add

2665
02:30:41,310 --> 02:30:44,760
this public variable to favorite
number, we're secretly adding a

2666
02:30:44,760 --> 02:30:48,390
function that just returns this
favorite number, we can also add

2667
02:30:48,390 --> 02:30:51,120
our own function that also
returns the favorite number to

2668
02:30:51,120 --> 02:30:53,670
resemble the function that's
getting created in the backend.

2669
02:30:53,790 --> 02:30:58,320
So we can say function, we call
it retrieve, and we make it a

2670
02:30:58,320 --> 02:31:05,220
public view. And we'll say it
returns, you went to 56. or

2671
02:31:05,220 --> 02:31:08,280
explain what that means in just
a second. And we'll say return

2672
02:31:08,310 --> 02:31:13,830
favorite number. Now, I'm going
to hit command S, which again,

2673
02:31:13,830 --> 02:31:16,110
I'm going to do that a lot
throughout this section. But

2674
02:31:16,110 --> 02:31:19,140
just remember that that's
equivalent to me going to the

2675
02:31:19,140 --> 02:31:22,710
compile tab and hitting compile.
Now if we go to the deploy tab,

2676
02:31:22,800 --> 02:31:26,820
delete our last one, deploy a
new one, we now have a retrieve

2677
02:31:26,820 --> 02:31:30,240
function, which is going to
return the exact same thing that

2678
02:31:30,240 --> 02:31:32,910
our favorite number is going to
return. Again, if we update this

2679
02:31:32,910 --> 02:31:36,630
to five, called favorite number
and then retrieve they both now

2680
02:31:36,660 --> 02:31:40,470
return five. Now as you can see
here, these two functions are

2681
02:31:40,470 --> 02:31:44,100
blue, but this function is
orange. What's the difference?

2682
02:31:44,100 --> 02:31:47,250
Why did these have these
different colors? Well, the key

2683
02:31:47,280 --> 02:31:50,790
lies in this view keyword here,
there are actually two keywords

2684
02:31:50,790 --> 02:31:54,360
in solidity that notate a
function that doesn't actually

2685
02:31:54,360 --> 02:31:58,890
have to spend gas to run. And
those keywords are view, and

2686
02:31:58,890 --> 02:32:02,280
pure. And let's also get rid of
this variable here. A function

2687
02:32:02,280 --> 02:32:05,850
that is a view function means
we're just going to read state

2688
02:32:06,120 --> 02:32:08,400
from this contract, we're just
going to read something off of

2689
02:32:08,400 --> 02:32:11,250
this contract. For example, our
retrieve function right now is

2690
02:32:11,250 --> 02:32:14,910
just reading what favorite
number is, a view function

2691
02:32:14,940 --> 02:32:19,020
disallows any modification of
state. So you can't update the

2692
02:32:19,020 --> 02:32:22,860
blockchain at all with a view
function. Pure functions also

2693
02:32:22,890 --> 02:32:26,070
disallow any modification of
state. So we couldn't update our

2694
02:32:26,070 --> 02:32:29,490
favorite number. Not only that,
but they also disallow reading

2695
02:32:29,490 --> 02:32:32,400
from the blockchain. So we
couldn't read favorite number

2696
02:32:32,400 --> 02:32:36,330
either. Instead, what you might
do with a pure function is maybe

2697
02:32:36,330 --> 02:32:37,110
something like

2698
02:32:38,010 --> 02:32:44,760
function, add public here, one
plus one,

2699
02:32:45,990 --> 02:32:51,810
or return, one plus one, this
would be turns you into 36,

2700
02:32:51,930 --> 02:32:54,510
maybe something like this, maybe
there's some math you want to

2701
02:32:54,510 --> 02:32:57,930
use over and over again, maybe
there's some specific algorithm

2702
02:32:57,930 --> 02:32:59,940
that you want to implement that
doesn't actually need to read

2703
02:32:59,940 --> 02:33:03,600
any storage, etc. Now, if we
call a view function, or a pure

2704
02:33:03,600 --> 02:33:07,350
function by itself, we actually
don't need to spend any gas.

2705
02:33:07,380 --> 02:33:09,900
Since we're just reading from
the blockchain. Remember, we

2706
02:33:09,900 --> 02:33:13,800
only spend gas we only make a
transaction if we modify the

2707
02:33:13,800 --> 02:33:17,610
blockchain state. So you'll
notice in our little console

2708
02:33:17,610 --> 02:33:21,090
down here, that if I call
retrieve this call things comes

2709
02:33:21,090 --> 02:33:24,210
up. However, it looks different
than when we call the store

2710
02:33:24,210 --> 02:33:26,820
function. And we call the store
function, we get this little

2711
02:33:26,820 --> 02:33:30,750
checkmark, we get a hash, we
don't get a little checkmark.

2712
02:33:30,750 --> 02:33:33,960
And we don't get a hash with the
calls. That's because clicking

2713
02:33:33,960 --> 02:33:37,140
these blue buttons doesn't make
a transaction. This is saying,

2714
02:33:37,170 --> 02:33:39,330
Hey, we're just going to read
off chain, we're just going to

2715
02:33:39,330 --> 02:33:43,350
read this value. However, if you
look in the details of this

2716
02:33:43,350 --> 02:33:46,830
call, there's this execution
cost bit here. So what's going

2717
02:33:46,830 --> 02:33:50,550
on? Well, we can read this part
right here, cost only applies

2718
02:33:50,550 --> 02:33:54,720
when called by contract. If we
do have a function that calls

2719
02:33:54,720 --> 02:33:58,290
retrieve, if there's a function
that is updating state that

2720
02:33:58,290 --> 02:34:01,770
calls a view or a pure function,
that's the only time it'll cost

2721
02:34:01,800 --> 02:34:05,190
gas. So for example, if our
store function which is not a

2722
02:34:05,190 --> 02:34:08,730
view function, were to call
retrieve at some point, then

2723
02:34:08,760 --> 02:34:12,600
we'd have to pay the cost of the
Retrieve because reading from

2724
02:34:12,600 --> 02:34:16,290
the blockchain cost this
computation and cost gas calling

2725
02:34:16,290 --> 02:34:20,760
view functions is free, unless
you're calling it inside of a

2726
02:34:20,760 --> 02:34:24,420
function that costs gas, in
which case it will cost gas. So

2727
02:34:24,420 --> 02:34:31,140
if we leave it here, we delete
this recompile redeploy. We had

2728
02:34:31,140 --> 02:34:34,770
favorite number retrieved, they
both still cost nothing. But if

2729
02:34:34,770 --> 02:34:40,020
we add, restore eight in here,
we can see, we can see our

2730
02:34:40,020 --> 02:34:43,230
execution cost has gone up from
what it was without retrieve,

2731
02:34:43,320 --> 02:34:45,840
which we can go ahead, we can
compile, I hit command us to

2732
02:34:45,840 --> 02:34:49,950
compile here, we can deploy.
Let's go ahead and store again.

2733
02:34:50,760 --> 02:34:53,730
We'll click on that transaction,
we can see that it's much

2734
02:34:53,730 --> 02:34:56,430
cheaper without that retrieve
function in there. And again,

2735
02:34:56,460 --> 02:34:59,640
our favorite number variable as
long as it has this public

2736
02:34:59,640 --> 02:35:04,050
visible solidity, it also is
counted as a view function that

2737
02:35:04,050 --> 02:35:08,760
returns a un 256. The returns
keyword means what is this

2738
02:35:08,760 --> 02:35:11,940
function going to give us after
we call it so we say this

2739
02:35:11,940 --> 02:35:15,030
function is going to give us
this function is going to return

2740
02:35:15,330 --> 02:35:20,640
a un 256. When we call retrieve,
it's going to return or give us

2741
02:35:20,700 --> 02:35:25,080
a utility six. This is the
result of calling the function

2742
02:35:25,110 --> 02:35:28,410
this six is the result of
calling arbitrary function.

2743
02:35:31,200 --> 02:35:32,130
Now our contract is

2744
02:35:32,130 --> 02:35:35,280
good as it is, it allows us to
store a single favorite number.

2745
02:35:35,310 --> 02:35:38,130
But what if we want to store a
range of favorite numbers? Or

2746
02:35:38,130 --> 02:35:42,060
maybe we want to store a whole
bunch of different people who

2747
02:35:42,060 --> 02:35:44,400
have different favorite numbers?
Well, how do we do that there

2748
02:35:44,400 --> 02:35:46,650
are several different ways that
we can approach this, one of the

2749
02:35:46,650 --> 02:35:48,930
ways we could start approaching
this is by creating what's

2750
02:35:48,930 --> 02:35:53,640
called a struct of people. Or we
create a new type. In our

2751
02:35:53,640 --> 02:35:57,600
solidity, we can create a people
object that holds both someone's

2752
02:35:57,600 --> 02:36:02,040
name, and their favorite number.
To do that, we say struct

2753
02:36:02,910 --> 02:36:11,850
people, you went to 56, favorite
number, and a string name. Now

2754
02:36:11,880 --> 02:36:15,450
we've created a new type called
people kinda like you intuited

2755
02:36:15,450 --> 02:36:19,470
six, or Boolean, or string. Now
we have a people type that we

2756
02:36:19,470 --> 02:36:23,730
can use. Now similar to how we
created a un 256 public favorite

2757
02:36:23,730 --> 02:36:28,290
number, we can do the exact same
thing. But with a people, we

2758
02:36:28,290 --> 02:36:33,510
could say people public, we call
this person, and we can create a

2759
02:36:33,510 --> 02:36:37,260
new people and assign it to this
variable person. So we'll say

2760
02:36:37,260 --> 02:36:42,390
equals people public person,
equals, and we'll add

2761
02:36:42,420 --> 02:36:46,170
parentheses here to signify
we're creating a new person. And

2762
02:36:46,170 --> 02:36:49,350
since we made this a struct, we
add little curly brackets here

2763
02:36:49,440 --> 02:36:52,380
to let solidity know that we're
going to be grabbing from these

2764
02:36:52,380 --> 02:36:57,540
struct variables, we'll say
favorite number is going to be

2765
02:36:57,540 --> 02:37:04,560
two, and the name is going to be
Patrick semicolon, and then we

2766
02:37:04,560 --> 02:37:07,950
can hit Ctrl S, or we can go
ahead and compile. Now if we go

2767
02:37:07,950 --> 02:37:15,390
ahead and deploy this we now
have a new person, since this,

2768
02:37:15,420 --> 02:37:19,230
again, is a public variable, it
has a getter function called

2769
02:37:19,230 --> 02:37:23,880
person. And if we click person,
we see our new object, the

2770
02:37:23,880 --> 02:37:27,600
favorite number is two. And then
the name is Patrick, you see

2771
02:37:27,600 --> 02:37:31,950
this zero and this one, because
these are showing the index of

2772
02:37:31,950 --> 02:37:33,900
the different variables. But
those of you new to computer

2773
02:37:33,900 --> 02:37:36,390
science, typically in computer
science, let's start with the

2774
02:37:36,390 --> 02:37:39,810
number zero. So what are zero
with index, we have you in 256,

2775
02:37:39,840 --> 02:37:43,470
called favorite number, which is
saved at two. And then at index

2776
02:37:43,470 --> 02:37:47,160
one, we have a string, which
stands for the name of Patrick,

2777
02:37:47,190 --> 02:37:50,310
whenever you have a list of
variables inside of an object in

2778
02:37:50,310 --> 02:37:54,240
solidity, they get automatically
indexed. So favorite number gets

2779
02:37:54,270 --> 02:37:58,680
indexed to zero, and name gets
indexed to one. Interestingly

2780
02:37:58,710 --> 02:38:01,770
enough, if you have a whole
bunch of variables inside your

2781
02:38:01,770 --> 02:38:05,460
contract, like we have public
favorite number, this favorite

2782
02:38:05,460 --> 02:38:09,090
number, actually, technically is
getting indexed at the zero with

2783
02:38:09,120 --> 02:38:12,360
storage slot. And if we were to
make another one of these, maybe

2784
02:38:12,360 --> 02:38:16,230
you want to get six public
brother's favorite number, this

2785
02:38:16,230 --> 02:38:19,410
would technically be indexed at
the first slot. And then if we

2786
02:38:19,410 --> 02:38:23,070
were to make one more, maybe
sister's favorite number, this

2787
02:38:23,070 --> 02:38:25,920
would be the next add the second
slot. So favorite number at

2788
02:38:25,920 --> 02:38:29,430
zero, this add one, and this a
two, but we'll learn more about

2789
02:38:29,430 --> 02:38:33,300
that much later in the course.
Similarly, favorite number is

2790
02:38:33,300 --> 02:38:37,320
index zero name is index at one.
Now what we have is great, but

2791
02:38:37,320 --> 02:38:39,900
if we want a whole lot of people
are we gonna have to keep copy

2792
02:38:39,900 --> 02:38:43,560
pasting and changing the
people's name person to their

2793
02:38:43,560 --> 02:38:47,760
favorite one, number one, number
three, will name them ally.

2794
02:38:48,780 --> 02:38:53,370
Person three, their favorite
number will be seven. Their name

2795
02:38:53,370 --> 02:38:58,110
will be Chad or something. This
obviously isn't great way to

2796
02:38:58,110 --> 02:39:00,750
create lists and large number of
people's because we have to

2797
02:39:00,750 --> 02:39:04,440
statically keep typing them in.
So a much better way to create a

2798
02:39:04,440 --> 02:39:08,160
list. And let's actually just go
ahead and delete Patrick to a

2799
02:39:08,160 --> 02:39:11,580
much better way to create a list
is to use a data structure

2800
02:39:11,580 --> 02:39:15,720
called an array. An array is a
way to store a list, or a

2801
02:39:15,720 --> 02:39:19,470
sequence of objects, creating an
array works the exact same we've

2802
02:39:19,470 --> 02:39:22,260
seen to initialize other
different types. Typically, we

2803
02:39:22,260 --> 02:39:26,670
do the type of the object, the
visibility of the object, and

2804
02:39:26,670 --> 02:39:29,040
then the variable name. We do
the exact same thing with

2805
02:39:29,040 --> 02:39:33,030
arrays. We'll say we want a
people array. These little

2806
02:39:33,030 --> 02:39:37,350
brackets represent that we want
an array of people. We'll give

2807
02:39:37,350 --> 02:39:42,510
it a visibility of public and
we'll call it people you could

2808
02:39:42,510 --> 02:39:45,690
do the same thing with you and
256 for example, you could say

2809
02:39:45,690 --> 02:39:48,270
you went to 56

2810
02:39:49,290 --> 02:39:54,000
public favorite numbers list

2811
02:39:54,120 --> 02:39:57,480
and just add this little array
key here. And now favorite

2812
02:39:57,480 --> 02:40:00,630
numbers list is going to be an
array or a list We're going to

2813
02:40:00,630 --> 02:40:03,240
comment that out for now. Now if
I were to go ahead and deploy

2814
02:40:03,240 --> 02:40:06,060
this contract, let's go ahead
delete the last one, let's

2815
02:40:06,060 --> 02:40:11,310
redeploy. We now have this blue
people button here. Remember,

2816
02:40:11,340 --> 02:40:14,820
since it's public, and it's a
variable, it automatically is

2817
02:40:14,820 --> 02:40:18,270
given a view function, it's
given one of these blue buttons.

2818
02:40:18,300 --> 02:40:22,080
And instead of just having a
single button where the value

2819
02:40:22,080 --> 02:40:25,920
shows up, it's giving us a form
to fill out, it wants to take a

2820
02:40:25,920 --> 02:40:30,390
un 256 as an input parameter. So
if I put zero, I get nothing

2821
02:40:30,390 --> 02:40:33,660
back, if I put one, I get
nothing back. No matter what you

2822
02:40:33,660 --> 02:40:36,120
put in this box, right? Now
we're gonna get nothing back.

2823
02:40:36,150 --> 02:40:40,470
This is because our people array
or our people list is currently

2824
02:40:40,470 --> 02:40:43,560
empty. And the value that it
wants is going to be the index

2825
02:40:43,590 --> 02:40:47,430
of the object that you want. So
for example, if at index zero, I

2826
02:40:47,430 --> 02:40:50,370
had Patrick, it would show
Patrick for zero, if it didn't x

2827
02:40:50,370 --> 02:40:54,600
one I had John, or actually
better yet, to Patrick.

2828
02:40:57,000 --> 02:40:58,230
Seven, John,

2829
02:40:59,400 --> 02:41:03,150
etc. This is what it would show.
But since it's empty, it's going

2830
02:41:03,150 --> 02:41:06,060
to show nothing. And let's go
ahead and remove the public

2831
02:41:06,060 --> 02:41:09,180
variable from favorite numbers
so that we don't get the

2832
02:41:09,180 --> 02:41:12,090
duplicate functions at the
moment, we'll just get the

2833
02:41:12,090 --> 02:41:14,880
Retrieve function, we'll show
you how to add to this array in

2834
02:41:14,880 --> 02:41:17,910
just a second. This type of
array is what's known as a

2835
02:41:17,940 --> 02:41:22,650
dynamic array, because the size
of the array isn't given at the

2836
02:41:22,650 --> 02:41:26,340
array initialization. If we were
to say, a people array and add a

2837
02:41:26,340 --> 02:41:29,670
three in these brackets here,
that means that this list, or

2838
02:41:29,670 --> 02:41:34,020
this array of people could only
be three people big, if we don't

2839
02:41:34,020 --> 02:41:37,260
give it a size, it means it can
be any size and the size of the

2840
02:41:37,260 --> 02:41:40,530
array can grow and shrink as we
add and subtract people, if I

2841
02:41:40,530 --> 02:41:44,340
add three, it can only have a
maximum of three in the array

2842
02:41:44,370 --> 02:41:47,130
ever, we're going to work with a
dynamic array, because we're

2843
02:41:47,130 --> 02:41:50,460
going to want to add a arbitrary
number of people to this array.

2844
02:41:50,490 --> 02:41:53,130
So let's go ahead and create a
function that's going to add

2845
02:41:53,130 --> 02:41:58,080
people who are people array, so
we're gonna say function, add

2846
02:41:58,080 --> 02:42:04,860
person. And we're going to take
string, memory, name as input

2847
02:42:04,860 --> 02:42:08,400
parameter, and I'll explain that
in a minute. And a un 256

2848
02:42:08,520 --> 02:42:13,110
underscore favorite number,
we're going to make this a

2849
02:42:13,110 --> 02:42:17,130
public function, or we're going
to do is we're going to call a

2850
02:42:17,130 --> 02:42:21,330
push function that's available
on our people object. So we're

2851
02:42:21,330 --> 02:42:25,110
gonna say people dot push, and
we're going to create a new

2852
02:42:25,110 --> 02:42:28,470
person, a new people object,
which is going to take in the

2853
02:42:28,470 --> 02:42:29,400
favorite number.

2854
02:42:31,680 --> 02:42:32,400
And the name.

2855
02:42:34,050 --> 02:42:36,840
Now, this might be a little bit
tricky to you. So let's break

2856
02:42:36,840 --> 02:42:40,170
this down. People here is
capitalized. So we know that

2857
02:42:40,170 --> 02:42:43,740
since capitalize, it's referring
to this struct people and not

2858
02:42:43,740 --> 02:42:46,740
our variable people, the
lowercase people here is

2859
02:42:46,740 --> 02:42:51,180
referring to this lowercase
array. So we're saying our array

2860
02:42:51,240 --> 02:42:55,110
dot push, or push is the
equivalent of adding basically,

2861
02:42:55,620 --> 02:42:59,670
a new people that grabs favorite
number and name. Another way

2862
02:42:59,670 --> 02:43:03,660
that we could actually do this
is we could create a variable of

2863
02:43:03,660 --> 02:43:07,800
type people and then add it like
so. So we could say people, new

2864
02:43:07,800 --> 02:43:12,570
person equals people. And then
we put those brackets the same

2865
02:43:12,570 --> 02:43:17,670
way we did before. You say
favorite number is going to be

2866
02:43:18,000 --> 02:43:21,930
this input value, this
parameter, and we could say name

2867
02:43:22,260 --> 02:43:26,280
is going to be this parameter.
Now if you hit save, you'll get

2868
02:43:26,280 --> 02:43:29,760
this error set here, saying data
location must be stored in

2869
02:43:29,790 --> 02:43:32,850
memory, or called data for
variable but no one's given. For

2870
02:43:32,850 --> 02:43:35,160
now, we're just going to add the
memory keyword here, and I'll

2871
02:43:35,160 --> 02:43:37,710
explain what it does in a little
bit. And then of course, we need

2872
02:43:37,710 --> 02:43:40,950
to add the new person into our
people dot push right here. So

2873
02:43:40,950 --> 02:43:44,580
this is how we're actually going
to push people into our people

2874
02:43:44,580 --> 02:43:47,790
array. And I'll get to this
memory keyword in a bit. Now if

2875
02:43:47,790 --> 02:43:52,320
we go back to our deploy tab, we
delete our last contract. Let's

2876
02:43:52,320 --> 02:43:56,070
deploy this new one. Right now,
if we try to look at the zero

2877
02:43:56,070 --> 02:43:59,370
with person in our people array,
we get nothing but let's go

2878
02:43:59,370 --> 02:44:03,090
ahead and add a person, we'll
call it, Patrick will be the

2879
02:44:03,090 --> 02:44:07,290
name, and seven will be the
favorite number. So we added

2880
02:44:07,290 --> 02:44:11,430
Patrick, we added seven. Now if
we look at people's zero, we

2881
02:44:11,430 --> 02:44:14,670
should see the zeroeth person
has a name of Patrick, and a

2882
02:44:14,670 --> 02:44:18,420
favorite number of seven, boom.
And that's exactly what we do

2883
02:44:18,420 --> 02:44:21,570
see, we see a favorite number of
seven, and we see a string name

2884
02:44:21,630 --> 02:44:26,400
Patrick, we tried to add John
and do his 16. We hit Add

2885
02:44:26,400 --> 02:44:29,790
Person, we can see our
transaction go through. And now

2886
02:44:29,790 --> 02:44:33,480
if we go to people at zero, it's
still Patrick with a favorite

2887
02:44:33,480 --> 02:44:37,350
number of seven. But if we look
at the people at index one, it's

2888
02:44:37,350 --> 02:44:40,860
going to be John with a favorite
number of 16. And if we look at

2889
02:44:40,860 --> 02:44:44,550
two, this, of course, should be
blank. And we do indeed see

2890
02:44:44,580 --> 02:44:47,460
nothing actually happens here.
Perfect. Now there's actually a

2891
02:44:47,460 --> 02:44:50,580
couple of different ways to
create this new person here,

2892
02:44:50,790 --> 02:44:54,180
like we showed before, we can
use this bracket notation, or

2893
02:44:54,540 --> 02:44:57,540
what we can do is we can
actually just add the parameters

2894
02:44:57,570 --> 02:45:01,500
in the order that they show. So
the first parameter for people

2895
02:45:01,500 --> 02:45:04,560
is going to be favorite number.
So we can just do favorite

2896
02:45:04,560 --> 02:45:08,490
number, comma, and the second
one is going to be name, the

2897
02:45:08,490 --> 02:45:12,330
second one is going to be name.
So if we save this, this, this

2898
02:45:12,330 --> 02:45:15,420
line we just created is the
exact same as the last line,

2899
02:45:15,720 --> 02:45:18,270
we're being a little bit less
explicit here. So the other way

2900
02:45:18,270 --> 02:45:21,270
is generally a little bit better
because it's more explicit as to

2901
02:45:21,270 --> 02:45:24,720
what variables are what or we
don't even need to save to this

2902
02:45:24,720 --> 02:45:27,780
variable here, we could take out
this whole line, replace new

2903
02:45:27,780 --> 02:45:32,130
person with exactly what we just
saw, like so now we don't even

2904
02:45:32,130 --> 02:45:37,110
need the memory keyword. Now,
you've probably seen this by

2905
02:45:37,110 --> 02:45:40,680
now. But if I go ahead and
compile, and I see a little,

2906
02:45:40,920 --> 02:45:44,220
little red one here, I roll
over. And it says something

2907
02:45:44,220 --> 02:45:48,690
about error, expected semicolon,
but got bracket, all these

2908
02:45:48,690 --> 02:45:52,110
errors mean that your code isn't
compiling. It's not working as

2909
02:45:52,110 --> 02:45:55,980
expected. So now I can go over
here and do a little semicolon

2910
02:45:56,640 --> 02:45:59,880
recompile, and I get a green.
Now if I delete this top line,

2911
02:45:59,880 --> 02:46:03,930
for example, and I compile it,
actually get a yellow thing.

2912
02:46:04,350 --> 02:46:08,070
Yellow stands for warnings, the
warning that I get is warning

2913
02:46:08,160 --> 02:46:12,150
SPX license identifier, not
provided, you should add it. So

2914
02:46:12,150 --> 02:46:15,090
let's go ahead and add that
back. recompile. And the warning

2915
02:46:15,090 --> 02:46:18,060
goes away. Warnings Don't stop
your code from compiling. So if

2916
02:46:18,060 --> 02:46:20,940
you get warnings, it's okay. But
it's usually a good idea to

2917
02:46:20,940 --> 02:46:23,610
listen to the warnings, because
often they'll give really

2918
02:46:23,670 --> 02:46:26,790
insightful information about how
to improve your smart contracts.

2919
02:46:26,820 --> 02:46:30,120
So to summarize, if it's red,
it's broken. If it's yellow, you

2920
02:46:30,120 --> 02:46:32,040
might want to check it out. But
it won't stop you from

2921
02:46:32,040 --> 02:46:39,210
continuing to code. So one thing

2922
02:46:39,210 --> 02:46:42,420
that you'll notice here is that
we have this memory keyword. And

2923
02:46:42,420 --> 02:46:44,580
you'll notice if you try to
delete it from our function

2924
02:46:44,580 --> 02:46:47,730
here, you try to compile, you
actually run into an error data

2925
02:46:47,730 --> 02:46:51,390
location must be memory or call
data for parameter and function.

2926
02:46:51,480 --> 02:46:54,720
Now there are actually six
places you can store data in

2927
02:46:54,720 --> 02:46:59,970
solidity you have the stack,
memory, storage, call data, code

2928
02:47:00,000 --> 02:47:03,750
and logs. We're not going to go
over these right now. But we are

2929
02:47:03,750 --> 02:47:06,420
going to focus on three of the
big ones, or three of the

2930
02:47:06,420 --> 02:47:10,200
important ones for this section,
which are called data, memory,

2931
02:47:10,290 --> 02:47:12,300
and storage. So for this
section, we're going to talk

2932
02:47:12,300 --> 02:47:15,390
about call data memory and
storage. And this is a little

2933
02:47:15,390 --> 02:47:18,300
bit advanced. So if you don't
totally grasp it the first time,

2934
02:47:18,330 --> 02:47:21,450
that's totally okay. Please
continue. Even if it's not

2935
02:47:21,450 --> 02:47:24,540
crystal clear what's going on
here, call data and memory mean

2936
02:47:24,540 --> 02:47:29,190
that the variable is only going
to exist temporarily. So this

2937
02:47:29,190 --> 02:47:32,670
name variable only exists
temporarily during the

2938
02:47:32,670 --> 02:47:36,210
transaction that this Add Person
function is called storage

2939
02:47:36,210 --> 02:47:41,130
variables exist, even outside of
just the function executing.

2940
02:47:41,310 --> 02:47:45,060
Even though we didn't specify it
up above, our favorite number is

2941
02:47:45,090 --> 02:47:48,870
automatically cast to be a
storage variable. Since it's not

2942
02:47:48,870 --> 02:47:52,110
explicitly defined in one of
these functions. Since we don't

2943
02:47:52,110 --> 02:47:55,920
need this name variable anymore
after this function runs, we can

2944
02:47:55,920 --> 02:48:00,030
keep it as memory, or we could
keep it as called data, you can

2945
02:48:00,030 --> 02:48:03,030
have a parameter as called data
if you don't end up modifying

2946
02:48:03,060 --> 02:48:07,080
the name. For example, we
couldn't reassign name to equal

2947
02:48:07,140 --> 02:48:11,100
cat here, if we compile we run
into an error. Type literal

2948
02:48:11,100 --> 02:48:14,430
string cat is not implicitly
convertible to expect the type

2949
02:48:14,460 --> 02:48:18,690
string called data. However, if
we have this as memory, and we

2950
02:48:18,690 --> 02:48:22,500
compile and save it, that error
goes away call data is temporary

2951
02:48:22,500 --> 02:48:25,500
variables that can't be
modified. Memory is temporary

2952
02:48:25,500 --> 02:48:29,010
variables that can be modified.
And storage is permanent

2953
02:48:29,010 --> 02:48:32,370
variables that can be modified.
Now even though I just said

2954
02:48:32,370 --> 02:48:35,190
there's actually six places
where we can access and store

2955
02:48:35,190 --> 02:48:40,110
information, we cannot say a
variable is stack code or logs,

2956
02:48:40,290 --> 02:48:43,950
we can only say memory storage
are called data, you will learn

2957
02:48:43,950 --> 02:48:46,710
why in a much later section.
Now, this is a bit of an

2958
02:48:46,710 --> 02:48:49,650
oversimplification of this. But
that's essentially what's going

2959
02:48:49,650 --> 02:48:53,970
on. The next question you might
have is, well, why do I need to

2960
02:48:53,970 --> 02:48:58,230
say memory here, but I don't
need to say memory here. Well,

2961
02:48:58,230 --> 02:49:01,620
let's go ahead and put memory
here and hit CTRL S or compile.

2962
02:49:02,130 --> 02:49:05,280
And let's see what happens we
get from solidity data location

2963
02:49:05,280 --> 02:49:08,760
can only be specified for an
array, struct or mapping types.

2964
02:49:08,880 --> 02:49:12,330
A memory was given arrays
structs and mappings are

2965
02:49:12,330 --> 02:49:15,900
considered special types and
solidity. solidity automatically

2966
02:49:15,900 --> 02:49:19,650
knows where are you in 256 is
going to be slowly knows that

2967
02:49:19,650 --> 02:49:24,000
for this function, a un 256 is
going to live just in memory.

2968
02:49:24,150 --> 02:49:27,480
However, it's not sure what a
string is going to be. Strings

2969
02:49:27,510 --> 02:49:30,240
are actually kind of
complicated. Behind the scenes,

2970
02:49:30,270 --> 02:49:34,410
a string is actually an array of
bytes. And since a string is an

2971
02:49:34,410 --> 02:49:38,070
array, we need to add this
memory bit to it because we need

2972
02:49:38,070 --> 02:49:41,910
to tell solidity, the data
location of arrays structs, or

2973
02:49:41,910 --> 02:49:45,480
mappings and a string is
secretly an array. So that's why

2974
02:49:45,480 --> 02:49:48,060
we need to tell it it's in
memory. You'll notice we can't

2975
02:49:48,060 --> 02:49:50,910
add the storage keyword here
slowly also knows that since

2976
02:49:50,910 --> 02:49:53,850
this is a function, this name
variable isn't actually getting

2977
02:49:53,850 --> 02:49:56,730
stored anywhere. So it says Hey,
you can't have that you need to

2978
02:49:56,730 --> 02:49:59,340
have it beat memory or called
data and those are the only two

2979
02:49:59,340 --> 02:50:02,130
that it accepts So this is what
we want our function to look

2980
02:50:02,130 --> 02:50:05,190
like here. So the summary of
this is struct mappings and

2981
02:50:05,190 --> 02:50:09,300
arrays need to be given this
memory or called Data keyword

2982
02:50:09,360 --> 02:50:12,090
when adding them as a parameter
to different functions. We'll

2983
02:50:12,090 --> 02:50:15,480
learn more about storage memory
and call data in later

2984
02:50:15,480 --> 02:50:19,560
sessions. Now, this list

2985
02:50:19,590 --> 02:50:22,620
is great, but what if we know
someone's name, but we don't

2986
02:50:22,620 --> 02:50:25,380
know their favorite number?
Well, what we could do is we

2987
02:50:25,380 --> 02:50:28,320
could look through the whole
array looking for that person.

2988
02:50:28,650 --> 02:50:32,250
For example, in our contract, we
can say, Okay, I'm looking for

2989
02:50:32,250 --> 02:50:36,450
John. Okay, let's start with
zero. No, okay, that's Patrick.

2990
02:50:36,720 --> 02:50:39,720
Okay, let's go to one. Okay.
That's John. Oh, great. His

2991
02:50:39,720 --> 02:50:42,240
favorite number 16? Well, this
was really easy, because we only

2992
02:50:42,240 --> 02:50:45,390
had two people. But what if we
had hundreds of people in this

2993
02:50:45,390 --> 02:50:48,930
array? Well, we'd keep have to
iterating all the way up to the

2994
02:50:48,930 --> 02:50:51,720
index that that person was in,
it's obviously really

2995
02:50:51,720 --> 02:50:54,930
inefficient. What's another way
to store this information so

2996
02:50:54,930 --> 02:50:57,840
that it's much easier and
quicker to access? Well, another

2997
02:50:57,840 --> 02:51:00,810
data structure that we can use
is something called a mapping,

2998
02:51:00,990 --> 02:51:04,260
you can think of a mapping as
sort of like a dictionary, it's

2999
02:51:04,260 --> 02:51:08,070
a set of keys, which each key
returning a certain value

3000
02:51:08,070 --> 02:51:10,680
associated with that key. And we
create a mapping variable the

3001
02:51:10,680 --> 02:51:14,520
exact same way we create all of
our other variables. This is

3002
02:51:14,520 --> 02:51:17,910
going to be a type mapping of
string

3003
02:51:19,170 --> 02:51:22,650
to you and tivity sex,

3004
02:51:22,920 --> 02:51:25,830
this is going to be our type of
visibility keyword is going to

3005
02:51:25,830 --> 02:51:32,250
be public. And we'll call it
name to favorite number. Now we

3006
02:51:32,250 --> 02:51:36,360
have a dictionary where every
single name is going to map to a

3007
02:51:36,360 --> 02:51:39,750
specific number. So let's add
some capability to our Add

3008
02:51:39,750 --> 02:51:43,980
Person function. So we are going
to add our people to our array.

3009
02:51:44,100 --> 02:51:48,120
But let's also add them to our
mapping here, what we'll do is

3010
02:51:48,120 --> 02:51:53,340
we'll say name to favorite
number. App key name is going to

3011
02:51:53,340 --> 02:51:54,510
equal to

3012
02:51:57,180 --> 02:52:00,900
favorite number. So let's go
ahead, compile this.

3013
02:52:03,600 --> 02:52:08,970
We'll go to our deploy screen,
we'll deploy this click, we have

3014
02:52:08,970 --> 02:52:12,540
a new button named a favorite
number. If I type in Patrick,

3015
02:52:13,050 --> 02:52:17,160
nothing shows up. By typing
Patrick, you'll see I get zero

3016
02:52:17,160 --> 02:52:21,270
response. By typing John, I also
get a zero response. If I type

3017
02:52:21,270 --> 02:52:25,380
in Becca, I also get a with zero
response. When you create a

3018
02:52:25,380 --> 02:52:29,070
mapping, you initialize
everything to its null value,

3019
02:52:29,190 --> 02:52:32,430
every single possible string on
the planet right now is

3020
02:52:32,430 --> 02:52:35,700
initialized to having a favorite
number of zero. So if we want to

3021
02:52:35,700 --> 02:52:38,910
change that, we'll have to go in
and manually add that. So let's

3022
02:52:38,910 --> 02:52:43,590
go ahead and add a person to our
mapping here. So we'll add

3023
02:52:43,590 --> 02:52:47,520
Patrick. And we'll say my
favorite number is seven. And

3024
02:52:47,580 --> 02:52:51,720
looks like that transaction did
go through also add, Becca, and

3025
02:52:51,720 --> 02:52:56,280
we'll say her favorite number is
13. Let John and we'll say his

3026
02:52:56,280 --> 02:53:01,920
favorite number is 16. Now, if I
look up, Patrick, I'll

3027
02:53:01,950 --> 02:53:04,710
immediately get back what
Patrick's favorite number is, I

3028
02:53:04,710 --> 02:53:08,550
get seven back. If we look up,
John, we immediately get back

3029
02:53:08,580 --> 02:53:12,510
16. Back up, we may only get
back 13. And we also can see

3030
02:53:12,510 --> 02:53:16,650
them in our array. Because we
kept in this people that push

3031
02:53:16,650 --> 02:53:22,080
bit zero, we see Patrick's
there. At one, we see Becca. And

3032
02:53:22,080 --> 02:53:26,100
at two, we see John, in our
mapping, we're saying the string

3033
02:53:26,130 --> 02:53:31,350
name is being mapped to the UN
256 favorite number. And a lot

3034
02:53:31,350 --> 02:53:33,960
of my variables, I like to make
them explicitly named like that.

3035
02:53:34,110 --> 02:53:35,760
So this is name to

3036
02:53:35,790 --> 02:53:39,810
favorite number. So

3037
02:53:39,840 --> 02:53:43,410
now we're in a space where let's
say that we really like our

3038
02:53:43,410 --> 02:53:46,920
simple storage contract. Right
now we have a favorite number, a

3039
02:53:46,950 --> 02:53:51,330
global variable that we can save
a favorite number to with our

3040
02:53:51,360 --> 02:53:56,190
store function, we have a
mapping of name to favorite

3041
02:53:56,190 --> 02:54:00,210
numbers, and we have an array of
a new type that we created

3042
02:54:00,240 --> 02:54:04,440
called people, we can add to
both the array and to the

3043
02:54:04,440 --> 02:54:08,370
mapping. Using this Add Person
function that we've created,

3044
02:54:08,850 --> 02:54:11,730
we're able to save multiple
people's favorite numbers as

3045
02:54:11,730 --> 02:54:14,880
well as kind of a global
favorite number as well. Let's

3046
02:54:14,880 --> 02:54:17,610
say we really love this
contract, and we're ready to

3047
02:54:17,610 --> 02:54:20,850
send it to a test net to have
other people interact with it.

3048
02:54:20,970 --> 02:54:23,400
Now in future sections, you'll
hear me say that you shouldn't

3049
02:54:23,400 --> 02:54:26,670
do this until you write tests
until you do some really simple

3050
02:54:26,670 --> 02:54:29,730
auditing. But for now, let's go
ahead and learn how to actually

3051
02:54:29,730 --> 02:54:34,230
deploy this to a test net or to
a real network. Now remember,

3052
02:54:34,260 --> 02:54:36,990
test nets are run out of the
goodness of people's hearts. So

3053
02:54:36,990 --> 02:54:39,810
if it's a little bit funky, or
maybe doesn't work exactly as we

3054
02:54:39,810 --> 02:54:43,020
show here, that's okay. As long
as it works with the JavaScript

3055
02:54:43,020 --> 02:54:46,680
VM, you'll be all set but it is
good practice to learn how to

3056
02:54:46,680 --> 02:54:50,460
deploy these to a real test net.
Let's go ahead and do that. Our

3057
02:54:50,460 --> 02:54:53,970
contract is here. Simple Storage
dot soul. It's compiled,

3058
02:54:54,180 --> 02:54:57,630
compiling is passing we get this
little green checkmark here we

3059
02:54:57,630 --> 02:55:00,600
go to the deploy section. Let's
go ahead and do Get this. And

3060
02:55:00,600 --> 02:55:03,480
now we're going to change the
environment. So we were working

3061
02:55:03,480 --> 02:55:07,020
with a JavaScript VM or kind of
this fake simulated environment,

3062
02:55:07,320 --> 02:55:11,850
we want to now move to either
injected web three, or web three

3063
02:55:11,850 --> 02:55:14,670
provider. If you hover over
injected web three, there's this

3064
02:55:14,670 --> 02:55:18,360
really, really small text here.
But this basically means we're

3065
02:55:18,360 --> 02:55:22,800
going to inject our meta mask or
our web three wallet into our

3066
02:55:22,800 --> 02:55:25,890
browser to use similar to what
we did with the faucet, we'll

3067
02:55:25,890 --> 02:55:29,010
pick our account we want to use.
So I'm gonna go ahead and pick

3068
02:55:29,040 --> 02:55:34,170
account one. And now we actually
see our account in the Account

3069
02:55:34,170 --> 02:55:38,700
section of remix, injected web
three means we're using our meta

3070
02:55:38,700 --> 02:55:42,360
mask or whatever web three
wallet, web three provider is,

3071
02:55:42,360 --> 02:55:45,690
when we a little bit more
manually choose an endpoint. And

3072
02:55:45,810 --> 02:55:48,420
we're not going to go over this
right now. But as we get later

3073
02:55:48,420 --> 02:55:50,940
into the course, you'll
understand what this means. So

3074
02:55:50,940 --> 02:55:53,730
we're picking injected web
three, whatever network are

3075
02:55:53,730 --> 02:55:57,150
injected web three, or in this
case, our wallet is connected to

3076
02:55:57,390 --> 02:56:00,240
is going to be the network that
we deploy to. So for this

3077
02:56:00,240 --> 02:56:03,120
section, we're going to be
deploying to Rinkeby. But again,

3078
02:56:03,120 --> 02:56:05,670
depending on whatever the
recommended test net and the

3079
02:56:05,670 --> 02:56:09,300
recommended faucet is, that will
dictate which test net you

3080
02:56:09,300 --> 02:56:12,990
should actually deploy to. For
us, it's going to be Rigby. To

3081
02:56:12,990 --> 02:56:15,720
deploy to a test that remember,
we're going to need gas, so

3082
02:56:15,720 --> 02:56:18,330
we're going to need some tested
Etherium. Or if you're deploying

3083
02:56:18,330 --> 02:56:21,300
to a main net main Aetherium,
which you shouldn't be come to

3084
02:56:21,300 --> 02:56:23,160
the top of the GitHub repo to
make sure you have the most

3085
02:56:23,190 --> 02:56:26,820
updated faucet, the other place
you can go is link token

3086
02:56:27,240 --> 02:56:31,380
contracts page in the chain link
documentation and scroll down

3087
02:56:31,950 --> 02:56:34,740
the ranking. And you can see
test that link available here,

3088
02:56:35,040 --> 02:56:38,400
test that eath available here.
So this is the other location,

3089
02:56:38,400 --> 02:56:41,670
you can always look to find the
most up to date faucets, and

3090
02:56:41,670 --> 02:56:45,120
both of them point right back
here. So now that we're working

3091
02:56:45,120 --> 02:56:47,670
with injected web three, we can
just go through the exact same

3092
02:56:47,670 --> 02:56:53,160
steps to deploy to a test net as
to deploy to a virtual machine.

3093
02:56:53,280 --> 02:56:56,220
And remember, if you run out of
gas to deploy this, be sure to

3094
02:56:56,220 --> 02:56:58,800
check back to the faucets to
actually deploy this. So we're

3095
02:56:58,800 --> 02:57:00,720
going to do the same thing,
we're gonna go ahead and hit

3096
02:57:00,720 --> 02:57:05,820
Deploy. But this time Metamask
is going to pop up and ask us if

3097
02:57:05,820 --> 02:57:09,840
we want to actually deploy this,
this is the exact same as what

3098
02:57:09,840 --> 02:57:13,020
we saw with the blockchain
example, where we sign

3099
02:57:13,050 --> 02:57:17,010
transactions, we are signing and
sending this transaction, the

3100
02:57:17,010 --> 02:57:21,420
data of this transaction is this
massive, massive data thing

3101
02:57:21,420 --> 02:57:24,630
here, which represents the
contract that we just created,

3102
02:57:24,930 --> 02:57:28,650
we can see all the payment
information for this transaction

3103
02:57:28,680 --> 02:57:32,610
for deploying this contract, we
see it's going to cost around

3104
02:57:32,670 --> 02:57:36,030
this much Aetherium to deploy.
But again, we're on the Rinkeby

3105
02:57:36,030 --> 02:57:38,640
test network. So this is going
to be fake Aetherium. We're

3106
02:57:38,640 --> 02:57:43,110
gonna go ahead, hit Confirm. And
if you pop up a little console,

3107
02:57:43,590 --> 02:57:48,750
and remix, you'll see that after
a slight delay, it'll actually

3108
02:57:48,750 --> 02:57:51,960
say have this green checkmark
that it's confirmed that it went

3109
02:57:51,960 --> 02:57:55,650
actually went through, we can go
ahead right click, open a new

3110
02:57:55,650 --> 02:58:00,270
tab, and view this on ether
scan. And after a slight delay,

3111
02:58:00,300 --> 02:58:03,450
we'll actually be able to see
the transaction details here,

3112
02:58:03,630 --> 02:58:06,570
exactly the same as our
transaction details for sending

3113
02:58:06,570 --> 02:58:10,350
Aetherium we have a hash, we
have a status, we have blocked

3114
02:58:10,350 --> 02:58:13,560
block confirmations, we have
timestamp from which is going to

3115
02:58:13,560 --> 02:58:16,920
be us two, which is going to be
the average of the contract that

3116
02:58:16,920 --> 02:58:20,070
we just created. We didn't send
any value with this. So this is

3117
02:58:20,070 --> 02:58:22,500
going to be zero ether. And then
of course, we see the

3118
02:58:22,500 --> 02:58:26,880
transaction fee, and as well as
the gas price. Because again,

3119
02:58:26,970 --> 02:58:29,430
deploying a contract to the
blockchain is modifying the

3120
02:58:29,430 --> 02:58:32,220
state of the blockchain. So we
have to pay gas, and we can see

3121
02:58:32,520 --> 02:58:36,330
all the different pieces here.
As we can see, gas limit and gas

3122
02:58:36,330 --> 02:58:39,690
usage is much higher than just
sending Aetherium, since we are

3123
02:58:39,690 --> 02:58:43,860
putting a lot of data on chain
and adding a lot of computation.

3124
02:58:44,070 --> 02:58:48,210
So this number is much higher
than the 21,000 number of just

3125
02:58:48,240 --> 02:58:51,450
sending Aetherium. Now, if we
come back to our remix and

3126
02:58:51,450 --> 02:58:55,200
scroll down, we're able to see
our simple storage contract at

3127
02:58:55,200 --> 02:58:59,040
this address. If we hit this
copy button, and we go to the

3128
02:58:59,040 --> 02:59:03,300
rink be ether scan, we paste it
in the search bar, we will get

3129
02:59:03,330 --> 02:59:06,510
the contract that we just
deployed. And we see this first

3130
02:59:06,510 --> 02:59:10,050
transaction is going to be the
contract creation transaction.

3131
02:59:10,170 --> 02:59:14,220
So this contract that we just
created one transaction, which

3132
02:59:14,220 --> 02:59:17,310
is contract created. So now that
we have this contract created,

3133
02:59:17,310 --> 02:59:19,950
we have all the exact same
functions that we saw when

3134
02:59:19,950 --> 02:59:22,740
working with the JavaScript
virtual machine, or the our fake

3135
02:59:22,770 --> 02:59:25,920
environment, or our super fake
environment. Now we can do all

3136
02:59:25,920 --> 02:59:28,890
the exact same things that we
did with the JavaScript VM, but

3137
02:59:28,890 --> 02:59:32,160
on a real test network. So
you'll see if I hit retrieve

3138
02:59:32,460 --> 02:59:36,240
Metamask doesn't pop up. Because
again, this is a blue view

3139
02:59:36,240 --> 02:59:39,240
function. If we look people at
zero, this is also a view

3140
02:59:39,240 --> 02:59:42,480
function and nothing pops up,
named a favorite number should

3141
02:59:42,480 --> 02:59:45,540
be blank. So if I type in
Patrick now, absolutely nothing

3142
02:59:45,540 --> 02:59:49,470
happens, right? I get I get zero
returned because mappings

3143
02:59:49,500 --> 02:59:53,910
initialize every single key with
a blank or a null value, which

3144
02:59:53,910 --> 02:59:58,920
for you 256 is zero. Now, we can
go ahead and store a favorite

3145
02:59:58,920 --> 03:00:01,890
number store When your favorite
number is going to modify the

3146
03:00:01,890 --> 03:00:06,270
blockchain, so our meta mask
should pop up for us to confirm

3147
03:00:06,330 --> 03:00:10,020
the transaction and sign that
transaction to modify the

3148
03:00:10,020 --> 03:00:13,500
blockchain state. So I'm going
to store my favorite number of

3149
03:00:13,500 --> 03:00:18,750
16, we'll hit store, meta mask
will pop up, and we're going to

3150
03:00:18,750 --> 03:00:21,960
go ahead and actually confirm
this didn't confirm is

3151
03:00:21,960 --> 03:00:24,780
equivalent to US signing this
transaction and sending it to

3152
03:00:24,780 --> 03:00:27,780
the blockchain to modify the
state. So we're gonna go ahead

3153
03:00:27,780 --> 03:00:31,560
and confirm this, we should be
able to view this on ether scan.

3154
03:00:31,920 --> 03:00:34,440
And again, it might take a
little bit for it to actually

3155
03:00:34,440 --> 03:00:37,770
index or actually start working.
So please be patient with these

3156
03:00:37,770 --> 03:00:40,110
test nets. And again, this is
why when building your

3157
03:00:40,110 --> 03:00:43,890
applications, you want the test
net piece to absolutely try to

3158
03:00:43,890 --> 03:00:47,520
be your last step, because you
have to wait a really long time.

3159
03:00:47,700 --> 03:00:50,490
And it puts a burden on these
people running these tests into

3160
03:00:50,490 --> 03:00:52,920
running it out of the goodness
of their heart. So please try to

3161
03:00:52,920 --> 03:00:56,460
make this the last step of your
actual building process. For us

3162
03:00:56,460 --> 03:01:00,150
learning right here, it's okay.
And after a slight delay, once

3163
03:01:00,150 --> 03:01:03,510
we hit refresh, it looks like
it's indexing on ether scan, the

3164
03:01:03,510 --> 03:01:05,580
ether scan website is still
figuring out where the

3165
03:01:05,580 --> 03:01:08,760
transaction is going to remix,
it looks like on the blockchain,

3166
03:01:08,790 --> 03:01:10,860
this has actually already gone
through. So now if we hit

3167
03:01:10,860 --> 03:01:14,880
retrieve, we do indeed see, our
favorite number is 16. Of

3168
03:01:14,880 --> 03:01:17,880
course, these two are still
going to be blank. And it looks

3169
03:01:17,880 --> 03:01:20,310
like that transaction has gone
through and ether scan has

3170
03:01:20,310 --> 03:01:23,580
indexed. So now let's go ahead
and add a person will add

3171
03:01:23,580 --> 03:01:27,570
Patrick, and my favorite number
is going to be 16. We'll go

3172
03:01:27,570 --> 03:01:30,780
ahead and add person. Again,
since these are orange

3173
03:01:30,960 --> 03:01:33,000
transactions gonna pop up
because we're modifying the

3174
03:01:33,000 --> 03:01:36,810
blockchain state, we'll go ahead
and hit Confirm. And we're going

3175
03:01:36,810 --> 03:01:39,270
to be a little bit patient here
and wait for this transaction to

3176
03:01:39,270 --> 03:01:43,200
go through. And we should see
this update. And this update.

3177
03:01:43,350 --> 03:01:47,190
Now if I hit named a favorite
number of Patrick, I get 16. And

3178
03:01:47,190 --> 03:01:50,700
if I hit people of zero, I get
favorite number 16. And the name

3179
03:01:50,730 --> 03:01:54,030
is Patrick. Awesome. So you've
actually successfully deployed a

3180
03:01:54,030 --> 03:01:58,170
contract to an actual test net,
and actually seen on ether scan

3181
03:01:58,170 --> 03:02:00,750
what these transactions look
like, you should be incredibly

3182
03:02:00,750 --> 03:02:03,450
proud of yourself, be sure to
give yourself a high five pat on

3183
03:02:03,450 --> 03:02:07,050
the back, send a tweet saying
exactly how excited you are. But

3184
03:02:07,050 --> 03:02:09,990
make sure to celebrate these
little wins, celebrating these

3185
03:02:09,990 --> 03:02:12,930
little wins will give you the
motivation to keep going and

3186
03:02:12,930 --> 03:02:16,560
really excite you for learning
each new thing. So huge.

3187
03:02:16,560 --> 03:02:19,290
Congratulations. If you got this
far, you've deployed your first

3188
03:02:19,290 --> 03:02:22,500
contract to a test net,
congratulations. Now if you want

3189
03:02:22,500 --> 03:02:24,780
to see what it looks like to
deploy to a different network,

3190
03:02:24,990 --> 03:02:28,650
all you need to do in your
Metamask is switch to a

3191
03:02:28,650 --> 03:02:32,160
different test net. See, if we
switch to COVID remix

3192
03:02:32,190 --> 03:02:35,460
automatically updates and says,
ah, injected web three is now

3193
03:02:35,490 --> 03:02:39,600
the COVID test network. We could
switch again maybe to Grilley,

3194
03:02:39,810 --> 03:02:42,540
we say Ah, the injected web
three is now at the Grilley.

3195
03:02:42,570 --> 03:02:45,720
This is the test net that we'd
be deploying to of course, we

3196
03:02:45,720 --> 03:02:48,840
need actual test net Aetherium
to do any deploying, so we

3197
03:02:48,840 --> 03:02:51,690
wouldn't be able to here. And if
we go ahead and hit Deploy right

3198
03:02:51,690 --> 03:02:55,740
now Metamask pops up. But we get
this little red thing saying

3199
03:02:55,800 --> 03:02:59,550
insufficient funds. Of course,
later on, we'll learn how to add

3200
03:02:59,580 --> 03:03:03,180
new networks like polygon like
avalanche like phantom into our

3201
03:03:03,180 --> 03:03:05,640
Metamask. So we can deploy from
any one of them

3202
03:03:05,640 --> 03:03:06,120
as well.

3203
03:03:08,790 --> 03:03:11,190
Now, I mentioned this term
before, but all this code that

3204
03:03:11,190 --> 03:03:14,520
we wrote, when we hit this
compile button, it compiles it

3205
03:03:14,520 --> 03:03:20,910
down to the EVM or the Ethereum
virtual machine. Don't worry too

3206
03:03:20,910 --> 03:03:24,930
much about what this means. EVM
is a standard of how to deploy

3207
03:03:24,930 --> 03:03:28,950
smart contracts to Aetherium
like blockchains. And any

3208
03:03:28,950 --> 03:03:32,550
blockchain that implements a
type of EVM. You can deploy

3209
03:03:32,580 --> 03:03:36,780
solidity code to some examples
of EVM compatible blockchains

3210
03:03:36,810 --> 03:03:41,400
are going to be avalanche,
Phantom, and polygon. Since

3211
03:03:41,400 --> 03:03:44,730
these are EVM compatible, this
means we can write our solidity

3212
03:03:44,730 --> 03:03:48,000
code, and deploy to these
blockchains, which again, I'll

3213
03:03:48,000 --> 03:03:50,490
show you later on how to add
these new networks into your

3214
03:03:50,490 --> 03:03:53,700
Metamask. And then how to deploy
them. Let's do a quick recap of

3215
03:03:53,700 --> 03:03:56,370
our first smart contract. And
then you should actually take a

3216
03:03:56,370 --> 03:04:00,060
break, maybe get some ice cream
or coffee because you absolutely

3217
03:04:00,060 --> 03:04:02,760
deserve it. Congratulations. The
first thing you always need to

3218
03:04:02,760 --> 03:04:06,960
do in your smart contracts is
tell solidity, what version of

3219
03:04:06,960 --> 03:04:09,990
solidity that you're going to be
using. And additionally, you

3220
03:04:09,990 --> 03:04:13,260
want to add an spdx license
identifier, then you have to

3221
03:04:13,260 --> 03:04:16,680
create your contract object and
name your contract. The contract

3222
03:04:16,710 --> 03:04:19,410
in solidity is similar to a
class in other programming

3223
03:04:19,410 --> 03:04:23,010
languages, and everything inside
the squiggly brackets is a part

3224
03:04:23,040 --> 03:04:26,730
of that contract. There are many
different types in solidity like

3225
03:04:26,760 --> 03:04:32,970
unsigned integer, 256, Boolean
string, bytes, 32, etc. If we

3226
03:04:32,970 --> 03:04:35,130
want to create a new type, we
can create what's called a

3227
03:04:35,130 --> 03:04:38,760
struct in solidity. You can
create arrays or lists in

3228
03:04:38,760 --> 03:04:41,970
solidity, you can create
dictionaries, or what's called

3229
03:04:42,000 --> 03:04:45,750
mappings in solidity or hash
tables, which when you give it a

3230
03:04:45,750 --> 03:04:49,410
key, it'll spit out the value
that that key represents. We can

3231
03:04:49,410 --> 03:04:52,530
create functions in solidity
that modify the state of the

3232
03:04:52,530 --> 03:04:55,860
blockchain. We can also create
functions in solidity that don't

3233
03:04:55,860 --> 03:04:58,620
modify the state of the
blockchain view in pure

3234
03:04:58,620 --> 03:05:01,830
functions, don't modify by the
state of a blockchain, we also

3235
03:05:01,830 --> 03:05:05,280
can specify different data
locations in our functions,

3236
03:05:05,580 --> 03:05:09,450
called data and memory mean that
that data is only temporary and

3237
03:05:09,450 --> 03:05:12,390
will only exist for the duration
of the function. Storage

3238
03:05:12,390 --> 03:05:15,150
variables are permanent and stay
there forever. function

3239
03:05:15,150 --> 03:05:17,940
parameters can't be stored
variables because they're only

3240
03:05:17,940 --> 03:05:20,550
going to exist for the duration
of the function. All the

3241
03:05:20,550 --> 03:05:23,610
solidity code that we work with,
when we hit Compile, it actually

3242
03:05:23,610 --> 03:05:28,080
compiles down to this Aetherium
virtual machine specifications.

3243
03:05:28,170 --> 03:05:30,690
We'll learn more about those
specifications later. And last,

3244
03:05:30,690 --> 03:05:33,600
but not least, another huge
congratulations on your first

3245
03:05:33,600 --> 03:05:34,260
contract here.

3246
03:05:37,290 --> 03:05:37,740
Awesome.

3247
03:05:37,800 --> 03:05:41,340
All right, let's get started on
our lesson three, remember,

3248
03:05:41,370 --> 03:05:43,920
everything is in the GitHub
repository. And we can scroll

3249
03:05:43,920 --> 03:05:47,550
down, hit Lesson three and see
all the code here. I'm building

3250
03:05:47,550 --> 03:05:50,400
up this repo as I film. So
underneath this lesson three is

3251
03:05:50,400 --> 03:05:52,530
going to be a lot more
information than just the code

3252
03:05:52,530 --> 03:05:57,420
here, all of our code samples
end with dash f f, c, which

3253
03:05:57,420 --> 03:06:00,960
means dash Free Code Camp. So if
you see a GitHub repo that ends

3254
03:06:00,960 --> 03:06:05,370
with dash F, F, C, know that
that repository is associated

3255
03:06:05,370 --> 03:06:07,950
with this course, I'm going to
do a quick high level

3256
03:06:07,950 --> 03:06:10,890
walkthrough of what we're going
to be building in this lesson.

3257
03:06:10,890 --> 03:06:14,430
So you don't need to code right
now just sit back watch and

3258
03:06:14,430 --> 03:06:16,860
enjoy. In this lesson, we're
actually going to expand to

3259
03:06:16,860 --> 03:06:19,890
having three different
contracts. Let's say we want to

3260
03:06:19,890 --> 03:06:23,760
be able to deploy simple storage
contracts from a contract

3261
03:06:23,760 --> 03:06:28,230
itself. Yes, contracts can
indeed deploy contracts, we are

3262
03:06:28,230 --> 03:06:31,200
going to create a contract
called storage factory dot sole,

3263
03:06:31,410 --> 03:06:34,380
that's going to be able to
deploy and interact with other

3264
03:06:34,380 --> 03:06:38,400
contracts itself. So what we
could do is we could go deploy

3265
03:06:38,400 --> 03:06:41,670
this to a JavaScript VM, we're
going to choose storage factory,

3266
03:06:42,000 --> 03:06:45,120
and we're gonna go ahead and hit
Deploy. In our contract down

3267
03:06:45,120 --> 03:06:48,510
below, we have a number of
different functions. Our top

3268
03:06:48,510 --> 03:06:52,020
function is this function called
crate simple storage contract,

3269
03:06:52,230 --> 03:06:56,100
which we can click and it'll
actually create a simple storage

3270
03:06:56,100 --> 03:06:59,760
contract for us, then we can go
ahead and interact with it at an

3271
03:06:59,760 --> 03:07:04,260
IG zero will save a favorite
number of one. Now, if we hit SF

3272
03:07:04,260 --> 03:07:05,340
get zero,

3273
03:07:06,390 --> 03:07:09,390
we get one back. And

3274
03:07:09,510 --> 03:07:12,360
we can see the address of the
simple storage contract that we

3275
03:07:12,360 --> 03:07:14,460
just deployed. Additionally,
we're going to learn about a

3276
03:07:14,460 --> 03:07:18,600
number of solidity features,
such as importing inheritance,

3277
03:07:18,660 --> 03:07:22,080
and so much more. So let's go
ahead and jump in. And remember

3278
03:07:22,080 --> 03:07:25,590
all the code is available here
from the GitHub repository. So

3279
03:07:25,620 --> 03:07:28,350
be sure to refer back to these
contracts if you get lost.

3280
03:07:31,110 --> 03:07:32,040
So here we are

3281
03:07:32,070 --> 03:07:35,160
back in remix, and we have our
simple storage dot soul. If you

3282
03:07:35,160 --> 03:07:38,190
skipped over the last section,
be sure to go to the full

3283
03:07:38,190 --> 03:07:42,780
blockchain solidity course, Jas.
And scroll down to lesson two,

3284
03:07:42,810 --> 03:07:46,650
welcome to remix and grab this
code. Go to simple storage

3285
03:07:46,650 --> 03:07:50,730
outsole. And copy paste this
code into remix. Because this is

3286
03:07:50,730 --> 03:07:53,370
where we're going to be starting
from, we have this simple

3287
03:07:53,370 --> 03:07:56,160
storage contract, which is
great. It allows us to store a

3288
03:07:56,160 --> 03:07:59,010
favorite number. And it allows
us to store favorite numbers

3289
03:07:59,040 --> 03:08:02,970
across different people in both
mappings and arrays. But let's

3290
03:08:02,970 --> 03:08:05,940
say we want to get even more
advanced with this, we actually

3291
03:08:05,940 --> 03:08:10,140
can have a contract actually
deploy other contracts for us.

3292
03:08:10,500 --> 03:08:13,650
And then go ahead and interact
with those contracts from other

3293
03:08:13,650 --> 03:08:17,280
contracts, contracts interacting
with each other is an essential

3294
03:08:17,280 --> 03:08:19,980
part of working with solidity
and working with smart

3295
03:08:19,980 --> 03:08:23,310
contracts. The ability for
contracts to seamlessly interact

3296
03:08:23,310 --> 03:08:26,220
with each other is what's known
as composability. smart

3297
03:08:26,220 --> 03:08:28,920
contracts are composable,
because they can easily interact

3298
03:08:28,920 --> 03:08:31,410
with each other. This is
especially awesome when it comes

3299
03:08:31,410 --> 03:08:34,230
to things like defy where you
can have really complex

3300
03:08:34,230 --> 03:08:38,130
financial products interact with
each other incredibly easily,

3301
03:08:38,490 --> 03:08:41,100
since all their code is
available on chain. So we're

3302
03:08:41,100 --> 03:08:43,920
going to learn how to do that.
So let's keep our simple storage

3303
03:08:43,920 --> 03:08:46,830
contract exactly the way it is,
we're going to create a new

3304
03:08:46,830 --> 03:08:49,740
contract called storage factory.
So we're going to hit the New

3305
03:08:49,740 --> 03:08:56,310
File button and type in storage,
factory dot salt. And let's

3306
03:08:56,310 --> 03:08:59,040
close this off for now. So let's
go ahead and get this contract

3307
03:08:59,040 --> 03:09:01,770
setup from what we learned
before. First thing we're going

3308
03:09:01,770 --> 03:09:08,010
to want to do is the spdx
license identifier, which we're

3309
03:09:08,010 --> 03:09:11,400
going to do MIT. And then the
next thing we're always going to

3310
03:09:11,400 --> 03:09:13,590
need is our solidity version.

3311
03:09:13,680 --> 03:09:16,680
So we'll do pragma solidity

3312
03:09:17,700 --> 03:09:21,300
and we could do zero point 8.7.
But for this one, let's do zero

3313
03:09:21,750 --> 03:09:25,320
point 8.0 And then just add the
carrot, meaning any version of

3314
03:09:25,320 --> 03:09:28,950
0.8 point something will work.
And then let's add our contract

3315
03:09:28,950 --> 03:09:33,480
name, which is going to be
storage factory. Now hit command

3316
03:09:33,480 --> 03:09:37,500
S or ctrl S or go to the compile
tab and hit compile, and boom,

3317
03:09:37,530 --> 03:09:41,010
we have our regular setup here.
Now we want to create a function

3318
03:09:41,070 --> 03:09:44,310
that can actually deploy our
simple storage contract. So

3319
03:09:44,340 --> 03:09:49,860
we'll create a function called
function. create simple storage

3320
03:09:49,860 --> 03:09:53,760
contract, we'll have it be
public, so anybody can call it

3321
03:09:53,880 --> 03:09:57,810
will have to deploy a simple
storage contract and save it to

3322
03:09:57,810 --> 03:10:00,780
a global variable. But before we
can do it How can our storage

3323
03:10:00,780 --> 03:10:04,740
factory contract know what our
simple storage contract looks

3324
03:10:04,740 --> 03:10:08,400
like? In order to deploy it, if
our storage factory contract is

3325
03:10:08,400 --> 03:10:11,610
going to deploy simple storage,
it's going to need to know code

3326
03:10:11,640 --> 03:10:14,130
of simple storage. One way we
can do this is we can actually

3327
03:10:14,130 --> 03:10:18,120
go to our simple storage dot
soul and copy everything

3328
03:10:18,330 --> 03:10:23,070
underneath pragma, solidity and
down and paste it into our

3329
03:10:23,070 --> 03:10:26,640
storage factory dot soul
underneath our pragma, solidity.

3330
03:10:27,510 --> 03:10:30,690
If we go ahead and compile and
save this, it actually works our

3331
03:10:30,690 --> 03:10:33,450
storage factory, that soul
contract actually now has two

3332
03:10:33,450 --> 03:10:36,750
contracts in it. It has the
simple storage contract, and it

3333
03:10:36,750 --> 03:10:39,750
has the storage factory contract
in it, you actually go to the

3334
03:10:39,750 --> 03:10:43,200
deploy tab and scroll down to
deploy while you're on the

3335
03:10:43,200 --> 03:10:46,350
storage factory dot soul, not
the simple storage that's all on

3336
03:10:46,350 --> 03:10:49,860
storage factory, you can see
that you can actually choose

3337
03:10:49,890 --> 03:10:52,620
which one of these contracts to
deploy, a single file of

3338
03:10:52,620 --> 03:10:56,040
solidity can hold multiple
different contracts. Now that we

3339
03:10:56,040 --> 03:10:59,130
have our simple storage, that's
all in our storage factory, we

3340
03:10:59,130 --> 03:11:02,640
can actually go ahead and create
this function to deploy a simple

3341
03:11:02,640 --> 03:11:05,310
storage console, we're going to
create a global variable the

3342
03:11:05,310 --> 03:11:07,980
same way that we would create
any other global variable, we'll

3343
03:11:07,980 --> 03:11:11,940
do the type, which is going to
be type simple storage contract,

3344
03:11:12,330 --> 03:11:16,260
we'll give it a visibility of
public. And we'll give it a

3345
03:11:17,220 --> 03:11:20,640
variable name. Type simple
storage contract going to be

3346
03:11:20,640 --> 03:11:23,370
public, the name of the variable
is going to be simple storage.

3347
03:11:24,030 --> 03:11:26,700
Now in our function, create
simple storage contract, we're

3348
03:11:26,700 --> 03:11:29,070
gonna say simple storage equals

3349
03:11:29,250 --> 03:11:32,640
new, simple storage.

3350
03:11:34,380 --> 03:11:37,830
This new keyword is how solidity
knows Ah, okay, we're going to

3351
03:11:37,830 --> 03:11:41,700
deploy a new simple storage
contract. So we go ahead and

3352
03:11:41,700 --> 03:11:44,640
compile this, we'll go to the
deploy tab, make sure we're on

3353
03:11:44,640 --> 03:11:48,600
the JavaScript VM, we'll scroll
down to the contract. And we'll

3354
03:11:48,600 --> 03:11:51,780
choose storage factory. And
remember, you need to have

3355
03:11:51,780 --> 03:11:54,570
storage factory dot soul
selected. In order for that to

3356
03:11:54,570 --> 03:11:59,460
show up storage factory, we'll
go ahead and hit Deploy. And now

3357
03:12:00,030 --> 03:12:04,380
we see our storage factory
contract has two buttons. One is

3358
03:12:04,380 --> 03:12:07,560
create simple storage, and the
other one is going to be a view

3359
03:12:07,710 --> 03:12:11,070
of our simple storage contract.
If we click it right now, it's

3360
03:12:11,070 --> 03:12:13,650
going to show us that it's
currently at address zero,

3361
03:12:13,740 --> 03:12:16,440
because it gets initialized to
being blank. It's saying there

3362
03:12:16,440 --> 03:12:19,530
is no simple storage contract
currently deployed. Now if we

3363
03:12:19,530 --> 03:12:23,730
pull up our console and click
create simple storage, we see we

3364
03:12:23,730 --> 03:12:27,060
created a new function call
storage factory dot create

3365
03:12:27,060 --> 03:12:30,660
simple storage contract. And in
doing so we called this function

3366
03:12:30,690 --> 03:12:34,200
which created and deployed a new
simple storage contract, we can

3367
03:12:34,200 --> 03:12:36,960
now see what address the simple
storage contract is out by

3368
03:12:36,960 --> 03:12:39,870
clicking the simple storage
button and we see the address

3369
03:12:39,900 --> 03:12:42,870
associated with it. So now we
know how a contract can actually

3370
03:12:42,870 --> 03:12:46,590
deploy another contract. But the
thing is, having this massive

3371
03:12:46,590 --> 03:12:49,890
chunk of code above our storage
factory is a little bit

3372
03:12:49,890 --> 03:12:52,800
redundant, especially since we
have our other file called

3373
03:12:52,800 --> 03:12:56,220
Simple Storage dot soul. And
let's say we have a contract

3374
03:12:56,220 --> 03:12:59,430
that has got a ton of other
contracts in it. Always copy

3375
03:12:59,430 --> 03:13:02,640
pasting all these contracts is
going to be a lot of work. So

3376
03:13:02,640 --> 03:13:06,240
instead, what we can do is use
what's called an import. So

3377
03:13:06,240 --> 03:13:09,450
let's go ahead and delete our
contracts simple storage. And

3378
03:13:09,450 --> 03:13:14,610
now we're just going to type
import dot slash simple storage

3379
03:13:15,270 --> 03:13:19,410
dot soul. This import dot slash
simple storage dot Seoul is the

3380
03:13:19,410 --> 03:13:22,560
exact same as our copy pasted
version of simple storage.

3381
03:13:22,560 --> 03:13:27,030
That's all. It takes the path of
another file, it takes the path

3382
03:13:27,030 --> 03:13:29,970
package or GitHub, which we'll
get to in a minute of another

3383
03:13:29,970 --> 03:13:34,650
file and says, Okay, we're going
to paste that contract into the

3384
03:13:34,650 --> 03:13:37,800
top of this contract here, we
actually see we go back to

3385
03:13:37,800 --> 03:13:42,240
compile, we go to deploy, let's
delete our old contract, we can

3386
03:13:42,240 --> 03:13:45,900
actually see storage factory dot
soul again, we can deploy it,

3387
03:13:46,440 --> 03:13:49,860
click the drop down. And once
again, we can run those

3388
03:13:49,860 --> 03:13:52,500
functions exactly the same.
importing our contracts like

3389
03:13:52,500 --> 03:13:56,070
this is much nicer than always
copy pasting the code. This way,

3390
03:13:56,100 --> 03:13:58,380
if we want to change something
in simple storage, we have one

3391
03:13:58,380 --> 03:14:01,110
canonical place to go ahead and
change it instead of having to

3392
03:14:01,110 --> 03:14:03,780
change it in multiple different
places. Now additionally, you'll

3393
03:14:03,780 --> 03:14:06,750
notice the pragma, solidity if
we have our contracts in two

3394
03:14:06,750 --> 03:14:09,780
separate files, we actually can
have different versions of

3395
03:14:09,780 --> 03:14:13,620
solidity right now our storage
factory has carrot zero point

3396
03:14:13,620 --> 03:14:18,420
8.0 Which means that anything
within the 0.8 range of this

3397
03:14:18,420 --> 03:14:22,500
contract is okay. But for simple
storage that sole, it says

3398
03:14:22,500 --> 03:14:27,000
anything in the zero point 8.8
And above range is okay. So if

3399
03:14:27,000 --> 03:14:31,710
we were to try to change the
compiler version 8.5 And then go

3400
03:14:31,710 --> 03:14:34,680
ahead and compile, a remix is
going to automatically bump it

3401
03:14:34,680 --> 03:14:37,500
up to a better version that is
compatible with both of them, in

3402
03:14:37,500 --> 03:14:41,460
this case eight point 13. But if
we, for example, changed our

3403
03:14:41,460 --> 03:14:46,710
solidity version of storage
factory to zero point 7.0 And

3404
03:14:46,710 --> 03:14:51,180
then tried to compile them. We
actually end up getting an issue

3405
03:14:51,450 --> 03:14:54,600
parser error source file
requires a different compiler

3406
03:14:54,600 --> 03:14:58,470
version. This is because our
storage factory is saying hey,

3407
03:14:58,500 --> 03:15:03,300
anything in 0.7 means is okay.
However, our simple storage is

3408
03:15:03,300 --> 03:15:07,350
saying anything in the zero
point 8.8 And above is okay. So

3409
03:15:07,350 --> 03:15:10,170
those two versions are not
compatible. So what we need to

3410
03:15:10,170 --> 03:15:13,230
do is we need to make sure our
versions of solidity are indeed

3411
03:15:13,230 --> 03:15:17,880
compatible. So let's change the
version back recompile. And now

3412
03:15:17,910 --> 03:15:20,490
we're looking good again. Now
since we have this create simple

3413
03:15:20,490 --> 03:15:23,520
storage contract, every single
time we call it right now, it'll

3414
03:15:23,520 --> 03:15:26,520
just replace whatever is
currently in our public simple

3415
03:15:26,520 --> 03:15:29,520
storage variable. Let's go ahead
and update this so that we can

3416
03:15:29,520 --> 03:15:32,430
actually keep a running list of
all of our deployed simple

3417
03:15:32,430 --> 03:15:35,130
storage contracts. So instead of
having this be a single

3418
03:15:35,130 --> 03:15:39,180
variable, we'll make this a
simple storage array or list

3419
03:15:39,420 --> 03:15:44,460
public simple storage array.
Now, whenever we create a new

3420
03:15:44,460 --> 03:15:48,150
simple storage contract, instead
of saving it like this, what

3421
03:15:48,150 --> 03:15:51,540
we're going to do is we're going
to save it as a memory variable

3422
03:15:51,570 --> 03:15:56,820
by saying simple storage, simple
storage equals new simple

3423
03:15:56,820 --> 03:16:00,840
storage. And we're going to add
this variable to our simple

3424
03:16:00,840 --> 03:16:04,500
storage array. So the same way
we did it before, we're gonna do

3425
03:16:04,500 --> 03:16:11,040
simple storage array dot push,
simple storage. So I should

3426
03:16:11,040 --> 03:16:14,490
spell storage, right? Let's go
ahead and compile this looks

3427
03:16:14,490 --> 03:16:19,890
good. We'll deploy the storage
factory deploy. Like here, we

3428
03:16:19,890 --> 03:16:24,480
now have simple storage array
View button, we'll do create

3429
03:16:24,480 --> 03:16:27,570
simple storage. Now we can view
the simple storage contract

3430
03:16:27,600 --> 03:16:31,260
zero. Right now there's nothing
at one. But if we create another

3431
03:16:31,260 --> 03:16:33,810
simple storage contract, we can
see the new simple storage

3432
03:16:33,810 --> 03:16:35,640
contract address at index one.

3433
03:16:38,400 --> 03:16:39,540
All right, so this is great,

3434
03:16:39,720 --> 03:16:43,080
we can now keep track of all of
our simple storage deployments.

3435
03:16:43,140 --> 03:16:45,870
But how do we actually interact
with them, let's say we wanted

3436
03:16:45,870 --> 03:16:48,870
to be able to call the store
function on all of our simple

3437
03:16:48,870 --> 03:16:52,500
storage dot souls from our
storage factory, you can think

3438
03:16:52,500 --> 03:16:55,230
of the storage factory as almost
like a manager of all of our

3439
03:16:55,230 --> 03:16:58,140
simple storages. That's all
let's create a new function that

3440
03:16:58,140 --> 03:17:01,500
can do exactly that. So we'll
create function, and we'll call

3441
03:17:01,500 --> 03:17:06,720
it S F store, which is going to
stand for storage factory store.

3442
03:17:07,380 --> 03:17:13,890
And it's going to take you in
256, simple storage index, and a

3443
03:17:13,890 --> 03:17:19,470
UNT 256, underscore simple
storage

3444
03:17:20,100 --> 03:17:22,740
number. There'll be a public

3445
03:17:23,850 --> 03:17:26,640
auction as well. Now in order
for you to interact with any

3446
03:17:26,640 --> 03:17:30,120
contract, you're always going to
need two things. And we're going

3447
03:17:30,120 --> 03:17:34,740
to refer to this a lot. You're
always going to need the address

3448
03:17:34,860 --> 03:17:39,960
of the contract, and the ABI of
the contract. The API stands for

3449
03:17:40,560 --> 03:17:44,850
Application binary interface,
the API will tell our code

3450
03:17:44,880 --> 03:17:48,300
exactly how it can interact with
the contract, we'll go deeper

3451
03:17:48,300 --> 03:17:52,080
into API as we move on. But if
you go to your compile tab, you

3452
03:17:52,080 --> 03:17:54,810
hit compile, and things are
actually compiling. You can

3453
03:17:54,810 --> 03:17:58,800
scroll down, and you can see
compilation details. And you can

3454
03:17:58,800 --> 03:18:02,790
see a whole bunch of information
on your different contracts. You

3455
03:18:02,790 --> 03:18:05,970
can see the name of your
contract, which for our simple

3456
03:18:05,970 --> 03:18:08,670
storage contract is simple
storage, you can see a whole

3457
03:18:08,670 --> 03:18:12,000
bunch of metadata, like the
compiler, the language output

3458
03:18:12,000 --> 03:18:15,600
settings, all this other stuff.
You can see the exact bytecode

3459
03:18:15,870 --> 03:18:18,660
and the opcodes, which we'll
talk about much later. But you

3460
03:18:18,660 --> 03:18:22,470
can also see this API, this API
tells you all the different

3461
03:18:22,650 --> 03:18:24,870
inputs and outputs and
everything you could do with

3462
03:18:24,870 --> 03:18:28,200
this contract. For example, in
our simple storage, if we look

3463
03:18:28,200 --> 03:18:32,280
at the zero with index of our
API, we have a function add

3464
03:18:32,280 --> 03:18:36,090
person. If we look at one, we
see our name to favorite number,

3465
03:18:36,570 --> 03:18:42,240
we looked at two we can see our
people three retrieve for store,

3466
03:18:42,240 --> 03:18:44,880
it tells us all these different
ways we can actually interact

3467
03:18:44,880 --> 03:18:47,370
with our contract. And the
different functions that we can

3468
03:18:47,370 --> 03:18:51,030
call, we know where addresses
are, because we're storing them

3469
03:18:51,090 --> 03:18:55,020
in this array here, our simple
storage array, we can also get

3470
03:18:55,020 --> 03:18:58,800
the API because we're importing
simple storage dot soul when you

3471
03:18:58,800 --> 03:19:02,370
compile simple storage on soul.
As you saw on the compilation

3472
03:19:02,370 --> 03:19:05,940
details, whenever you compile
it, it comes prepackaged with

3473
03:19:05,940 --> 03:19:09,900
the ABI, we automatically get
the ABI just by importing it

3474
03:19:09,900 --> 03:19:12,840
like this. In the future, we'll
see other ways that we can

3475
03:19:12,840 --> 03:19:15,930
actually get API's really
easily. So to call the store

3476
03:19:15,930 --> 03:19:18,180
function on one of our
contracts, we're first going to

3477
03:19:18,180 --> 03:19:21,360
need to get that contract
object. So what we can do is we

3478
03:19:21,360 --> 03:19:27,540
can say simple storage variable
named simple storage. Variable

3479
03:19:27,570 --> 03:19:30,930
Name simple storage of type
simple storage is going to be

3480
03:19:30,960 --> 03:19:38,670
equal to a simple storage
object. And instead of doing new

3481
03:19:38,700 --> 03:19:41,640
simple storage, like we did last
time, we're just going to put

3482
03:19:41,670 --> 03:19:45,390
the address of this simple
storage object in here, which

3483
03:19:45,420 --> 03:19:48,570
again, we can get from our
array. And in this function,

3484
03:19:48,570 --> 03:19:52,500
we're passing the array index.
So we can say simple storage

3485
03:19:52,500 --> 03:19:59,610
contract at address simple
storage array. At index simple

3486
03:20:00,000 --> 03:20:05,010
Storage index. This bracket
notation here is how you access

3487
03:20:05,010 --> 03:20:08,790
different elements of arrays. So
if we want the zeroeth element

3488
03:20:08,820 --> 03:20:12,780
of our list here, simple storage
index would be zero, and we pass

3489
03:20:12,780 --> 03:20:16,440
it into this bit here, then
that'll give us the address of

3490
03:20:16,440 --> 03:20:18,960
our simple storage contract,
which we pass into simple

3491
03:20:18,960 --> 03:20:22,170
storage here. Since this is an
array of simple storage

3492
03:20:22,170 --> 03:20:25,890
contracts, we can just access
that simple storage contract

3493
03:20:25,920 --> 03:20:32,760
using the index. So we would
say, simple store, Edge array at

3494
03:20:32,760 --> 03:20:40,290
index underscore simple storage
index. Now we're saving the

3495
03:20:40,290 --> 03:20:44,310
contract object at index simple
storage index to our simple

3496
03:20:44,310 --> 03:20:47,610
storage variable. Our array here
is keeping track of the

3497
03:20:47,610 --> 03:20:52,050
addresses for us. And it
automatically comes with the ABI

3498
03:20:52,050 --> 03:20:56,100
is here. If this was just an
array of addresses of the

3499
03:20:56,100 --> 03:21:00,060
contract objects, instead, we
would have to wrap the address

3500
03:21:00,090 --> 03:21:04,230
in a simple storage object like
this. But we'll get to that much

3501
03:21:04,230 --> 03:21:07,710
later. So for now, all we have
to do is this and we now have a

3502
03:21:07,710 --> 03:21:10,890
simple storage contract object.
Now that we have it, we can call

3503
03:21:11,220 --> 03:21:15,480
our store function on the simple
storage contract. So we'll call

3504
03:21:15,480 --> 03:21:21,780
simple storage dot store. And
we'll store the simple storage

3505
03:21:23,100 --> 03:21:24,300
number to it. So this

3506
03:21:24,300 --> 03:21:26,790
is perfect. And if we were to
deploy this right now, though,

3507
03:21:26,820 --> 03:21:29,430
we wouldn't be able to read the
store function. So let's create

3508
03:21:29,430 --> 03:21:32,250
another function that can read
from the simple storage contract

3509
03:21:32,280 --> 03:21:36,840
from the storage factory. So
we'll create a function called S

3510
03:21:36,870 --> 03:21:42,180
F get, which stands for storage
factory get, it'll take a un 256

3511
03:21:42,210 --> 03:21:47,610
underscore simple storage index.
This will be a public view

3512
03:21:47,610 --> 03:21:50,370
function, since we're just going
to be reading from our simple

3513
03:21:50,370 --> 03:21:54,690
storage contract. And it's going
to return a UNT 256. And we'll

3514
03:21:54,690 --> 03:21:56,610
say simple storage.

3515
03:21:57,690 --> 03:22:01,290
Simple Storage. Equals

3516
03:22:01,560 --> 03:22:04,560
when you use this same syntax
from up here to get the contract

3517
03:22:04,590 --> 03:22:07,710
simple storage array at the
simple storage index. And then

3518
03:22:07,710 --> 03:22:09,000
we're going to do return,

3519
03:22:10,290 --> 03:22:15,330
simple storage.re retrieve

3520
03:22:16,050 --> 03:22:20,160
to get that number that we just
stored up here. And I should

3521
03:22:20,160 --> 03:22:24,810
spell retrieved correctly, so we
get no issues. Perfect. So now

3522
03:22:24,810 --> 03:22:29,790
we'll compile, we'll deploy JAVA
script, we're working on a fake

3523
03:22:29,790 --> 03:22:33,210
account, we're going to use our
storage factory, go ahead and

3524
03:22:33,210 --> 03:22:35,730
delete all the contracts we have
so far. Let's go ahead and

3525
03:22:35,730 --> 03:22:41,370
deploy the drop down rate. Right
now if we do SF get at zero,

3526
03:22:41,910 --> 03:22:44,880
we're going to get nothing.
Simple Storage address zero is

3527
03:22:44,880 --> 03:22:47,370
going to be nothing. Let's
create a simple storage

3528
03:22:47,370 --> 03:22:52,200
contract. Now it's simple
storage list, we get an address

3529
03:22:52,230 --> 03:22:56,760
at zero. If we hit SF get right
now it didn't zero, we get zero.

3530
03:22:57,240 --> 03:23:02,040
So let's store a value on this
contract here. So the index of

3531
03:23:02,040 --> 03:23:05,460
that contract is zero. So we're
going to pass zero as a symbol

3532
03:23:05,460 --> 03:23:09,570
storage index. And we're going
to save the number seven. So

3533
03:23:09,570 --> 03:23:13,620
we'll go ahead and do SF store.
And if we did this, right, this

3534
03:23:13,620 --> 03:23:18,930
is going to store the value
seven into this contract. So if

3535
03:23:18,930 --> 03:23:23,010
we do SF get of zero now, it
does indeed return seven. If we

3536
03:23:23,010 --> 03:23:27,750
do SF get one we're going to get
nothing's going to happen. And

3537
03:23:27,750 --> 03:23:30,660
we're actually going to get this
revert error here. So let's

3538
03:23:30,660 --> 03:23:33,870
create another simple storage
contract. Now if we do SF get

3539
03:23:33,900 --> 03:23:37,230
one, we get zero, because we're
gonna get that default value.

3540
03:23:37,350 --> 03:23:40,440
Let's go ahead on the simple
storage contract and index one

3541
03:23:40,500 --> 03:23:45,360
will store the number 16 will
hit SF store. Now we'll do SF

3542
03:23:45,360 --> 03:23:49,410
get one and we get 16. Feel free
to pause right now and play

3543
03:23:49,410 --> 03:23:51,840
around with this so that you
really understand it. The quick

3544
03:23:51,840 --> 03:23:54,930
recap is our storage factory
contract allows us to create

3545
03:23:54,930 --> 03:23:58,140
simple storage contracts, it
then saves it to our simple

3546
03:23:58,140 --> 03:24:02,460
storage array, which we can then
call different functions on, we

3547
03:24:02,460 --> 03:24:06,540
can store values from our
storage factory contract. And

3548
03:24:06,540 --> 03:24:09,870
then we can read values from our
storage factory contract for any

3549
03:24:09,870 --> 03:24:13,170
of the simple storage contracts
that we've created. This is

3550
03:24:13,170 --> 03:24:16,170
incredibly powerful, we can
additionally make these two

3551
03:24:16,170 --> 03:24:20,220
functions even easier. We can
call the Retrieve function

3552
03:24:20,280 --> 03:24:24,030
directly on this when we call
simple storage array. And then

3553
03:24:24,030 --> 03:24:27,840
we have these brackets and add
the simple storage index. This

3554
03:24:28,260 --> 03:24:31,440
returns a simple storage object.
So what we could do is we could

3555
03:24:31,440 --> 03:24:32,850
actually delete this whole part

3556
03:24:34,290 --> 03:24:36,480
and just do dot retrieve

3557
03:24:38,010 --> 03:24:41,880
right here, and then delete this
line and say return and just

3558
03:24:41,880 --> 03:24:44,670
have it be just like this. If
you go ahead and save or hit

3559
03:24:44,670 --> 03:24:47,340
Compile, you'll get the green
checkmark there. We're calling

3560
03:24:47,340 --> 03:24:51,600
the Retrieve function on
whatever this is. And whatever

3561
03:24:51,600 --> 03:24:55,740
this is, is a simple storage
object. So perfect. We can do

3562
03:24:55,740 --> 03:24:59,490
the same thing up here by
deleting this part and just

3563
03:24:59,490 --> 03:25:08,010
doing dot store, underscore
simple store edge number, we

3564
03:25:08,010 --> 03:25:11,220
save it. And this will work
exactly the same. Awesome, we

3565
03:25:11,220 --> 03:25:13,350
now have a simple storage
contract that can store

3566
03:25:13,350 --> 03:25:16,650
variables in a storage factory
contract that can be almost like

3567
03:25:16,680 --> 03:25:19,530
a manager of these simple
storage contracts and deploy and

3568
03:25:19,530 --> 03:25:21,570
interact with them themselves.
This is

3569
03:25:21,570 --> 03:25:26,220
fantastic. Now, let's say that

3570
03:25:26,250 --> 03:25:28,950
we really liked the simple
storage contract, but it doesn't

3571
03:25:28,950 --> 03:25:32,160
do everything that we want it to
do. Maybe we want it so that

3572
03:25:32,160 --> 03:25:35,310
whenever we actually store value
doesn't store the favorite

3573
03:25:35,310 --> 03:25:39,030
number, it stores the favorite
number plus five, for some

3574
03:25:39,030 --> 03:25:41,580
reason you want a contract that
that everyone's favorite number

3575
03:25:41,580 --> 03:25:44,670
is five numbers bigger than what
they think it is. But you really

3576
03:25:44,670 --> 03:25:47,610
like everything else that this
contract has to offer. Let's

3577
03:25:47,610 --> 03:25:50,430
create this new contract. And
we'll call it extra storage.

3578
03:25:51,480 --> 03:25:55,650
So we'll say extra storage dot
soul.

3579
03:25:56,340 --> 03:25:58,440
And we'll create this new
contract, we're going to set it

3580
03:25:58,440 --> 03:26:02,580
up the exact same way we
normally would spdx license

3581
03:26:02,970 --> 03:26:09,390
identifier, gonna be MIT, we'll
give it pragma solidity. And

3582
03:26:09,390 --> 03:26:10,680
we'll just do zero

3583
03:26:12,300 --> 03:26:16,740
point 8.0 with the carrot. And
we'll say contract, extra

3584
03:26:17,370 --> 03:26:19,920
storage, like so

3585
03:26:20,009 --> 03:26:23,309
if you save or compile, you'll
get the green checkmark. So what

3586
03:26:23,309 --> 03:26:26,339
can we do? Well, the first thing
we could do is we could copy

3587
03:26:26,339 --> 03:26:30,209
paste all this code back into
here, and then modify our extra

3588
03:26:30,209 --> 03:26:33,119
storage contract as we see fit.
This seems a little bit

3589
03:26:33,119 --> 03:26:36,389
redundant. And a lot of work
though. So what's another way we

3590
03:26:36,389 --> 03:26:39,929
can actually get our extra
storage contract to be like our

3591
03:26:39,929 --> 03:26:42,179
simple storage contract? Well,
this is where we can do

3592
03:26:42,179 --> 03:26:46,259
something called inheritance, we
can have our extra storage

3593
03:26:46,259 --> 03:26:50,129
contract, do what's called a
child contract of our simple

3594
03:26:50,129 --> 03:26:54,809
storage contract. And we can
have extra storage, inherit all

3595
03:26:54,809 --> 03:26:59,189
the functionality of simple
storage with two lines of code.

3596
03:26:59,789 --> 03:27:03,059
So first, in order for our extra
storage contract to know about

3597
03:27:03,059 --> 03:27:06,419
simple storage, we once again
need to import it. So we'll say

3598
03:27:06,419 --> 03:27:12,779
import dot slash, simple storage
dot soul. And we'll say our

3599
03:27:12,779 --> 03:27:20,639
contract extra storage is simple
storage. And we save or compile.

3600
03:27:20,819 --> 03:27:25,109
Now our extra storage contract
is going to be the exact same as

3601
03:27:25,109 --> 03:27:28,439
simple storage. And it's going
to do what's called inherit all

3602
03:27:28,439 --> 03:27:30,779
the functionality of simple
storage. And we can actually

3603
03:27:30,779 --> 03:27:34,469
even see that, let's go ahead
and make sure this is compiled.

3604
03:27:34,889 --> 03:27:37,589
And we'll go and deploy this.
And now in our deployed

3605
03:27:37,589 --> 03:27:42,479
contract, we can see we have
extra storage deployed with all

3606
03:27:42,479 --> 03:27:45,359
the functions that simple
storage has, if you want a

3607
03:27:45,359 --> 03:27:48,149
contract to inherit all the
functionality of another

3608
03:27:48,149 --> 03:27:52,829
contract, you can just import it
and say your contract is that

3609
03:27:52,829 --> 03:27:56,579
other contract. Now, we can add
additional functions to our

3610
03:27:56,579 --> 03:27:59,519
extra storage contract. That
will include all the

3611
03:27:59,519 --> 03:28:02,969
functionality of simple storage.
Now, let's say that we inherit

3612
03:28:02,969 --> 03:28:06,449
simple storage to extra storage.
However, one of the functions in

3613
03:28:06,449 --> 03:28:09,389
simple storage we don't really
actually like. So if we go back

3614
03:28:09,389 --> 03:28:12,539
to our simple storage contract,
our store function, all it does

3615
03:28:12,539 --> 03:28:15,779
is take a favorite number, and
then assigns the global favorite

3616
03:28:15,779 --> 03:28:19,079
number to whatever new number
that we give it in our extra

3617
03:28:19,079 --> 03:28:21,719
storage. We want the store
function to do something

3618
03:28:21,719 --> 03:28:26,249
different. We want it to add
five, to any number that we give

3619
03:28:26,249 --> 03:28:29,189
it. How can we achieve this?
Well, we can do something called

3620
03:28:29,459 --> 03:28:32,519
overriding the functions. And
there are two keywords that

3621
03:28:32,519 --> 03:28:36,749
we're going to use. Those are
virtual, and override. Right

3622
03:28:36,749 --> 03:28:39,659
now, if I were to try to
implement a store function for

3623
03:28:39,659 --> 03:28:42,509
extra storage, let's see what
happens. We'll say function

3624
03:28:42,989 --> 03:28:48,569
store, you went to the six
favorite number. There'll be a

3625
03:28:48,569 --> 03:28:53,189
public function. And let's say
instead of just storing favorite

3626
03:28:53,189 --> 03:28:59,339
number, we'll say favorite
number equals favorite number,

3627
03:28:59,639 --> 03:29:03,779
plus five. If we try to compile
this right now, we'll actually

3628
03:29:03,779 --> 03:29:06,839
run into two different errors.
First one is going to say

3629
03:29:07,229 --> 03:29:10,649
overriding function is missing,
override specifier. If the

3630
03:29:10,649 --> 03:29:13,949
parent contract, which in our
case is simple storage has that

3631
03:29:13,949 --> 03:29:17,189
same function, we need to tell
solidity that we're going to

3632
03:29:17,219 --> 03:29:22,529
override this store function and
instead we're going to use this

3633
03:29:22,559 --> 03:29:25,139
store function. But
additionally, we get this other

3634
03:29:25,139 --> 03:29:28,919
error saying trying to override
non virtual function. Did you

3635
03:29:28,919 --> 03:29:33,149
forget to add virtual in order
for a function to be overridable

3636
03:29:33,479 --> 03:29:37,589
you need to add the virtual
keyword to the store function.

3637
03:29:37,709 --> 03:29:40,949
Now it can be overridable.
However, if we save and compile,

3638
03:29:41,309 --> 03:29:44,309
we still have this issue
overriding function is missing

3639
03:29:44,309 --> 03:29:48,839
override specifier. And then all
we need to do is add override to

3640
03:29:48,839 --> 03:29:52,589
restore function. Now if we save
everything compiles correctly,

3641
03:29:52,769 --> 03:29:55,529
let's go ahead and deploy this.
Let's delete our old contracts.

3642
03:29:56,219 --> 03:29:59,369
JavaScript VM right account.
Great we're going to choose

3643
03:29:59,369 --> 03:30:02,849
extra store Reg, let's go ahead
and deploy. And here's our extra

3644
03:30:02,849 --> 03:30:06,029
storage contract. Right now if
we retrieve, we get zero.

3645
03:30:06,419 --> 03:30:09,689
Previously, our store function
would store the exact number.

3646
03:30:09,929 --> 03:30:13,949
However, if I were to store
five, it'll store five, plus

3647
03:30:13,949 --> 03:30:17,819
five. So we should have 10
stored here. Let's go ahead call

3648
03:30:17,819 --> 03:30:21,479
store looks like that one
through, and we'll hit retrieved

3649
03:30:21,479 --> 03:30:25,649
now. And we do indeed see 10 is
in here. So this is how we do

3650
03:30:25,679 --> 03:30:27,659
inheritance, and we override

3651
03:30:27,840 --> 03:30:32,220
functions. And that's it. For
this

3652
03:30:32,220 --> 03:30:35,670
section, you've just learned a
ton of incredibly powerful

3653
03:30:35,760 --> 03:30:39,450
solidity for having multiple
files. Let's do a quick overview

3654
03:30:39,480 --> 03:30:42,390
of what we learned, we learned
that we can actually deploy

3655
03:30:42,510 --> 03:30:46,500
contracts from other contracts
using the new keyword, we

3656
03:30:46,500 --> 03:30:50,010
learned that we can actually
import other contracts into our

3657
03:30:50,010 --> 03:30:53,310
contracts and into our code
using the Import keyword. And

3658
03:30:53,310 --> 03:30:56,490
the import keyword is the same
as copying pasting that file to

3659
03:30:56,490 --> 03:30:59,850
the location of the import line,
we learned that we can interact

3660
03:30:59,850 --> 03:31:03,540
with other contracts. As long as
we have the ABI and address. We

3661
03:31:03,540 --> 03:31:06,360
didn't learn too much about the
ABI. But we'll learn more later,

3662
03:31:06,480 --> 03:31:09,690
we learned that if we want to
create a child contract and

3663
03:31:09,690 --> 03:31:12,900
inherit the functionality of
some other contract, we can do

3664
03:31:12,900 --> 03:31:15,900
something called inheritance.
And the way to inherit

3665
03:31:15,930 --> 03:31:19,440
functionality is using the is
keyword and saying our contract

3666
03:31:19,470 --> 03:31:22,290
is some other contract. However,
if we want to change from the

3667
03:31:22,290 --> 03:31:26,340
functionality of the parent
contract, we have to override

3668
03:31:26,370 --> 03:31:29,460
that function. And additionally,
we have to set the function we

3669
03:31:29,460 --> 03:31:32,760
want to override to virtual now
we can have our own store

3670
03:31:32,760 --> 03:31:36,060
function, do whatever we want it
to do. That is the end of this

3671
03:31:36,060 --> 03:31:38,610
lesson. Once again, give
yourself a huge round of

3672
03:31:38,610 --> 03:31:41,370
applause a pat on the back for
making it this far. And for

3673
03:31:41,370 --> 03:31:44,310
finishing this section. You're
getting more and more advanced

3674
03:31:44,310 --> 03:31:48,180
facility so quickly, so be sure
to celebrate the little wins by

3675
03:31:48,180 --> 03:31:50,850
getting some ice cream, maybe
going for a walk or tweeting

3676
03:31:50,850 --> 03:31:53,580
about or posting on Reddit.
Congratulations, you have

3677
03:31:53,580 --> 03:31:54,870
completed this section.

3678
03:31:57,780 --> 03:32:00,960
All right, everybody. Welcome
back. We are now headed into

3679
03:32:00,990 --> 03:32:06,000
Lesson four remix Funmi. And of
course, all the code can be

3680
03:32:06,000 --> 03:32:09,120
found on the GitHub repository
associated with this course.

3681
03:32:09,360 --> 03:32:12,540
We're going to be working with
two contracts here, one of them

3682
03:32:12,570 --> 03:32:15,840
is fundament outsole. And then
one of them is price converted

3683
03:32:15,840 --> 03:32:19,380
outsole Funmi dot Sol is going
to be a contract that allows

3684
03:32:19,380 --> 03:32:22,350
people to actually fund a
collective good. So people can

3685
03:32:22,350 --> 03:32:26,130
send Aetherium send Aetherium,
or polygon or Avalanche or

3686
03:32:26,130 --> 03:32:30,210
Phantom, or whatever blockchain
native token into this contract,

3687
03:32:30,420 --> 03:32:33,180
and some owner of the contract
can then withdraw those funds

3688
03:32:33,210 --> 03:32:36,690
and do whatever they want. After
deploying this to a test net, we

3689
03:32:36,690 --> 03:32:39,420
can see the list of functions
this contract has, this will

3690
03:32:39,420 --> 03:32:44,730
have two red buttons, which are
used to notate to payable

3691
03:32:44,760 --> 03:32:49,350
functions in fund in our fund
function. And in our withdrawal

3692
03:32:49,350 --> 03:32:54,240
function, withdraw allows users
to withdraw the funding and fund

3693
03:32:54,270 --> 03:32:58,110
allows users to send money to
the contract, what we can do is

3694
03:32:58,200 --> 03:33:02,010
we can send some value along
with our transaction. When we

3695
03:33:02,010 --> 03:33:05,130
call this fund function, then
what we can do is we can

3696
03:33:05,130 --> 03:33:08,730
actually fund this contract with
a certain amount of eath, or way

3697
03:33:08,910 --> 03:33:12,900
by pasting some value into the
way value section. And then

3698
03:33:12,900 --> 03:33:16,260
hitting fund, we will now have
sent money into our deployed

3699
03:33:16,260 --> 03:33:20,310
contract. And we can see a list
of the funders and a mapping of

3700
03:33:20,310 --> 03:33:23,580
those addresses and how much
they've actually sent into the

3701
03:33:23,580 --> 03:33:27,270
contract, we can then withdraw
the funds out of the contract.

3702
03:33:27,690 --> 03:33:30,600
With a special exception with
only the person who deployed

3703
03:33:30,600 --> 03:33:32,970
this contract can actually
withdraw the funds back out.

3704
03:33:33,090 --> 03:33:35,760
Once the funds are withdrawn,
the amount of all the funds is

3705
03:33:35,760 --> 03:33:38,340
reset back to zero. Are you
excited? Well, you should be.

3706
03:33:38,400 --> 03:33:41,070
And if you've finished the
section, you've completed most

3707
03:33:41,070 --> 03:33:44,040
of the basics of solidity, and
you'll be ready to start making

3708
03:33:44,220 --> 03:33:46,770
even more powerful smart
contracts, we'll be using

3709
03:33:46,800 --> 03:33:49,830
channeling price feeds to
actually set the value of how

3710
03:33:49,830 --> 03:33:53,040
much these people should be able
to fund in USD as opposed to

3711
03:33:53,040 --> 03:33:56,340
just in terms of ether, we're
gonna go over a lot of advanced

3712
03:33:56,370 --> 03:33:58,590
sections here. And I'll let you
know what parts might be a

3713
03:33:58,620 --> 03:34:01,080
little bit harder to digest. So
you don't have to spend your

3714
03:34:01,080 --> 03:34:03,900
entire time trying to figure out
exactly what's going on. Be sure

3715
03:34:03,900 --> 03:34:05,970
to use the GitHub repo to your
advantage here and the

3716
03:34:05,970 --> 03:34:08,940
discussions tab to stay
connected with other people

3717
03:34:08,970 --> 03:34:14,850
taking this lesson. Alright,
let's jump in. So at this point,

3718
03:34:14,880 --> 03:34:17,520
in remix, you'll have a couple
of contracts here, simple

3719
03:34:17,520 --> 03:34:20,550
storage, storage, factory extra
storage, maybe you refreshed

3720
03:34:20,550 --> 03:34:23,340
remix, and these have gone away.
And in the case, make sure that

3721
03:34:23,340 --> 03:34:26,130
you just don't have any of those
tabs open, we're going to create

3722
03:34:26,160 --> 03:34:31,350
a new contract called funding.
So let's go ahead and start

3723
03:34:31,350 --> 03:34:34,980
creating our funding contract.
Again, we want it to be able to

3724
03:34:35,460 --> 03:34:41,040
get funds from users and
withdraw funds and set a minimum

3725
03:34:41,760 --> 03:34:45,270
funding value in USD. This is
what we're going to get our

3726
03:34:45,270 --> 03:34:50,670
contract to do. So first, let's
set it up spdx license I tend to

3727
03:34:51,810 --> 03:35:00,810
fire MIT do pragma solidity do
caret zero point 8.8. And we'll

3728
03:35:00,810 --> 03:35:05,640
do contract bunbee. Awesome. And
we'll compile, see if things

3729
03:35:05,640 --> 03:35:09,510
look good. And they do. Great.
Let's keep going. So before we

3730
03:35:09,510 --> 03:35:11,910
actually embark on creating all
of our functions here, let's

3731
03:35:11,910 --> 03:35:14,190
just add the different functions
that we're going to implement.

3732
03:35:14,310 --> 03:35:18,240
So we want a function fund for
people to actually send money

3733
03:35:18,240 --> 03:35:23,340
to, we want a function withdraw,
or the owner of this contract to

3734
03:35:23,340 --> 03:35:25,710
actually withdraw the funds that
different funders actually give

3735
03:35:25,710 --> 03:35:29,370
us. And that's pretty much it.
These are the two main functions

3736
03:35:29,370 --> 03:35:32,790
that we want this contract to
do, we will be implementing more

3737
03:35:32,790 --> 03:35:36,180
functions to help facilitate
these two functions. But let's

3738
03:35:36,180 --> 03:35:39,090
get started by looking at fund.
let's comment out withdrawal for

3739
03:35:39,090 --> 03:35:42,090
now. And let's just start with
fun. So we want anybody to be

3740
03:35:42,090 --> 03:35:46,320
able to call this fun function.
So we'll make this public. So as

3741
03:35:46,320 --> 03:35:52,170
we mentioned, we want to be able
to set a minimum font amount in

3742
03:35:52,170 --> 03:35:55,170
USD. So there's a lot of things
to think about here. First thing

3743
03:35:55,170 --> 03:35:58,890
we probably want to think about
is how do we send eath to this

3744
03:35:58,890 --> 03:36:02,550
contract, whenever we create a
transaction on the on any of

3745
03:36:02,550 --> 03:36:06,390
these EVM blockchains, there's
this value field that we can set

3746
03:36:06,480 --> 03:36:08,880
value represents how much
Aetherium we're going to be

3747
03:36:08,880 --> 03:36:12,270
sending with our transactions.
For example, when we transferred

3748
03:36:12,270 --> 03:36:15,690
Aetherium. between our different
accounts, we were actually

3749
03:36:15,720 --> 03:36:19,080
populating this value parameter
with different amounts of

3750
03:36:19,080 --> 03:36:22,530
Aetherium. In fact, every single
transaction that we send, will

3751
03:36:22,530 --> 03:36:26,430
have these fields, it'll have a
nonce or the transaction count

3752
03:36:26,550 --> 03:36:30,600
the account the gas price, the
gas limit that we've seen on

3753
03:36:30,600 --> 03:36:35,040
ether scan a to aka the address
that the transaction is sent to

3754
03:36:35,160 --> 03:36:37,920
a value which is going to be
this amount that we're talking

3755
03:36:37,920 --> 03:36:40,380
about. They'll also have data
which is going to be what we

3756
03:36:40,380 --> 03:36:44,250
send if we make a function call
or deploy contract, and then

3757
03:36:44,250 --> 03:36:47,490
we'll have this v r s
components. We're not really

3758
03:36:47,490 --> 03:36:50,130
going to go over these v r and s
because this is that

3759
03:36:50,130 --> 03:36:53,490
cryptographic magic that's
happening when a transaction is

3760
03:36:53,490 --> 03:36:56,430
signed, but just know that
that's it Now, for sending

3761
03:36:56,430 --> 03:37:00,060
value, we can populate some of
these fields, the gas limit, for

3762
03:37:00,060 --> 03:37:04,800
example, was populated to 21,000
data is going to be empty. And

3763
03:37:04,800 --> 03:37:07,740
then that two is going to be the
address of the transaction we

3764
03:37:07,740 --> 03:37:11,790
want to send to, for a function
call, we can also still populate

3765
03:37:12,000 --> 03:37:16,290
the way that we want to send. So
we can call a function and send

3766
03:37:16,290 --> 03:37:19,260
a value at the same time in
remix has a little drop down

3767
03:37:19,260 --> 03:37:23,190
here for way way Feeny and
ether, we're gonna ignore Feeny

3768
03:37:23,190 --> 03:37:26,400
for now. But of course, we have
our way, great and ether. Again,

3769
03:37:26,760 --> 03:37:30,960
we're one ether is worth this
much way. And this much way, the

3770
03:37:30,960 --> 03:37:33,330
first thing we need to do in
order to make a function payable

3771
03:37:33,360 --> 03:37:36,540
with Aetherium, or any other
native blockchain currency is we

3772
03:37:36,540 --> 03:37:39,330
need to mark the function as
payable. It's this payable

3773
03:37:39,330 --> 03:37:43,170
keyword that makes our font
function red, as opposed to

3774
03:37:43,200 --> 03:37:46,530
having it normal orange, just
like how our wallet can hold

3775
03:37:46,530 --> 03:37:51,000
funds, contract addresses can
hold funds as well, since every

3776
03:37:51,000 --> 03:37:54,420
time you deploy a contract, they
get a contract address, it's

3777
03:37:54,420 --> 03:37:59,280
nearly the exact same as a
wallet address. So both wallets

3778
03:37:59,340 --> 03:38:04,470
and contracts can hold native
blockchain token like Aetherium.

3779
03:38:04,710 --> 03:38:07,530
And you'll see that when we
deploy this later on in the

3780
03:38:07,530 --> 03:38:11,910
lesson, that actually will gain
a balance of Aetherium. Now that

3781
03:38:11,910 --> 03:38:15,480
we have it payable, we can
access this value attribute by

3782
03:38:15,480 --> 03:38:18,930
using one of the global keywords
in solidity with message dot

3783
03:38:18,930 --> 03:38:22,380
value to get how much value
somebody is sending. You use

3784
03:38:22,410 --> 03:38:25,710
message dot value in your
function. Now let's say we want

3785
03:38:25,710 --> 03:38:29,310
to set our message add value to
a certain value of Aetherium.

3786
03:38:29,370 --> 03:38:32,430
Let's say we wanted it to be
let's say we wanted people to

3787
03:38:32,550 --> 03:38:37,320
send at least one whole ether
with all the transactions. Or

3788
03:38:37,320 --> 03:38:40,350
put another way, if they sent
Aetherium, they would need to

3789
03:38:40,350 --> 03:38:43,410
send at least one Aetherium. How
would we implement that? Well,

3790
03:38:43,440 --> 03:38:46,860
we could do something called
require, we would say we want to

3791
03:38:46,860 --> 03:38:53,580
require the message dot value is
greater than one e 18. There's a

3792
03:38:53,580 --> 03:38:59,610
couple of things to unpack here.
One, e 18 is equal to one times

3793
03:38:59,640 --> 03:39:04,050
10 raised to the 18th, which is
also equal to

3794
03:39:04,890 --> 03:39:12,960
112345 678-910-1234 5678. This
is the value in way of one

3795
03:39:12,990 --> 03:39:16,710
Aetherium this much way is one
eath. So if we wanted the

3796
03:39:16,710 --> 03:39:20,130
message dot value to be at least
one eath, or one polygon or

3797
03:39:20,130 --> 03:39:23,940
whatever ranch etc, we would set
it like this require message on

3798
03:39:23,940 --> 03:39:28,710
value is greater than one. This
require keyword is a checker it

3799
03:39:28,710 --> 03:39:33,090
says hey, is message dot value
greater than one. If not, it's

3800
03:39:33,090 --> 03:39:35,880
going to revert, it's going to
do what's called revert with an

3801
03:39:35,880 --> 03:39:40,110
error message. And we can say
didn't send enough, we're gonna

3802
03:39:40,110 --> 03:39:43,770
try deploying this on a
JavaScript VM, deploy Funmi,

3803
03:39:44,100 --> 03:39:47,610
we'll hit Deploy, look at Funmi
we see this fun button is now

3804
03:39:47,610 --> 03:39:52,260
red. If we call Funmi right now,
and we look at the console, you

3805
03:39:52,260 --> 03:39:55,530
can see we actually get an error
here, call it again, we get an

3806
03:39:55,530 --> 03:39:59,520
error, we get an error here, we
know that the air is going to be

3807
03:39:59,610 --> 03:40:04,020
this didn't send enough. So what
we need to do is we need to send

3808
03:40:04,230 --> 03:40:07,860
at least one ether with this fun
transaction, in order for this

3809
03:40:07,860 --> 03:40:11,370
require statement to be
fulfilled. So back up in the

3810
03:40:11,370 --> 03:40:15,240
value section, we can change
this value to one. So that's

3811
03:40:15,240 --> 03:40:20,100
gonna be one ether, or this much
way or this much way. Now we can

3812
03:40:20,100 --> 03:40:23,340
hit fund oh actually needs to be
greater than one.

3813
03:40:23,490 --> 03:40:28,530
So let's send to for example.
Now we'll scroll down. And now

3814
03:40:28,530 --> 03:40:32,280
we'll hit fund. And we see that
that actually passes the require

3815
03:40:32,280 --> 03:40:36,630
statement says if our first
section is false, then go ahead

3816
03:40:36,630 --> 03:40:39,960
and revert with this error. What
is reverting? Revert can be a

3817
03:40:39,960 --> 03:40:42,570
little bit confusing, so I
wouldn't let this section hold

3818
03:40:42,570 --> 03:40:46,530
you back. If it's a little bit
confusing. Revert is when it

3819
03:40:46,530 --> 03:40:49,800
undos any actions that happened
before and send the remaining

3820
03:40:49,800 --> 03:40:53,490
gas back. So what does that
actually look like? Well, let's

3821
03:40:53,490 --> 03:40:59,190
say for example, we had a un
256. Public number. And in our

3822
03:40:59,190 --> 03:41:04,350
fund function, we said number
equals five. If we were to go

3823
03:41:04,350 --> 03:41:06,870
ahead and deploy this, let's
delete our old contract.

3824
03:41:07,920 --> 03:41:11,670
deployed this new contract or
number right now is zero. But if

3825
03:41:11,670 --> 03:41:14,610
we were to call our fund
function number gets set to

3826
03:41:14,610 --> 03:41:19,230
five. However, if we call a fund
and this require isn't met, this

3827
03:41:19,230 --> 03:41:23,670
transaction would revert an
undue setting number to five. So

3828
03:41:23,670 --> 03:41:27,840
let's go ahead and look at our
logs here. We'll keep value zero

3829
03:41:27,870 --> 03:41:31,590
so that our fun function
reverts. We'll call fund will

3830
03:41:31,590 --> 03:41:35,010
see that this transaction failed
because this require end up

3831
03:41:35,010 --> 03:41:38,730
reverting and number is still
zero. So then the question

3832
03:41:38,730 --> 03:41:43,650
becomes, did we actually spend
gas Yes, we spent gas to change

3833
03:41:43,650 --> 03:41:48,030
number to five and then any
remaining gas we would get

3834
03:41:48,030 --> 03:41:52,800
returned by this require for
example, if we had a ton of

3835
03:41:52,890 --> 03:41:56,970
computation here, it On a
computation here, we would have

3836
03:41:56,970 --> 03:42:00,990
need to send a ton of gas with
our fun function. But all the

3837
03:42:00,990 --> 03:42:05,010
extra gas that we send, after
this require gets returned the

3838
03:42:05,010 --> 03:42:07,980
original user after it gets
reverted right here, if reverts

3839
03:42:08,010 --> 03:42:10,710
are a little bit confusing for
you here, don't worry too much

3840
03:42:10,710 --> 03:42:13,650
about it, we'll go over it in
future modules. All you need to

3841
03:42:13,650 --> 03:42:16,830
know right now is that when you
do a require statement, if this

3842
03:42:16,860 --> 03:42:20,130
first section isn't met, the
transaction will be canceled,

3843
03:42:20,190 --> 03:42:23,310
and any prior work will be
undone, and it'll send an error

3844
03:42:23,310 --> 03:42:27,720
message. Cool. Let's delete this
number for now. And we'll delete

3845
03:42:27,720 --> 03:42:30,690
it from the global scope.
There's actually another way to

3846
03:42:30,690 --> 03:42:32,370
do these reverts, which we'll go
over

3847
03:42:32,400 --> 03:42:38,430
later in this contract. So what
we've done so far is great.

3848
03:42:38,760 --> 03:42:43,380
However, we're checking message
dot value in terms of Aetherium,

3849
03:42:43,440 --> 03:42:48,330
we're looking for one whole
Aetherium instead of $50, we

3850
03:42:48,330 --> 03:42:52,020
want to check that message add
value is greater than some

3851
03:42:52,020 --> 03:42:56,550
number like $50. Let's go ahead
and first set the minimum USD

3852
03:42:56,550 --> 03:43:00,600
value we want people to send
along with the fund function, we

3853
03:43:00,600 --> 03:43:04,410
can do that at the top of our
contract, we can say you went to

3854
03:43:04,410 --> 03:43:14,040
56 public minimum USD equals 50.
Now we have some place to check

3855
03:43:14,100 --> 03:43:18,090
for minimum USD, we're going to
update this minimum USD to make

3856
03:43:18,090 --> 03:43:21,300
it more gas efficient and a
little bit. Now that we've set

3857
03:43:21,300 --> 03:43:24,630
our minimum USD, we want to be
able to require the message that

3858
03:43:24,630 --> 03:43:28,620
value is greater than or let's
say greater than or equal to the

3859
03:43:28,620 --> 03:43:34,470
minimum USD. But minimum USD is
in terms of USD and value is in

3860
03:43:34,470 --> 03:43:41,100
terms of Aetherium. So how do we
convert Aetherium to USD, this

3861
03:43:41,130 --> 03:43:44,400
is where Oracle's and chainlink
are going to come into play. The

3862
03:43:44,400 --> 03:43:47,610
USD value of Aetherium is
something that we've assigned

3863
03:43:47,640 --> 03:43:51,690
outside of the blockchain to
Aetherium, or any other layer

3864
03:43:51,690 --> 03:43:54,300
one currency or any other native
smart contract platform

3865
03:43:54,300 --> 03:43:57,750
currency. So in order to get
this value that is outside the

3866
03:43:57,750 --> 03:44:00,990
blockchain, we have to use a
decentralized Oracle network to

3867
03:44:00,990 --> 03:44:05,700
get the price of one ether in
terms of USD. So before we can

3868
03:44:05,700 --> 03:44:08,550
continue on here, let's learn a
little bit more about the

3869
03:44:08,550 --> 03:44:11,040
architecture of these
decentralized Oracle networks

3870
03:44:11,070 --> 03:44:13,800
and the different solutions that
they have. So that we can create

3871
03:44:13,800 --> 03:44:17,220
this Funmi contract in the most
advanced way possible, as we've

3872
03:44:17,220 --> 03:44:20,280
talked about blockchains are
deterministic systems, which

3873
03:44:20,280 --> 03:44:23,310
means that they themselves can't
actually interact with real

3874
03:44:23,310 --> 03:44:26,820
world data and events. They
don't know what the value of an

3875
03:44:26,820 --> 03:44:29,280
Aetherium is, they don't know
what random numbers are. They

3876
03:44:29,280 --> 03:44:31,080
don't know if it's sunny
outside, they don't know the

3877
03:44:31,080 --> 03:44:33,690
temperature, they don't know
who's president, they don't know

3878
03:44:33,720 --> 03:44:37,410
any of this information. These
blockchains also can't do any

3879
03:44:37,440 --> 03:44:40,890
external computation. Maybe you
have some amazing artificial

3880
03:44:40,890 --> 03:44:43,050
intelligence model that you want
to integrate with a smart

3881
03:44:43,050 --> 03:44:46,170
contract. smart contracts by
themselves can't do anything

3882
03:44:46,170 --> 03:44:49,260
with that. As we've mentioned,
this is because blockchains are

3883
03:44:49,260 --> 03:44:52,800
deterministic by design. This is
so that all the nodes can reach

3884
03:44:52,800 --> 03:44:57,090
consensus. If you start adding
variable data or random data, or

3885
03:44:57,090 --> 03:45:00,900
values that returned from an API
call, different nodes could get

3886
03:45:00,900 --> 03:45:03,240
different results, and they
would never be able to reach a

3887
03:45:03,240 --> 03:45:06,360
consensus. This is known as the
smart contract connectivity

3888
03:45:06,360 --> 03:45:10,290
problem, or the Oracle problem.
And this is bad news, because we

3889
03:45:10,290 --> 03:45:13,620
want our smart contracts to be
able to replace traditional

3890
03:45:13,620 --> 03:45:16,980
agreements. And traditional
agreements need data and they

3891
03:45:16,980 --> 03:45:19,260
need to interact with the real
world. So this is where

3892
03:45:19,260 --> 03:45:22,560
chainlink and blockchain,
Oracle's come into place. A

3893
03:45:22,560 --> 03:45:25,620
blockchain Oracle is going to be
any device that interacts with

3894
03:45:25,620 --> 03:45:28,620
the often world to provide
external data or computation to

3895
03:45:28,620 --> 03:45:31,530
smart contracts. However, the
whole story doesn't even in

3896
03:45:31,530 --> 03:45:36,090
there. If we use a centralized
Oracle, we are reintroducing a

3897
03:45:36,090 --> 03:45:39,660
point of failure. We've done all
this work to make our logic

3898
03:45:39,660 --> 03:45:42,570
layer decentralized. But if we
get our data through a

3899
03:45:42,570 --> 03:45:46,290
centralized node or through a
centralized API, we decide we

3900
03:45:46,290 --> 03:45:49,590
want to make the API call
ourselves. We are reintroducing

3901
03:45:49,620 --> 03:45:52,350
these trust assumptions that
we've worked so hard to get rid

3902
03:45:52,350 --> 03:45:55,650
of, we're essentially ruining
the entire purpose of building a

3903
03:45:55,650 --> 03:45:59,010
smart contract. So we don't want
to get our data or do external

3904
03:45:59,010 --> 03:46:03,150
computation through centralized
nodes. Those are bad news. chain

3905
03:46:03,150 --> 03:46:06,840
link is the solution here. chain
link is a decentralized Oracle

3906
03:46:06,840 --> 03:46:10,650
network for bringing data and
external computation into our

3907
03:46:10,650 --> 03:46:13,920
smart contracts. As we mentioned
before, this gives rise to these

3908
03:46:13,950 --> 03:46:17,040
hybrid smart contracts, which
combined on chain and off chain

3909
03:46:17,040 --> 03:46:21,000
to make incredibly feature rich,
powerful applications. chain

3910
03:46:21,000 --> 03:46:23,970
link is a modular, decentralized
Oracle network that can be

3911
03:46:23,970 --> 03:46:27,600
customized to deliver any data
or do any external computation

3912
03:46:27,630 --> 03:46:31,500
that you like. So for example, a
lot of people say, Oh, I can

3913
03:46:31,500 --> 03:46:36,480
just make an HTTPS call to some
API, and we'll be good to go.

3914
03:46:36,870 --> 03:46:40,170
The blockchain nodes can't make
these HTTPS calls, because they

3915
03:46:40,170 --> 03:46:42,390
wouldn't be able to reach
consensus. If they called the

3916
03:46:42,390 --> 03:46:45,780
node at different times, or they
did something else. All the

3917
03:46:45,780 --> 03:46:49,620
consensus would be broken. So
instead, we need a decentralized

3918
03:46:49,620 --> 03:46:52,500
network of chain link Oracle's
to do this, and then in the

3919
03:46:52,500 --> 03:46:56,430
transaction, this network of
nodes will work Turn the data to

3920
03:46:56,430 --> 03:46:59,790
our smart contracts for us. Now
chainlink networks can be

3921
03:46:59,790 --> 03:47:02,730
completely customized to bring
any data or any external

3922
03:47:02,730 --> 03:47:06,540
computation that you want.
However, doing the customization

3923
03:47:06,540 --> 03:47:09,210
can be a little bit extra work,
there are a ton of chainlink

3924
03:47:09,210 --> 03:47:12,060
features that come out of the
box completely decentralized,

3925
03:47:12,090 --> 03:47:14,700
ready to plug and play into your
smart contract applications.

3926
03:47:15,030 --> 03:47:17,040
What are those features, the
first one is going to be

3927
03:47:17,040 --> 03:47:19,260
channeling data feeds, and
that's the one we're actually

3928
03:47:19,260 --> 03:47:21,510
going to be using for
application here. Channeling

3929
03:47:21,510 --> 03:47:24,750
data feeds currently at the time
of recording are powering over

3930
03:47:24,750 --> 03:47:29,040
$50 billion. In the defy world,
the way they work is a network

3931
03:47:29,040 --> 03:47:32,550
of chain link nodes gets data
from different exchanges and

3932
03:47:32,550 --> 03:47:36,300
data providers and brings that
data through a network of

3933
03:47:36,300 --> 03:47:39,030
decentralized chain like notes,
the chain link nodes use a

3934
03:47:39,030 --> 03:47:42,030
median to figure out what the
actual price of the asset is,

3935
03:47:42,120 --> 03:47:45,630
and then deliver that in a
single transaction to what's

3936
03:47:45,630 --> 03:47:48,360
called a reference contract, a
price feed contract or a data

3937
03:47:48,360 --> 03:47:52,020
contract on chain that other
smart contracts can use. And

3938
03:47:52,020 --> 03:47:55,320
then those smart contracts use
that pricing information to

3939
03:47:55,320 --> 03:47:58,560
power their defy application, we
can see an example. We can see

3940
03:47:58,560 --> 03:48:02,340
an example at data dot chain dot
link. And you can change

3941
03:48:02,370 --> 03:48:05,190
networks, you can change price
feeds, you can change a whole

3942
03:48:05,190 --> 03:48:07,560
bunch of different information
to see some of those popular

3943
03:48:07,560 --> 03:48:11,760
price feeds. Let's look at eath
USD for example. On eath USD, we

3944
03:48:11,760 --> 03:48:14,310
can see this whole network of
independent chain link node

3945
03:48:14,310 --> 03:48:17,610
operators that are each getting
different answers for the price

3946
03:48:17,640 --> 03:48:20,790
of eth USD, they're getting
aggregated by the network and

3947
03:48:20,790 --> 03:48:24,240
then delivered on chain, we can
see how often they're updated.

3948
03:48:24,360 --> 03:48:28,410
These ones are updated 4.5
deviation threshold or a few

3949
03:48:28,410 --> 03:48:31,560
hour heartbeat, whichever one
hits. First, we can see when the

3950
03:48:31,560 --> 03:48:35,430
last update was we can see the
number of Oracle responses etc,

3951
03:48:35,940 --> 03:48:39,750
we can see the contract address
directly on chain, we can even

3952
03:48:39,750 --> 03:48:43,650
look at the contract on ether
scan, we can see some of the

3953
03:48:43,650 --> 03:48:46,590
history, we can see all the
responses of the different

3954
03:48:46,590 --> 03:48:49,440
Oracle's. And then at the
bottom, we can see the different

3955
03:48:49,440 --> 03:48:54,390
users and sponsors, keeping this
network up. Similar to

3956
03:48:54,390 --> 03:48:58,620
transaction gas, whenever a node
operator delivers data to a

3957
03:48:58,620 --> 03:49:01,530
smart contract, the chain link
node operators are paid a little

3958
03:49:01,530 --> 03:49:04,470
bit of Oracle gas in the chain
link token. Right now these

3959
03:49:04,470 --> 03:49:07,080
users of the protocol are
sponsoring keeping these feeds

3960
03:49:07,080 --> 03:49:10,200
up and are paying the Oracle gas
associated with delivering this

3961
03:49:10,200 --> 03:49:13,260
data on chain. Here's an
illustration of what the current

3962
03:49:13,260 --> 03:49:15,990
model of these data feeds look
like a network of these chain

3963
03:49:15,990 --> 03:49:19,410
link nodes, each reaches out and
gets the information about an

3964
03:49:19,410 --> 03:49:23,280
asset and then signs the data
with their own private key in a

3965
03:49:23,280 --> 03:49:27,060
single transaction, then, one
node will deliver all the data

3966
03:49:27,090 --> 03:49:29,310
with all the different
signatures to a reference

3967
03:49:29,310 --> 03:49:32,430
contract. If that node doesn't
deliver the data, another node

3968
03:49:32,430 --> 03:49:35,370
will send it instead. Reputation
is incredibly important when

3969
03:49:35,370 --> 03:49:37,920
your chain link node operator if
you miss data updates, if you

3970
03:49:37,920 --> 03:49:40,290
forget to send transactions,
you'll probably be quickly

3971
03:49:40,290 --> 03:49:42,780
kicked off these networks and
have no chance of making any

3972
03:49:42,780 --> 03:49:45,330
more money in the future. These
data feeds are used by some of

3973
03:49:45,330 --> 03:49:49,200
the largest protocols in the
space, such as synthetics, sushi

3974
03:49:49,200 --> 03:49:53,490
swap compound, and Avi, with
several billion dollars each, we

3975
03:49:53,490 --> 03:49:57,150
can take a look at an example
over at Doc's dot chain dot link

3976
03:49:57,180 --> 03:50:00,870
work with EVM contracts, we're
going to hit EVM chains, scroll

3977
03:50:00,870 --> 03:50:04,470
down to data feeds. We'll scroll
down to the solidity section.

3978
03:50:04,500 --> 03:50:08,340
And we can see an example of an
entire contract that uses and

3979
03:50:08,340 --> 03:50:12,090
reads from one of these trending
price feeds. We can even open

3980
03:50:12,120 --> 03:50:17,040
this up and remix and work with
it and remix. It looks like this

3981
03:50:17,040 --> 03:50:20,790
example is reading from a price
feed on COVID. The reason we're

3982
03:50:20,790 --> 03:50:23,280
actually going to use a test net
to see this work is that there's

3983
03:50:23,280 --> 03:50:25,710
a set of chain link nodes
monitoring the test network.

3984
03:50:25,740 --> 03:50:28,740
Just to show you exactly how
this works out. Once we get

3985
03:50:28,740 --> 03:50:30,960
deeper into the course, we'll
show you how to actually run

3986
03:50:30,960 --> 03:50:34,290
tests and work with chain link
nodes without actually being on

3987
03:50:34,290 --> 03:50:36,930
a test net, which will make your
development much faster. But I

3988
03:50:36,930 --> 03:50:40,620
highly recommend walking through
this section along with me so

3989
03:50:40,620 --> 03:50:44,100
that you can see firsthand how
this actually works. So let's go

3990
03:50:44,100 --> 03:50:47,940
ahead and faucets dot chain dot
link slash COVID. We're going to

3991
03:50:47,940 --> 03:50:51,990
switch to the COVID network,
we're going to get some COVID

3992
03:50:51,990 --> 03:50:55,320
eath. But remember, look at the
network flag and use whatever

3993
03:50:55,320 --> 03:50:59,100
network is in the documentation.
So to get some COVID, we're

3994
03:50:59,100 --> 03:51:01,560
going to come to the faucet,
we're going to turn off test

3995
03:51:01,560 --> 03:51:04,860
link, we'll just stay with eath
I'm not a robot,

3996
03:51:06,659 --> 03:51:10,109
and then send request. Once our
COVID Aetherium has reached our

3997
03:51:10,109 --> 03:51:14,039
wallet, we can go ahead and
close we can take a look in our

3998
03:51:14,039 --> 03:51:18,179
wallet and see that we do indeed
have 0.1 eath on Kelvin. Now

3999
03:51:18,209 --> 03:51:22,289
let's go back to our remix,
we'll compile this contract, go

4000
03:51:22,319 --> 03:51:25,679
and deploy this on injected web
three. And again, the reason

4001
03:51:25,679 --> 03:51:28,349
we're going to use injected web
three instead of JavaScript VM

4002
03:51:28,649 --> 03:51:32,639
is that there's no network of
chain link nodes watching our

4003
03:51:32,639 --> 03:51:35,249
little fake JavaScript VM. There
are a network of chain link

4004
03:51:35,249 --> 03:51:39,869
nodes watching the test net. So
we'll scroll down. We'll switch

4005
03:51:39,869 --> 03:51:43,619
contract to the price consumer V
three, and we'll hit Deploy and

4006
03:51:43,619 --> 03:51:47,039
a mass will pop up and after a
brief delay, we can see our

4007
03:51:47,039 --> 03:51:50,099
price feed consumer down here
and we can hit Get the latest

4008
03:51:50,099 --> 03:51:54,179
price which shows us the latest
price of Aetherium in terms of

4009
03:51:54,179 --> 03:51:57,809
USD you may be wondering why the
number looks so weird. That

4010
03:51:57,809 --> 03:52:00,149
seems like a really large number
for the price of Aetherium in

4011
03:52:00,149 --> 03:52:03,329
terms of USD, and this is
because decimals don't actually

4012
03:52:03,329 --> 03:52:06,329
work so well in solidity, and
we'll get to that in a little

4013
03:52:06,329 --> 03:52:09,779
bit. There's a decimals flag
associated with this price feed

4014
03:52:09,779 --> 03:52:13,589
address, that tells us how many
decimals to include with this

4015
03:52:13,589 --> 03:52:16,829
price. It's also in the
documentation. However, I know

4016
03:52:16,829 --> 03:52:19,499
that this one has eight
decimals. So this is saying the

4017
03:52:19,499 --> 03:52:24,719
value of Aetherium right now is
$3,262. It may of course be

4018
03:52:24,719 --> 03:52:27,599
different when you go ahead and
try this. Now there's a number

4019
03:52:27,599 --> 03:52:30,059
of things that happened in this
contract that I'll explain in

4020
03:52:30,059 --> 03:52:32,969
our Funmi example. But if you
want to take a look now and see

4021
03:52:32,969 --> 03:52:35,339
if you can figure out what's
going on, I recommend you do so.

4022
03:52:35,489 --> 03:52:37,769
Price feeds are one of the most
powerful out of the box

4023
03:52:37,799 --> 03:52:41,249
decentralized features, you can
use your smart contract to level

4024
03:52:41,249 --> 03:52:44,039
them up, especially for
decentralized finance. If you're

4025
03:52:44,039 --> 03:52:46,799
looking for different addresses
of different price feeds, you

4026
03:52:46,799 --> 03:52:49,589
can check the contract addresses
section of the documentation,

4027
03:52:49,799 --> 03:52:53,039
choose the network that you
want, and then scroll down and

4028
03:52:53,039 --> 03:52:55,829
look some of the different
addresses of the different price

4029
03:52:55,829 --> 03:52:59,879
feeds. For example, this address
will give you the price of one

4030
03:52:59,879 --> 03:53:02,879
inch token in terms of
Aetherium. This address will

4031
03:53:02,879 --> 03:53:07,709
give you the price of the Apple
stock in terms of USD, and so on

4032
03:53:07,709 --> 03:53:10,529
and so forth. The next
decentralized application right

4033
03:53:10,529 --> 03:53:13,589
out of the box is going to be
channeling VRF or channeling

4034
03:53:13,619 --> 03:53:17,189
verifiable random dysfunction.
Once we do our lottery example a

4035
03:53:17,189 --> 03:53:20,189
little bit later, we'll talk
about how randomness can be

4036
03:53:20,189 --> 03:53:22,979
manipulated in blockchain.
blockchains are deterministic

4037
03:53:22,979 --> 03:53:25,919
systems, which by definition
means that they can't have

4038
03:53:25,919 --> 03:53:28,799
randomness. If you can determine
what a random number is, it's

4039
03:53:28,799 --> 03:53:31,499
not really random anymore, is
it? So we need to wait to get a

4040
03:53:31,499 --> 03:53:34,019
provably random number by
looking outside of the

4041
03:53:34,019 --> 03:53:37,019
blockchain and Oracle's are
perfectly positioned to do

4042
03:53:37,049 --> 03:53:40,019
exactly that. chainlink
verifiable randomness function

4043
03:53:40,049 --> 03:53:42,839
is a way to get provably a
random number into our smart

4044
03:53:42,839 --> 03:53:46,109
contract to guarantee fairness
and guarantee randomness of

4045
03:53:46,109 --> 03:53:50,309
applications. Many protocols
like pool together x infinity,

4046
03:53:50,609 --> 03:53:54,479
ether cards, avocado cheese and
more use channeling VRF for

4047
03:53:54,479 --> 03:53:58,559
lotteries, randomizing NF T's
for gaming and for more, we're

4048
03:53:58,559 --> 03:54:01,199
going to do an example of
channeling VRF in a later

4049
03:54:01,199 --> 03:54:03,809
section. Once we get to the
lottery section, if you want to

4050
03:54:03,809 --> 03:54:06,299
see if you can play with the
randomness yourself right now, I

4051
03:54:06,299 --> 03:54:09,659
recommend you go into Doc's
chain link EVM chains, and

4052
03:54:09,659 --> 03:54:12,509
scroll down to get a random
number. And this will teach you

4053
03:54:12,509 --> 03:54:15,449
how to get a provably random
number into your applications.

4054
03:54:15,539 --> 03:54:18,929
The next decentralized out of
the box feature of chain link is

4055
03:54:18,959 --> 03:54:22,229
chain like keepers, which is
decentralized event driven

4056
03:54:22,259 --> 03:54:25,589
execution. As we've seen, in
order to kick off some type of

4057
03:54:25,589 --> 03:54:29,279
transaction, somebody needs to
spend the gas and somebody needs

4058
03:54:29,279 --> 03:54:32,039
to sit down and hit the go
button or hit the transact

4059
03:54:32,039 --> 03:54:34,649
button or hit the sun. But this
is obviously a centralized

4060
03:54:34,649 --> 03:54:37,199
vector. If you have a
decentralized application that

4061
03:54:37,199 --> 03:54:40,439
needs to run at specific times,
or after specific events are

4062
03:54:40,439 --> 03:54:42,929
triggered. Channeling keepers
are the solution to this

4063
03:54:42,959 --> 03:54:45,959
channeling keepers are chain
link nodes that listen to a

4064
03:54:45,959 --> 03:54:48,749
registration contract for
different events that you

4065
03:54:48,749 --> 03:54:52,379
specify to fire. Maybe you say
every 10 minutes, you want to do

4066
03:54:52,379 --> 03:54:55,679
something or once a week do
something or if the price of

4067
03:54:55,679 --> 03:54:59,129
some acid hits some number, or
maybe a liquidity pool is at a

4068
03:54:59,129 --> 03:55:02,429
certain level, whatever event
that you want to code, you

4069
03:55:02,429 --> 03:55:05,789
absolutely can the chain link
nodes constantly listen for

4070
03:55:05,789 --> 03:55:08,849
these triggers to happen and
check the different contracts

4071
03:55:08,879 --> 03:55:12,539
for these triggers. Once a
trigger returns true, the chain

4072
03:55:12,539 --> 03:55:15,599
link nodes will then perform
whatever action that you tell

4073
03:55:15,659 --> 03:55:18,389
the chain link nodes to do,
we're also not going to go over

4074
03:55:18,419 --> 03:55:21,029
the chain link keepers examples
right now, because we're going

4075
03:55:21,029 --> 03:55:23,519
to get to them in a later
module. However, if you want to

4076
03:55:23,519 --> 03:55:26,069
try them out, go to Doc's
touching that link slash

4077
03:55:26,069 --> 03:55:30,089
Aetherium. Going and go to
making compatible contracts and

4078
03:55:30,089 --> 03:55:32,219
feel free to read the
documentation. Try it out

4079
03:55:32,219 --> 03:55:35,159
yourself. The last out of the
box feature of chain link is the

4080
03:55:35,159 --> 03:55:38,669
most customizable, but also the
hardest to get correct end to

4081
03:55:38,669 --> 03:55:41,759
end reliability is the ultimate
promise of our smart contracts.

4082
03:55:41,789 --> 03:55:45,449
And we want and need them to be
able to do anything, we want to

4083
03:55:45,449 --> 03:55:49,949
be able to take any input and
get any output making HTTP GET

4084
03:55:50,039 --> 03:55:53,639
HTTP POST request is an easy way
to customize our chain link

4085
03:55:53,639 --> 03:55:56,909
nodes to be able to do anything.
Remember how we talked about

4086
03:55:56,939 --> 03:56:00,659
making API calls that blockchain
nodes themselves can do that?

4087
03:56:00,809 --> 03:56:04,079
Well, chain link nodes can do
that chain link nodes can make

4088
03:56:04,079 --> 03:56:07,589
direct requests to any API that
you specify. In order to do

4089
03:56:07,589 --> 03:56:11,399
this, you both have to choose
the chain link node and the URL

4090
03:56:11,429 --> 03:56:14,729
slash data to send the request
to this is a little bit trickier

4091
03:56:14,819 --> 03:56:18,779
than chain link VRF keepers or
price feeds because you then

4092
03:56:18,779 --> 03:56:21,419
have to be responsible for
creating the chain link network

4093
03:56:21,449 --> 03:56:23,999
that gets data from many
different chain link nodes and

4094
03:56:23,999 --> 03:56:25,229
many different data providers.

4095
03:56:25,259 --> 03:56:29,039
But let's look at an example in
remix anyways. For this section,

4096
03:56:29,039 --> 03:56:31,439
feel free to just watch it since
we are working with a test net

4097
03:56:31,439 --> 03:56:34,109
here. And test nets, as we've
seen, can take a little bit of

4098
03:56:34,109 --> 03:56:36,629
time. As long as you're familiar
with what this process looks

4099
03:56:36,629 --> 03:56:39,149
like. That's good enough. You
don't actually have to try it if

4100
03:56:39,149 --> 03:56:42,989
you don't want to. So we'll open
up and remix will read through.

4101
03:56:43,319 --> 03:56:46,319
It looks like this example is on
the COVID network. So we'll go

4102
03:56:46,319 --> 03:56:49,979
ahead and compile API consumer.
We're gonna go ahead and deploy

4103
03:56:50,129 --> 03:56:53,159
on the injected web three, we're
going to make sure that we're

4104
03:56:53,159 --> 03:56:57,059
back on the COVID test network.
We're going to scroll down. And

4105
03:56:57,059 --> 03:56:59,819
we're going to change the
contract to the API consumer.

4106
03:56:59,969 --> 03:57:02,459
And we're going to go ahead and
hit Deploy, we're going to

4107
03:57:02,459 --> 03:57:06,239
deploy this contract to the
COVID. Test net. And now we can

4108
03:57:06,329 --> 03:57:09,449
call this function called
Request volume data to actually

4109
03:57:09,449 --> 03:57:12,779
make an API call. Now, like I
mentioned before, whenever we

4110
03:57:12,779 --> 03:57:15,929
request data from a chain link
node, we have to pay a little

4111
03:57:15,929 --> 03:57:20,459
bit of Oracle gas, or link
token, in order to pay some link

4112
03:57:20,459 --> 03:57:23,609
token, we're going to need to
have link token in our API

4113
03:57:23,609 --> 03:57:26,159
consumer contract. This is
what's known as the basic

4114
03:57:26,159 --> 03:57:29,189
request and receive model to get
link token, we go back to our

4115
03:57:29,189 --> 03:57:32,729
faucet, and this time, we'll
select 10 test link for our

4116
03:57:32,729 --> 03:57:35,339
contract. Let's go ahead and
verify that we're human. And

4117
03:57:35,339 --> 03:57:38,819
we'll hit Send Request. This
time, instead of sending us

4118
03:57:38,819 --> 03:57:42,779
Aetherium. They're sending us 10
test link, which is what's known

4119
03:57:42,779 --> 03:57:47,489
as an ERC 20 token. Or more
accurately, in ERC 677 We'll get

4120
03:57:47,489 --> 03:57:50,699
to understanding that a little
bit later, we can see the asset

4121
03:57:50,759 --> 03:57:54,239
in our Metamask. By importing
the token, in order to get the

4122
03:57:54,239 --> 03:57:57,239
token, we're going to come back
to the documentation. And we're

4123
03:57:57,239 --> 03:58:02,549
going to look up link token
contracts like that, we're going

4124
03:58:02,549 --> 03:58:05,699
to go to the network that we
just got the tokens on, which

4125
03:58:05,699 --> 03:58:10,829
for us was COVID. We're going to
copy this address, we're gonna

4126
03:58:10,829 --> 03:58:14,969
go to Metamask, hit import
tokens, paste that address, and

4127
03:58:14,969 --> 03:58:19,289
hit add custom token, and then
import tokens. And now we can

4128
03:58:19,289 --> 03:58:24,029
see in our account one, we both
have Aetherium and 10. Link, now

4129
03:58:24,029 --> 03:58:27,869
that we have our link or Oracle
gas, we're going to send it to

4130
03:58:27,869 --> 03:58:31,169
our API consumer, we're going to
copy the address of the API

4131
03:58:31,169 --> 03:58:36,239
consumer, open up our meta mask,
we're gonna hit send, paste the

4132
03:58:36,239 --> 03:58:41,219
address of our contract, switch
the asset to link. For now we'll

4133
03:58:41,219 --> 03:58:46,589
just send 0.2 link. We'll hit
next, next. And we'll hit

4134
03:58:46,589 --> 03:58:49,979
Confirm. And we'll wait for this
transaction to go through. I

4135
03:58:49,979 --> 03:58:54,569
chose 0.2 Link, because in this
contract, there's a fee

4136
03:58:54,719 --> 03:58:59,159
character, which tells us how
much making an API call for this

4137
03:58:59,159 --> 03:59:03,059
is going to cost. This one is
actually 0.1 link, I send 0.2.

4138
03:59:03,059 --> 03:59:05,819
Just in case, we want to make
that API call twice. Everything

4139
03:59:05,819 --> 03:59:08,189
that's going on in this function
will explain in a little bit

4140
03:59:08,189 --> 03:59:10,559
later section. But for now, I
just want to show you what it

4141
03:59:10,559 --> 03:59:13,319
looks like to do is, once we
send the link to our contract,

4142
03:59:13,769 --> 03:59:18,089
we can first check to see what
the volume is volume is zero, we

4143
03:59:18,089 --> 03:59:21,329
want to get the volume of the
last 24 hours of Aetherium

4144
03:59:21,389 --> 03:59:25,229
asset, we're going to be calling
this API which has a ton of raw

4145
03:59:25,229 --> 03:59:29,159
data, including one in specific
called volume over the last 24

4146
03:59:29,159 --> 03:59:31,769
hours, which can be this number
right here. Say we wanted to get

4147
03:59:31,769 --> 03:59:35,459
this into our contract from this
API, we're going to make an HTTP

4148
03:59:35,459 --> 03:59:39,749
GET call to this API. And what's
going to happen is we're going

4149
03:59:39,749 --> 03:59:43,589
to make the request in one
transaction. And in a second

4150
03:59:43,589 --> 03:59:46,859
transaction, the chain link node
is gonna return the value and

4151
03:59:46,859 --> 03:59:51,329
store it in this volume variable
in the global scope. So let's go

4152
03:59:51,329 --> 03:59:55,139
ahead and hit request volume
data Metamask gonna pop up,

4153
03:59:55,379 --> 03:59:57,989
we're going to go ahead and hit
Confirm. And you'll notice right

4154
03:59:57,989 --> 04:00:01,349
away volume doesn't update. This
is again, because we actually

4155
04:00:01,349 --> 04:00:05,189
need to wait two transactions,
we're sending a transaction for

4156
04:00:05,189 --> 04:00:08,429
the request. And then in a
second transaction, the chain

4157
04:00:08,429 --> 04:00:11,609
link node is actually going to
respond. And after a slight

4158
04:00:11,609 --> 04:00:14,759
delay, the chain link node has
indeed responded with the result

4159
04:00:14,759 --> 04:00:18,029
of making that API call back to
our contract. We'll go over this

4160
04:00:18,029 --> 04:00:20,759
process a little bit more in
depth in later sections. The

4161
04:00:20,759 --> 04:00:24,509
reason that I wanted to show you
specifically the API calls, is

4162
04:00:24,509 --> 04:00:27,119
because we're going to show you
a real life example of how to

4163
04:00:27,119 --> 04:00:29,909
use chain link VRF and chain the
keepers in a later lesson.

4164
04:00:32,790 --> 04:00:35,700
Now I know we've already gone
over a ton. So let's do a quick

4165
04:00:35,730 --> 04:00:39,030
review. In order to send
Aetherium or whatever native

4166
04:00:39,030 --> 04:00:43,590
blockchain token with a function
need to mark it as payable. If

4167
04:00:43,590 --> 04:00:46,380
you need something in your
contract to happen, and you want

4168
04:00:46,410 --> 04:00:49,500
the whole transaction to fail.
If that doesn't happen, you can

4169
04:00:49,500 --> 04:00:52,890
use a require statement. To get
the Aetherium or native

4170
04:00:52,890 --> 04:00:55,920
blockchain token value of a
transaction, you can use the

4171
04:00:55,920 --> 04:00:59,430
global keyword message dot
value. chain link is a

4172
04:00:59,430 --> 04:01:02,130
technology for getting external
data and doing external

4173
04:01:02,130 --> 04:01:05,760
computation in a decentralized
context for our smart contracts.

4174
04:01:06,030 --> 04:01:09,450
Channeling data feeds or price
feeds are ways to read pricing

4175
04:01:09,450 --> 04:01:12,870
information or other pieces of
data from the real world that's

4176
04:01:12,870 --> 04:01:15,870
already aggregated and
decentralized for us, channeling

4177
04:01:15,870 --> 04:01:19,410
VRF is a way to get provably
random numbers from the real

4178
04:01:19,410 --> 04:01:22,320
world into our smart contracts.
Channeling keepers are a way to

4179
04:01:22,320 --> 04:01:26,310
do decentralized event driven
computation. We can set some

4180
04:01:26,310 --> 04:01:29,700
trigger say if this trigger hits
do something and we get to

4181
04:01:29,700 --> 04:01:32,310
define what the trigger is and
what to do something is

4182
04:01:32,400 --> 04:01:36,150
channeling any API's is the
ultimate customization of

4183
04:01:36,150 --> 04:01:39,510
channeling nodes and allows us
to connect to anything on the

4184
04:01:39,510 --> 04:01:42,390
planet. To make this one
production ready. We have to do

4185
04:01:42,390 --> 04:01:44,700
the most work because it doesn't
come already with a

4186
04:01:44,700 --> 04:01:47,730
decentralized Oracle network,
like chaining the keepers and

4187
04:01:47,730 --> 04:01:50,550
price feeds. We'll learn more
about these channeling services

4188
04:01:50,640 --> 04:01:56,640
as we continue in this course.
Now in order for us to figure

4189
04:01:56,640 --> 04:02:00,450
out if our message dot value is
actually greater than the

4190
04:02:00,450 --> 04:02:03,990
minimum USD that we set, we
actually have to convert our

4191
04:02:03,990 --> 04:02:09,900
message dot value from its layer
one slash Aetherium to the USD

4192
04:02:09,930 --> 04:02:12,780
equivalent. So how are we
actually going to do that? Well,

4193
04:02:12,780 --> 04:02:15,510
first, we're gonna need to get
the price of Aetherium, or

4194
04:02:15,510 --> 04:02:18,390
Phantom, or Avalanche or
whatever layer, one blockchain

4195
04:02:18,420 --> 04:02:21,420
that we're working with. So
let's create a function to get

4196
04:02:21,420 --> 04:02:24,270
that price to get that
conversion rate. So we'll do

4197
04:02:24,270 --> 04:02:29,430
function, get price, and this is
going to be the function that we

4198
04:02:29,430 --> 04:02:33,120
use to get the price of the room
in terms of USD, so we can

4199
04:02:33,120 --> 04:02:37,230
convert our message dot value to
USD. And then we're also going

4200
04:02:37,230 --> 04:02:45,570
to do a function called Get
conversion rate. These are both

4201
04:02:45,570 --> 04:02:47,880
going to be public functions, so
that we can go ahead and call

4202
04:02:47,880 --> 04:02:50,100
them and test them and do
whatever we want with them. So

4203
04:02:50,100 --> 04:02:52,530
in order to get the price, we're
going to have to use one of

4204
04:02:52,530 --> 04:02:56,400
these chain link data feeds to
get the pricing information. And

4205
04:02:56,400 --> 04:03:00,810
we can look right here at this
contract to see what using one

4206
04:03:00,810 --> 04:03:03,390
of these channeling price feeds
looks like. What we're actually

4207
04:03:03,390 --> 04:03:06,000
doing when we're interacting
with this channeling price feed

4208
04:03:06,030 --> 04:03:09,690
is we're actually reading from
one of these contracts, there's

4209
04:03:09,690 --> 04:03:12,600
a contract out there called the
aggregator contract that has a

4210
04:03:12,600 --> 04:03:15,870
function called latest round
data, which returns a whole

4211
04:03:15,870 --> 04:03:20,820
bunch of data. But namely, this
int price. And this in price is

4212
04:03:20,820 --> 04:03:24,180
what we are interested in. Let's
look at our get price function

4213
04:03:24,210 --> 04:03:27,300
and figure out how do we
actually call this since this is

4214
04:03:27,300 --> 04:03:30,870
an instance of us interacting
with a contract outside of our

4215
04:03:30,870 --> 04:03:34,680
project, we're going to need two
things. What are those two

4216
04:03:34,680 --> 04:03:35,220
things,

4217
04:03:35,280 --> 04:03:39,480
we're going to need the ABI of
the contract, and also the

4218
04:03:39,480 --> 04:03:43,680
address of the contract. So the
address of the contract is going

4219
04:03:43,680 --> 04:03:46,830
to be easy, we can get the
address of the contract from the

4220
04:03:46,830 --> 04:03:50,010
contract address this section of
the chain link data feeds. Let's

4221
04:03:50,010 --> 04:03:56,580
scroll on down to bank B. And we
can find the eath USD address on

4222
04:03:56,580 --> 04:03:59,160
Rigby and we'll create this
contract so that it works on

4223
04:03:59,160 --> 04:04:01,650
Rinkeby. So we're going to grab
this address, we're going to

4224
04:04:01,650 --> 04:04:05,370
copy it. And we're going to move
back to our to our code here.

4225
04:04:05,400 --> 04:04:08,070
And we're going to paste the
address here. So great, we have

4226
04:04:08,070 --> 04:04:10,410
the address. Now we have the
address of the other contract

4227
04:04:10,410 --> 04:04:13,110
that we don't want to interact.
Now, how do we get the ABI?

4228
04:04:13,290 --> 04:04:16,290
Well, what we did before was
simple storage was we imported

4229
04:04:16,320 --> 04:04:19,260
the entire contract into our
code here. That's something that

4230
04:04:19,260 --> 04:04:22,590
we could do. But that's actually
a lot of code. So what's

4231
04:04:22,590 --> 04:04:25,110
something that we could do
instead, remember, if we're

4232
04:04:25,110 --> 04:04:28,530
looking at remix, and we look at
one of the contracts that we

4233
04:04:28,530 --> 04:04:33,150
compiled before, the ABI is
really just kind of this list of

4234
04:04:33,180 --> 04:04:36,270
the different functions and
interactions you can have with a

4235
04:04:36,270 --> 04:04:39,570
contract. The ABI itself doesn't
actually need to include any of

4236
04:04:39,570 --> 04:04:42,150
the logic, it just needs to
include, hey, here are the

4237
04:04:42,150 --> 04:04:45,240
different functions that you can
call, for example, in this

4238
04:04:45,240 --> 04:04:48,060
contract, we can call fund, we
have get conversion rate, we

4239
04:04:48,060 --> 04:04:50,910
have get price, they're not
implemented yet, but they will

4240
04:04:50,910 --> 04:04:53,250
be eventually now there
technically is another way to

4241
04:04:53,250 --> 04:04:57,360
interact with contracts without
the API. But for now, we're just

4242
04:04:57,360 --> 04:05:00,060
going to ignore that. So how can
we get the API, there's a

4243
04:05:00,060 --> 04:05:03,390
concept in solidity called an
interface. And let's look at an

4244
04:05:03,390 --> 04:05:07,800
example of an interface. If we
go to github.com/smart, contract

4245
04:05:07,800 --> 04:05:11,940
kits, chainlink, we can see a
number of different contracts in

4246
04:05:11,940 --> 04:05:17,280
the chainlink repository, we can
go to contracts, src, V 0.8,

4247
04:05:17,670 --> 04:05:22,080
interfaces, and we'll go to
aggregator v3 interface, dot

4248
04:05:22,080 --> 04:05:25,560
soul. And if we look at the
solidity in here, we can see a

4249
04:05:25,560 --> 04:05:28,470
whole bunch of function
declarations, but none of the

4250
04:05:28,470 --> 04:05:32,340
logic is actually implemented in
this. This is what's known as an

4251
04:05:32,340 --> 04:05:36,840
interface. If we compile this,
we'll actually get the ABI of a

4252
04:05:36,840 --> 04:05:40,080
contract, because it defines all
the different ways we can

4253
04:05:40,080 --> 04:05:43,350
interact with the contract. It
doesn't actually say, what these

4254
04:05:43,350 --> 04:05:46,440
functions do, which is fine,
though, because we don't need to

4255
04:05:46,440 --> 04:05:49,290
know what the functions actually
do, those are going to be stored

4256
04:05:49,560 --> 04:05:54,120
in the contract. So what we can
do is we can grab this interface

4257
04:05:54,450 --> 04:05:58,050
from the code and paste it into
our remix. Now hold on, if

4258
04:05:58,050 --> 04:06:00,660
you're following along, you
don't have to copy paste this

4259
04:06:00,660 --> 04:06:02,820
with me, because I'm going to
show you an easier way in just a

4260
04:06:02,820 --> 04:06:05,550
second. So for now, feel free to
go ahead and just watch. But

4261
04:06:05,550 --> 04:06:09,240
once we have this interface
aggregator v3 interface, we can

4262
04:06:09,240 --> 04:06:14,610
now use this to make API calls.
So now we could say, aggregator

4263
04:06:14,610 --> 04:06:19,950
v3 interface at this address.
And the combination of these

4264
04:06:19,950 --> 04:06:24,360
two, give us that aggregator v3
contract with whatever code is

4265
04:06:24,360 --> 04:06:27,480
here. If at this contract
address is aggregator v3

4266
04:06:27,510 --> 04:06:30,750
interfaces valid, we can do
something like dot version.

4267
04:06:31,950 --> 04:06:34,770
Let's look at this interface. Is
there a version function? There

4268
04:06:34,770 --> 04:06:39,360
sure is. So that means we can
call the version function on

4269
04:06:39,450 --> 04:06:42,300
this contract. So let's actually
go ahead and copy this into a

4270
04:06:42,300 --> 04:06:45,900
different section. I'm going to
create a new function called Get

4271
04:06:45,900 --> 04:06:50,130
version just to illustrate this.
I'm going to be public. It's

4272
04:06:50,130 --> 04:06:55,050
going to be a view and it's
going to return the UN 256 and

4273
04:06:55,080 --> 04:06:58,020
We're gonna split it up into two
steps here. We're gonna say

4274
04:06:58,020 --> 04:07:04,320
aggregate tour, v3 interface,
price feed. So we're creating a

4275
04:07:04,770 --> 04:07:10,410
variable of type aggregator v3
interface equals aggregator v3

4276
04:07:10,410 --> 04:07:18,540
interface at this address. And
then we're going to return price

4277
04:07:18,540 --> 04:07:22,020
feed that version. Now I'm going
to go ahead and deploy this

4278
04:07:22,020 --> 04:07:25,290
contract to Rigby just to show
you what this git version is

4279
04:07:25,290 --> 04:07:28,080
going to return. But you don't
have to follow along here if you

4280
04:07:28,080 --> 04:07:30,360
don't want because again, we're
working with the test net, you

4281
04:07:30,360 --> 04:07:33,120
can just watch if you'd like for
this section, we're going to

4282
04:07:33,120 --> 04:07:36,180
test a little bit more sparse.
Since we're going to be mainly

4283
04:07:36,180 --> 04:07:38,820
using the test net, since we're
going to be working with an

4284
04:07:38,820 --> 04:07:41,730
actual chain link Oracle
network, once you move over to

4285
04:07:41,730 --> 04:07:45,090
hard hat, and with JavaScript,
all this testing locally will be

4286
04:07:45,090 --> 04:07:47,910
a lot easier and a lot faster,
you're more than welcome to go

4287
04:07:47,910 --> 04:07:50,460
ahead and fiddle and try and
test a lot of this stuff as we

4288
04:07:50,460 --> 04:07:53,700
go along. But just know that it
might take a little bit longer

4289
04:07:53,700 --> 04:07:55,380
to do some of the testing on the
test net,

4290
04:07:55,530 --> 04:07:58,020
let's delete that last funding
contract, we're going to deploy

4291
04:07:58,020 --> 04:08:00,780
this one, we're going to scroll
up, we're going to switch to

4292
04:08:00,810 --> 04:08:05,460
injected web three, we're going
to switch from COVID to rink B.

4293
04:08:05,760 --> 04:08:08,430
And the reason we want to make
sure we're on rink beam is

4294
04:08:08,430 --> 04:08:12,120
because this address is specific
to rink B, the contract that

4295
04:08:12,120 --> 04:08:15,150
we're looking to interact with
might not be at this address on

4296
04:08:15,150 --> 04:08:17,970
every single chain, we want to
make sure we're on the rink B

4297
04:08:17,970 --> 04:08:20,550
chain for this, because of some
other contract is there on the

4298
04:08:20,550 --> 04:08:23,670
different chain, this version
function obviously won't exist,

4299
04:08:23,850 --> 04:08:26,790
and this function could error.
So let's go ahead, we're gonna

4300
04:08:26,790 --> 04:08:30,840
find me, we're going to deploy
this to the rink V chain. Again,

4301
04:08:31,170 --> 04:08:33,210
you don't have to follow along
with me here, you can just

4302
04:08:33,210 --> 04:08:36,750
watch. And once that contract
has been deployed, we now have a

4303
04:08:36,750 --> 04:08:39,090
view function called Get
version. And we can see it's

4304
04:08:39,090 --> 04:08:42,540
returning the variable for
showing us that this is the

4305
04:08:42,540 --> 04:08:47,190
fourth version of a price feed.
So this is a really easy way for

4306
04:08:47,190 --> 04:08:50,700
us to interact with contracts
that exist. Outside of our

4307
04:08:50,700 --> 04:08:53,430
project, we use one of these
interfaces, which can get

4308
04:08:53,430 --> 04:08:57,450
compiled down to the API, and
then combine that ABI with the

4309
04:08:57,450 --> 04:09:00,570
address to call a function. As
we work with these interfaces

4310
04:09:00,570 --> 04:09:03,600
more and more, they'll start to
make more and more sense. So if

4311
04:09:03,600 --> 04:09:05,760
it's a little confusing to you
right now, don't get

4312
04:09:05,760 --> 04:09:08,010
discouraged, the more you work
with it, the easier it will

4313
04:09:08,010 --> 04:09:13,890
become. Now, though, now that we
know how to call these functions

4314
04:09:13,890 --> 04:09:17,460
in here, we can start working
with this interface. However, as

4315
04:09:17,460 --> 04:09:19,560
you know, if we have a whole
bunch of interfaces, we're gonna

4316
04:09:19,560 --> 04:09:21,750
have to stick a whole bunch of
interfaces at the top of our

4317
04:09:21,750 --> 04:09:25,320
code, which looks pretty ugly.
What's a better way for us to do

4318
04:09:25,320 --> 04:09:29,700
this? Well, before we used
import, right, we imported from

4319
04:09:29,940 --> 04:09:34,110
simple storage. That's all for
this one, what we could do is we

4320
04:09:34,110 --> 04:09:38,820
could import from an array gay
Tore v3 interface. That's all,

4321
04:09:39,000 --> 04:09:42,030
we can go ahead and create a new
contract with this aggregator v3

4322
04:09:42,030 --> 04:09:46,890
interface. Or what we can do is
we can import this directly from

4323
04:09:46,890 --> 04:09:50,010
GitHub. If we go back to the
documentation of these chainlink

4324
04:09:50,010 --> 04:09:53,940
data feeds go to using data
feeds, we scroll down, we see at

4325
04:09:53,940 --> 04:09:57,600
the top, we have this import
statement, import at chain link

4326
04:09:57,600 --> 04:10:01,890
slash contracts slash SFC visa
right interfaces aggregator v3

4327
04:10:01,890 --> 04:10:07,050
interface, this, this import is
has the same path setup as the

4328
04:10:07,050 --> 04:10:10,920
GitHub repository for the chain
link code, instead of us

4329
04:10:10,950 --> 04:10:14,820
directly adding all the code
right into our remix, what we

4330
04:10:14,820 --> 04:10:18,900
can do instead is we can import
directly from GitHub, or what's

4331
04:10:18,900 --> 04:10:22,710
called an NPM package. Remix is
smart enough to know that at

4332
04:10:22,710 --> 04:10:26,640
chain link slash contracts, is
referring to the NPM package at

4333
04:10:26,640 --> 04:10:29,670
chain link slash contracts,
we'll talk about NPM, a little

4334
04:10:29,670 --> 04:10:32,880
bit in the future, it's what's
known as a package manager, and

4335
04:10:32,880 --> 04:10:35,760
can keep versions of different
contracts for us to directly

4336
04:10:35,760 --> 04:10:39,390
import into our code bases at
chain link slash contracts is

4337
04:10:39,390 --> 04:10:43,350
created directly from the
chainlink GitHub repository. So

4338
04:10:43,350 --> 04:10:47,220
remix downloads this code from
NPM, which is created from this

4339
04:10:47,220 --> 04:10:50,820
GitHub. So now we know that if
we import at chain link slash

4340
04:10:50,820 --> 04:10:54,960
contracts, src, V 0.8 interfaces
aggregator v3 interface dot

4341
04:10:54,960 --> 04:10:59,130
soul, this is the same as if we
had just stuck this whole

4342
04:10:59,130 --> 04:11:02,520
contract right at the top of our
funding contract, which makes

4343
04:11:02,520 --> 04:11:05,670
our code look a lot nicer. And
now we have this aggregator v3

4344
04:11:05,670 --> 04:11:11,010
interface that we can work with.
Okay, great. So now that we have

4345
04:11:11,010 --> 04:11:14,190
a minimalistic interface, which
will give us the API, how do we

4346
04:11:14,190 --> 04:11:17,070
actually go ahead and get the
price here? Well, documentation

4347
04:11:17,100 --> 04:11:19,380
has a good example, if you want
to play with it and try to

4348
04:11:19,380 --> 04:11:21,870
reverse engineer it as well.
Here's how we're going to do it.

4349
04:11:21,990 --> 04:11:25,740
In our code. We're going to
create an aggregator v3

4350
04:11:25,740 --> 04:11:32,070
interface object called price
feed an aggregator v3 variable

4351
04:11:32,190 --> 04:11:36,150
called price feed, which is
going to equal to aggregator v3

4352
04:11:36,150 --> 04:11:41,910
interface contract at address
this address exactly the same as

4353
04:11:41,910 --> 04:11:45,330
what we're doing down here.
We're assuming a contract at

4354
04:11:45,330 --> 04:11:48,300
this address is going to have
all the functionality of this

4355
04:11:48,300 --> 04:11:51,810
aggregator v3 interface, which
again, means it has this

4356
04:11:51,810 --> 04:11:54,630
decimals function, this
description function version,

4357
04:11:54,660 --> 04:11:57,960
get round data. And the
important one latest round data,

4358
04:11:57,990 --> 04:12:01,230
which has the latest price at
this answer piece, what we can

4359
04:12:01,230 --> 04:12:04,470
do now is we can call that
latest round data function on

4360
04:12:04,470 --> 04:12:08,970
the price feed. So we'll say
price feed dot latest round

4361
04:12:09,540 --> 04:12:12,630
data. Now if we look at the
interface, we see that this

4362
04:12:12,630 --> 04:12:16,380
latest round data actually
doesn't return one variable, it

4363
04:12:16,380 --> 04:12:20,190
returns a whole bunch of
different variables. And that's

4364
04:12:20,190 --> 04:12:22,980
what we're going to return in
our contract. So we're going to

4365
04:12:22,980 --> 04:12:27,960
put these parentheses, and we're
going to say, you went at round

4366
04:12:27,960 --> 04:12:30,720
ID, we can even look right at
the documentation to see what

4367
04:12:30,720 --> 04:12:34,410
else it returns int price, you
went,

4368
04:12:36,000 --> 04:12:45,450
you went started out, you went
timestamp. And then you went ad,

4369
04:12:45,930 --> 04:12:51,120
answered and round. Now there's
a lot of code here. Since this

4370
04:12:51,120 --> 04:12:54,840
function returns so many
different variables, we have to

4371
04:12:54,870 --> 04:12:57,960
set something up to capture
them. However, all we care about

4372
04:12:57,990 --> 04:13:01,140
is price. We don't care about
round Id started at timestamp or

4373
04:13:01,140 --> 04:13:03,930
answered in round. So what we
can do is just remove them and

4374
04:13:03,930 --> 04:13:04,890
just leave the commas.

4375
04:13:10,560 --> 04:13:15,180
Now we have int price equals
price feed that latest round

4376
04:13:15,180 --> 04:13:19,920
data. The reason that price is
an int 256. And not a un 256 is

4377
04:13:19,920 --> 04:13:23,070
because some prices or some data
feeds could be negative here, so

4378
04:13:23,070 --> 04:13:26,250
that it's an int 256. So it can
stay flexible. Now that we have

4379
04:13:26,250 --> 04:13:31,650
the price, this is going to be
price of eath in terms of USD.

4380
04:13:32,250 --> 04:13:35,790
And we saw an example of this
before, it was around 3000. And

4381
04:13:35,790 --> 04:13:39,120
it returned this number because
solidity doesn't work with

4382
04:13:39,120 --> 04:13:41,670
decimals for a number of
reasons. But we just need to

4383
04:13:41,670 --> 04:13:44,820
know that there are eight
decimal places associated with

4384
04:13:44,820 --> 04:13:47,460
this price feed. If you want to
double check how many decimals

4385
04:13:47,460 --> 04:13:50,190
there are, this contract has a
decimal function that you can

4386
04:13:50,190 --> 04:13:53,520
call as well, that will tell you
exactly how many decimals are in

4387
04:13:53,520 --> 04:13:57,150
this price feed. Now as we know,
message dot value is going to

4388
04:13:57,150 --> 04:14:00,450
have 18 decimal places. Why does
it have 18 decimal places? Well,

4389
04:14:00,450 --> 04:14:07,590
because one ether is equal to
1-234-567-8910 12345678 Is this

4390
04:14:07,590 --> 04:14:12,540
massive number in way which has
18 zeros, which is equivalent to

4391
04:14:12,570 --> 04:14:20,100
1.12345 678-910-1234 5678. So we
want these to have the same

4392
04:14:20,130 --> 04:14:22,890
decimal places, right? Because
right now this has eight, this

4393
04:14:22,890 --> 04:14:26,760
is 18. They're different units
right now. So to get them to

4394
04:14:26,760 --> 04:14:33,990
match up, all we need to do is
return price times one, ie 10,

4395
04:14:34,170 --> 04:14:40,560
or one raised to the 10th, which
is equal to 1123456789 10.

4396
04:14:40,710 --> 04:14:45,120
Message dot value, though, is
going to be a UNT 256. And right

4397
04:14:45,120 --> 04:14:49,830
now, price is an interval at
six. So why did we convert this

4398
04:14:49,830 --> 04:14:54,300
value from n into 56. To a human
to 56? Well, we can do what's

4399
04:14:54,300 --> 04:14:58,560
called typecasting, all we need
to do is add you into 56. And

4400
04:14:58,560 --> 04:15:01,710
wrap this whole thing up between
these two parentheses, you can't

4401
04:15:01,710 --> 04:15:06,360
typecast anything. But there are
some values like into 56 and you

4402
04:15:06,360 --> 04:15:09,600
into 56, that can be easily
converted between the two. Now

4403
04:15:09,600 --> 04:15:12,720
of course, since we're not
modifying any state with this

4404
04:15:12,720 --> 04:15:16,860
get price function, we can make
this view and say it returns

4405
04:15:17,400 --> 04:15:21,210
that you went to 36. And if we
save and compile, we go ahead

4406
04:15:21,240 --> 04:15:23,820
and we get that checkmark. Now
math can be a little bit tricky.

4407
04:15:23,820 --> 04:15:26,370
The first couple times you do it
in solidity. But the more you do

4408
04:15:26,370 --> 04:15:28,920
it, the easier it becomes. And
in the future, we can always

4409
04:15:28,950 --> 04:15:32,250
reference a function like this
to figure out okay, here's the

4410
04:15:32,250 --> 04:15:35,070
easiest way for me to get this
number. Awesome. So now we have

4411
04:15:35,100 --> 04:15:39,030
a get price function, which is
going to return a un 256, which

4412
04:15:39,030 --> 04:15:42,960
is going to be the price of
Aetherium. In terms of USD, all

4413
04:15:42,960 --> 04:15:46,500
we need to do is convert the
message dot value from

4414
04:15:46,710 --> 04:15:51,540
Aetherium. To terms of dollars,
let's create this get conversion

4415
04:15:51,540 --> 04:15:54,120
rate function. So this one,
we're going to take an input

4416
04:15:54,120 --> 04:15:58,590
parameter of un 256 of eath
amount, it's going to be a

4417
04:15:58,590 --> 04:16:04,290
public view function. And it's
going to return you went to 56,

4418
04:16:04,620 --> 04:16:08,010
we're going to pass it some eath
amount. And on the other side,

4419
04:16:08,010 --> 04:16:11,760
we're going to get how much that
eath is worth in terms of USD.

4420
04:16:11,880 --> 04:16:16,200
So we're going to do a u
intuity. Six eath price equals

4421
04:16:16,800 --> 04:16:21,030
get price. So first, we're going
to call our get price function

4422
04:16:21,120 --> 04:16:24,330
that we just created to get the
price of Aetherium. Then we're

4423
04:16:24,330 --> 04:16:31,680
going to do u and 256 eath
amount in USD equals eath price

4424
04:16:32,010 --> 04:16:36,870
times eath amount, and then
we're going to divide it by 118.

4425
04:16:37,050 --> 04:16:40,440
When you're doing multiplication
and division math in solidity,

4426
04:16:40,680 --> 04:16:44,250
you always want to multiply and
add first and then go ahead and

4427
04:16:44,250 --> 04:16:48,780
divide since eath price and eath
amount both have 18 additional

4428
04:16:48,780 --> 04:16:51,900
decimal places if we were to
just let them rock without this,

4429
04:16:52,200 --> 04:16:55,920
they would have an additional 36
zeros tax tacked onto the end.

4430
04:16:56,040 --> 04:16:58,740
So we need to divide by one EA
team. Now when we get to the

4431
04:16:58,740 --> 04:17:01,590
hard hat sections of this course
testing all this math is going

4432
04:17:01,590 --> 04:17:04,380
to be a lot easier. And if
you're really struggling with

4433
04:17:04,380 --> 04:17:06,660
some of the math bits right now,
I wouldn't let that slow you

4434
04:17:06,660 --> 04:17:08,880
down. Because once we get to
heart, it's going to become a

4435
04:17:08,880 --> 04:17:12,300
lot easier to actually test this
than working on a test net. And

4436
04:17:12,300 --> 04:17:15,870
this eath amount in terms of USD
is the number that we're looking

4437
04:17:15,870 --> 04:17:20,430
for. So we can just go ahead and
return eath amount in USD, CSB

4438
04:17:20,430 --> 04:17:24,150
returns here, and boom, now we
have a good conversion rate

4439
04:17:24,150 --> 04:17:26,760
function to walk you through the
math real quick. Let's say the

4440
04:17:26,760 --> 04:17:29,910
eath price is going to be
$3,000. So it's going to be

4441
04:17:29,910 --> 04:17:33,600
3000. But it's going to have an
additional 18 zeros tacked on

4442
04:17:33,600 --> 04:17:37,680
the end, it matches the message
dot value way units. And let's

4443
04:17:37,680 --> 04:17:45,180
say for example, we send one
eath or 112345 678-910-1234 5678

4444
04:17:45,240 --> 04:17:51,090
eath into this contract, one
eath should equal $3,000. So to

4445
04:17:51,090 --> 04:17:54,990
get the price, we're going to
now do the eath price, which is

4446
04:17:54,990 --> 04:17:59,580
3000 times the eath amount,
which is this one, and then

4447
04:17:59,580 --> 04:18:02,490
divide by one raised to the
18th. So method out we'll do

4448
04:18:02,490 --> 04:18:09,060
3123 1-234-567-8910 12345678
times we'd

4449
04:18:09,060 --> 04:18:19,920
1001 2345678 1-234-567-8910
times 112345678 1-234-567-8910.

4450
04:18:20,220 --> 04:18:27,150
And now we divide that by
112345678 1-234-567-8910, which

4451
04:18:27,180 --> 04:18:32,490
equals 2.9. Mmm, II 21, which
the calculator kind of messed up

4452
04:18:32,490 --> 04:18:38,370
them a little bit, but 2.9, not
2.99, ie 21 means this has 21

4453
04:18:38,370 --> 04:18:46,800
decimal places. So it'd be
2.1 234-567-8910 1-234-567-8910

4454
04:18:46,860 --> 04:18:53,310
one, or
1-234-567-8910 12345678 2900 I

4455
04:18:53,310 --> 04:18:58,350
9.99 and a nine. And this is
actually exactly the reason why

4456
04:18:58,380 --> 04:19:01,560
we don't do decimal math in
solidity, our calculator saw

4457
04:19:01,560 --> 04:19:04,140
that massive number was having a
hard time getting it. So it

4458
04:19:04,140 --> 04:19:07,560
ended up rounding that number to
2.999. And nine, when we work

4459
04:19:07,560 --> 04:19:11,130
exclusively with whole numbers
in solidity, we don't have a

4460
04:19:11,130 --> 04:19:14,370
chance of losing that precision.
And in solidity, this is going

4461
04:19:14,370 --> 04:19:19,290
to return exactly $3,000, which
is correct one Aetherium at

4462
04:19:19,350 --> 04:19:23,940
$3,000 per Aetherium is going to
be $3,000. And like I said,

4463
04:19:24,060 --> 04:19:26,850
since we're building this
contract, assuming we're going

4464
04:19:26,850 --> 04:19:29,310
to be working on this test net,
we're not going to test this

4465
04:19:29,460 --> 04:19:31,590
function on the test net,
because we're going to have to

4466
04:19:31,590 --> 04:19:34,290
wait for that transaction to go
through. If you want to go ahead

4467
04:19:34,290 --> 04:19:36,600
and deploy this and play around
with it yourself, you're more

4468
04:19:36,600 --> 04:19:39,540
than welcome to Okay, great, now
we have a function called Get

4469
04:19:39,540 --> 04:19:43,140
conversion rate that we can use
on our fund function to make

4470
04:19:43,140 --> 04:19:46,410
sure we've sent enough message
dot value in our fund. So what

4471
04:19:46,410 --> 04:19:50,220
we can do now is all we need to
do is to get conversion rate of

4472
04:19:50,220 --> 04:19:53,760
message dot value needs to be
greater than the minimum USD. Of

4473
04:19:53,760 --> 04:19:57,870
course, right now our minimum
USD is just in terms of 50. And

4474
04:19:57,870 --> 04:20:01,950
we know that conversion rate is
going to return it with 18 zeros

4475
04:20:01,980 --> 04:20:05,400
to represent the decimal places,
our minimum USD amount needs to

4476
04:20:05,400 --> 04:20:12,360
be upgraded to 10 to 50 times
one e 18. Or again, one times

4477
04:20:12,360 --> 04:20:16,380
10, raise the 18th, I'm going to
deploy this to a test net just

4478
04:20:16,380 --> 04:20:19,110
to demonstrate it. But again,
you don't have to if you don't

4479
04:20:19,110 --> 04:20:21,780
want to wait for this. So I'm
gonna go ahead and deploy this

4480
04:20:22,230 --> 04:20:25,500
confirm. And now we have this
funny contract. If I don't say

4481
04:20:25,500 --> 04:20:28,950
anything in value, and hit the
fun button, we're gonna get this

4482
04:20:28,950 --> 04:20:32,610
gas estimation error failed.
This is kind of a blanket error,

4483
04:20:32,640 --> 04:20:34,650
basically saying, Hey, you can
go ahead and send this

4484
04:20:34,650 --> 04:20:36,930
transaction if you want, it's
highly likely that it's not

4485
04:20:36,930 --> 04:20:39,420
going to work. And the reason
that remix knows that it's

4486
04:20:39,420 --> 04:20:42,000
probably not going to work is
because it can see this require

4487
04:20:42,030 --> 04:20:44,760
and simulate the transaction and
say, Hey, you didn't send enough

4488
04:20:44,760 --> 04:20:49,170
money with this. However, even
if we send some money, like 5000

4489
04:20:49,170 --> 04:20:52,740
way, it'll still give us this
error. Because that's not

4490
04:20:52,740 --> 04:20:55,380
enough. Let's do the calculation
right now based on what the

4491
04:20:55,380 --> 04:20:59,010
price of eath is. So we can
actually go to data dot chain

4492
04:20:59,010 --> 04:21:02,370
that link, we look and see
approximately what the price is.

4493
04:21:02,550 --> 04:21:04,770
So it looks like the price of
Aetherium right now is about

4494
04:21:04,770 --> 04:21:07,770
$3,000. And this might be
different for you depending on

4495
04:21:07,770 --> 04:21:10,890
when you do that. So if the
price of Aetherium is $3,000,

4496
04:21:10,980 --> 04:21:14,760
and our minimum is at least 50.
We could do 50 divided by

4497
04:21:15,450 --> 04:21:21,990
3000 0.016 eath should be
approximately enough. So if we

4498
04:21:21,990 --> 04:21:27,390
go to our Aetherium converter,
and we do 0.016, we'll get how

4499
04:21:27,390 --> 04:21:33,060
much that is in way, let's do
0.02 Just to make sure that

4500
04:21:33,090 --> 04:21:36,510
we're going to be over the
amount. So we'll paste that in.

4501
04:21:36,780 --> 04:21:40,170
We'll change this to way. And
now if I hit the fun button,

4502
04:21:40,650 --> 04:21:43,440
instead of us getting that error
popping up, it's going to

4503
04:21:43,440 --> 04:21:46,500
actually go ahead and let us do
the fun function and we could

4504
04:21:46,500 --> 04:21:49,650
confirm it and it wouldn't fail.
I'm going to reject it for now

4505
04:21:49,650 --> 04:21:51,690
just because I don't really feel
like waiting for the transaction

4506
04:21:51,690 --> 04:21:54,030
to go through. But great. We've
confirmed that our get

4507
04:21:54,030 --> 04:21:57,000
conversion rate is one working
as intended, awesome, great

4508
04:21:57,000 --> 04:21:57,420
work.

4509
04:22:00,149 --> 04:22:02,819
So what's the next bit of this
funding contract that we want to

4510
04:22:02,819 --> 04:22:06,509
do? Well, when people actually
send money to this contract, we

4511
04:22:06,509 --> 04:22:09,689
want to keep track of all the
people who send us money. So

4512
04:22:09,689 --> 04:22:12,389
let's create some data
structures. To keep track. Let's

4513
04:22:12,389 --> 04:22:16,709
create an array of addresses
called funders. And we'll keep

4514
04:22:16,739 --> 04:22:20,519
adding all the funders who send
money to us. So we'll say an

4515
04:22:20,519 --> 04:22:24,689
address array, or an address
list. We'll make it public

4516
04:22:25,199 --> 04:22:29,189
funders. And anytime somebody
sends us money, and this

4517
04:22:29,189 --> 04:22:32,399
actually does indeed go through,
we'll add that funded server

4518
04:22:32,399 --> 04:22:37,799
list. So we'll say funders dot
push message dot sender, like

4519
04:22:37,799 --> 04:22:41,819
message dot value. Message dot
sender is an always available

4520
04:22:41,819 --> 04:22:45,779
global keyword message dot value
stands for how much Aetherium or

4521
04:22:45,779 --> 04:22:48,989
how much native blockchain
currency is sent. Message dot

4522
04:22:48,989 --> 04:22:53,069
sender is the address of whoever
calls the font function. So if

4523
04:22:53,069 --> 04:22:56,729
we're on Rigby message dot
sender is going to be equal to

4524
04:22:56,759 --> 04:23:00,239
whatever address is calling that
function. Since our address is

4525
04:23:00,239 --> 04:23:04,469
sending the ether, we're going
to add our address to this

4526
04:23:04,469 --> 04:23:07,259
funders list. This way we can
keep track of all the wonderful

4527
04:23:07,259 --> 04:23:11,579
donators who are donating to our
contract, then maybe we won't

4528
04:23:11,579 --> 04:23:17,549
even make a mapping of addresses
to you and 250 sixes of

4529
04:23:17,579 --> 04:23:20,819
addresses to how much money each
one of these people have

4530
04:23:20,819 --> 04:23:25,409
actually sent. So we'll do
address to you and 256 public

4531
04:23:26,099 --> 04:23:31,769
address to amount funded. And
when somebody funds our contract

4532
04:23:31,799 --> 04:23:35,129
will say address to amount
funded of message dot sender

4533
04:23:36,089 --> 04:23:40,349
equals message dot value. Now we
have a function where people can

4534
04:23:40,349 --> 04:23:44,519
fund our contract. And we can
set a value in terms of USD and

4535
04:23:44,519 --> 04:23:47,699
we keep track of the different
funders who actually fund our

4536
04:23:47,699 --> 04:23:54,239
contract. This is fantastic. Now
I know we've gone over a lot of

4537
04:23:54,239 --> 04:23:57,779
really intense math and intense
stuff here. So so let's do a

4538
04:23:57,779 --> 04:24:00,389
quick refresher of what we've
learned so far. Whenever we work

4539
04:24:00,389 --> 04:24:03,869
with a contract, we always need
the API and the address when

4540
04:24:03,869 --> 04:24:08,279
compiled an interface gives us
that minimalistic API to

4541
04:24:08,279 --> 04:24:12,239
interact with contracts outside
of our project. When you combine

4542
04:24:12,269 --> 04:24:15,269
these compiled interfaces with
an address, we can call the

4543
04:24:15,269 --> 04:24:19,109
functions on that interface on
that contract. chain link. data

4544
04:24:19,109 --> 04:24:22,889
feeds are a decentralized way to
get information about the real

4545
04:24:22,889 --> 04:24:25,769
world. In this case, we're
getting the price of Aetherium

4546
04:24:25,799 --> 04:24:29,069
in terms of USD from a
decentralized collective of

4547
04:24:29,069 --> 04:24:32,039
chain link nodes. When working
with math and solidity. Decimals

4548
04:24:32,069 --> 04:24:35,099
don't work. So we need to keep
that in mind when doing any type

4549
04:24:35,099 --> 04:24:38,399
of math in solidity. And we need
to make sure we always have the

4550
04:24:38,399 --> 04:24:42,809
correct units, so that our math
makes sense. Message dot value,

4551
04:24:42,899 --> 04:24:46,199
and message dot sender, our
globally available variables

4552
04:24:46,229 --> 04:24:49,139
were message dot sender
represents the sender of the

4553
04:24:49,139 --> 04:24:52,679
message or transaction. And
message dot value represents the

4554
04:24:52,679 --> 04:24:55,559
number of ways sent with the
message. There's a whole bunch

4555
04:24:55,589 --> 04:24:58,259
of different special variables
and functions that we can access

4556
04:24:58,259 --> 04:25:00,929
at any time. And these are
available in the solidity

4557
04:25:00,929 --> 04:25:06,269
documentation. Alright, great,
we've got a great way that we

4558
04:25:06,269 --> 04:25:09,059
can actually start funding our
contract. But our code looks a

4559
04:25:09,059 --> 04:25:11,639
little bit messy, we've got a
couple of different functions

4560
04:25:11,819 --> 04:25:14,489
for getting the price and
working with these prices, is

4561
04:25:14,489 --> 04:25:17,939
there a way to make this math a
lot easier to use, this is where

4562
04:25:17,939 --> 04:25:21,509
we're going to introduce the
concept of a library. So what is

4563
04:25:21,539 --> 04:25:23,999
a library, I definitely
recommend checking out solidity

4564
04:25:23,999 --> 04:25:27,359
by example.org, as you're going
along with this course, as well,

4565
04:25:27,419 --> 04:25:30,869
they've got some fantastic
examples. One of such example is

4566
04:25:30,899 --> 04:25:33,089
going to be about libraries,
libraries are similar to

4567
04:25:33,089 --> 04:25:35,879
contracts. But you can't declare
any state variables and you

4568
04:25:35,879 --> 04:25:39,989
can't send ether. We can also
use libraries to add more

4569
04:25:39,989 --> 04:25:43,289
functionality to different
values. What do I mean by that?

4570
04:25:43,379 --> 04:25:47,009
Well, what we can do actually is
we can have get conversion rate

4571
04:25:47,039 --> 04:25:53,489
be a function of a un 256. So we
could do something like Messer

4572
04:25:53,489 --> 04:25:59,189
dot value dot get convert John,
conversion rate. And we can add

4573
04:25:59,189 --> 04:26:03,209
functions as if you went to 36
was an object or a struct or a

4574
04:26:03,209 --> 04:26:06,509
contract that we actually
created. So how do we do this?

4575
04:26:06,539 --> 04:26:09,929
Well, let's create a new
contract in our contracts folder

4576
04:26:10,229 --> 04:26:12,599
and create a new file. We're
going to call it price

4577
04:26:12,899 --> 04:26:17,819
converter, dot salt. And our
price converted outsole is going

4578
04:26:17,819 --> 04:26:21,869
to be a library that we're going
to attach to a un 256. So how do

4579
04:26:21,869 --> 04:26:24,449
you actually create a library
and what is a library? Well, a

4580
04:26:24,449 --> 04:26:27,389
library is going to be really,
really similar to a smart

4581
04:26:27,389 --> 04:26:34,169
contract. It's gonna start with
spdx license identifier. My

4582
04:26:34,169 --> 04:26:40,049
team, we're gonna give it a
pragma, solidity zero point 8.0.

4583
04:26:40,349 --> 04:26:43,349
And instead of typing contract
for the name of the contract,

4584
04:26:43,379 --> 04:26:46,559
we're going to do library for
the name of the library. We're

4585
04:26:46,559 --> 04:26:49,349
going to call it price
converter. Now libraries can't

4586
04:26:49,349 --> 04:26:52,649
have any state variables and
they also can't send ether and

4587
04:26:52,649 --> 04:26:55,049
all the functions in a library
are going to be in there.

4588
04:26:55,079 --> 04:26:58,769
kernel. So what we can do is we
can go back to fund me dot soul,

4589
04:26:59,549 --> 04:27:03,779
we can grab get price, get
version and get conversion rate,

4590
04:27:04,079 --> 04:27:08,549
copy them all, delete them from
Funmi dot soul and paste them

4591
04:27:08,579 --> 04:27:11,909
into our library. And of course,
since we're using aggregator v3

4592
04:27:11,909 --> 04:27:17,039
interface in here, we can also
copy the import from Funmi. And

4593
04:27:17,069 --> 04:27:19,979
since we're not using the
aggregate of three interface and

4594
04:27:19,979 --> 04:27:23,189
our contract anymore, and we're
using our price converter, we

4595
04:27:23,189 --> 04:27:26,219
can paste it into our price
converter. Now, if we compile

4596
04:27:26,369 --> 04:27:30,149
price converted at soul, we see
that it actually passes. Now all

4597
04:27:30,149 --> 04:27:33,749
the functions inside of our
library need to be internal. And

4598
04:27:33,749 --> 04:27:36,479
we're gonna make this library
price converter different

4599
04:27:36,479 --> 04:27:40,109
functions, we can call on you
activity six, for example, we're

4600
04:27:40,109 --> 04:27:42,899
going to be able to do message
dot value dot get conversion

4601
04:27:42,899 --> 04:27:45,989
rate, we're going to directly be
able to get the conversion rate

4602
04:27:46,049 --> 04:27:50,069
of a value of a U and 256 as if
that was a function for it the

4603
04:27:50,069 --> 04:27:54,479
whole time. So first, let's make
this internal. Let's make get

4604
04:27:54,479 --> 04:27:57,149
conversion rate internal. And
we'll make good version

4605
04:27:57,149 --> 04:28:00,749
internal. Now that we have this
library price converter back in

4606
04:28:00,749 --> 04:28:04,259
our Funmi, we can now import
this price converter and attach

4607
04:28:04,259 --> 04:28:08,849
it to you in 256. So we'll do
import that slash price

4608
04:28:08,849 --> 04:28:10,649
converter, dot soul.

4609
04:28:11,670 --> 04:28:19,740
And in Funmi, we'll do using
price converter for UNT 256. Of

4610
04:28:19,740 --> 04:28:23,520
course, if we compile our Funmi.
Now, this line is getting an

4611
04:28:23,520 --> 04:28:26,520
issue because saying hey, get
conversion rate isn't defined.

4612
04:28:26,700 --> 04:28:31,020
Now in our library, the first
variable that gets passed to the

4613
04:28:31,020 --> 04:28:33,780
function is going to be the
object that it's called on

4614
04:28:33,780 --> 04:28:37,530
itself. So in Funmi dot soul,
let's go ahead and comment out

4615
04:28:37,530 --> 04:28:40,950
this line for now. If we do
message dot value dot get

4616
04:28:40,950 --> 04:28:44,220
conversion rate, this is
secretly the same as we did get

4617
04:28:44,220 --> 04:28:47,820
conversion rate or message dot
value in our price converter

4618
04:28:47,880 --> 04:28:50,790
library, the message dot value
is going to be passed as the

4619
04:28:50,790 --> 04:28:53,610
input parameter to get
conversion rate, forget price

4620
04:28:53,610 --> 04:28:56,970
and get version we don't really
care about the number. So we're

4621
04:28:56,970 --> 04:29:00,330
just going to leave it blank for
now. So instead of require get

4622
04:29:00,330 --> 04:29:05,160
conversion rate of message dot
value, we can now do message dot

4623
04:29:05,160 --> 04:29:11,160
value dot get conversion rate.
And compile that you'll see that

4624
04:29:11,160 --> 04:29:14,220
here we're not passing a
variable, even though our get

4625
04:29:14,220 --> 04:29:17,340
conversion rate function says
hey, I'm expecting a variable.

4626
04:29:17,550 --> 04:29:20,640
Again, the reason for this is,
is this message add value is

4627
04:29:20,640 --> 04:29:23,730
considered the first parameter
for any of these library

4628
04:29:23,730 --> 04:29:26,460
functions. And that's how it
works. If we wanted another

4629
04:29:26,460 --> 04:29:32,370
variable in here, like you went
to 56, something else. Now we

4630
04:29:32,370 --> 04:29:36,990
would want to pass something
else in here 123. And this 123

4631
04:29:37,020 --> 04:29:39,870
would get assigned to this
something else. But we're going

4632
04:29:39,870 --> 04:29:44,430
to delete that for now. Okay,
great. And in doing that, we've

4633
04:29:44,430 --> 04:29:48,600
minimized our Funmi contract a
lot by moving a lot of that math

4634
04:29:48,600 --> 04:29:52,350
and price conversion stuff into
our price converter library dot

4635
04:29:52,350 --> 04:29:57,720
Sol. One of the most common
libraries that was used for the

4636
04:29:57,720 --> 04:30:02,520
longest time was this library
called Safe math dot Sol. And

4637
04:30:02,520 --> 04:30:05,220
you'll probably see it a lot of
different places, we're gonna go

4638
04:30:05,220 --> 04:30:08,220
off on a quick little tangent
here and teach you about safe

4639
04:30:08,220 --> 04:30:11,580
math. So let's close Funmi close
price converter. And let's

4640
04:30:11,580 --> 04:30:17,580
create a new file called Safe
math tester. That's all. And

4641
04:30:17,580 --> 04:30:20,640
let's start with some basic
stuff in here. Safe math was all

4642
04:30:20,640 --> 04:30:24,750
over the place before version
0.8 of solidity. And now it's

4643
04:30:24,780 --> 04:30:28,290
almost in no contracts. What
happened, why is safe math no

4644
04:30:28,290 --> 04:30:32,370
longer used as much? Well, let's
create a sample contract. This

4645
04:30:32,370 --> 04:30:34,950
is a section that you don't have
to follow along if you don't

4646
04:30:34,950 --> 04:30:38,070
want to code along with me. But
if you want to you absolutely

4647
04:30:38,070 --> 04:30:40,890
still can. This is going to be a
contract we are going to deploy

4648
04:30:40,920 --> 04:30:44,010
on a JavaScript virtual machine,
we can use any version of

4649
04:30:44,010 --> 04:30:48,510
solidity before version 0.8 of
solidity. So for example, we use

4650
04:30:48,510 --> 04:30:54,150
pragma, carrot, zero, point 6.0.
And we'll create contract safe

4651
04:30:54,540 --> 04:31:00,180
math tester, dot Sol. Now if I
create a you int eight, I set it

4652
04:31:00,180 --> 04:31:06,960
to public big number. And I set
this to 255 Oops safe math

4653
04:31:06,960 --> 04:31:11,010
tester. Let's go ahead and
compile safe math tester with

4654
04:31:11,520 --> 04:31:17,700
zero point 6.7 pragma, solidity,
the maximum size of a Yewande

4655
04:31:17,730 --> 04:31:21,390
eight is going to be 255. This
is going to be the biggest

4656
04:31:21,390 --> 04:31:24,450
number that we can fit in the
new int eight. And if I were to

4657
04:31:24,450 --> 04:31:29,130
deploy this to a JavaScript VM
or even a test network, safe

4658
04:31:29,130 --> 04:31:33,810
math tester, let's go ahead to
play up. If I hit big number,

4659
04:31:34,050 --> 04:31:38,730
we're gonna get 255. Well, what
happens if I create a function

4660
04:31:39,270 --> 04:31:45,840
called ADD? That sets big number
equal to big number plus one?

4661
04:31:46,620 --> 04:31:50,850
Let's save that. Delete that old
contract and deploy. All right

4662
04:31:50,850 --> 04:31:55,920
now big numbers 255 What happens
when we add one two? big number.

4663
04:31:56,100 --> 04:32:01,170
When 255 is the max size a, UNT
eight can be? Well, let's hit

4664
04:32:01,170 --> 04:32:06,030
add. Now let's check what big
number is. Big number gets reset

4665
04:32:06,420 --> 04:32:10,740
to zero. So what's going on?
Well, prior to version 0.8, of

4666
04:32:10,740 --> 04:32:14,520
solidity, unsigned integers and
integers ran on this concept of

4667
04:32:14,520 --> 04:32:18,840
being unchecked, which means
that if you passed the upper

4668
04:32:18,840 --> 04:32:22,830
limit of a number, it would just
wrap around and start back from

4669
04:32:22,860 --> 04:32:25,470
the lowest number it could be.
So if I call add a whole bunch

4670
04:32:25,470 --> 04:32:28,920
more times, and hit big number,
now let's say if I were to hit

4671
04:32:28,920 --> 04:32:32,910
this add button a ton more times
and get it back to two and a 55.

4672
04:32:33,210 --> 04:32:36,540
It would then continue to wrap
over to zero. So one of the most

4673
04:32:36,540 --> 04:32:39,840
popular libraries that was out
there was this safe math

4674
04:32:39,840 --> 04:32:43,770
library, which would basically
check to make sure that you

4675
04:32:43,770 --> 04:32:47,910
weren't wrapping around a un 256
or an intuitive six, basically,

4676
04:32:47,940 --> 04:32:50,880
it was a way to say, hey, you've
reached the max this number can

4677
04:32:50,880 --> 04:32:54,270
be and now your transaction is
going to fail. If we switch this

4678
04:32:54,660 --> 04:33:00,360
to 0.8, of solidity, delete the
old contract, go switch this to

4679
04:33:00,360 --> 04:33:05,190
0.8. We'll go ahead and compile
it. And now we deploy this to

4680
04:33:05,190 --> 04:33:06,090
JavaScript VM.

4681
04:33:07,410 --> 04:33:11,880
If I hit big number, we get to
under 55. But if we hit Add, it

4682
04:33:11,880 --> 04:33:16,140
actually fails. And we still get
to under 55. In version 0.8, in

4683
04:33:16,140 --> 04:33:19,740
solidity, they added this bit,
where it automatically checks to

4684
04:33:19,740 --> 04:33:22,740
make sure if you're going to do
what's called overflow or

4685
04:33:22,740 --> 04:33:26,040
underflow on a variable, we can
actually revert back to the

4686
04:33:26,070 --> 04:33:30,390
unchecked version by using an
unchecked keyword. So if we wrap

4687
04:33:30,390 --> 04:33:33,390
this big number equals big
number plus one in this

4688
04:33:33,420 --> 04:33:37,830
unchecked bracket, let's delete
our old contract will compile

4689
04:33:38,010 --> 04:33:42,810
will redeploy. We had big
numbers to 55. Now we hit add,

4690
04:33:42,840 --> 04:33:47,040
we hit big number again, it
reverted back to zero. So that's

4691
04:33:47,040 --> 04:33:50,460
a little bit more about safe
math, checked and unchecked. So

4692
04:33:50,460 --> 04:33:54,960
in version 0.76, and below this
code that you see in front of

4693
04:33:54,960 --> 04:34:00,090
you, is going to be the exact
same as this code in 0.8. And

4694
04:34:00,090 --> 04:34:02,640
above with this unchecked
keyword. Now you might be

4695
04:34:02,640 --> 04:34:06,900
thinking in newer versions of
solidity, why would I use this

4696
04:34:06,900 --> 04:34:10,710
unchecked keyword? Well, you'll
find out later that this

4697
04:34:10,710 --> 04:34:14,250
unchecked keyword makes your
code a little bit more gas

4698
04:34:14,280 --> 04:34:16,800
efficient. So if you're
absolutely positive that your

4699
04:34:16,800 --> 04:34:19,530
math is never going to reach the
top or bottom limits of a

4700
04:34:19,530 --> 04:34:22,440
number, that it might make sense
for you to use the unchecked

4701
04:34:22,440 --> 04:34:26,040
keyword. Let's head back over to
our Funmi contract, where we are

4702
04:34:26,040 --> 04:34:29,130
now using the price converter
library that we just created.

4703
04:34:31,920 --> 04:34:34,770
Alright, great. So now we've got
a pretty minimalistic contract

4704
04:34:34,770 --> 04:34:37,950
here for actually doing the
funding. And we have all of our

4705
04:34:37,950 --> 04:34:42,420
math for getting conversion
rates done in our library price

4706
04:34:42,420 --> 04:34:45,480
converter, which we're going to
import at the top of Funmi.

4707
04:34:45,690 --> 04:34:49,830
Cool. So at this point, we've
got our fun method. Awesome. And

4708
04:34:49,830 --> 04:34:53,820
so we can allow anybody to go
ahead and fund this contract and

4709
04:34:53,820 --> 04:34:58,050
send this contract Aetherium, or
any native blockchain currency

4710
04:34:58,170 --> 04:35:01,650
to this contract. Well, now what
do we want to do? Well, once all

4711
04:35:01,650 --> 04:35:04,380
the funders have gone ahead and
funded, we're going to want the

4712
04:35:04,380 --> 04:35:08,850
project to be able to withdraw
the funds out of this contract.

4713
04:35:08,880 --> 04:35:12,690
So they can actually go ahead
and use those funds to buy

4714
04:35:12,690 --> 04:35:16,020
things for this project. So
let's go ahead and create a

4715
04:35:16,110 --> 04:35:20,640
withdrawal function. So we'll
create a function withdraw. And

4716
04:35:20,640 --> 04:35:23,610
we'll make this public. Since
we're going to be withdrawing

4717
04:35:23,640 --> 04:35:26,760
all the funds out of this
contract, we probably also want

4718
04:35:26,760 --> 04:35:31,200
to reset our funders array, and
our address to amount funded.

4719
04:35:31,380 --> 04:35:35,190
Since we'll be withdrawing all
the funds, those amounts should

4720
04:35:35,220 --> 04:35:39,030
go back down to zero. So let's
go ahead and loop through the

4721
04:35:39,030 --> 04:35:42,660
funders array and update our
mapping object so that each of

4722
04:35:42,660 --> 04:35:46,680
these funders now has zero,
because in just a second, we're

4723
04:35:46,680 --> 04:35:51,420
going to withdraw all the money
from them. So to do this, we're

4724
04:35:51,420 --> 04:35:54,840
going to use something called a
for loop. So what is a for loop?

4725
04:35:54,960 --> 04:35:57,870
A for loop is a way to loop
through some type of index

4726
04:35:57,870 --> 04:36:01,260
object or loop through some
range of numbers or just do a

4727
04:36:01,260 --> 04:36:05,550
task a certain amount of times
repeating. So for example, let's

4728
04:36:05,550 --> 04:36:11,970
say we have an array or list.
And on that list, we have 1234.

4729
04:36:12,060 --> 04:36:16,980
If we wanted to get all of the
elements in this array, or in

4730
04:36:16,980 --> 04:36:22,140
this list, okay, 1234. How do we
get all the elements in this

4731
04:36:22,140 --> 04:36:28,170
list? Well, we would use a for
loop to loop through each one of

4732
04:36:28,170 --> 04:36:33,510
these objects. So at zero with
index would be one at the first

4733
04:36:33,510 --> 04:36:37,950
index would be two, and at the
second index would be three, at

4734
04:36:37,950 --> 04:36:40,980
the last index would be four. So
we would loop through the

4735
04:36:40,980 --> 04:36:45,060
indexes zero through three to
get all these elements. Or maybe

4736
04:36:45,060 --> 04:36:51,240
another example is if this was
A, B, C, D, A is at the zero

4737
04:36:51,240 --> 04:36:55,860
with index B is at the first
index sees the second Indy's at

4738
04:36:55,860 --> 04:36:59,280
the third and we will loop zero
through three. To get to each

4739
04:36:59,280 --> 04:37:01,950
one of these elements, we're
gonna do that exact same thing.

4740
04:37:02,580 --> 04:37:06,540
But with the funders array. So
how do we actually do that?

4741
04:37:06,720 --> 04:37:11,100
Well, we first start with the
for keyword, the for keyword

4742
04:37:11,100 --> 04:37:14,610
says, Okay, we're about to start
a loop. And inside of these

4743
04:37:14,610 --> 04:37:18,450
parentheses, we define how we
want to loop through it. Also

4744
04:37:18,480 --> 04:37:21,930
backslash star, and star
backslash is sort of like

4745
04:37:21,960 --> 04:37:26,640
brackets for comments. Anything
in between these two will be a

4746
04:37:26,640 --> 04:37:29,430
comment. So in a for loop,
first, we give it the starting

4747
04:37:29,430 --> 04:37:34,560
index, then we give it the
ending index, and then we give

4748
04:37:34,560 --> 04:37:39,060
it the step amount. For example,
maybe we want to start with

4749
04:37:39,060 --> 04:37:43,080
zero, we want to go to 10. And
we want to go up by one each

4750
04:37:43,080 --> 04:37:47,850
time. So we would go
01 234-567-8910. Or maybe we

4751
04:37:47,850 --> 04:37:51,480
start at zero, we want to end at
10. And we go up by two each

4752
04:37:51,480 --> 04:37:57,420
time. So we'd go 02468 10. Or
maybe we want to go from zero to

4753
04:37:57,420 --> 04:38:02,070
five, we want to go from two to
five, with a step of one, we'd

4754
04:38:02,070 --> 04:38:08,370
go 2345, etc. So this is what's
going to go inside of this four

4755
04:38:08,370 --> 04:38:12,180
bit here. So for our starting
index, and let me even just put

4756
04:38:12,180 --> 04:38:14,940
this above so that you can
reference it. So our starting

4757
04:38:14,940 --> 04:38:17,970
index is going to be you in to
VT six variable, and we're going

4758
04:38:17,970 --> 04:38:21,870
to call it funder index. And
we're going to start with

4759
04:38:21,870 --> 04:38:25,740
thunder index being equal to
zero. So we're starting with

4760
04:38:25,770 --> 04:38:30,000
zero here. And we're going to
end with the length of our

4761
04:38:30,000 --> 04:38:33,780
funders array, since we want to
loop through all of the funders.

4762
04:38:33,810 --> 04:38:40,230
So we're going to say, funder
index needs to be less than

4763
04:38:40,230 --> 04:38:44,790
funders dot length. So our
ending index is going to be

4764
04:38:44,790 --> 04:38:49,650
whenever funders index is no
longer less than funders dot

4765
04:38:49,650 --> 04:38:54,120
length. And then finally, we're
gonna say funder index equals

4766
04:38:54,150 --> 04:39:00,120
funder index, plus one, which
means that every time the code

4767
04:39:00,150 --> 04:39:03,360
inside of this loop finishes,
we're going to increase funder

4768
04:39:03,360 --> 04:39:07,710
index by one. That's how we go
from zero to one to two to three

4769
04:39:07,710 --> 04:39:11,820
to four to five, etc. Another
way you can type funder index

4770
04:39:11,850 --> 04:39:15,780
equals funder index plus one is
you can just do funder index

4771
04:39:15,840 --> 04:39:21,180
plus plus, this plus plus syntax
means funder index equals itself

4772
04:39:21,210 --> 04:39:25,410
plus one. So let's start looping
through our funders array to

4773
04:39:25,410 --> 04:39:28,920
access the the zero with element
or the first element, we're

4774
04:39:28,920 --> 04:39:34,170
going to say, funders of funder
index. So we're saying we want

4775
04:39:34,170 --> 04:39:38,070
to access the zero with element
of our funders object. And this

4776
04:39:38,070 --> 04:39:41,880
is going to return an address
for us to use, we're gonna go

4777
04:39:41,880 --> 04:39:48,240
ahead and say address under
equals funders at the funder

4778
04:39:48,240 --> 04:39:52,320
index. So now we have this
funder address. And we want to

4779
04:39:52,320 --> 04:39:58,560
use this to reset our mapping.
So we're going to say, address

4780
04:39:58,770 --> 04:40:06,780
to amount funded at at the
funder key is now equal to zero.

4781
04:40:07,080 --> 04:40:13,500
Because remember, in fund we
update the amount. Whenever we

4782
04:40:13,740 --> 04:40:17,040
fund the contract, when we
withdraw the money from the

4783
04:40:17,040 --> 04:40:21,510
contract, we're going to reset
it back to zero. Now let's walk

4784
04:40:21,510 --> 04:40:25,140
through this funder index starts
from zero. So we're going to get

4785
04:40:25,140 --> 04:40:29,190
the zero with funder, we're
going to grab that funder at the

4786
04:40:29,190 --> 04:40:32,040
zero with index and we're going
to reset the address to male

4787
04:40:32,040 --> 04:40:36,720
funded of that funder to zero,
then this for loop is going to

4788
04:40:36,840 --> 04:40:40,710
update by one, it's going to
move from zero to one, it's

4789
04:40:40,710 --> 04:40:44,160
going to check then if funder
index is less than the length,

4790
04:40:44,190 --> 04:40:47,610
let's say funders has 10 people
in it. If funders has 10 people

4791
04:40:47,610 --> 04:40:51,900
in it, it'll still be less. So
now funder links will be one

4792
04:40:51,990 --> 04:40:55,800
address funder will equal
funders of one now instead of

4793
04:40:55,800 --> 04:40:59,190
zero, and we'll grab that
address, and we'll reset that

4794
04:40:59,190 --> 04:41:03,150
addresses about funded to zero,
then we'll continue to two to

4795
04:41:03,150 --> 04:41:07,620
three to four all the way up to
the length of our funders array.

4796
04:41:07,680 --> 04:41:10,530
And this is how we can loop
through our objects. So saying

4797
04:41:10,530 --> 04:41:14,220
this middle one is the ending
index isn't exactly right, since

4798
04:41:14,220 --> 04:41:17,310
we're really checking for a
boolean to see if this is still

4799
04:41:17,310 --> 04:41:21,150
true, but hopefully you get the
idea. So we've reset the

4800
04:41:21,150 --> 04:41:24,840
balances of the mapping.
However, we still haven't done

4801
04:41:24,840 --> 04:41:28,530
two things, we still need to
reset the array to make the

4802
04:41:28,530 --> 04:41:33,570
funders a blank array. And then
we also need to actually

4803
04:41:33,690 --> 04:41:39,930
withdraw the funds. Since when
we funded this, we sent message

4804
04:41:39,930 --> 04:41:45,030
dot value along with calling
this fund function. However, we

4805
04:41:45,030 --> 04:41:48,930
didn't actually withdraw the
funds. So to reset the array, we

4806
04:41:48,930 --> 04:41:53,880
could loop through it and delete
objects from this address array.

4807
04:41:54,180 --> 04:41:57,690
Or we could Just totally refresh

4808
04:41:57,720 --> 04:42:03,510
this variable. So instead of
looping through the array and

4809
04:42:03,510 --> 04:42:08,550
deleting objects, we're just
going to say funders equals a

4810
04:42:08,550 --> 04:42:13,440
new address array, we're going
to completely reset the array by

4811
04:42:13,440 --> 04:42:19,470
saying this font is variable now
equals a brand new address array

4812
04:42:19,740 --> 04:42:23,190
with zero objects in it to
start, if we were to put a one

4813
04:42:23,190 --> 04:42:26,670
here, this would be there'll be
one element to start in the

4814
04:42:26,670 --> 04:42:30,690
array, two would be two, three
would be three, etc, we're just

4815
04:42:30,690 --> 04:42:43,230
going to start it as a
completely blank new array. So

4816
04:42:43,230 --> 04:42:46,410
great, we've gone ahead and
reset the array. But how do we

4817
04:42:46,410 --> 04:42:50,760
actually now with draw funds
from this contract? How do we

4818
04:42:50,760 --> 04:42:55,530
send the funds back to whomever
is calling this now to actually

4819
04:42:55,530 --> 04:42:59,460
send ether or send native
blockchain currency, there are

4820
04:42:59,460 --> 04:43:02,820
actually three different ways to
do this, we're going to look at

4821
04:43:02,850 --> 04:43:06,300
all three, and say what the
differences between the three of

4822
04:43:06,300 --> 04:43:09,300
them are, the three different
ways are going to be transfer,

4823
04:43:10,200 --> 04:43:15,240
send, and call. Let's go ahead
and start with transfer. Since

4824
04:43:15,240 --> 04:43:19,140
transfer is the simplest and at
surface level makes the most

4825
04:43:19,140 --> 04:43:23,430
sense to us. So if we want to
transfer the funds to whomever

4826
04:43:23,430 --> 04:43:27,120
is calling this withdrawal
function, we would do we would

4827
04:43:27,120 --> 04:43:32,550
say message dot sender, dot
transfer. And then we'd get the

4828
04:43:32,550 --> 04:43:39,780
balance of our contract here by
saying address this, this

4829
04:43:39,780 --> 04:43:44,370
keyword refers to this whole
contract dot balance, and we can

4830
04:43:44,370 --> 04:43:46,650
get the native blockchain
currency or the Aetherium

4831
04:43:46,650 --> 04:43:49,650
currency balance of this address
like this. And we can just do

4832
04:43:49,650 --> 04:43:53,670
that only thing that we need to
do is we need to cast we need to

4833
04:43:53,670 --> 04:44:00,840
typecast message dot sender from
an address type to a payable

4834
04:44:00,870 --> 04:44:07,500
address type. So message dot
sender is of type address.

4835
04:44:08,310 --> 04:44:14,400
Whereas payable, message that
sender is of type, payable

4836
04:44:14,400 --> 04:44:17,580
address, and in solidity in
order to send the native

4837
04:44:17,580 --> 04:44:21,210
blockchain token like Aetherium,
you can only work with payable

4838
04:44:21,210 --> 04:44:25,110
addresses. To do that, we just
wrap it in this payable type

4839
04:44:25,110 --> 04:44:29,100
caster. So this is the first way
that we actually send Aetherium

4840
04:44:29,100 --> 04:44:33,690
or send tokens from different
contracts to each other, we wrap

4841
04:44:33,690 --> 04:44:37,020
the address that we want to send
it in, in this payable keyword,

4842
04:44:37,470 --> 04:44:41,610
we do dot transfer, and then we
say exactly how much we want to

4843
04:44:41,610 --> 04:44:45,240
transfer. But there are some
issues with transfer. Here we

4844
04:44:45,240 --> 04:44:50,130
are on solidity by example, for
sending ether, which, again is a

4845
04:44:50,130 --> 04:44:54,540
fantastic resource to refer to,
if you get lost, the method that

4846
04:44:54,540 --> 04:44:59,430
we just looked at was this
transfer method. Now we saw way

4847
04:44:59,430 --> 04:45:04,260
earlier in the course, that if I
sent Aetherium, from one address

4848
04:45:04,260 --> 04:45:10,740
to another, it cost about 2100
gas or 2100. Gas, our transfer

4849
04:45:10,740 --> 04:45:16,350
function is capped at 2300 gas.
And if more gas is used, it

4850
04:45:16,350 --> 04:45:19,740
throws an error. The next one
that we're using is going to be

4851
04:45:19,740 --> 04:45:24,960
sent which is also capped at
2300 gas. And if it fails, it'll

4852
04:45:24,960 --> 04:45:28,740
return a Boolean. So with
transfer, if this line fails,

4853
04:45:28,770 --> 04:45:32,850
it'll air and revert the
transaction with send, it won't

4854
04:45:32,850 --> 04:45:36,420
air, it'll return a boolean of
whether or not it was

4855
04:45:36,420 --> 04:45:41,670
successful. So using send will
do payable message that sender

4856
04:45:42,480 --> 04:45:50,490
that send address this balance.
But we don't want to finish our

4857
04:45:50,490 --> 04:45:54,360
call here. If this were to fail,
the contract wouldn't revert the

4858
04:45:54,360 --> 04:45:58,260
transaction, and we just want to
get our money sent. So we want

4859
04:45:58,260 --> 04:46:05,400
to do Boolean send success
equals this whole bit here. And

4860
04:46:05,400 --> 04:46:11,040
then we want to require success.
And if this send fails will

4861
04:46:11,040 --> 04:46:14,040
throw an error saying sin
failed.

4862
04:46:15,420 --> 04:46:20,310
This way, if this fails, we will
still revert by adding our

4863
04:46:20,340 --> 04:46:23,790
require statement here. Transfer
automatically reverts if the

4864
04:46:23,790 --> 04:46:28,680
transfer fails, send will only
revert the transaction if we add

4865
04:46:28,680 --> 04:46:32,820
this require statement here. So
great. What's the third way that

4866
04:46:32,820 --> 04:46:36,330
we can actually send Etherium or
native currency wallets with

4867
04:46:36,330 --> 04:46:40,110
this call command. Now call is
going to be one of the first

4868
04:46:40,140 --> 04:46:43,950
lower level commands that we
actually use in our solidity

4869
04:46:43,950 --> 04:46:48,330
code, because this call function
is actually incredibly powerful.

4870
04:46:48,540 --> 04:46:53,190
And we can use it to call
virtually any function in all of

4871
04:46:53,190 --> 04:46:57,090
Aetherium without even having to
Have the API we'll learn the

4872
04:46:57,090 --> 04:47:00,510
advanced ways to use this call
much later. For now, we're just

4873
04:47:00,510 --> 04:47:03,720
going to learn how to use it to
send Aetherium, or your native

4874
04:47:03,720 --> 04:47:07,650
blockchain currency call is
going to look very similar to

4875
04:47:07,740 --> 04:47:14,070
send, we're going to do payable,
message dot sender, dot call.

4876
04:47:14,250 --> 04:47:18,300
And this is where we will put
any function information or any

4877
04:47:18,300 --> 04:47:21,180
information about the function,
we want to call on some other

4878
04:47:21,180 --> 04:47:24,240
contract, we actually don't want
to call a function. So we're

4879
04:47:24,240 --> 04:47:27,000
going to leave this blank, we
can show that we're leaving it

4880
04:47:27,000 --> 04:47:30,240
blank by just putting in these
two quotes here, we instead want

4881
04:47:30,240 --> 04:47:34,920
to use this like a transaction.
And as we saw in our deployment,

4882
04:47:34,950 --> 04:47:38,160
there's always this message dot
value bid, we're going to use

4883
04:47:38,190 --> 04:47:41,940
this call function as if it's a
regular transaction, and we can

4884
04:47:41,970 --> 04:47:45,840
add stuff like message dot
value. So in here, we're going

4885
04:47:45,840 --> 04:47:51,030
to add these squiggly brackets.
And we're going to say, value

4886
04:47:52,320 --> 04:48:00,060
address this dot balance, this
call function returns actually

4887
04:48:00,060 --> 04:48:03,240
two variables. And when a
function returns two variables,

4888
04:48:03,570 --> 04:48:07,110
we can show that by placing them
into parentheses on the left

4889
04:48:07,110 --> 04:48:10,290
hand side, the two variables, it
returns are going to be a

4890
04:48:10,290 --> 04:48:15,840
Boolean, that we're going to
call call success. And also a

4891
04:48:15,840 --> 04:48:20,580
bytes object called data
returned, since call allows us

4892
04:48:20,580 --> 04:48:23,670
to actually call different
functions. If that function

4893
04:48:23,700 --> 04:48:28,020
returns some data or returns
value, we're going to save that

4894
04:48:28,050 --> 04:48:32,790
in the data returned variable.
It also returns call success,

4895
04:48:32,820 --> 04:48:36,180
where if the function was
successfully called this will be

4896
04:48:36,180 --> 04:48:41,310
true. If not, this will be
false. And since bytes objects

4897
04:48:41,400 --> 04:48:46,590
are arrays, data returns needs
to be in memory. Now for our

4898
04:48:46,590 --> 04:48:49,980
code here, we're actually not
calling a function, so we don't

4899
04:48:49,980 --> 04:48:53,640
really care about data returned.
So similar to what we saw with

4900
04:48:53,670 --> 04:48:57,300
the price contract, we can just
go ahead and delete that and

4901
04:48:57,300 --> 04:49:00,570
leave the comma to tell solidity
Yeah, we know this function

4902
04:49:00,570 --> 04:49:03,930
returns two variables, but we
only care about one. And then

4903
04:49:03,960 --> 04:49:07,590
similar to the centerpiece
above, we're going to do require

4904
04:49:08,070 --> 04:49:12,690
cost access call failed, meaning
that we're requiring cost

4905
04:49:12,690 --> 04:49:16,650
accesses true. Otherwise, we'll
revert with an error that says

4906
04:49:16,650 --> 04:49:19,590
call failed. Now of learning the
difference between these three

4907
04:49:19,620 --> 04:49:22,830
is a little complicated for you
right now. Don't let that slow

4908
04:49:22,830 --> 04:49:26,040
you down. Feel free to come back
to this after you've learned

4909
04:49:26,040 --> 04:49:28,950
more about how some of these
lower level functions work. And

4910
04:49:28,950 --> 04:49:32,040
a little bit more about how
gasworks solidity by example,

4911
04:49:32,070 --> 04:49:35,520
does a fantastic job though of
saying what the difference is

4912
04:49:35,520 --> 04:49:39,450
between all three, our transfer
has a maximum of 2300 gas and

4913
04:49:39,450 --> 04:49:43,920
throws an error if it fails,
send has a maximum of 2300 gas

4914
04:49:44,220 --> 04:49:48,390
returns a Boolean, if it fails,
call forwards all gas so doesn't

4915
04:49:48,390 --> 04:49:54,300
have a capped gas. And similar
to send returns a Boolean, if it

4916
04:49:54,360 --> 04:49:59,280
is successful, or if it fails,
As of recording right now using

4917
04:49:59,280 --> 04:50:04,020
call is the recommended way to
actually send and receive

4918
04:50:04,350 --> 04:50:07,650
Aetherium or your blockchain
native token for now, if this

4919
04:50:07,650 --> 04:50:10,440
part's a little bit confusing
for you, for now, just look at

4920
04:50:10,440 --> 04:50:14,880
this and see ah, that's how we
send and transfer Aetherium or

4921
04:50:14,880 --> 04:50:17,880
native blockchain currency
tokens. And I'm going to delete

4922
04:50:18,030 --> 04:50:21,780
this part for the video, but
I'll keep those comments in the

4923
04:50:21,780 --> 04:50:27,990
code repository associated with
this course. And okay, perfect.

4924
04:50:28,050 --> 04:50:32,280
If we hit compile a fun meat
outsole, we do indeed see that

4925
04:50:32,430 --> 04:50:36,900
it's passing compliation.
However, there's a bit of an

4926
04:50:36,900 --> 04:50:38,700
issue here, right now,

4927
04:50:38,850 --> 04:50:43,530
anybody can withdraw from this
contract. So anybody can fund,

4928
04:50:43,620 --> 04:50:46,980
which is what we want. But we
don't want anyone to be able to

4929
04:50:46,980 --> 04:50:50,220
withdraw. We only want the
person who's collecting the

4930
04:50:50,220 --> 04:50:53,730
funds to be able to actually
withdraw the funds. So how do we

4931
04:50:53,730 --> 04:50:58,290
set this up so that the withdraw
function is only called by the

4932
04:50:58,320 --> 04:51:01,230
owner of this contract? Well, to
do that, we're going to set up a

4933
04:51:01,230 --> 04:51:05,640
couple new functions. So when we
deploy this contract, we want to

4934
04:51:05,670 --> 04:51:09,510
automatically set it up so that
whomever deploys this contract

4935
04:51:09,540 --> 04:51:12,480
is going to be the owner of this
contract. And then we can do

4936
04:51:12,480 --> 04:51:16,140
some parameters to set it up so
that only the owner of this

4937
04:51:16,140 --> 04:51:18,870
contract can call the withdrawal
function. So how would we do

4938
04:51:18,870 --> 04:51:23,490
that? Well, maybe we can create
a function called like, call me

4939
04:51:23,520 --> 04:51:28,740
right away. And right after we
deploy this contract, we call

4940
04:51:28,740 --> 04:51:31,980
this call me right away
function, which will set up us

4941
04:51:31,980 --> 04:51:35,070
as the owner. Now that's going
to take two transactions. And

4942
04:51:35,070 --> 04:51:38,340
that would be really annoying if
we had to do that. So instead,

4943
04:51:38,550 --> 04:51:44,340
solidity has something called a
constructor. And if you're

4944
04:51:44,340 --> 04:51:46,860
familiar with other programming
language, a constructor is

4945
04:51:46,860 --> 04:51:50,250
exactly the same as other
programming languages.

4946
04:51:50,400 --> 04:51:53,340
constructor is going to be the
function that gets called when,

4947
04:51:53,490 --> 04:51:57,450
immediately whenever or you
deploy a contract. So if I were

4948
04:51:57,450 --> 04:52:03,270
to deploy Funmi, dot Sol, and I
were to say, minimum USD equals

4949
04:52:03,360 --> 04:52:08,850
to minimum USD would no longer
be 50 times one e to the 18th,

4950
04:52:08,880 --> 04:52:12,900
it would be immediately updated
to two. Because constructor is a

4951
04:52:12,900 --> 04:52:16,440
function that gets immediately
called in the same transaction,

4952
04:52:16,740 --> 04:52:20,370
that we create this contract,
this constructor function is

4953
04:52:20,370 --> 04:52:23,100
going to be incredibly helpful
for us, because it allows us to

4954
04:52:23,100 --> 04:52:26,910
set up the contract the way we
want it to be. So for example,

4955
04:52:27,240 --> 04:52:30,960
if we want the withdrawal
function to only be able to be

4956
04:52:30,960 --> 04:52:34,050
called by the owner of this
contract, we can have the

4957
04:52:34,050 --> 04:52:38,070
constructor set up who the owner
of the contract is. So let's

4958
04:52:38,070 --> 04:52:43,860
create a global variable called
address, public owner. And then

4959
04:52:43,860 --> 04:52:47,640
in our constructor, we'll say
the owner is going to be equal

4960
04:52:47,640 --> 04:52:52,650
to the message dot sender. The
message that sender of the

4961
04:52:52,650 --> 04:52:56,670
constructor function is going to
be whoever is deploying the

4962
04:52:56,670 --> 04:53:00,720
contract. So owner is now going
to be whoever deployed this

4963
04:53:00,720 --> 04:53:04,200
contract. And don't worry, we're
going to demo all this very soon

4964
04:53:04,200 --> 04:53:07,410
and show you everything that's
going on with ether scan

4965
04:53:07,410 --> 04:53:10,590
everything, demoing this all
right now might take a little

4966
04:53:10,590 --> 04:53:13,260
bit of time, because we're using
a test net. So if you want to

4967
04:53:13,260 --> 04:53:16,500
test it all right now,
absolutely go for it, but just

4968
04:53:16,500 --> 04:53:21,990
know, it'll take you a little
bit longer to do so. Now that we

4969
04:53:21,990 --> 04:53:25,350
have the owner setup, we can
modify our withdrawal function

4970
04:53:25,410 --> 04:53:29,850
to make it so that only the
owner can actually call this

4971
04:53:29,850 --> 04:53:32,700
withdrawal function. So at the
top of the withdrawal function,

4972
04:53:32,850 --> 04:53:37,080
maybe we want to add a section,
maybe we want to say require

4973
04:53:37,980 --> 04:53:44,010
message dot sender equals the
owner, a note about double

4974
04:53:44,010 --> 04:53:48,000
equals versus equals, you can
think of this single equals as a

4975
04:53:48,000 --> 04:53:53,640
set parameter. So when I say
owner, is now set to message dot

4976
04:53:53,640 --> 04:53:58,590
sender, double equals is how you
check to see if these two

4977
04:53:58,620 --> 04:54:02,430
variables are equivalent. So
we're saying is message dot

4978
04:54:02,430 --> 04:54:06,780
sender, the same as owner. So
this is checking to see

4979
04:54:06,810 --> 04:54:10,440
equivalence. This is setting
checking to see equivalence

4980
04:54:10,590 --> 04:54:14,460
setting. So we're gonna say
require message dot sender is

4981
04:54:14,460 --> 04:54:18,180
equal to owner, otherwise, we're
gonna throw an error, saying,

4982
04:54:18,330 --> 04:54:23,340
sender is not owner. Perfect.
Now we have a quick way to make

4983
04:54:23,340 --> 04:54:28,530
sure the withdrawal function is
only called by the owner of this

4984
04:54:28,530 --> 04:54:31,500
contract. Now, let's say that
there's a lot of functions that

4985
04:54:31,500 --> 04:54:35,370
we have in this contract that
are going to be required to be

4986
04:54:35,370 --> 04:54:38,340
the owner, maybe there's a lot
of functions in this contract

4987
04:54:38,370 --> 04:54:40,740
that need a whole lot of
different requires, we don't

4988
04:54:40,740 --> 04:54:43,620
want to have to copy paste this
line to every single one of our

4989
04:54:43,620 --> 04:54:46,440
functions. So what can we do?
Well, this is where something

4990
04:54:46,440 --> 04:54:50,310
called modifiers come in. So for
now, we're gonna go ahead and

4991
04:54:50,310 --> 04:54:54,090
delete this line. And below,
we're going to create something

4992
04:54:54,090 --> 04:54:59,010
called a modifier, our modifier
is going to be a key word that

4993
04:54:59,010 --> 04:55:03,240
we can add right in the function
declaration. To modify the

4994
04:55:03,240 --> 04:55:05,640
function with that
functionality, we're going to

4995
04:55:05,640 --> 04:55:10,230
create a modifier and call it
only owner. And we're going to

4996
04:55:10,230 --> 04:55:15,240
paste that line that we just
made in withdraw. And underneath

4997
04:55:15,240 --> 04:55:18,000
that, we're going to put a
little underscore, what I can do

4998
04:55:18,000 --> 04:55:21,900
now is I can take this only
owner modifier, and stick it in

4999
04:55:21,900 --> 04:55:25,320
the function declaration of my
withdrawal function. So what's

5000
04:55:25,320 --> 04:55:29,160
happening with this modifier
with only owner in this function

5001
04:55:29,160 --> 04:55:29,970
declaration,

5002
04:55:30,060 --> 04:55:33,660
we're saying, hey, for this
withdrawal function, before you

5003
04:55:33,660 --> 04:55:37,410
read all this code inside of it,
look down at the only owner

5004
04:55:37,410 --> 04:55:42,510
modifier and do whatever is in
there first, and then do

5005
04:55:42,510 --> 04:55:45,540
whatever's in the underscore,
this underscore represents doing

5006
04:55:45,540 --> 04:55:48,330
the rest of the code. So now,
when we go call the withdraw

5007
04:55:48,330 --> 04:55:53,730
function, we actually do this
require statement first, and

5008
04:55:53,730 --> 04:55:57,900
then call the rest of the code.
If this require statement, we're

5009
04:55:57,900 --> 04:56:02,100
below the underscore, this would
tell our function to go ahead

5010
04:56:02,100 --> 04:56:06,900
and do all this code first. And
then run the require. Because

5011
04:56:06,900 --> 04:56:09,690
again, we have this only only
keyword, we're saying, Great,

5012
04:56:09,690 --> 04:56:12,810
we've got a function, it's
withdraw its public, oh, only

5013
04:56:12,810 --> 04:56:16,710
odor modifier. Let's look at how
that works. Okay, it tells us

5014
04:56:16,710 --> 04:56:19,350
how to do all the code of the
original function first. So

5015
04:56:19,350 --> 04:56:22,320
let's go ahead and do that.
Okay, now we're done. Now, what

5016
04:56:22,320 --> 04:56:25,800
do we do? Okay, now we'll run
the require, we want to go ahead

5017
04:56:25,800 --> 04:56:29,670
and put the require here first.
So this is how modifiers work,

5018
04:56:30,030 --> 04:56:35,820
and how we can use them to
improve our functionality. All

5019
04:56:35,820 --> 04:56:39,600
right, awesome. We have all the
basic functionality of our

5020
04:56:39,600 --> 04:56:42,840
contract that we need here. Now
we're finally actually going to

5021
04:56:42,840 --> 04:56:46,740
run everything on a test and see
everything happened live before

5022
04:56:46,740 --> 04:56:49,290
our eyes. Are you ready? Let's
do this.

5023
04:56:49,350 --> 04:56:52,590
So let's go over to the deploy
tab. And we're going to switch

5024
04:56:52,650 --> 04:56:55,710
of course to injected web three.
Remember But we're using

5025
04:56:55,710 --> 04:56:59,580
injected web three, because our
price converter dot soul is

5026
04:56:59,580 --> 04:57:02,760
using chainlink Oracle's that
actually exist and are actually

5027
04:57:02,760 --> 04:57:05,430
monitoring the Rinkeby network
for us. Now we're going to

5028
04:57:05,430 --> 04:57:09,690
scroll down to, and we're going
to choose the Funmi contract.

5029
04:57:09,780 --> 04:57:12,780
And we're going to go ahead and
deploy. Once again, we want to

5030
04:57:12,780 --> 04:57:16,380
make sure we're on the Rinkeby
test net. And we have a little

5031
04:57:16,380 --> 04:57:19,620
bit of rinky eath in our wallet,
let's go ahead and deploy,

5032
04:57:20,730 --> 04:57:24,510
confirm. And we'll wait a little
bit. And I'll pull up our log

5033
04:57:24,510 --> 04:57:28,320
here. And we'll wait a little
bit for our contract to get

5034
04:57:28,320 --> 04:57:31,290
deployed. Alright, great. It
looks like our contract has

5035
04:57:31,290 --> 04:57:35,040
indeed been deployed. If we
scroll down, we can see all of

5036
04:57:35,040 --> 04:57:40,500
our functionality, minimum USD
is going to be that $50. But

5037
04:57:40,500 --> 04:57:44,580
with 18 zeros so that the units
are the same as Aetherium, the

5038
04:57:44,580 --> 04:57:49,980
owner of our contract was set to
our address, the instant we

5039
04:57:49,980 --> 04:57:53,070
deployed this contract, it was
deployed by calling our

5040
04:57:53,070 --> 04:57:58,440
constructor function. So this
address 0x 106 x is going to be

5041
04:57:58,440 --> 04:58:02,760
the same as the address in our
meta mask, your address here, of

5042
04:58:02,760 --> 04:58:05,460
course, is going to be a little
bit different than mine, we have

5043
04:58:05,460 --> 04:58:08,850
our funders array, which, of
course is going to be blank, we

5044
04:58:08,850 --> 04:58:11,640
have our address array, which is
also going to be blank. And then

5045
04:58:11,640 --> 04:58:14,730
we have two functions that we
can use to modify the state of

5046
04:58:14,730 --> 04:58:18,300
the blockchain withdraw is going
to be orange, because we're not

5047
04:58:18,330 --> 04:58:22,290
paying any Aetherium we're
actually gaining Aetherium or

5048
04:58:22,290 --> 04:58:25,290
whatever native blockchain
currency fund is going to be

5049
04:58:25,290 --> 04:58:29,310
read, because fun is a payable
function that we are going to be

5050
04:58:29,310 --> 04:58:33,030
sending Aetherium to or sending
whatever native blockchain

5051
04:58:33,030 --> 04:58:35,820
currency that you're working
with. So let's go ahead and see

5052
04:58:35,850 --> 04:58:39,540
how this all works. So first,
let's go ahead and fund this

5053
04:58:39,540 --> 04:58:43,620
contract. Again, funding, we got
to do a little bit of math,

5054
04:58:43,680 --> 04:58:47,790
right now, since the price of
eath is around $3,000. And we're

5055
04:58:47,790 --> 04:58:53,460
looking for $50. Minimum, we do
50 divided by 3000. We can do

5056
04:58:53,460 --> 04:58:58,710
3000 divided by 50, we can do 50
divided by 3000. So we know that

5057
04:58:58,740 --> 04:59:04,860
around 0.02 Aetherium, should be
enough for this contract to

5058
04:59:04,860 --> 04:59:11,250
work. So 0.02 Aetherium is this
much way, we can copy that,

5059
04:59:12,240 --> 04:59:16,020
paste that into here. So when we
hit fund, it should actually

5060
04:59:16,020 --> 04:59:20,610
pass. And we do indeed see meta
masks pop up. And we'll go ahead

5061
04:59:20,610 --> 04:59:23,760
and confirm. Once this
transaction goes through, we'll

5062
04:59:23,760 --> 04:59:28,110
be able to see this contract on
ether scan with the funds in it.

5063
04:59:28,290 --> 04:59:31,860
Now if we don't add way here, if
we don't add a value, once

5064
04:59:31,860 --> 04:59:35,880
again, we had fund will say gas
estimation failed because we're

5065
04:59:35,880 --> 04:59:39,450
not sending enough here. And in
fact, we even see execution

5066
04:59:39,450 --> 04:59:42,660
reverted didn't send enough, we
can absolutely send this

5067
04:59:42,660 --> 04:59:46,320
transaction however, it's going
to fail. Great. So now that our

5068
04:59:46,320 --> 04:59:49,680
transaction has gone through, if
we go on to the rink the ether

5069
04:59:49,680 --> 04:59:53,430
scan, once we wait a little bit
for it to finish indexing here

5070
04:59:53,430 --> 04:59:56,700
on the Rinkeby ether scan, we
can see that transaction

5071
04:59:56,730 --> 04:59:59,970
actually went through for doing
the funding, we can actually see

5072
05:00:00,000 --> 05:00:03,240
a lot of different details going
on with this transaction as

5073
05:00:03,240 --> 05:00:06,750
well. And if we scroll down, we
once again, you can see all the

5074
05:00:06,750 --> 05:00:10,530
information about us calling
this fun function, gas limit

5075
05:00:10,560 --> 05:00:15,660
gas, you should the gas fees,
gas price, and we can see the

5076
05:00:15,660 --> 05:00:20,040
input data as well, we can see
that we called the fund function

5077
05:00:20,070 --> 05:00:23,370
down here. We'll learn more
about the input data later. If

5078
05:00:23,370 --> 05:00:27,750
we go to the contract that we
deployed, we can now see two

5079
05:00:27,750 --> 05:00:31,680
transactions, we can see our
contract created transaction.

5080
05:00:32,130 --> 05:00:36,150
And we can also see we called a
font method. And if we look at

5081
05:00:36,150 --> 05:00:40,950
the balance of our contract, and
now has 0.02 ether, which makes

5082
05:00:40,950 --> 05:00:46,710
sense, since we just sent it
0.02. If we put that 0.02 eath

5083
05:00:46,710 --> 05:00:51,840
in terms of way back into the
value section, and we call font

5084
05:00:51,840 --> 05:00:57,660
again, after this transaction
goes through, we should see this

5085
05:00:57,660 --> 05:01:04,350
number go from 0.02 to 0.04. Now
after we wait a brief delay, we

5086
05:01:04,350 --> 05:01:09,030
do indeed see the balance has
gone up to 0.04, which is

5087
05:01:09,030 --> 05:01:12,240
exactly what we'd expect.
Awesome. So our funding

5088
05:01:12,240 --> 05:01:16,170
mechanism is working correctly.
And if we go down into our

5089
05:01:16,200 --> 05:01:18,090
array, and our mapping

5090
05:01:20,190 --> 05:01:25,140
to do address to array, and we
paste our address, we should see

5091
05:01:25,470 --> 05:01:29,700
the phone number show up. And if
we go to funders of zero, we see

5092
05:01:29,700 --> 05:01:33,390
our address. And if we go to
funders of one, we also see our

5093
05:01:33,390 --> 05:01:37,500
address and we see that and we
see this call going through if

5094
05:01:37,500 --> 05:01:41,040
we go to funders have to in our
log over here, we actually see

5095
05:01:41,040 --> 05:01:44,130
that we get an error an
optimization that we could make

5096
05:01:44,130 --> 05:01:48,420
to our contract in the future is
to check to see if an address is

5097
05:01:48,420 --> 05:01:51,210
already in the funders array and
then not add it if it's already

5098
05:01:51,210 --> 05:01:54,690
there. Now let's go ahead and
try to call this withdrawal

5099
05:01:54,690 --> 05:01:58,110
function. But let's try to call
it with a different address than

5100
05:01:58,110 --> 05:02:00,750
the address we originally
deployed this contract with. So

5101
05:02:00,750 --> 05:02:05,610
to do that, scroll all the way
to the top of this here. And I'm

5102
05:02:05,610 --> 05:02:11,100
going to go to my Metamask. And
I'm going to switch to a second

5103
05:02:11,130 --> 05:02:16,500
account and hit connect. Now,
our remixes should be updated

5104
05:02:16,530 --> 05:02:19,560
with the new account that's in
here, you'll see that if I

5105
05:02:19,560 --> 05:02:24,240
switch back to account one, it
switches back to account one, so

5106
05:02:24,240 --> 05:02:27,690
long as they're both connected,
you can see which accounts are

5107
05:02:27,690 --> 05:02:30,870
connected to applications by
clicking this connected button

5108
05:02:31,080 --> 05:02:33,300
and see which ones are
connected. If you ever want to

5109
05:02:33,300 --> 05:02:36,780
disconnect that account, you can
click the three little dots and

5110
05:02:36,780 --> 05:02:40,200
it disconnect the account. And
now we can see that this account

5111
05:02:40,230 --> 05:02:45,330
is not connected. However, count
two is connected. Let's go back

5112
05:02:45,330 --> 05:02:49,320
to account one and Connect
account one so that both of them

5113
05:02:49,350 --> 05:02:53,640
are now connected. But we'll
switch to account two, let's

5114
05:02:53,640 --> 05:02:57,180
switch to account two, because
again, account two isn't the

5115
05:02:57,180 --> 05:03:02,130
owner of this contract. We
scroll down to owner, we can see

5116
05:03:02,130 --> 05:03:07,290
owner's 0x 1066 Something
something and account two is

5117
05:03:07,680 --> 05:03:11,460
0x 043. Something something
awesome. So what do you think

5118
05:03:11,460 --> 05:03:15,390
will happen when we hit withdraw
here? Well, our modifier only

5119
05:03:15,390 --> 05:03:19,140
owner should kick in. And we
should get notified that if we

5120
05:03:19,140 --> 05:03:23,130
send the transaction, we'll get
this error sender is not owner.

5121
05:03:23,340 --> 05:03:27,360
So let's try it. Ah gas
estimation failed, we do get

5122
05:03:27,360 --> 05:03:31,560
this error. Sender is not owner,
which is perfect. This is

5123
05:03:31,560 --> 05:03:34,650
exactly what we want, we could
absolutely send this transaction

5124
05:03:34,680 --> 05:03:37,860
if we wanted to. But that would
just be a waste of gas because

5125
05:03:37,860 --> 05:03:41,880
this transaction is going to
fail. However, if we switch back

5126
05:03:42,150 --> 05:03:48,780
to account one, and we hit
withdraw, meta mask will pop up,

5127
05:03:48,990 --> 05:03:53,940
enabling us to confirm and
withdraw the ether out of this

5128
05:03:53,940 --> 05:03:57,180
contract address. Now if we look
at this contract address on

5129
05:03:57,180 --> 05:04:01,710
ether scan, after a brief delay,
we'll see the balance go from

5130
05:04:01,710 --> 05:04:07,200
0.04 back down to zero. And
we'll see our wallet balance go

5131
05:04:07,290 --> 05:04:12,000
up from what it is back to 0.04
plus what it was. And after a

5132
05:04:12,000 --> 05:04:15,810
brief delay, you can see our
balance is indeed back down to

5133
05:04:15,810 --> 05:04:20,010
zero in our contract. Now, if we
do address to amount for our

5134
05:04:20,010 --> 05:04:22,770
wallet address that was doing
the funding, it's back down to

5135
05:04:22,770 --> 05:04:27,060
zero. And if we try to check the
address of funders at index

5136
05:04:27,060 --> 05:04:30,900
zero, we get called to funders
that fund me errored execution

5137
05:04:30,900 --> 05:04:31,440
reverted.

5138
05:04:40,590 --> 05:04:43,650
We've completed all the basics
of this section that I wanted to

5139
05:04:43,650 --> 05:04:46,350
go through. And you should be
incredibly proud of yourself for

5140
05:04:46,350 --> 05:04:49,320
getting this far, you've just
deployed a really advanced smart

5141
05:04:49,320 --> 05:04:53,370
contract, we're using a library
and chainlink contracts to build

5142
05:04:53,400 --> 05:04:55,860
some of the most powerful
applications in the planet,

5143
05:04:55,890 --> 05:04:59,370
we've learned to use a library
for any type we want in our

5144
05:04:59,370 --> 05:05:03,150
smart contracts. We've learned
more about multiplication, and

5145
05:05:03,150 --> 05:05:06,240
then units of measure in
solidity and smart contracts.

5146
05:05:06,540 --> 05:05:09,000
We've learned about mappings
more about arrays what the

5147
05:05:09,000 --> 05:05:12,180
constructor does, we've learned
how to send money we've learned

5148
05:05:12,180 --> 05:05:15,270
about for loops, we've learned
about the different ways we can

5149
05:05:15,270 --> 05:05:18,030
actually send money, at least
from a low level. And we've

5150
05:05:18,030 --> 05:05:20,940
learned about modifiers. This
section is one of the tougher

5151
05:05:20,940 --> 05:05:23,460
sections in this course. So if
you completed this, you should

5152
05:05:23,460 --> 05:05:26,460
be incredibly excited. We're
going to go through our code

5153
05:05:26,460 --> 05:05:29,760
now. And we're going to make a
number of tweaks. Now this

5154
05:05:29,760 --> 05:05:32,400
section, we are going to do a
little bit more advanced

5155
05:05:32,430 --> 05:05:36,120
solidity here. So if you get a
little bit lost, don't sweat it

5156
05:05:36,120 --> 05:05:39,570
too much. And feel free to try
some of this stuff in the future

5157
05:05:39,570 --> 05:05:44,670
on your own. We're going to
modify this contract to make it

5158
05:05:44,700 --> 05:05:47,430
a little bit more professional.
It's not going to be end to end

5159
05:05:47,430 --> 05:05:49,650
amazing, but it's going to be a
little bit better. And you'll

5160
05:05:49,650 --> 05:05:51,690
see why in a minute. So the
first thing that we're going to

5161
05:05:51,690 --> 05:05:53,940
do is we're looking we're going
to look at some of these

5162
05:05:53,940 --> 05:05:58,860
variables here. In particular
owner and minimum USD, owner

5163
05:05:58,860 --> 05:06:02,700
gets set one time in our
contract here. And then it never

5164
05:06:02,700 --> 05:06:08,460
changes. Again, minimum USD gets
set one time, even outside of

5165
05:06:08,460 --> 05:06:12,210
the constructor. If we have
variables that only get set one

5166
05:06:12,210 --> 05:06:16,440
time, we can actually use some
tools in solidity to make them

5167
05:06:16,440 --> 05:06:19,200
more gas efficient. For now
let's compile our Funmi

5168
05:06:19,200 --> 05:06:22,500
contract, and then deploy it to
a JavaScript virtual machine.

5169
05:06:22,710 --> 05:06:25,980
Remember, we can go ahead and
deploy it right now. However,

5170
05:06:26,040 --> 05:06:29,400
funding and withdrawing and
doing in the money stuff isn't

5171
05:06:29,400 --> 05:06:32,790
going to work. Because again, we
don't have a chain link network

5172
05:06:33,000 --> 05:06:36,270
on our JavaScript VM. So those
aren't going to work so well.

5173
05:06:36,300 --> 05:06:38,640
But for what we're gonna do
right now, we don't really care

5174
05:06:38,640 --> 05:06:42,300
so much. Here's what we do care
about. You do care about how

5175
05:06:42,300 --> 05:06:46,020
much gas this costs to actually
send. We do care about how much

5176
05:06:46,020 --> 05:06:50,460
gas is costs to create right now
creating this contract costs

5177
05:06:50,880 --> 05:06:56,400
about 859,000 gas and we're
going to Add a couple of tricks.

5178
05:06:56,580 --> 05:06:59,310
Right now to bring this number
down, we're going to add some

5179
05:06:59,310 --> 05:07:02,610
stuff back in in the bid, which
will bring it back up. But for

5180
05:07:02,610 --> 05:07:04,260
now, we're going to learn some
tricks to bring this number

5181
05:07:04,260 --> 05:07:07,470
down. The two tricks that we're
going to learn are the constant

5182
05:07:07,470 --> 05:07:10,950
keyword and the immutable
keyword, in their solidity.

5183
05:07:10,980 --> 05:07:14,700
There are two keywords that make
it so that your variables can't

5184
05:07:14,700 --> 05:07:18,300
be changed. And those keywords
are constant and immutable. You

5185
05:07:18,300 --> 05:07:21,270
can learn more about them in the
solidity documentation, if you

5186
05:07:21,270 --> 05:07:24,630
assign a variable once outside
of a function, and then never

5187
05:07:24,630 --> 05:07:28,350
change it, so if if it's
assigned at compile time, you

5188
05:07:28,350 --> 05:07:32,250
can go ahead and add this
constant keyword. We'll learn

5189
05:07:32,250 --> 05:07:35,520
later about storage. But when
you add a constant keyword, this

5190
05:07:35,520 --> 05:07:40,080
minimum USD no longer takes up a
storage spot, and is much easier

5191
05:07:40,110 --> 05:07:43,860
to read too. So now we recompile
this, and we deploy this new

5192
05:07:43,860 --> 05:07:48,300
contract. Let's see if we saved
any gas. We look in the

5193
05:07:48,300 --> 05:07:52,770
transaction logs, now, we can
grab the transaction cost of how

5194
05:07:52,770 --> 05:07:55,920
much this cost to deploy, let's
compare it to how much it was

5195
05:07:55,920 --> 05:08:00,270
before. Well, we saved almost
19,000 gas, that's almost as

5196
05:08:00,270 --> 05:08:03,420
much gas as a cost to send
Aetherium. Typically, constant

5197
05:08:03,420 --> 05:08:06,870
variables have a different
naming convention. Typically,

5198
05:08:06,900 --> 05:08:11,430
you'll want to do them all caps
like Min imaam. Underscore, who

5199
05:08:11,430 --> 05:08:15,030
is the CIO all caps with
underscores. So now let's just

5200
05:08:15,030 --> 05:08:18,780
find minimum use D, and replace
that with all caps as well. With

5201
05:08:18,780 --> 05:08:22,050
this interaction, we know that
this variable is a constant

5202
05:08:22,050 --> 05:08:25,560
variable, and it's much cheaper
to read from now, if we go ahead

5203
05:08:25,560 --> 05:08:30,330
and compile this and redeploy.
In our Funmi contract, even

5204
05:08:30,330 --> 05:08:34,290
though this is a view function,
remember, view functions do have

5205
05:08:34,290 --> 05:08:38,670
gas costs when when called by
contract as a constant variable,

5206
05:08:38,700 --> 05:08:44,370
we can see the execution cost of
this variable 21,415 gas. So

5207
05:08:44,400 --> 05:08:46,380
let's put a little note rather
Nathan.

5208
05:08:47,610 --> 05:08:50,880
If we remove the constant
variable, we delete this

5209
05:08:50,880 --> 05:08:56,160
contract. And we redeploy, like
Funmi. And we hit minimum ust

5210
05:08:56,160 --> 05:09:00,000
again, we can now see how much
gas this was cost. If it wasn't

5211
05:09:00,000 --> 05:09:03,810
a constant variable, we can see
the gas cost did indeed go up.

5212
05:09:03,900 --> 05:09:06,510
Now on chains that are much
cheaper, this gas difference

5213
05:09:06,540 --> 05:09:08,940
probably won't make that much of
a difference. But on more

5214
05:09:08,940 --> 05:09:11,550
expensive chains like Aetherium,
this is going to make a big

5215
05:09:11,550 --> 05:09:15,210
difference. For example, on
Aetherium, we can actually see

5216
05:09:15,240 --> 05:09:19,200
current gas prices on Aetherium.
Here, we can see the current gas

5217
05:09:19,200 --> 05:09:23,580
price of Aetherium is about 141
way, so we'll go to our

5218
05:09:23,580 --> 05:09:28,620
converter, way to way we'll copy
the way price times this will

5219
05:09:28,620 --> 05:09:32,610
get the gas price of calling our
minimum USD, which is this

5220
05:09:32,610 --> 05:09:36,660
number here, which if we put
back in our Aetherium

5221
05:09:36,690 --> 05:09:41,520
uniconverter, we can see cost
this much gas. And if we times

5222
05:09:41,520 --> 05:09:45,120
that by the approximate current
price of Aetherium, which is

5223
05:09:45,120 --> 05:09:49,920
around $3,000. Calling minimum
use D as a constant is going to

5224
05:09:49,920 --> 05:09:54,870
cost $9 on the inside is at a
nonconstant is going to cost

5225
05:09:54,930 --> 05:09:58,860
almost an entire dollar more,
you can see how all these little

5226
05:09:58,860 --> 05:10:01,470
gas optimization tricks are
going to make your life a lot

5227
05:10:01,470 --> 05:10:04,350
better. So let's keep this
constant keyword in here. We'll

5228
05:10:04,350 --> 05:10:07,890
learn more about constant and
storage in later sections of

5229
05:10:07,890 --> 05:10:10,440
this course. Now, as you're just
getting started with this

5230
05:10:10,440 --> 05:10:15,420
course, and with slip the Do not
struggle. And do not worry about

5231
05:10:15,420 --> 05:10:19,200
making your contracts as gas
efficient as possible in the

5232
05:10:19,200 --> 05:10:22,500
beginning, and especially right
now. Just write your contracts

5233
05:10:22,500 --> 05:10:26,490
as best as you can. Once you get
really good at gas. And once you

5234
05:10:26,490 --> 05:10:30,210
get much later on in the course,
and much more advanced with

5235
05:10:30,210 --> 05:10:33,240
solidity, then you can start
going back and working on gas

5236
05:10:33,270 --> 05:10:37,290
optimizations. But do not let
gas optimizations hold you back.

5237
05:10:37,290 --> 05:10:41,250
Or if you start stressing over
it, just let it go. Don't worry

5238
05:10:41,250 --> 05:10:44,970
about it and just write your
code as best you can. So long

5239
05:10:44,970 --> 05:10:48,270
story short, Do not stress about
gas optimizations right now. Now

5240
05:10:48,300 --> 05:10:51,390
another variable we only set one
time is going to be our owner

5241
05:10:51,390 --> 05:10:56,040
variable. Owner equals message
dot sender. We set this one time

5242
05:10:56,070 --> 05:11:00,300
in the constructor variables
that we set one time but outside

5243
05:11:00,300 --> 05:11:02,910
of the same line that they're
declared. And we set them for

5244
05:11:02,910 --> 05:11:06,540
example, in the constructor, we
can mark as a mutable typically

5245
05:11:06,540 --> 05:11:09,330
a good convention for marking
immutable variables is going to

5246
05:11:09,360 --> 05:11:13,470
be doing I underscore so that we
know that these are immutable

5247
05:11:13,470 --> 05:11:16,350
variables, they have very
similar gas savings to the

5248
05:11:16,350 --> 05:11:19,140
constant keyword. Owner, of
course, is a variable that we

5249
05:11:19,140 --> 05:11:23,190
can't set on the line here
because inside the global scope,

5250
05:11:23,220 --> 05:11:26,610
there's no function going on.
However, inside functions,

5251
05:11:27,030 --> 05:11:29,730
because inside the global scope,
there's going to be no message

5252
05:11:29,730 --> 05:11:32,880
that sender, there's only going
to be a message dot sender when

5253
05:11:32,880 --> 05:11:36,150
we're inside of a function. So
inside here, we might say I

5254
05:11:36,150 --> 05:11:39,600
owner equals message dot sender.
And then of course, we'll scroll

5255
05:11:39,600 --> 05:11:44,610
down and we'll change this
require only owner now equals i

5256
05:11:44,610 --> 05:11:50,100
owner. Now if we compile that
deploy up, we can see how much

5257
05:11:50,100 --> 05:11:53,880
gas we can see how much gas
calling I owner is going to be

5258
05:11:53,880 --> 05:11:59,520
by with immutable notice, we get
21,508, which we'll go ahead and

5259
05:11:59,520 --> 05:12:02,340
copy for now. And we'll put
right here, we'll say,

5260
05:12:02,880 --> 05:12:08,760
immutable. Now, if we remove the
immutable keyword, let's close

5261
05:12:08,760 --> 05:12:13,920
this redeploy. If we scroll down
to I owner, screw up the logs,

5262
05:12:13,950 --> 05:12:17,940
we go down to the call, scroll
down, we see the execution cost

5263
05:12:17,970 --> 05:12:24,900
was much more. So we'll do the
backslash, a seven here, yes, or

5264
05:12:24,900 --> 05:12:28,350
non immutable. So you want to
keep some of these tricks in

5265
05:12:28,350 --> 05:12:32,310
mind, when it comes to storing
variables. The reason that these

5266
05:12:32,310 --> 05:12:35,940
two save gas is because instead
of storing these variables

5267
05:12:36,270 --> 05:12:39,270
inside of a storage slot, we
actually store them directly

5268
05:12:39,270 --> 05:12:41,940
into the bytecode of the
contract. And like I said, don't

5269
05:12:41,940 --> 05:12:44,760
worry too much about that for
now, later on in the course,

5270
05:12:44,790 --> 05:12:47,940
we'll teach you more about
storage and a lot of this low

5271
05:12:47,940 --> 05:12:50,820
level stuff that comes to these
contracts. But for now, just

5272
05:12:50,820 --> 05:12:54,210
know that these exist. And
they're nice gas savers, if

5273
05:12:54,210 --> 05:12:59,100
you're only setting your
variables once. Alright, great.

5274
05:12:59,100 --> 05:13:02,130
So we've just made our contract
a little bit more gas efficient,

5275
05:13:02,400 --> 05:13:04,770
little gas efficiency
improvements are going to be

5276
05:13:04,770 --> 05:13:07,620
concept I sprinkled throughout
this course. And when we get to

5277
05:13:07,620 --> 05:13:10,680
the more advanced section, I'm
going to break down exactly

5278
05:13:10,680 --> 05:13:13,590
what's going on and why all
these gas efficiencies exist and

5279
05:13:13,590 --> 05:13:15,960
what's going on behind the
scenes for these gas

5280
05:13:15,960 --> 05:13:18,930
efficiencies to occur. It's a
little bit in the weeds, which

5281
05:13:18,930 --> 05:13:20,820
is why I'm going to gloss over
it right now.

5282
05:13:20,850 --> 05:13:23,790
So if it's confusing, don't
worry, I wouldn't let these gas

5283
05:13:23,790 --> 05:13:26,700
efficiencies be the thing that
slow you down. Awesome. So we

5284
05:13:26,700 --> 05:13:29,550
have these two gas
optimizations? How else can we

5285
05:13:29,550 --> 05:13:32,910
make this contract a little bit
more gas efficient? Well, one of

5286
05:13:32,910 --> 05:13:35,910
the ways we can make this more
gas efficient, is by updating

5287
05:13:35,940 --> 05:13:39,570
our requires right now with our
require statement, we actually

5288
05:13:39,570 --> 05:13:43,860
have to store this sender is not
an owner as a string array,

5289
05:13:44,070 --> 05:13:46,710
every single one of these
characters in this errorlog

5290
05:13:46,950 --> 05:13:49,860
needs to get stored
individually, this string may

5291
05:13:49,860 --> 05:13:52,710
not seem very big, but it's a
lot bigger than the alternative

5292
05:13:52,710 --> 05:13:56,340
with what we can do. As of zero,
point 8.4 of solidity, you can

5293
05:13:56,340 --> 05:14:01,530
now actually do custom errors.
For our reverts, we declare them

5294
05:14:01,530 --> 05:14:05,730
at the top and then use ifs,
instead of require and then just

5295
05:14:05,730 --> 05:14:09,450
add a revert statements. This
ends up saving a lot of gas,

5296
05:14:09,480 --> 05:14:12,930
since we just call the error
code, as opposed to calling the

5297
05:14:12,930 --> 05:14:17,040
entire string associated with
the air. So for example, with

5298
05:14:17,040 --> 05:14:20,040
our require down here, and with
actually with all of our

5299
05:14:20,040 --> 05:14:23,820
requires, well we could do is
instead of having this require

5300
05:14:23,820 --> 05:14:28,410
we could create a custom error.
So at the top, what we could do

5301
05:14:28,710 --> 05:14:35,850
is we could say error, not
owner. And you'll notice that

5302
05:14:35,850 --> 05:14:39,150
this is actually outside of the
contract here. Now what we can

5303
05:14:39,150 --> 05:14:42,660
do is we can take this error not
owner scroll down into our only

5304
05:14:42,660 --> 05:14:45,480
owner, instead of doing a
require we'll do an if

5305
05:14:45,480 --> 05:14:53,400
statement, we'll say if message
dot sender is not owner, then

5306
05:14:53,580 --> 05:14:59,940
we're going to go ahead and
revert with a non owner error.

5307
05:15:00,360 --> 05:15:03,270
This ends up saving us a lot of
gas, since we don't have to

5308
05:15:03,270 --> 05:15:07,230
store and emit this long string
here. Now in a lot of code

5309
05:15:07,230 --> 05:15:10,350
today, you'll still see require
a lot of places because these

5310
05:15:10,380 --> 05:15:13,680
these custom errors are pretty
new in solidity. So you'll want

5311
05:15:13,680 --> 05:15:16,380
to get used to writing in both
ways. I wouldn't be surprised if

5312
05:15:16,380 --> 05:15:19,710
in the future, the syntax for
some of these errors looks like

5313
05:15:19,710 --> 05:15:22,920
this so that it's more readable.
But for now, if you want to do a

5314
05:15:22,920 --> 05:15:25,530
more gas efficient way than
required, you can use something

5315
05:15:25,530 --> 05:15:28,710
like this, we could update all
of our requires here for these

5316
05:15:28,710 --> 05:15:31,380
customers. But for now, I'm
going to leave both in just to

5317
05:15:31,380 --> 05:15:34,140
show you the differences. This
revert keyword does the exact

5318
05:15:34,140 --> 05:15:37,200
same thing that required us
without the conditional

5319
05:15:37,200 --> 05:15:40,350
beforehand. So you can actually
go ahead and revert any

5320
05:15:40,350 --> 05:15:43,050
transaction or any function call
in the middle of the function

5321
05:15:43,050 --> 05:15:49,230
call. Now let's look at one more
way to improve this contract.

5322
05:15:49,320 --> 05:15:51,570
Sometimes people will try to
interact with the contract that

5323
05:15:51,570 --> 05:15:54,360
takes Aetherium or the native
blockchain token without

5324
05:15:54,360 --> 05:15:57,120
actually going through the
required function calls that

5325
05:15:57,150 --> 05:16:01,200
that are needed. For example, on
a JavaScript EVM here, I could

5326
05:16:01,200 --> 05:16:04,830
actually try to send this
contract money without calling

5327
05:16:04,830 --> 05:16:08,310
the fund function. However, if I
were to do that, what would

5328
05:16:08,310 --> 05:16:11,520
happen with our fund function
get triggered? No, it wouldn't

5329
05:16:11,520 --> 05:16:14,250
get triggered, we wouldn't keep
track of that funder, we

5330
05:16:14,250 --> 05:16:17,100
wouldn't have that person's
information updated in this

5331
05:16:17,100 --> 05:16:20,490
contract. So if later on we want
to give rewards or something we

5332
05:16:20,490 --> 05:16:23,520
wouldn't know about those
funders. And this wouldn't be

5333
05:16:23,520 --> 05:16:26,160
great because people would send
our contract money without us

5334
05:16:26,160 --> 05:16:28,770
ever knowing and we wouldn't be
able to give them any credit or

5335
05:16:28,770 --> 05:16:32,940
anything. Additionally, maybe
they called the wrong function

5336
05:16:32,940 --> 05:16:35,760
by accident, and they they
weren't using Metamask. And they

5337
05:16:35,760 --> 05:16:38,070
weren't using a tool to tell
them, hey, this transaction is

5338
05:16:38,070 --> 05:16:41,580
likely going to fail. So what
can we do in this case? What

5339
05:16:41,580 --> 05:16:48,900
happens if someone sends this
contract, ether without calling

5340
05:16:49,290 --> 05:16:52,860
the fun function? Right now, if
we were to send this Funmi

5341
05:16:52,860 --> 05:16:55,800
contract, ie it would just go to
the contract Right, and this

5342
05:16:55,800 --> 05:16:58,410
contract just wouldn't keep
track of those people. But

5343
05:16:58,410 --> 05:17:00,840
there's actually a way for when
people send money to this

5344
05:17:00,840 --> 05:17:04,050
contract, or people call a
function that doesn't exist for

5345
05:17:04,050 --> 05:17:07,410
us to still trigger some code.
And now there are two special

5346
05:17:07,410 --> 05:17:12,690
functions in solidity one is
called receive, and one is

5347
05:17:12,690 --> 05:17:16,830
called the fallback. Now in
solidity, there are actually a

5348
05:17:16,830 --> 05:17:19,830
number of special functions and
two of these special functions

5349
05:17:19,860 --> 05:17:23,190
are the receive special
function. And the fallback

5350
05:17:23,220 --> 05:17:26,340
special function, a contract can
have at most one receive

5351
05:17:26,340 --> 05:17:29,250
function declared using the
received external payable.

5352
05:17:29,580 --> 05:17:32,700
Without the function keyword.
This function cannot have

5353
05:17:32,700 --> 05:17:34,980
arguments cannot return anything
and must have external

5354
05:17:34,980 --> 05:17:38,670
visibility, and a payable state
mutability. What does that

5355
05:17:38,670 --> 05:17:42,000
actually mean? And or look like?
Well, let's create a separate

5356
05:17:42,000 --> 05:17:44,820
contract to go ahead and play
with this. So in here, we're

5357
05:17:44,820 --> 05:17:48,960
going to create a new file
called fallback example, dot

5358
05:17:48,960 --> 05:17:52,710
soul. And in here, we're going
to add our basic pieces, SPX

5359
05:17:52,710 --> 05:18:00,660
license identifier, MIT pragma,
solidity zero, point 8.7. And

5360
05:18:00,660 --> 05:18:06,090
we'll do contract fallback
example, like so, feel free to

5361
05:18:06,090 --> 05:18:09,210
pause the video to catch up to
this point, let's recreate our

5362
05:18:09,210 --> 05:18:12,480
fallback contract, let's create
a variable to go ahead and try

5363
05:18:12,480 --> 05:18:17,490
to test this function, we'll
create a un 256 public result

5364
05:18:17,490 --> 05:18:20,820
variable. And let's create this
receive function. So we'll say

5365
05:18:20,820 --> 05:18:24,180
receive, it's going to be an
external payable.

5366
05:18:25,740 --> 05:18:30,210
function, we don't add the
function keyword for receive,

5367
05:18:30,510 --> 05:18:34,170
since solidity knows that
receive is a special function

5368
05:18:34,200 --> 05:18:38,610
whenever we send Aetherium or
make a transaction to this

5369
05:18:38,610 --> 05:18:41,880
contract. Now, as long as
there's no data associated with

5370
05:18:41,880 --> 05:18:45,030
that transaction, this receive
function will get triggered.

5371
05:18:45,300 --> 05:18:50,850
What we can do in here now is we
can say result equals one. So

5372
05:18:50,880 --> 05:18:53,610
let's go ahead and test this out
on the JavaScript virtual

5373
05:18:53,610 --> 05:18:56,820
machine, we compile this, so
we're gonna go ahead and compile

5374
05:18:56,820 --> 05:19:00,420
this. And we'll go deploy it on
the Java Virtual Machine, we're

5375
05:19:00,420 --> 05:19:04,200
going to deploy our fallback
example. And we're going to see

5376
05:19:04,200 --> 05:19:07,560
what result is initialized to,
since we haven't set anything

5377
05:19:07,560 --> 05:19:12,270
for result, result, of course,
is initialized zero. But what if

5378
05:19:12,270 --> 05:19:16,530
we were to send this contract
some Aetherium? Well receive

5379
05:19:16,530 --> 05:19:19,530
would go ahead and be triggered
here, we can actually send this

5380
05:19:19,530 --> 05:19:22,380
contract some material directly
by working with this low level

5381
05:19:22,380 --> 05:19:25,050
interactions. But here, don't
worry about what call data means

5382
05:19:25,050 --> 05:19:28,830
for now, just know that this
area down here is a way we can

5383
05:19:28,830 --> 05:19:32,070
send and work with different
functions. And we can add

5384
05:19:32,070 --> 05:19:35,580
parameters to this transaction,
by going up here and adjusting

5385
05:19:35,580 --> 05:19:39,090
the variables up here. If we
keep called Data blank, it'll be

5386
05:19:39,090 --> 05:19:42,360
the same as if we were in
Metamask. And just hitting send

5387
05:19:42,390 --> 05:19:45,360
in the choosing this contract
address. Again, we can't

5388
05:19:45,360 --> 05:19:48,570
actually use Metamask, since
this is a virtual machine, and

5389
05:19:48,570 --> 05:19:51,270
not one of the networks that
we're working with. So if I do,

5390
05:19:51,270 --> 05:19:55,860
for example, I change this value
to one way, and I keep

5391
05:19:55,860 --> 05:19:59,490
everything blank. And I go ahead
and hit this transaction button,

5392
05:19:59,520 --> 05:20:02,460
which again, is going to be the
same as hitting this Send

5393
05:20:02,460 --> 05:20:05,640
button, but only sending one
way. What do you think will

5394
05:20:05,640 --> 05:20:10,110
happen? Well, let's try it. We
can see in the log area that we

5395
05:20:10,110 --> 05:20:14,370
did indeed send a transaction.
And if you look at the

5396
05:20:14,370 --> 05:20:17,850
description here, you can even
see it says from so and so to

5397
05:20:17,880 --> 05:20:22,500
fall back example, dot receive,
it looks like it called our

5398
05:20:22,500 --> 05:20:26,190
received function, which should
have updated our result to one.

5399
05:20:26,610 --> 05:20:30,660
So if we hit result, now we can
indeed see that result has been

5400
05:20:30,690 --> 05:20:33,930
updated to the value of one.
Well, let's go ahead and delete

5401
05:20:33,930 --> 05:20:38,010
this. Let's deploy this contract
again. And this time, let's have

5402
05:20:38,010 --> 05:20:42,120
this value be zero, does receive
get triggered this time. So

5403
05:20:42,120 --> 05:20:45,630
let's pull this down. Let's hit
transact. Let's leave the call

5404
05:20:45,630 --> 05:20:49,860
data blank, we'll leave value at
zero. So this will be the same

5405
05:20:50,100 --> 05:20:55,200
as if we had sent zero Aetherium
to this contract. Let's hit

5406
05:20:55,200 --> 05:20:58,860
transact. It looks like that
went through, do you think

5407
05:20:58,860 --> 05:21:02,310
result is going to be one or
zero? You thought one you were

5408
05:21:02,310 --> 05:21:05,700
correct or receive function gets
triggered anytime we send a

5409
05:21:05,700 --> 05:21:09,600
transaction to this contract
now, and we don't specify a

5410
05:21:09,600 --> 05:21:13,260
function. And we keep the call
data blank when working with any

5411
05:21:13,260 --> 05:21:16,620
other contract like Funmi. For
example, when we call one of

5412
05:21:16,620 --> 05:21:19,500
these functions, we're actually
just populating this call data

5413
05:21:19,500 --> 05:21:22,860
bit with certain data that
points to one of these functions

5414
05:21:22,860 --> 05:21:26,190
up here. If we send a
transaction and we add data to

5415
05:21:26,190 --> 05:21:29,010
it, we could actually call one
of these functions. Now let's

5416
05:21:29,010 --> 05:21:32,130
try this again. Let's delete the
contract again we'll redeploy

5417
05:21:32,430 --> 05:21:36,690
open this up result is currently
zero receive like I said only is

5418
05:21:36,690 --> 05:21:41,280
triggered if our call data to it
is blank. Now this time if I had

5419
05:21:41,280 --> 05:21:44,040
some call data to this
transaction, do you think

5420
05:21:44,040 --> 05:21:46,800
receive will be triggered this
time? If we hit transact and

5421
05:21:46,800 --> 05:21:50,340
remix we actually get a pop up
saying fallback function is not

5422
05:21:50,340 --> 05:21:53,880
defined. This is because
whenever data is sent with a

5423
05:21:53,880 --> 05:21:58,140
transaction solidity says, Oh,
well, since you're sending data

5424
05:21:58,380 --> 05:22:00,900
you're not looking for receive,
you're looking for some

5425
05:22:00,900 --> 05:22:04,350
function. So let me look for
that function for you. Hmm, I

5426
05:22:04,350 --> 05:22:08,130
don't see any function that
matches the 0x 00. So I'm going

5427
05:22:08,130 --> 05:22:11,430
to look for your fallback
function. Remix is smart enough

5428
05:22:11,430 --> 05:22:14,760
to know that we don't have a
fallback function. The second

5429
05:22:14,760 --> 05:22:17,670
special function in solidity is
called the fallback function.

5430
05:22:17,970 --> 05:22:21,420
This is very similar to the
receive function, except for the

5431
05:22:21,420 --> 05:22:24,720
fact that can work even when
data is sent along with

5432
05:22:24,720 --> 05:22:27,360
transaction. So our fallback
will look something like this

5433
05:22:27,960 --> 05:22:28,650
callback,

5434
05:22:29,730 --> 05:22:38,610
external payable. result equals
to Fallback is another one of

5435
05:22:38,610 --> 05:22:40,890
these functions where we're not
going to put the function

5436
05:22:40,890 --> 05:22:44,310
selector because solidity is
expecting this, actually, you're

5437
05:22:44,310 --> 05:22:48,000
already familiar with one other
special function, we go back to

5438
05:22:48,000 --> 05:22:52,470
our Funmi. Our constructor, for
example, is a another type of

5439
05:22:52,470 --> 05:22:56,130
special function. There's no
function keyword. solidity knows

5440
05:22:56,130 --> 05:22:58,710
that this constructor is
immediately called when we

5441
05:22:58,710 --> 05:23:01,860
deploy this contract. So now we
have our fallback function.

5442
05:23:02,250 --> 05:23:05,700
Let's go ahead and compile this.
Let's delete our old contract.

5443
05:23:06,660 --> 05:23:11,340
Let's go ahead and deploy this
new contract. Like here, we hit

5444
05:23:11,340 --> 05:23:15,900
result, we do indeed, see, it's
set to zero. Now, if I add this

5445
05:23:15,930 --> 05:23:21,390
0x 00, and I send this, and I
hit transact, this is equivalent

5446
05:23:21,630 --> 05:23:25,050
to calling our contract here
without a valid function. So our

5447
05:23:25,050 --> 05:23:27,270
contract goes, Huh, I don't
recognize what you're trying to

5448
05:23:27,270 --> 05:23:30,720
tell me here, I'm going to refer
you to our fallback. And now if

5449
05:23:30,720 --> 05:23:34,590
we hit result, we see that it's
been updated to two. If we take

5450
05:23:34,590 --> 05:23:38,100
this away, solidity will go,
Hmm, it looks like you're trying

5451
05:23:38,100 --> 05:23:40,950
to send some Aetherium, or call
this contract without specifying

5452
05:23:40,950 --> 05:23:43,980
what you want to do. Well, I
have a receipt function. So I'm

5453
05:23:43,980 --> 05:23:46,380
just gonna go ahead and forward
you to that. So if we call

5454
05:23:46,380 --> 05:23:50,790
transact, we hit result, we see
it updates back to one, add some

5455
05:23:50,790 --> 05:23:56,190
data, hit transact, we see it
updates to to no data, updates

5456
05:23:56,190 --> 05:24:00,120
to one slowly by example, that
org has a wonderful little chart

5457
05:24:00,240 --> 05:24:03,630
that we can use to figure out
whether or not receive is going

5458
05:24:03,630 --> 05:24:06,480
to get triggered, or Fallback is
going to get triggered. If it is

5459
05:24:06,480 --> 05:24:09,300
empty, and there's a receive
function, it'll call the receive

5460
05:24:09,300 --> 05:24:13,290
function. If it is data, and
there's no receive function,

5461
05:24:13,320 --> 05:24:16,200
it'll just go to the fallback
function. And if there's no

5462
05:24:16,200 --> 05:24:19,770
fallback function, it might just
it might air out. So this is a

5463
05:24:19,770 --> 05:24:22,260
lot of really fantastic
information here. How can we

5464
05:24:22,260 --> 05:24:26,550
apply this to our fund mi
contract here, or what we can do

5465
05:24:26,550 --> 05:24:30,450
now in our Funmi is we can add
these fallback and receive

5466
05:24:30,450 --> 05:24:34,080
functions, just in case somebody
actually sends us contract money

5467
05:24:34,110 --> 05:24:36,750
instead of calling the fund
function correctly. So what we

5468
05:24:36,750 --> 05:24:40,110
can do is let's add a receive
function. So if somebody

5469
05:24:40,110 --> 05:24:42,660
accidentally sends it money, we
can still process the

5470
05:24:42,660 --> 05:24:46,680
transaction will say receive is
going to be external payable.

5471
05:24:48,840 --> 05:24:52,860
And we'll just have the receive
function call fund. And we'll do

5472
05:24:52,860 --> 05:24:57,420
the same thing with our fallback
function will have fallback

5473
05:24:57,870 --> 05:25:04,140
external payable. We'll just
have it automatically call fund.

5474
05:25:04,620 --> 05:25:07,980
Now, if somebody accidentally
sends us money without calling

5475
05:25:07,980 --> 05:25:12,330
our fund function, it'll still
automatically route them over to

5476
05:25:12,330 --> 05:25:15,990
the fund function. This means to
that if somebody doesn't send us

5477
05:25:16,020 --> 05:25:19,500
enough funding, it'll, that
transaction will still get

5478
05:25:19,500 --> 05:25:22,710
reverted. So let's go ahead now.
And let's switch to rink B to

5479
05:25:22,710 --> 05:25:26,460
test this on a real test net,
Amman rink B and my Metamask.

5480
05:25:26,880 --> 05:25:30,990
Let's switch over to injected
web three. And we'll scroll down

5481
05:25:31,020 --> 05:25:34,740
we'll choose our Funmi contract.
And we'll go ahead and deploy

5482
05:25:34,740 --> 05:25:38,970
this Metamask pops up, I'm gonna
go ahead and confirm the

5483
05:25:38,970 --> 05:25:42,390
transaction. And we see our
Funmi contract here right now we

5484
05:25:42,390 --> 05:25:45,360
can see the owner we can see I'm
the owner, we can see minimum

5485
05:25:45,360 --> 05:25:49,350
USD. And we can see of course
that it's a blank contract, and

5486
05:25:49,350 --> 05:25:52,560
there's nothing funded in here.
If we the copy the address, and

5487
05:25:52,560 --> 05:25:58,110
then go to rink the ether scan,
paste the address in, we can see

5488
05:25:58,110 --> 05:26:01,170
that there's no ether in here.
And the only transaction

5489
05:26:01,170 --> 05:26:03,870
associated with this has been
the contract creation. We saw

5490
05:26:03,870 --> 05:26:06,960
what happened before when we hit
the fun function, our contract

5491
05:26:06,960 --> 05:26:11,430
was updated with a new balance,
and that funder was added to our

5492
05:26:11,430 --> 05:26:15,240
an array. Let's see what happens
now if we just directly send

5493
05:26:15,270 --> 05:26:19,170
this contract money without
calling the fund function here.

5494
05:26:19,590 --> 05:26:23,160
If we did this right, our
receive function should pick it

5495
05:26:23,160 --> 05:26:28,230
up and kick the transaction over
the font. So let's copy this

5496
05:26:28,230 --> 05:26:33,480
address. We'll go to our meta
mask. We'll hit send, paste the

5497
05:26:33,480 --> 05:26:38,340
address in here with 0.02 eath.
Again, because this should be

5498
05:26:38,790 --> 05:26:43,290
more than the minimum amount in
USD, we'll hit next. I'll go

5499
05:26:43,290 --> 05:26:47,610
ahead and confirm this. After a
slight delay, if we did this

5500
05:26:47,610 --> 05:26:51,750
right, we should see the
transaction having called the

5501
05:26:51,750 --> 05:26:54,720
fund function here, now that our
transaction has gone through

5502
05:26:55,080 --> 05:26:58,590
After a brief delay in waiting
for ethers can update, we do

5503
05:26:58,590 --> 05:27:02,580
indeed see that our balance has
updated to 0.02, which of

5504
05:27:02,580 --> 05:27:06,690
course, this makes sense. And we
see in the transactions list

5505
05:27:06,690 --> 05:27:09,810
here, we see that this actually
went through as a, as a transfer

5506
05:27:09,840 --> 05:27:12,810
instead of us calling the fund
function. Let's go ahead and

5507
05:27:12,810 --> 05:27:15,510
remix and see if our funders was
updated.

5508
05:27:16,800 --> 05:27:20,580
It looks like it was at the zero
with position of funders, we

5509
05:27:20,580 --> 05:27:23,760
have our address. And if we take
our address and pop it into

5510
05:27:23,760 --> 05:27:27,570
address to amount funded, we can
see exactly how much we had

5511
05:27:27,570 --> 05:27:30,540
funded. This means that since we
added this receive function in

5512
05:27:30,540 --> 05:27:34,530
here, we automatically had to
call our fun function up here.

5513
05:27:34,740 --> 05:27:38,580
So awesome work, we were able to
add a receive function to help

5514
05:27:38,580 --> 05:27:42,450
people who accidentally call the
wrong function or accidentally

5515
05:27:42,450 --> 05:27:45,570
send this contract money,
instead of correctly calling the

5516
05:27:45,570 --> 05:27:48,630
fun function. Now, if they had
directly called the fun

5517
05:27:48,630 --> 05:27:51,570
function, it would have cost
them a little bit less gas, but

5518
05:27:51,570 --> 05:27:54,180
at least this time, they're
gonna get credit and add it to

5519
05:27:54,180 --> 05:27:57,150
our funders array for having
sent our funding contract money.

5520
05:27:59,940 --> 05:28:03,390
We've even learned some advanced
sections of solidity. And this

5521
05:28:03,390 --> 05:28:05,760
is going to be the last time
that we start our projects in

5522
05:28:05,760 --> 05:28:10,080
remix, we're going to be moving
over to a code editor now, where

5523
05:28:10,080 --> 05:28:13,140
we can get even more advanced
with our solidity on our setups.

5524
05:28:13,680 --> 05:28:16,440
For the most part, you've gone
over the vast majority of

5525
05:28:16,440 --> 05:28:19,140
solidity basics, there are a
number of things that we still

5526
05:28:19,140 --> 05:28:21,810
haven't learned yet. And the
reason we haven't gotten into

5527
05:28:21,810 --> 05:28:24,180
them is because they get more
advanced. And understanding the

5528
05:28:24,180 --> 05:28:27,060
real use doesn't really make too
much sense until a little bit

5529
05:28:27,060 --> 05:28:30,060
later. Some of the things that
we're going to go over are itams

5530
05:28:30,120 --> 05:28:34,140
events, try catch function
selectors, abi encoding,

5531
05:28:34,170 --> 05:28:36,480
hashing, and then you will slash
and then you will slash

5532
05:28:36,480 --> 05:28:39,240
assembly. However, if you've
gotten this far, you probably

5533
05:28:39,240 --> 05:28:42,600
can read most solidity code and
understand what's going on,

5534
05:28:42,870 --> 05:28:45,870
which is absolutely fantastic.
So you should give yourself a

5535
05:28:45,870 --> 05:28:48,690
huge round of applause for
getting this far. And doing

5536
05:28:48,690 --> 05:28:51,900
this. Let's do a quick summary
of this more advanced section

5537
05:28:51,930 --> 05:28:54,540
and make sure we understand what
we learned in solidity there are

5538
05:28:54,540 --> 05:28:58,350
a couple special functions. Some
of them are receive fallback,

5539
05:28:58,950 --> 05:29:03,060
and Constructor. These functions
don't need to have the function

5540
05:29:03,060 --> 05:29:07,050
keyword. And instead it can just
be called like so. Receive and

5541
05:29:07,050 --> 05:29:10,470
fallback are two very special
functions. If data is sent with

5542
05:29:10,470 --> 05:29:14,670
a transaction, and no function
was specified, the transaction

5543
05:29:14,670 --> 05:29:17,220
will default to the fallback
function if that fallback

5544
05:29:17,220 --> 05:29:20,640
function exists. If data is
empty, and there's a receive

5545
05:29:20,640 --> 05:29:24,480
function, it'll call the receive
function. There are a couple of

5546
05:29:24,480 --> 05:29:28,110
keywords that can help us save
gas in the long run. Some of

5547
05:29:28,110 --> 05:29:31,200
those keywords are going to be
constant and immutable. Constant

5548
05:29:31,200 --> 05:29:34,290
and immutable are for variables
that can only be declared and

5549
05:29:34,290 --> 05:29:39,420
updated once. Once we say
minimum USD is 50 times 118.

5550
05:29:39,750 --> 05:29:43,470
This minimum USD can never be
changed again. And this helps us

5551
05:29:43,500 --> 05:29:47,310
save gas. Immutable can also
save gas similar to constant.

5552
05:29:47,580 --> 05:29:50,940
However, immutable variables can
be declared one time in the

5553
05:29:50,940 --> 05:29:55,110
constructor, once an immutable
variable is declared, it can't

5554
05:29:55,110 --> 05:29:58,770
be changed later on. In fact, if
we even tried to update an

5555
05:29:58,770 --> 05:30:02,700
immutable variable or constant
variable, and we compiled, a

5556
05:30:02,700 --> 05:30:06,390
compiler would give us an error
saying, Can't write to a mutable

5557
05:30:06,390 --> 05:30:11,250
here. Or if we tried to change a
constant variable. Our compiler

5558
05:30:11,250 --> 05:30:14,610
would say, Hey, you can't assign
to a constant variable, sorry.

5559
05:30:14,820 --> 05:30:17,550
In remix, if we want to send
ether to a contract that's on

5560
05:30:17,550 --> 05:30:21,360
the JavaScript virtual machine,
we can deploy that contract. And

5561
05:30:21,360 --> 05:30:23,790
then in the contract, we can
just hit the transact button

5562
05:30:24,090 --> 05:30:27,450
without any call data and update
the value that we send with the

5563
05:30:27,450 --> 05:30:30,720
transaction. If call data is
blank, it will trigger the

5564
05:30:30,780 --> 05:30:34,680
receive function if it exists.
But if there's data that doesn't

5565
05:30:34,680 --> 05:30:37,590
specify any of the other
functions, it'll trigger the

5566
05:30:37,590 --> 05:30:38,370
fallback function

5567
05:30:47,500 --> 05:30:50,470
Awesome, you've done
fantastically to get this far.

5568
05:30:50,800 --> 05:30:54,100
And for this section before we
get started actually moving over

5569
05:30:54,100 --> 05:30:57,040
to Hardhead. And moving over to
JavaScript and understanding why

5570
05:30:57,040 --> 05:31:00,280
we need to do that. Let's
understand a little bit about

5571
05:31:00,310 --> 05:31:03,460
getting help and running into
problems. So let's say we have

5572
05:31:03,460 --> 05:31:07,090
our Funmi contract here that we
just worked on. And we run into

5573
05:31:07,090 --> 05:31:11,020
an error. Let's say for example,
we forgot the payable keyword,

5574
05:31:11,230 --> 05:31:15,130
right, and we go ahead and
compile this compile fund, we

5575
05:31:15,130 --> 05:31:18,880
did so. And we scroll down. And
we see obviously, we have two

5576
05:31:18,880 --> 05:31:20,950
errors here, right, we're
getting some errors, and we

5577
05:31:20,950 --> 05:31:25,480
scroll down. And we see type
error message dot value and call

5578
05:31:25,480 --> 05:31:28,630
value can only be used and
payable public functions, make

5579
05:31:28,630 --> 05:31:31,540
the function payable or using an
internal function to avoid this

5580
05:31:31,540 --> 05:31:34,030
error. And then it goes ahead
and gives the line that's

5581
05:31:34,030 --> 05:31:38,230
airing. Now this error is pretty
clear, this error code is pretty

5582
05:31:38,230 --> 05:31:41,530
clear. It's saying Hey, make the
function payable, or using an

5583
05:31:41,530 --> 05:31:44,200
internal function to avoid this
error, right? This should be

5584
05:31:44,200 --> 05:31:48,220
pretty easy to to add payable,
and then recompile and be good

5585
05:31:48,220 --> 05:31:51,010
to go. And this is actually a
good example of what to do when

5586
05:31:51,010 --> 05:31:53,680
you run into errors. When you
run into errors. The first thing

5587
05:31:53,680 --> 05:31:56,290
you want to do is you want to
try to figure out exactly what's

5588
05:31:56,290 --> 05:32:00,310
going on yourself based off of
what the error says. This one's

5589
05:32:00,310 --> 05:32:02,740
pretty straightforward, but some
of them can be a little bit more

5590
05:32:02,740 --> 05:32:06,790
obscure step one when trying to
get unblocked trying to tinker

5591
05:32:06,790 --> 05:32:10,240
and figure out errors yourself,
right? Because maybe you go

5592
05:32:10,240 --> 05:32:14,410
okay, I'll make this payable,
right? And you go to save. And

5593
05:32:14,410 --> 05:32:17,020
then it gives a different error
saying, hey, you know, payable

5594
05:32:17,020 --> 05:32:21,460
doesn't go here. You resave you
recompile it goes, Hey, we're

5595
05:32:21,460 --> 05:32:24,430
still missing that payable
thing. First step is always

5596
05:32:24,430 --> 05:32:27,340
going to be trying to tinker and
figure it out yourself. For this

5597
05:32:27,340 --> 05:32:31,750
course, I want you to limit
tinkering, slash triaging to 20

5598
05:32:31,750 --> 05:32:36,490
minutes, if you take more than
20 minutes to tinker and triage,

5599
05:32:36,610 --> 05:32:40,150
then move on to the next step.
But I also want you to take at

5600
05:32:40,150 --> 05:32:48,700
least 15 minutes yourself or be
100% Sure, you exhausted all

5601
05:32:48,700 --> 05:32:51,910
options, you're completely out
of ideas. So typically try to

5602
05:32:51,910 --> 05:32:55,360
tinker try some stuff for 15
minutes. And if you're under 15

5603
05:32:55,360 --> 05:32:58,420
minutes, and you're saying, Hey,
I'm 100% Certain I've tried

5604
05:32:58,420 --> 05:33:01,330
everything that I can think of,
then you can move on to the next

5605
05:33:01,330 --> 05:33:04,090
step. So step one, when you run
into errors is always going to

5606
05:33:04,090 --> 05:33:11,200
be tinker and try to pinpoint
exactly what's going on. Try to

5607
05:33:11,200 --> 05:33:14,320
pinpoint exactly what's going
wrong. Step two, let's say you

5608
05:33:14,320 --> 05:33:16,960
tinkered and you tried payable
all over the place, and you

5609
05:33:16,960 --> 05:33:19,960
couldn't figure out what this
error was and how to debug this

5610
05:33:19,960 --> 05:33:24,790
here. Step two is always going
to be Google the exact error and

5611
05:33:24,790 --> 05:33:27,070
see if you can learn from that.
So zoom out a little bit, I'll

5612
05:33:27,070 --> 05:33:32,440
roll my mouse over this, grab
this, copy it, or quotes around

5613
05:33:32,440 --> 05:33:36,250
it, and do exactly that, in
Google search that exact error

5614
05:33:36,280 --> 05:33:38,920
and take some time going through
Google going through Stack

5615
05:33:38,920 --> 05:33:41,710
Overflow going through Stack
Exchange eath, and look to see

5616
05:33:41,710 --> 05:33:44,140
if somebody has asked this
question already. And it looks

5617
05:33:44,140 --> 05:33:47,230
like down here looks like
somebody has type error missed a

5618
05:33:47,230 --> 05:33:49,780
value and call though can only
be used on PayPal public

5619
05:33:49,780 --> 05:33:53,740
functions. And if we scroll
down, we see that somebody ran

5620
05:33:53,740 --> 05:33:56,470
into exactly this. And they went
ahead and solved it. They go, I

5621
05:33:56,470 --> 05:33:59,620
realized my mistake, I needed to
add the PayPal keyword to my own

5622
05:33:59,620 --> 05:34:02,440
implementation. And they go
ahead in this question, they've

5623
05:34:02,440 --> 05:34:05,710
added the payable. And hopefully
this would give you the insight

5624
05:34:05,710 --> 05:34:08,590
to say, Ah, okay, great. I do
need to come back here and add

5625
05:34:08,590 --> 05:34:11,710
payable. Let's say this
StackOverflow question didn't

5626
05:34:11,710 --> 05:34:14,620
show up. Right? This forum
wasn't here. What do we do next?

5627
05:34:14,650 --> 05:34:19,270
So step one, tinker. Step two,
Google the exact error, I'm

5628
05:34:19,270 --> 05:34:25,120
going to do a step 2.5 That only
is for this class, go to our

5629
05:34:25,120 --> 05:34:30,460
GitHub, repo discussions, and or
updates for this course,

5630
05:34:30,460 --> 05:34:34,330
specifically, go to this GitHub
repo, full blockchain solidity

5631
05:34:34,330 --> 05:34:36,400
course, Jas, it'll look a little
bit different when you all get

5632
05:34:36,400 --> 05:34:39,850
to it. But come to this repo,
and look in this chronological

5633
05:34:39,880 --> 05:34:43,960
update section to see if there's
an update on that section that

5634
05:34:43,960 --> 05:34:46,390
you're doing. Obviously, since
I'm recording right now, there's

5635
05:34:46,390 --> 05:34:50,050
no update. And if you don't get
anything, feel free to jump into

5636
05:34:50,050 --> 05:34:52,990
the discussion section. And ask
a question in here, right,

5637
05:34:52,990 --> 05:34:55,480
there's going to be a community
of people looking to help each

5638
05:34:55,480 --> 05:34:58,390
other out and looking to make
this a lot of fun. And the

5639
05:34:58,390 --> 05:35:02,200
reason I say 2.5 is because in
the real world, you're not going

5640
05:35:02,200 --> 05:35:05,530
to have our GitHub repo, when
working on stuff outside of this

5641
05:35:05,530 --> 05:35:09,100
course, you're not going to have
this GitHub repo. So instead, in

5642
05:35:09,100 --> 05:35:11,500
the real world, I'm still going
to give you the keys, I'm going

5643
05:35:11,500 --> 05:35:15,070
to give you what it takes to
still unblock yourself on

5644
05:35:15,100 --> 05:35:19,210
anything. Okay. So number three
is going to be asked a question

5645
05:35:19,690 --> 05:35:27,400
on a forum, like stack, exchange
eath and Stack Overflow. Stack

5646
05:35:27,430 --> 05:35:31,870
Overflow is a question and
answering tech forum like this,

5647
05:35:31,900 --> 05:35:35,290
right? You can ask tech
questions, and then you can

5648
05:35:35,290 --> 05:35:38,110
answer them as well. And as you
can see, when you search for

5649
05:35:38,110 --> 05:35:41,890
these issues, they'll show up so
Stack Overflow is more for

5650
05:35:41,890 --> 05:35:45,940
general Role programming
questions and Stack Exchange

5651
05:35:45,970 --> 05:35:50,410
Aetherium or Stack Exchange eath
Aetherium Stack Exchange, this

5652
05:35:50,410 --> 05:35:53,860
is for more Aetherium or EVM
based question and all the

5653
05:35:53,860 --> 05:35:56,710
solidity code that we're gonna
be working with, whether it's

5654
05:35:56,710 --> 05:35:59,920
polygon, whether it's avalanche,
whether it's whatever, those

5655
05:35:59,920 --> 05:36:03,040
questions are going to be valid
here, and you can ask here. So

5656
05:36:03,040 --> 05:36:06,190
what you'd want to do is you'd
want to sign up or log in, and

5657
05:36:06,190 --> 05:36:09,070
ask and format your questions on
these forms, you'll want to sign

5658
05:36:09,070 --> 05:36:11,650
up for GitHub, you want to sign
up for Stack Exchange, you'll

5659
05:36:11,650 --> 05:36:14,260
want to sign up for Stack
Overflow, so you can participate

5660
05:36:14,590 --> 05:36:17,440
in these forums. In fact, if you
haven't already, let's sign up

5661
05:36:17,440 --> 05:36:20,890
for GitHub right now. And let me
walk you through formatting one

5662
05:36:20,890 --> 05:36:22,990
of these questions, because the
better you format your

5663
05:36:22,990 --> 05:36:25,720
questions, the better chance you
have of actually getting the

5664
05:36:25,720 --> 05:36:28,000
answer. And remember, when
asking questions on these

5665
05:36:28,000 --> 05:36:31,870
forums, when asking questions,
in these discussion communities,

5666
05:36:31,930 --> 05:36:34,060
people answer these questions
out of the goodness of their

5667
05:36:34,060 --> 05:36:37,180
heart, right? So if you don't
get a response, there's a chance

5668
05:36:37,180 --> 05:36:40,120
that maybe nobody knows, maybe
it's your question isn't

5669
05:36:40,120 --> 05:36:43,630
formatted very well, and etc. So
we're going to learn how to ask

5670
05:36:43,630 --> 05:36:46,270
really good questions here. And
if you're new to blockchain, do

5671
05:36:46,270 --> 05:36:49,030
not skip this section. Okay,
this is going to be that piece

5672
05:36:49,030 --> 05:36:51,370
that's going to give you the
superpower to unblock yourself

5673
05:36:51,370 --> 05:36:54,490
from any coding issue you run
into. So don't skip this

5674
05:36:54,490 --> 05:36:57,220
powerup. Be sure to follow
along. Okay. So if you don't

5675
05:36:57,220 --> 05:36:59,920
have a GitHub already, you do
need an email to get started. So

5676
05:37:00,220 --> 05:37:03,190
I'm going to go ahead and sign
in, I made a burner account just

5677
05:37:03,190 --> 05:37:05,440
for this video. So what we're
gonna do, we're gonna go ahead

5678
05:37:05,440 --> 05:37:08,020
and sign up GitHub, enter your
email

5679
05:37:16,300 --> 05:37:18,310
and we hit Create Account,
they're going to send us an

5680
05:37:18,310 --> 05:37:20,800
email. So we're going to come
back to our email, and we got

5681
05:37:20,800 --> 05:37:25,570
our launch code here, paste it
in. And so a little bit of

5682
05:37:25,570 --> 05:37:32,290
information. We're going to
choose the free version. and

5683
05:37:32,290 --> 05:37:35,920
fantastic. We've now created a
GitHub profile. Now back over in

5684
05:37:35,920 --> 05:37:38,740
the smart contract kid full
blockchain solidity course, Jas,

5685
05:37:39,070 --> 05:37:41,920
I'm going to create a new
discussion, a new thread, and I

5686
05:37:41,920 --> 05:37:44,230
want you all to comment on to
make sure you understand how to

5687
05:37:44,230 --> 05:37:47,950
format and how to ask questions.
Okay, general thread for

5688
05:37:47,950 --> 05:37:53,770
practicing. Question formatting.
Oops. And so let's go back here.

5689
05:37:53,800 --> 05:37:57,190
So first, I'm going to format
this question poorly, two ways,

5690
05:37:57,220 --> 05:38:00,190
and then we're gonna format it
really, really well. So the

5691
05:38:00,190 --> 05:38:03,430
first way we're going to format
it poorly, is by not giving

5692
05:38:03,490 --> 05:38:07,060
enough information. So what
we're going to do is I'm gonna

5693
05:38:07,060 --> 05:38:11,260
just copy this issue we're going
to do is we'll just say like,

5694
05:38:11,290 --> 05:38:19,060
Hey, I'm having trouble with
remix and an error. Can someone

5695
05:38:19,060 --> 05:38:23,410
help me? Why is this not a well
formatted question? If this is

5696
05:38:23,410 --> 05:38:27,220
my question, there's not nearly
enough information here, I, as a

5697
05:38:27,220 --> 05:38:30,700
helper, have no idea what this
person's asking. So let's do

5698
05:38:30,700 --> 05:38:34,630
something else. What I'm going
to do is I'm going to copy this

5699
05:38:34,630 --> 05:38:38,800
entire contract all the fun,
read outsole, paste it in here,

5700
05:38:39,040 --> 05:38:46,000
and go, Hi, I'm having issues
here. Can someone help? I'm

5701
05:38:46,000 --> 05:38:49,450
gonna head start discussion here
want to hit start discussion, it

5702
05:38:49,450 --> 05:38:52,120
formats this all weird. And once
again, there's not really enough

5703
05:38:52,150 --> 05:38:56,140
information here. I don't know
what the issue is. But at least

5704
05:38:56,140 --> 05:38:58,150
with this one, we have some
code, we have some way to

5705
05:38:58,150 --> 05:39:00,490
actually debug. So this is a
little bit better. But it's

5706
05:39:00,490 --> 05:39:03,130
still not that good. Let's go
ahead and edit this. To make

5707
05:39:03,130 --> 05:39:06,640
this even better. We hit three
dots, we can hit edit, what we

5708
05:39:06,640 --> 05:39:10,870
can do is we can use something
called Markdown syntax, and

5709
05:39:10,930 --> 05:39:13,480
highly recommend learning a
little bit of markdown, it's

5710
05:39:13,480 --> 05:39:17,470
basically some syntax help make
discussions on GitHub. And also,

5711
05:39:17,650 --> 05:39:21,400
questions on Stack Overflow and
Stack Exchange a lot easier. So

5712
05:39:21,400 --> 05:39:25,450
we're going to format this code
by adding these three backticks

5713
05:39:25,510 --> 05:39:31,090
at the start, and then also at
the end of our code. And then

5714
05:39:31,090 --> 05:39:34,300
additionally, next, the first
three backticks, we're going to

5715
05:39:34,300 --> 05:39:40,990
type so lid did T which tells
the format or to to use solidity

5716
05:39:40,990 --> 05:39:44,830
to format this code here. Now if
we update discussion, we notice

5717
05:39:44,830 --> 05:39:49,300
we get some nice highlighting
here. So this becomes much, much

5718
05:39:49,300 --> 05:39:53,950
easier to read. Right? This is
way easier to read now than than

5719
05:39:53,950 --> 05:39:57,130
it was before. However, it's
still not specific enough. We've

5720
05:39:57,130 --> 05:40:00,100
given a ton of code here, and we
haven't given the specific

5721
05:40:00,100 --> 05:40:03,370
answer. So this is gonna be
really hard for somebody to

5722
05:40:03,550 --> 05:40:06,730
answer. So let's make this more
specific. So let's edit this

5723
05:40:06,730 --> 05:40:10,780
question again. And let's
specify, so we see here, our

5724
05:40:10,780 --> 05:40:15,640
issue is specifically on this
function. We're going to copy

5725
05:40:15,640 --> 05:40:18,340
this function and we're going to
delete everything else in here.

5726
05:40:19,630 --> 05:40:23,290
And now we have just this code
inside of here. Now we're going

5727
05:40:23,290 --> 05:40:26,500
to make this really specific.
We're going to say, on this

5728
05:40:26,500 --> 05:40:31,300
function, I'm running into an
error. And then what we're going

5729
05:40:31,300 --> 05:40:33,220
to do is we're going to come
back here, we're going to roll

5730
05:40:33,220 --> 05:40:36,100
the over this. We're going to
copy this we could have pull our

5731
05:40:36,100 --> 05:40:39,250
code if we want but we're going
to format this error like this.

5732
05:40:39,580 --> 05:40:43,960
And then we're gonna say Can
someone tell me What's going on?

5733
05:40:44,770 --> 05:40:49,810
Update? Now this is a much, much
easier question to debug. Right?

5734
05:40:49,810 --> 05:40:52,630
We have some minimalistic code,
we have the error that we're

5735
05:40:52,630 --> 05:40:56,080
getting. And we have Can someone
tell me what's going on?

5736
05:40:56,170 --> 05:41:00,100
Obviously, the answer to this
would be to add payable to this.

5737
05:41:00,130 --> 05:41:02,110
And that's what somebody would
say, hey, like, you need to add

5738
05:41:02,110 --> 05:41:04,960
payable to this, I want you all
to practice doing some

5739
05:41:04,960 --> 05:41:08,380
formatting, go ahead and add a
comment on this with your own

5740
05:41:08,380 --> 05:41:11,470
formatted question. So that you
understand how to actually do

5741
05:41:11,470 --> 05:41:14,590
the formatting. And this
markdown format. It's this

5742
05:41:14,590 --> 05:41:17,290
format here, that's gonna be the
exact same for asking questions

5743
05:41:17,290 --> 05:41:21,070
on Stack Overflow, or Stack
Exchange for this course, go

5744
05:41:21,070 --> 05:41:24,730
ahead and practice if you want
to create more new discussions,

5745
05:41:24,730 --> 05:41:27,280
feel free to create new
discussions. If you want to use

5746
05:41:27,280 --> 05:41:31,030
Stack Overflow or Stack Exchange
eath actually highly recommend

5747
05:41:31,030 --> 05:41:33,790
you Stack Overflow or Stack
Exchange eath as well, because

5748
05:41:33,790 --> 05:41:36,760
those are gonna get indexed a
lot better than GitHub here.

5749
05:41:37,360 --> 05:41:39,850
However, feel free to ask
questions, obviously, in this

5750
05:41:39,850 --> 05:41:42,580
GitHub as well. Now that I've
given you kind of the basics

5751
05:41:42,580 --> 05:41:45,610
rundown, we're going to watch a
video that I made that goes even

5752
05:41:45,610 --> 05:41:48,820
deeper into why and how to
format all these questions and

5753
05:41:48,820 --> 05:41:50,650
what to use. So let's go ahead

5754
05:41:50,739 --> 05:42:00,009
and watch that. Every developer
has run into this. Something

5755
05:42:00,009 --> 05:42:01,959
breaks or maybe you don't know
something, but you don't have

5756
05:42:01,959 --> 05:42:04,809
time to let these stop you.
There are a series of steps that

5757
05:42:04,809 --> 05:42:08,379
one should take to maximize
one's chances of solving any

5758
05:42:08,379 --> 05:42:11,499
coding problem, but you'd be
surprised at how few developers

5759
05:42:11,499 --> 05:42:14,289
currently use the superpower
effectively, our first one we'll

5760
05:42:14,289 --> 05:42:16,629
spend the least time on, because
it's just tinker and experiment.

5761
05:42:16,809 --> 05:42:19,059
When you run into an issue. Keep
trying different things you

5762
05:42:19,089 --> 05:42:21,519
think might work, maybe try
doing print statements

5763
05:42:21,519 --> 05:42:23,829
throughout the file, learn some
debugging tips, but don't be so

5764
05:42:23,829 --> 05:42:27,639
cocky that you only do this
first step. And this shouldn't

5765
05:42:27,639 --> 05:42:30,309
just be random running around.
This should be trying to

5766
05:42:30,309 --> 05:42:33,639
pinpoint exactly what's going
wrong in your code, so that you

5767
05:42:33,639 --> 05:42:36,279
can either ask an effective
question, or figure it out

5768
05:42:36,279 --> 05:42:39,909
yourself. So pinpoint exactly
what's going wrong, because

5769
05:42:39,909 --> 05:42:42,699
you'll need it for the next
steps. Anyways, next, check the

5770
05:42:42,699 --> 05:42:46,659
documentation. Not all tools
have good documentation. But

5771
05:42:46,659 --> 05:42:49,689
taking some time to explore
documentation can be a quick way

5772
05:42:49,689 --> 05:42:52,599
to find your answer, you'll want
to learn how to search a webpage

5773
05:42:52,599 --> 05:42:55,209
with Command F or Control F.
That way, you can look for

5774
05:42:55,209 --> 05:42:58,569
specific keywords on a page, or
hopefully they have a good

5775
05:42:58,569 --> 05:43:01,119
search bar that works well.
Sometimes documentation can be

5776
05:43:01,119 --> 05:43:03,879
really dense. So maybe you'll
move to the next step, which is

5777
05:43:03,879 --> 05:43:06,669
doing a web search. At the end
of the day, good software

5778
05:43:06,669 --> 05:43:09,969
engineers are secretly just
professional Googlers. And this

5779
05:43:09,969 --> 05:43:12,369
is one of their most powerful
tools, being able to search the

5780
05:43:12,369 --> 05:43:15,459
web for somebody else who has
already run into the problem

5781
05:43:15,459 --> 05:43:17,919
that you've just run into, and
then solved it. Most search

5782
05:43:17,919 --> 05:43:20,649
engines like Google have tools
you can use to get even more

5783
05:43:20,649 --> 05:43:23,889
specific about what you're
looking for. Often for specific

5784
05:43:23,919 --> 05:43:26,859
errors, the best thing to do is
actually just copy the exact

5785
05:43:26,859 --> 05:43:29,439
error and paste it in the search
bar with quotes or use the

5786
05:43:29,439 --> 05:43:32,259
Asterix in spots, your error
might be too specific. Most of

5787
05:43:32,259 --> 05:43:35,979
the results you'll get will be
from forums and q&a sites, which

5788
05:43:36,009 --> 05:43:38,949
leads us to our next step,
asking questions in these forums

5789
05:43:38,949 --> 05:43:42,999
and q&a sites. Just make sure
that before you ask a question,

5790
05:43:42,999 --> 05:43:46,779
you've done some ample Googling
around yourself beforehand. This

5791
05:43:46,779 --> 05:43:49,659
way you don't waste yours and
anybody else's time. And by

5792
05:43:49,659 --> 05:43:52,659
asking questions that you swear
you will promise me that at some

5793
05:43:52,659 --> 05:43:56,319
point, you will go back and help
other people learn as well got

5794
05:43:56,319 --> 05:43:59,619
it good. Before even asking your
question though, we should learn

5795
05:43:59,769 --> 05:44:03,879
where is going to be the best
place to ask. This is why I've

5796
05:44:03,879 --> 05:44:07,149
categorized for different types
of forums and QA sites, feel

5797
05:44:07,149 --> 05:44:10,029
free to pause to read them over.
And here's some specific

5798
05:44:10,029 --> 05:44:13,239
examples of each one of these
index code base forms like Stack

5799
05:44:13,239 --> 05:44:17,439
Overflow, index repositories
like GitHub issues, index

5800
05:44:17,439 --> 05:44:21,219
technology, specific forums,
like our slash eat dev or

5801
05:44:21,249 --> 05:44:24,759
unindexed discussion platforms
like chainlink discord, one of

5802
05:44:24,759 --> 05:44:28,419
the key differentiators in these
categories is the index keyword.

5803
05:44:28,449 --> 05:44:31,419
We typically want to ask
questions on forums that web

5804
05:44:31,419 --> 05:44:34,239
crawlers have gone through and
stuck them in their database or

5805
05:44:34,269 --> 05:44:37,419
index them this way. And three
weeks when we look back at the

5806
05:44:37,419 --> 05:44:40,449
code that we wrote, we can just
Google what was going on when we

5807
05:44:40,449 --> 05:44:43,269
forget what it does. And this
will help out other developers

5808
05:44:43,269 --> 05:44:46,359
who run into the same problem,
which in turn, they might go

5809
05:44:46,359 --> 05:44:49,659
ahead and help you out later.
Ideally, most of your questions

5810
05:44:49,689 --> 05:44:52,779
should be asked on one of these
index forms for this reason for

5811
05:44:52,779 --> 05:44:54,849
their searchability and
discoverability. However, at

5812
05:44:54,849 --> 05:44:58,329
some questions are a better fit
for DMS, Twitter or discord that

5813
05:44:58,359 --> 05:45:00,879
aren't index and we made a
little chart here to figure out

5814
05:45:00,909 --> 05:45:03,219
where's the best place to post
your questions, feel free to

5815
05:45:03,219 --> 05:45:05,409
pause the video take a look or
read our blog and the

5816
05:45:05,409 --> 05:45:07,959
descriptions with the picture as
well to take another look at it.

5817
05:45:07,989 --> 05:45:10,089
And of course, before actually
posting that in one of these

5818
05:45:10,089 --> 05:45:13,359
forums, be sure to read their
rules as they might state that

5819
05:45:13,419 --> 05:45:15,849
some kind of questions are
specifically for Ben. But

5820
05:45:15,849 --> 05:45:19,059
basically the breakdown looks
like this. Theoretical big

5821
05:45:19,059 --> 05:45:23,619
picture or opinionated questions
can go great on general q&a

5822
05:45:23,619 --> 05:45:27,759
forums like Quora or specific
technical forums like specific

5823
05:45:27,759 --> 05:45:31,269
subreddits or discord forums,
specific coding questions can go

5824
05:45:31,269 --> 05:45:35,619
on these forums as well, but
will often get more eyes on

5825
05:45:35,649 --> 05:45:38,829
coding forums like Stack
Overflow or Stack Exchange

5826
05:45:38,829 --> 05:45:41,709
communities often the question
of Oh, should I post this on

5827
05:45:41,739 --> 05:45:45,249
stack URL? flow or maybe a Stack
Exchange community is incredibly

5828
05:45:45,249 --> 05:45:47,979
blurry. And sometimes it doesn't
really matter which one you post

5829
05:45:47,979 --> 05:45:51,489
on. Now, if you run into a bug
or an issue with a technology

5830
05:45:51,489 --> 05:45:54,069
you're really familiar with, and
you think it shouldn't be

5831
05:45:54,069 --> 05:45:57,249
breaking, this is your chance to
pop an issue into their open

5832
05:45:57,249 --> 05:46:00,609
source code repository and
potentially improve the tool.

5833
05:46:00,639 --> 05:46:03,429
They don't have an open source
code repository, you throw that

5834
05:46:03,429 --> 05:46:06,879
closed source piece of shit into
the garbage, but just kidding

5835
05:46:06,879 --> 05:46:09,699
closed source Tech has its place
in our lives, too. Additionally,

5836
05:46:09,729 --> 05:46:12,489
if you're following a tutorial,
and they have a Git repo

5837
05:46:12,489 --> 05:46:16,179
associated with it, like all of
my videos that do, that's gonna

5838
05:46:16,179 --> 05:46:19,029
be the best place to leave your
issues. So as much as I hate to

5839
05:46:19,029 --> 05:46:22,449
say it, putting your issues onto
my GitHub repositories is going

5840
05:46:22,449 --> 05:46:25,869
to be much more effective for us
answering your questions than

5841
05:46:25,869 --> 05:46:29,139
posting it in the YouTube
comments. Now finally, Discord,

5842
05:46:29,169 --> 05:46:33,279
element, email, text message or
any other these unindexed chats

5843
05:46:33,309 --> 05:46:36,279
are still good places to ask
questions, but please try to use

5844
05:46:36,279 --> 05:46:39,309
them as a last resort. And if
they do end up answering one of

5845
05:46:39,309 --> 05:46:42,189
your questions, maybe go back
and add that question and answer

5846
05:46:42,189 --> 05:46:44,979
to one of the other forums that
we were talking about this way

5847
05:46:44,979 --> 05:46:47,829
it will be indexed next time you
or somebody else, Google's it

5848
05:46:47,889 --> 05:46:50,199
now these quicker chat forums
are places more for the

5849
05:46:50,199 --> 05:46:53,139
community to congregate and have
quick conversations with each

5850
05:46:53,139 --> 05:46:56,469
other. They're places to theory
craft, talk about new things

5851
05:46:56,469 --> 05:47:00,669
coming out new ideas, events,
and other things that shouldn't

5852
05:47:00,669 --> 05:47:03,879
be indexed by web crawlers.
They're also great places to

5853
05:47:03,879 --> 05:47:06,819
meet and network with people
that you might be able to bounce

5854
05:47:06,819 --> 05:47:09,549
ideas off directly as you get to
know each other, which leads

5855
05:47:09,549 --> 05:47:12,759
into our last section. But
before we do that, Oh, do you

5856
05:47:12,759 --> 05:47:17,109
hear that? Oh, that's the video
inside another video alarm

5857
05:47:17,109 --> 05:47:20,049
ringing. When you ask a question
in one of these forums, the

5858
05:47:20,049 --> 05:47:22,449
better you format your
questions, the better chance

5859
05:47:22,449 --> 05:47:25,059
you'll have of getting an
answered. Now there's no bad

5860
05:47:25,059 --> 05:47:28,299
questions out there. But there
are poorly formatted questions.

5861
05:47:28,509 --> 05:47:31,749
So let's teach you how to always
ask questions as format as best

5862
05:47:31,749 --> 05:47:34,839
as possible to give you the
highest chance of making sure

5863
05:47:34,839 --> 05:47:37,569
they get answered. Number one,
before asking your question,

5864
05:47:37,599 --> 05:47:40,689
make sure you followed all the
steps in the parent video. And

5865
05:47:40,689 --> 05:47:43,449
you've done some research on
this already and make sure the

5866
05:47:43,449 --> 05:47:46,239
question hasn't already been
asked. Number two, make a title

5867
05:47:46,239 --> 05:47:50,079
that summarizes the specifics of
the question three introduced

5868
05:47:50,079 --> 05:47:53,619
the problem before you write any
code, add minimalistic,

5869
05:47:53,649 --> 05:47:57,549
reproducible code minimalistic
code means it's not just a copy

5870
05:47:57,549 --> 05:48:00,549
paste your entire file. If
you're having problems on one

5871
05:48:00,549 --> 05:48:04,809
line, maybe just post that one
line reproducible code means

5872
05:48:04,809 --> 05:48:07,689
that others should be able to
run to the exact same error that

5873
05:48:07,689 --> 05:48:11,049
you're running into, or at least
post the steps for them to do

5874
05:48:11,049 --> 05:48:14,079
it. This doesn't mean that you
should put I was following along

5875
05:48:14,079 --> 05:48:17,739
Patrick's video and on our five
I ran into this problem, just

5876
05:48:17,739 --> 05:48:20,799
watch his video and you'll get
there. As flattering as this is

5877
05:48:20,829 --> 05:48:22,989
it's not reasonable that
everyone is going to have

5878
05:48:22,989 --> 05:48:25,869
watched my videos, even though
they should you want to give the

5879
05:48:25,869 --> 05:48:28,329
technical steps to reach the
error that you've reached. For

5880
05:48:28,329 --> 05:48:30,999
those of you watching my Free
Code Camp video, you're kind of

5881
05:48:30,999 --> 05:48:34,689
exempt from this, but you can
only say, Hey, I was on our Five

5882
05:48:34,749 --> 05:48:37,809
on this part of your video
inside of our discussions tab of

5883
05:48:37,809 --> 05:48:41,139
the GitHub repo associated with
this course. So you can do that.

5884
05:48:41,169 --> 05:48:44,169
But only in that GitHub repo
associated with this course,

5885
05:48:44,649 --> 05:48:48,549
learning markdown to format your
code, especially using these

5886
05:48:48,579 --> 05:48:53,379
three backticks and labeling of
the language. This is a critical

5887
05:48:53,379 --> 05:48:56,889
piece of formatting your code
and will drastically improve on

5888
05:48:56,889 --> 05:48:59,709
the number of people who answer
your questions. Any errors or

5889
05:48:59,709 --> 05:49:03,489
code should be formatted with
this three backticks syntax. And

5890
05:49:03,489 --> 05:49:06,099
finally, often people who care
about certain technologies,

5891
05:49:06,249 --> 05:49:10,239
monitor specific tags and
monitor specific questions being

5892
05:49:10,239 --> 05:49:12,369
asked about the technologies
that they like. And then

5893
05:49:12,369 --> 05:49:15,789
finally, again, be sure to read
the forum's guides before

5894
05:49:15,789 --> 05:49:18,729
posting different forums have
different rules about what they

5895
05:49:18,729 --> 05:49:21,129
want and what they don't want.
So being familiar will increase

5896
05:49:21,129 --> 05:49:24,099
your chances of getting an
answer. All right. So now back

5897
05:49:24,099 --> 05:49:26,619
to the main video. Now a note
about Stack Overflow, in

5898
05:49:26,619 --> 05:49:30,189
particular, Stack Overflow can
be a little aggressive, which is

5899
05:49:30,189 --> 05:49:32,649
why sometimes posting on
specific community forums might

5900
05:49:32,649 --> 05:49:35,289
be better for your specific
technology questions. If you

5901
05:49:35,289 --> 05:49:38,079
post on Stack Overflow, and you
get a ton of down votes on your

5902
05:49:38,079 --> 05:49:41,709
questions. Don't let that bother
you. Just take it as a learning

5903
05:49:41,709 --> 05:49:44,709
opportunity to learn about what
Stack Overflow likes and doesn't

5904
05:49:44,709 --> 05:49:48,729
like and just keep going but do
not let that discourage you.

5905
05:49:48,849 --> 05:49:51,879
Okay, well, now that we know
where things should go, where

5906
05:49:51,879 --> 05:49:55,269
questions should go and how to
actually format them. Let's

5907
05:49:55,269 --> 05:49:57,579
practice let's look at some
sample questions that you might

5908
05:49:57,579 --> 05:49:59,739
have. And we'll figure out where
we want to put them. So the

5909
05:49:59,739 --> 05:50:02,589
first one, where does this one
go? Feel free to pause and guess

5910
05:50:02,589 --> 05:50:05,859
yourself. So a question like
this is going to be great for a

5911
05:50:05,859 --> 05:50:09,789
Reddit or a discord? Probably
more a discord. Now, this is

5912
05:50:09,789 --> 05:50:12,699
definitely something that you
can search for. Right? So you

5913
05:50:12,699 --> 05:50:15,039
probably could search for this,
find an answer and go from

5914
05:50:15,039 --> 05:50:17,499
there. But maybe you want to ask
a buddy or maybe you want to ask

5915
05:50:17,529 --> 05:50:20,679
a very specific community like
our slash eat Dev. Now, of

5916
05:50:20,679 --> 05:50:22,629
course, if you see this
question, you obviously want to

5917
05:50:22,629 --> 05:50:25,569
recommend Patrick Collins his
YouTube channel. Now how about

5918
05:50:25,599 --> 05:50:28,899
this question. Notice its
formatting right? The title is

5919
05:50:28,989 --> 05:50:32,079
nice and big. They have a
technical command that is

5920
05:50:32,079 --> 05:50:34,809
formatted properly. They have
Git commit which is formatted

5921
05:50:34,809 --> 05:50:37,719
properly, where would this go
like this would definitely do

5922
05:50:37,719 --> 05:50:41,409
very well on a Stack Overflow or
an index code based forum to

5923
05:50:41,409 --> 05:50:44,829
very clearly try had to do
something technical. The problem

5924
05:50:44,829 --> 05:50:47,859
is laid out very clearly. And
they've given the command that

5925
05:50:47,859 --> 05:50:50,259
they're looking to do. Now, how
about this one, something like

5926
05:50:50,259 --> 05:50:52,749
this could go on either
StackOverflow. But it's probably

5927
05:50:52,749 --> 05:50:56,049
more likely going to go on a
GitHub issue for this brownie

5928
05:50:56,049 --> 05:51:00,309
package. A big difference
between code forums and and Git

5929
05:51:00,309 --> 05:51:03,339
repos like GitHub is that when
you make an issue on a GitHub

5930
05:51:03,339 --> 05:51:06,309
repository, especially when you
think there's a problem, you do

5931
05:51:06,309 --> 05:51:09,759
want to be as in depth as
possible. So oftentimes, when

5932
05:51:09,759 --> 05:51:12,039
making an issue on these repos,
they'll even ask, what version

5933
05:51:12,039 --> 05:51:15,099
are you using? Can you post all
your code? Can you post all your

5934
05:51:15,099 --> 05:51:18,759
files and just be much, much
more explicit? So how about

5935
05:51:18,759 --> 05:51:21,999
something like this. So this is
going to be really good for the

5936
05:51:21,999 --> 05:51:25,359
GitHub repo associated with this
tutorial, it looks like this

5937
05:51:25,359 --> 05:51:28,629
person is asking about a very
specific tutorial. So posting

5938
05:51:28,629 --> 05:51:32,019
this, there is going to be best.
Now if your question is on a

5939
05:51:32,019 --> 05:51:35,049
tutorial that doesn't have a
GitHub repo, well, they probably

5940
05:51:35,049 --> 05:51:38,019
should. But then maybe this is
better in the comment section.

5941
05:51:38,739 --> 05:51:42,039
Now, again, this is where this
all becomes a little bit more

5942
05:51:42,129 --> 05:51:45,099
art than science, because maybe
the specific error that they're

5943
05:51:45,099 --> 05:51:48,369
running into is a generic error
that a ton of people run into,

5944
05:51:48,429 --> 05:51:51,459
and maybe it is better on
StackOverflow. Or maybe there's

5945
05:51:51,459 --> 05:51:55,479
an issue with the package. So
maybe it is better on GitHub. Or

5946
05:51:55,479 --> 05:51:58,419
maybe the solution to this is
opinionated. And finally, what

5947
05:51:58,419 --> 05:52:01,629
about this? Yep, this is going
to be much better for a discord

5948
05:52:01,629 --> 05:52:04,029
or a DM with your buddy. And
away, it's our last step on

5949
05:52:04,029 --> 05:52:06,429
blocking you from any question
is going to be join and

5950
05:52:06,429 --> 05:52:09,099
strengthen the community of your
tool. Now at the start, it's

5951
05:52:09,099 --> 05:52:11,619
going to be hard for you to give
back since you're not going to

5952
05:52:11,619 --> 05:52:13,959
be very knowledgeable on these
tools. But as you get better at

5953
05:52:13,959 --> 05:52:16,209
these technologies, you'll want
to try to answer some of these

5954
05:52:16,209 --> 05:52:18,939
new questions that do come in.
The reason is because this will

5955
05:52:18,939 --> 05:52:21,519
give you a chance to actually
learn more about the tools that

5956
05:52:21,519 --> 05:52:24,339
you like, it'll strengthen the
community of your favorite

5957
05:52:24,339 --> 05:52:27,339
tools, meaning if you help
answer questions on tool, it'll

5958
05:52:27,339 --> 05:52:30,429
actually encourage other people
to use the tool because there's

5959
05:52:30,429 --> 05:52:33,399
a strong following there. And
likely, they might actually help

5960
05:52:33,399 --> 05:52:35,949
you sometime in the future, you
helping people will make you

5961
05:52:35,949 --> 05:52:38,589
look like a good person. And
then you'll also feel like a

5962
05:52:38,589 --> 05:52:41,319
good person. Additionally, in
many forums like Reddit,

5963
05:52:41,379 --> 05:52:44,319
oftentimes, mods will actually
look at how often you post

5964
05:52:44,349 --> 05:52:47,289
versus how often you help others
and comments on others people

5965
05:52:47,289 --> 05:52:50,289
posts and some mods may actually
start blocking your posts for

5966
05:52:50,289 --> 05:52:53,289
abusing the forums and not
giving back to the community and

5967
05:52:53,289 --> 05:52:55,899
only trying to take knowledge
you in the community will be

5968
05:52:55,929 --> 05:52:59,799
more successful if you join in
and help others and not just try

5969
05:52:59,799 --> 05:53:02,619
to extract things from other
people. Additionally, by

5970
05:53:02,619 --> 05:53:05,889
engaging with the community, I
can't tell you how many people

5971
05:53:05,919 --> 05:53:08,919
I've met and I've learned and
been able to brainstorm with.

5972
05:53:09,069 --> 05:53:11,199
And then the final step is going
to be iterate through these

5973
05:53:11,199 --> 05:53:14,559
steps. Maybe you get to the end
of these and you say, Oh, I'm

5974
05:53:14,559 --> 05:53:18,159
still blocked, but you'll likely
be much, much more

5975
05:53:18,159 --> 05:53:21,339
knowledgeable. So you want to go
back and try these steps again.

5976
05:53:21,429 --> 05:53:24,819
Now this is where this whole
process is a little bit more art

5977
05:53:24,849 --> 05:53:27,339
than science. Because some
questions might not have been

5978
05:53:27,339 --> 05:53:30,459
discovered yet. Only very few
people know not enough people

5979
05:53:30,459 --> 05:53:33,549
understand the importance of the
questions, or maybe people don't

5980
05:53:33,549 --> 05:53:36,369
understand your question. And
this is why it's important to go

5981
05:53:36,369 --> 05:53:39,519
back and iterate on these steps.
Now that you have the basic

5982
05:53:39,519 --> 05:53:41,889
building blocks of this
incredible superpower, I

5983
05:53:41,889 --> 05:53:44,649
encourage all of you to go out
there and try this and then let

5984
05:53:44,649 --> 05:53:45,429
me know how it went.

5985
05:53:48,460 --> 05:53:51,100
Alright, awesome. So now that we
know more about how to get

5986
05:53:51,130 --> 05:53:54,160
unblocked, we can move on. The
reason it's so important to

5987
05:53:54,160 --> 05:53:57,070
learn how to get unblocked is
because blockchain and web three

5988
05:53:57,310 --> 05:54:00,460
is more than just everybody on
their own. It is a very

5989
05:54:00,460 --> 05:54:04,120
collaborative space. So as you
get better, and as you learn

5990
05:54:04,120 --> 05:54:07,510
more a massive way to test how
much you've learned and give

5991
05:54:07,510 --> 05:54:09,820
back to the community is to
going to Stack Overflow and

5992
05:54:09,820 --> 05:54:13,330
going to stack exchange them and
trying to answer some questions

5993
05:54:13,330 --> 05:54:16,630
yourself. So I highly recommend
you all go to Stack Overflow,

5994
05:54:16,630 --> 05:54:19,450
and then you go to the GitHub
repo associated with the scores,

5995
05:54:19,690 --> 05:54:21,970
you try to answer some
discussions, try to answer some

5996
05:54:22,000 --> 05:54:24,970
issues and help other people out
because it's going to help you

5997
05:54:24,970 --> 05:54:28,210
become a much better software
engineer. The other reason I

5998
05:54:28,210 --> 05:54:31,480
want to do that part is because
when we install some of the

5999
05:54:31,480 --> 05:54:34,750
tools that I'm about to show
you, sometimes the installation

6000
05:54:34,750 --> 05:54:38,020
process is the hardest piece
there. Once you get past the

6001
05:54:38,020 --> 05:54:41,380
install process, it generally
becomes much, much easier. But

6002
05:54:41,380 --> 05:54:44,410
this can often be the hardest
part of the course is just

6003
05:54:44,440 --> 05:54:47,020
installing some of these tools
that we're going to give you.

6004
05:54:47,170 --> 05:54:50,080
And that's what we're going to
learn about right now. So we

6005
05:54:50,080 --> 05:54:54,460
have been working so far with
remix, remix IDE, or integrated

6006
05:54:54,460 --> 05:54:57,250
development environment. As
we've seen, it's this wonderful

6007
05:54:57,250 --> 05:55:00,070
place where we can try out code
we can try solidity out, we can

6008
05:55:00,070 --> 05:55:02,380
compile we can deploy, we can
pretty much do everything that

6009
05:55:02,380 --> 05:55:05,710
we need to do. It's web based.
It can do testing, debugging,

6010
05:55:05,710 --> 05:55:09,580
deploying local JavaScript VM,
it's very quick and easy to

6011
05:55:09,580 --> 05:55:12,130
create and test our smart
contracts. However, it does have

6012
05:55:12,130 --> 05:55:15,490
some limitations. It can really
only deal with smart contract,

6013
05:55:15,520 --> 05:55:18,820
it can't really integrate with
other parts of projects. It has

6014
05:55:18,820 --> 05:55:21,580
limited support for tests or
custom deployments. And you need

6015
05:55:21,580 --> 05:55:25,120
an internet connection to even
work with remix and it can be

6016
05:55:25,120 --> 05:55:28,240
tricky to do a lot more advanced
functionality. So it's a

6017
05:55:28,240 --> 05:55:30,760
phenomenal tool and absolutely
if you're looking to do

6018
05:55:30,760 --> 05:55:32,920
something very quickly, I
absolutely recommend everybody

6019
05:55:32,920 --> 05:55:35,830
just go to remix to go ahead and
try something out how are now

6020
05:55:35,830 --> 05:55:38,650
we're going to move over to a
more professional smart contract

6021
05:55:38,650 --> 05:55:42,100
developer setup. And this is
with hard hat. This is known as

6022
05:55:42,100 --> 05:55:45,790
a smart contract developer
framework similar to brownie or

6023
05:55:45,790 --> 05:55:49,180
foundry or, and likes, there's a
number of these frameworks. And

6024
05:55:49,180 --> 05:55:51,730
the reason that we're going to
do hard hat is because hard hat

6025
05:55:51,940 --> 05:55:55,540
is JavaScript based. It's a
JavaScript based development

6026
05:55:55,570 --> 05:55:58,630
environment. It's got JavaScript
based compilation, environment,

6027
05:55:58,630 --> 05:56:02,140
deploying, testing, debugging.
Now, for those of you who love

6028
05:56:02,170 --> 05:56:06,010
TypeScript, we will also have
TypeScript editions of every

6029
05:56:06,010 --> 05:56:09,280
single one of our code examples
for you. So if you love

6030
05:56:09,280 --> 05:56:12,880
JavaScript, we got you, if you
love TypeScript, we also got you

6031
05:56:12,910 --> 05:56:16,510
we're not always going to walk
through us doing the TypeScript.

6032
05:56:16,930 --> 05:56:20,320
But we will sometimes, and all
of the code for the TypeScript

6033
05:56:20,350 --> 05:56:23,590
will be available in the GitHub
repo. Now, before we can

6034
05:56:23,590 --> 05:56:26,860
actually learn hard hat, we have
to learn another package first.

6035
05:56:26,890 --> 05:56:30,100
So we're going to learn how to
do everything with ethers. Jas,

6036
05:56:30,130 --> 05:56:33,130
which is a JavaScript based
library for working with smart

6037
05:56:33,130 --> 05:56:36,310
contracts. And it's also what
powers the next tool that we're

6038
05:56:36,310 --> 05:56:39,250
going to be working with, which
is hard hat under the hood of

6039
05:56:39,250 --> 05:56:41,680
hard hat. There's a lot of
ethers Jas. So it's important

6040
05:56:41,680 --> 05:56:45,430
for us to learn ethers Jas so
that we can understand what hard

6041
05:56:45,430 --> 05:56:47,830
hat is actually doing. Now for
the rest of the course, I'm

6042
05:56:47,830 --> 05:56:51,970
going to be using a code editor
called Visual Studio code. This

6043
05:56:51,970 --> 05:56:54,940
is one of the most powerful code
editors on the planet. And if

6044
05:56:54,940 --> 05:56:57,400
you've already got it set up,
feel free to go ahead and skip

6045
05:56:57,400 --> 05:57:00,190
this part. If you already have a
professional coding setup with

6046
05:57:00,190 --> 05:57:03,490
no GS and VS code, and Git and
everything, feel free to use the

6047
05:57:03,490 --> 05:57:06,820
timestamps in the GitHub
repository. To skip over this

6048
05:57:06,850 --> 05:57:11,020
setup section. You'll often hear
people refer to this as VS code,

6049
05:57:11,050 --> 05:57:14,230
or Visual Studio code or just
Visual Studio. However, it's

6050
05:57:14,230 --> 05:57:18,490
important to note that Visual
Studio code this is different

6051
05:57:18,700 --> 05:57:22,090
than Visual Studio, which you
might see look like this. So

6052
05:57:22,480 --> 05:57:26,620
Visual Studio code is what you
want, not Visual Studio, Visual

6053
05:57:26,620 --> 05:57:29,620
Studio is a different
application, make sure you're on

6054
05:57:29,620 --> 05:57:33,310
Visual Studio code. Now, if you
choose so and you're a total

6055
05:57:33,310 --> 05:57:37,120
Harto, you can absolutely work
just with your terminal, or just

6056
05:57:37,120 --> 05:57:40,660
with PowerShell, or just with
whatever coding environment that

6057
05:57:40,660 --> 05:57:44,620
you want, like atom or Sublime.
However, for us, we're going to

6058
05:57:44,620 --> 05:57:47,770
be working with Visual Studio
code. And I'm going to be going

6059
05:57:47,770 --> 05:57:51,040
through setting up Visual Studio
code the way that I like to set

6060
05:57:51,040 --> 05:57:54,280
it up, you can actually set it
up whatever way that you feel

6061
05:57:54,280 --> 05:57:58,240
comfortable. And of course, in
our lesson six here, we have a

6062
05:57:58,240 --> 05:58:01,300
link to installation and setup.
And I'm going to be adding more

6063
05:58:01,300 --> 05:58:04,450
links as we go about here. And
once again, all the code that

6064
05:58:04,450 --> 05:58:07,990
we're going to be working with
is in this GitHub repository

6065
05:58:08,020 --> 05:58:10,900
down here where it says code.
Now we're gonna go through three

6066
05:58:10,900 --> 05:58:13,720
different installation processes
and pick the one that's most

6067
05:58:13,750 --> 05:58:17,350
appropriate for you. The first
one is going to be for Mac and

6068
05:58:17,350 --> 05:58:21,100
Linux users. The second one is
going to be for Windows users.

6069
05:58:21,250 --> 05:58:24,970
And then our third one is going
to be a last ditch effort. If

6070
05:58:24,970 --> 05:58:28,270
for whatever reason, you can't
get Windows or Linux or the Mac

6071
05:58:28,270 --> 05:58:31,390
instructions to work, we're
going to use a Git pod

6072
05:58:31,390 --> 05:58:34,840
installation. Now, I highly,
highly recommend that you try to

6073
05:58:34,840 --> 05:58:38,080
get everything working locally
without using Git pod. However,

6074
05:58:38,650 --> 05:58:42,010
if for whatever reason, you
can't get those installation

6075
05:58:42,010 --> 05:58:46,240
pieces to work, we will have Git
pod instructions for all of the

6076
05:58:46,240 --> 05:58:48,910
repos that we work with here.
But to get started, we'll start

6077
05:58:48,910 --> 05:58:51,850
with the Mac and Linux
installation instructions.

6078
05:58:54,430 --> 05:58:57,430
The first thing you're going to
want to do is download the Mac

6079
05:58:57,490 --> 05:59:01,120
or if you're working with Linux,
download the Linux installation

6080
05:59:01,150 --> 05:59:04,780
of Visual Studio code. Once you
have it installed, it'll look a

6081
05:59:04,780 --> 05:59:08,260
little something like this. And
if it's a fresh installation,

6082
05:59:08,470 --> 05:59:11,620
It'll even give you some tips
and tools to actually get

6083
05:59:11,620 --> 05:59:14,110
started. If you've never worked
with Visual Studio code before,

6084
05:59:14,380 --> 05:59:17,710
I highly recommend going through
any get started or getting

6085
05:59:17,710 --> 05:59:21,250
instructions tips that come with
opening Visual Studio Code.

6086
05:59:21,640 --> 05:59:25,420
Additionally, we have a Visual
Studio Code crash course in the

6087
05:59:25,420 --> 05:59:28,480
GitHub repo associated with this
course. Once you have Visual

6088
05:59:28,480 --> 05:59:31,690
Studio code installed, the next
thing that we're going to want

6089
05:59:31,690 --> 05:59:34,930
to install is going to be node j
s. And again, we have links to

6090
05:59:34,930 --> 05:59:37,720
all of these in the GitHub repo
associated with this course, you

6091
05:59:37,720 --> 05:59:40,660
can just go ahead and click
download for Mac OS or download

6092
05:59:40,660 --> 05:59:45,880
for Linux, I recommend using the
LTS version. lts stands for long

6093
05:59:45,880 --> 05:59:48,760
term support, which means that
they will be supporting this

6094
05:59:48,760 --> 05:59:53,170
version for a long time. So go
ahead and download Node js. I've

6095
05:59:53,170 --> 05:59:55,390
already downloaded this, so I'm
not gonna go ahead and

6096
05:59:55,390 --> 05:59:58,480
redownload this now one of the
awesome things about Visual

6097
05:59:58,480 --> 06:00:01,600
Studio code is it has this thing
called terminals, which are

6098
06:00:01,600 --> 06:00:05,290
command line prompts that allow
us to run scripts, basically,

6099
06:00:05,290 --> 06:00:07,630
it's where we're going to be
running all of our code where we

6100
06:00:07,630 --> 06:00:10,330
can open up the terminal is we
can go ahead and hit terminal

6101
06:00:10,630 --> 06:00:14,110
and select new terminal and
you'll get something like this.

6102
06:00:14,230 --> 06:00:18,520
Now you might have bash or Z ca
or some other type of shell type

6103
06:00:18,520 --> 06:00:21,370
that you have doesn't really
matter because on Mac and Linux

6104
06:00:21,550 --> 06:00:25,690
it's going to be Linux based we
can now test our no Jess

6105
06:00:25,690 --> 06:00:29,680
installation has been done
correctly by running Node dash

6106
06:00:29,680 --> 06:00:33,430
dash version, and you should see
something that looks like this.

6107
06:00:33,490 --> 06:00:37,030
The exact version of node that
you have doesn't really matter

6108
06:00:37,030 --> 06:00:40,720
here. But ideally you're at
least on Node version 14 or

6109
06:00:40,720 --> 06:00:43,540
higher. And if something like
this doesn't show up, remember

6110
06:00:43,540 --> 06:00:46,810
to go ahead and start looking at
Stack Overflow looking on the

6111
06:00:46,810 --> 06:00:49,960
GitHub repo in the discussions
tab, looking on the updated

6112
06:00:49,960 --> 06:00:52,990
section, etc. And like I said,
sometimes installing this can be

6113
06:00:52,990 --> 06:00:55,840
the hardest part of this entire
course so, so don't get

6114
06:00:55,840 --> 06:00:58,660
discouraged. And please use
Stack Overflow Stack Exchange

6115
06:00:58,660 --> 06:01:01,360
Etherium, and the GitHub repo to
move past any issues you run

6116
06:01:01,360 --> 06:01:05,440
into. Now, if you're on Mac or
Linux, you can actually hit Ctrl

6117
06:01:05,470 --> 06:01:08,860
back tick, to actually toggle
your terminal mode, this will

6118
06:01:08,860 --> 06:01:11,950
pull the terminal up and down
for you getting familiar with

6119
06:01:11,950 --> 06:01:14,650
keyboard shortcuts will actually
make your life a lot easier.

6120
06:01:14,650 --> 06:01:17,590
Because you'll be able to move
around Visual Studio code much

6121
06:01:17,590 --> 06:01:21,250
more effectively, we have a link
to a list of keyboard shortcuts.

6122
06:01:21,280 --> 06:01:24,190
Additionally, in the GitHub
repository associated with this

6123
06:01:24,190 --> 06:01:27,070
section, as we move along, I'll
give tip on different keyboard

6124
06:01:27,070 --> 06:01:29,950
shortcuts that you can
optionally use otherwise, you

6125
06:01:29,950 --> 06:01:32,530
can just go ahead and click as
well, you can click the trash

6126
06:01:32,530 --> 06:01:36,010
can to delete the terminal, go
back up Terminal new terminal to

6127
06:01:36,010 --> 06:01:38,080
pop it back up. Now the next
thing that we're going to need a

6128
06:01:38,080 --> 06:01:39,970
little bit later, we're not
going to need it for this

6129
06:01:39,970 --> 06:01:42,610
section, but it's good to
install it now is going to be

6130
06:01:42,610 --> 06:01:46,570
git no jazz is known as a
JavaScript runtime. And it's a

6131
06:01:46,570 --> 06:01:49,540
tool that we're going to use to
help run JavaScript code in our

6132
06:01:49,540 --> 06:01:52,690
Visual Studio Code slot exactly
JavaScript. And the difference

6133
06:01:52,690 --> 06:01:55,390
between no Jas and JavaScript
can be a little bit confusing,

6134
06:01:55,390 --> 06:01:58,030
but don't let that stop you for
now. Next, we're actually going

6135
06:01:58,030 --> 06:02:00,580
to go ahead and install Git, we
will have links to the

6136
06:02:00,580 --> 06:02:03,970
installation instructions in the
GitHub repository, installing

6137
06:02:03,970 --> 06:02:06,610
git on Linux, you're going to
use one of these two commands

6138
06:02:06,640 --> 06:02:10,000
and on macOS, if you just type
git on the command line, it

6139
06:02:10,000 --> 06:02:12,760
should go ahead and prompt you
to install it. So we're back in

6140
06:02:12,760 --> 06:02:15,130
our command line, and we just
type git, it should prompt you

6141
06:02:15,130 --> 06:02:18,340
to go ahead and stall it. And if
you do get dash dash version,

6142
06:02:18,970 --> 06:02:21,280
you should get something that
looks like this. You can also

6143
06:02:21,280 --> 06:02:24,280
use a Mac OS get installer by
clicking this link here and

6144
06:02:24,280 --> 06:02:26,860
running through the installation
process. Alright, now that you

6145
06:02:26,860 --> 06:02:31,270
have no JS yet in Visual Studio
code installed, we can continue

6146
06:02:31,270 --> 06:02:35,020
on to the next section. Awesome.
If you're not planning on using

6147
06:02:35,050 --> 06:02:38,800
Windows or get pod, feel free to
skip the next two sections.

6148
06:02:41,470 --> 06:02:44,920
I'm running this on Windows 11.
However, it should work on most

6149
06:02:44,920 --> 06:02:47,470
editions of Windows. So the
first thing that we're going to

6150
06:02:47,470 --> 06:02:53,410
want to install is Visual Studio
Code, which looks something like

6151
06:02:53,410 --> 06:02:56,980
this, it should auto detect it.
And we're gonna go ahead and

6152
06:02:56,980 --> 06:03:00,250
download this for windows in a
walk through all the

6153
06:03:00,610 --> 06:03:04,360
installation process. Go ahead
and create a desktop item, we'll

6154
06:03:04,360 --> 06:03:08,710
add this just in case we want to
open with code. And we'll go

6155
06:03:08,710 --> 06:03:12,220
ahead and install. And then
we'll go ahead and finish. Once

6156
06:03:12,220 --> 06:03:14,500
you've installed Visual Studio
code, you'll see something that

6157
06:03:14,500 --> 06:03:17,230
looks a little like this, it'll
go ahead and give you this get

6158
06:03:17,230 --> 06:03:19,960
started with VS Code section
where you can choose some

6159
06:03:19,960 --> 06:03:22,150
themes, and you can choose kind
of the way it looks feel free to

6160
06:03:22,150 --> 06:03:24,520
customize it the way that you
want. If you want to learn a

6161
06:03:24,520 --> 06:03:27,700
little bit more about Visual
Studio code, I highly recommend

6162
06:03:27,730 --> 06:03:30,670
you walk through this section to
learn more about the shortcuts

6163
06:03:30,670 --> 06:03:33,760
and making your development
experience more efficient. When

6164
06:03:33,760 --> 06:03:36,070
you're done, you can just go
ahead and close the tabs at the

6165
06:03:36,070 --> 06:03:38,740
top. And it'll look a little
something like this. Once we

6166
06:03:38,740 --> 06:03:41,530
have Visual Studio code
installed. The next thing that

6167
06:03:41,530 --> 06:03:44,290
we're going to want to install
is node j s. And of course, we

6168
06:03:44,290 --> 06:03:46,900
have a link to installing this
in the GitHub repository

6169
06:03:46,930 --> 06:03:48,970
associated with this course,
what we're going to do is we're

6170
06:03:48,970 --> 06:03:52,300
going to go ahead and come to
node j s.org. To download this

6171
06:03:52,300 --> 06:03:55,510
for Windows node. JS is a
JavaScript runtime environment,

6172
06:03:55,510 --> 06:03:58,420
it's not exactly JavaScript. And
the distinction can be a little

6173
06:03:58,420 --> 06:04:01,090
bit confusing, but just know
it's going to help us run our

6174
06:04:01,090 --> 06:04:03,610
JavaScript code for our
development environment. Let's

6175
06:04:03,610 --> 06:04:08,170
go ahead and download the LTS or
the long term support edition of

6176
06:04:08,200 --> 06:04:11,260
no GS. We'll go ahead and we'll
run through the setup wizard.

6177
06:04:15,610 --> 06:04:18,460
And we'll go ahead and make sure
that this is clicked just in

6178
06:04:18,460 --> 06:04:21,580
case we ever want to use some
different tools with our setup.

6179
06:04:21,610 --> 06:04:24,550
And then we'll go ahead and
click Install, you'll get a pop

6180
06:04:24,550 --> 06:04:27,220
up asking if you really want to
install this on your device. And

6181
06:04:27,220 --> 06:04:30,040
we'll go ahead and hit yes. And
then we'll hit finish, you might

6182
06:04:30,040 --> 06:04:33,010
get a pop up that looks like
this, go ahead and click any

6183
06:04:33,010 --> 06:04:35,830
button to go ahead and install
the tools, go ahead and press

6184
06:04:35,830 --> 06:04:39,280
any key again. And you'll likely
get a Windows PowerShell screen

6185
06:04:39,280 --> 06:04:42,370
pop up asking you to go ahead
and install a whole bunch of

6186
06:04:42,370 --> 06:04:45,250
different projects and files. If
you chose not to install this,

6187
06:04:45,280 --> 06:04:47,980
that's totally okay. But in the
future, this will be really

6188
06:04:47,980 --> 06:04:50,740
helpful since we are going to
use a lot of tools that this

6189
06:04:50,740 --> 06:04:54,010
package installs anyways, this
might take some time to install.

6190
06:04:54,010 --> 06:04:56,650
So go ahead and be patient. And
if it gets stuck, it might just

6191
06:04:56,650 --> 06:04:59,680
be waiting for you to go ahead
and hit enter. So go ahead and

6192
06:04:59,680 --> 06:05:02,440
hit Enter for any prompts. But
yes, please be patient with

6193
06:05:02,440 --> 06:05:04,600
this, it can be a little bit
slow to go ahead and install

6194
06:05:04,600 --> 06:05:06,880
everything. Once you have all
that installed, you can come

6195
06:05:06,880 --> 06:05:10,090
back to Visual Studio code. And
we're going to go ahead and open

6196
06:05:10,090 --> 06:05:13,870
up a terminal. To do that we hit
terminal and we hit new terminal

6197
06:05:13,960 --> 06:05:16,480
terminal is going to be our
command line prompt where we're

6198
06:05:16,480 --> 06:05:19,060
going to basically run all of
our scripts to work with our

6199
06:05:19,060 --> 06:05:23,260
code. And if you run Node dash
dash version, you should see

6200
06:05:23,260 --> 06:05:26,230
something that looks like this
to know that you've installed

6201
06:05:26,260 --> 06:05:30,070
Node js correctly. Now this
command line is known as Windows

6202
06:05:30,100 --> 06:05:33,010
PowerShell. If you want to work
with Windows PowerShell, you

6203
06:05:33,010 --> 06:05:36,010
absolutely can. In fact, if you
want to be a total Harto, and

6204
06:05:36,010 --> 06:05:38,440
write all your code through
Windows PowerShell, you can

6205
06:05:38,440 --> 06:05:40,930
absolutely do that as well.
However, we're actually not

6206
06:05:40,930 --> 06:05:42,790
going to be working with
PowerShell We're going to be

6207
06:05:42,790 --> 06:05:46,150
using a tool that makes our
Windows environments more like

6208
06:05:46,180 --> 06:05:48,670
Linux. The reason that we're
doing this is Linux is the

6209
06:05:48,670 --> 06:05:51,100
standard for most development
environments. And having

6210
06:05:51,100 --> 06:05:54,220
everybody work on a very similar
setup will make the rest of this

6211
06:05:54,220 --> 06:05:57,970
course a lot easier for everyone
to interact with each other, no

6212
06:05:57,970 --> 06:06:01,450
matter what coding environment,
they're working on. WsL stands

6213
06:06:01,450 --> 06:06:05,890
for Windows subsystem for Linux,
and allows Linux programs to run

6214
06:06:05,920 --> 06:06:09,310
natively on our Windows
environments. To get this setup,

6215
06:06:09,400 --> 06:06:14,560
we're gonna go ahead, go to the
WsL install. And we'll have a

6216
06:06:14,560 --> 06:06:19,090
link for this as well in our
GitHub repository. So what we're

6217
06:06:19,090 --> 06:06:23,290
going to do, you must be running
a Windows 10, version 2004 or

6218
06:06:23,290 --> 06:06:25,990
higher, or Windows 11. If you're
using an older version of

6219
06:06:25,990 --> 06:06:28,990
Windows, you can absolutely
continue with PowerShell. But

6220
06:06:28,990 --> 06:06:31,570
you might run into some issues
where all the commands don't

6221
06:06:31,570 --> 06:06:34,720
work exactly the same. So I
highly recommend working on a

6222
06:06:34,720 --> 06:06:40,510
newer version of Windows. To
install this back in your Visual

6223
06:06:40,510 --> 06:06:43,750
Studio Code, PowerShell, or just
the PowerShell app, or running

6224
06:06:43,750 --> 06:06:48,850
WsL dash dash install. Now if
you get this error, the

6225
06:06:48,850 --> 06:06:52,030
requested operation requires
elevation, it means that we have

6226
06:06:52,030 --> 06:06:55,960
to run our Visual Studio code or
our PowerShell application as

6227
06:06:55,960 --> 06:07:03,160
administrator. We close out our
Visual Studio code. And right

6228
06:07:03,160 --> 06:07:07,000
click it and say, Run as
Administrator, we get a little

6229
06:07:07,000 --> 06:07:09,790
pop up saying Do you want to
allow this app to make changes

6230
06:07:09,790 --> 06:07:13,090
to your device, we'll go ahead
and click Yes. And then we'll

6231
06:07:13,090 --> 06:07:18,250
reopen the terminal. And then we
can run WsL space dash dash

6232
06:07:18,280 --> 06:07:23,110
install. And we'll go ahead and
install WsL. This may take a

6233
06:07:23,110 --> 06:07:24,610
little bit so please be patient.

6234
06:07:25,990 --> 06:07:28,300
Once it's completed, you'll see
something that looks like this,

6235
06:07:28,330 --> 06:07:31,060
we're going to be working with
Ubuntu. And we have a list of

6236
06:07:31,060 --> 06:07:34,210
different commands to change
your Linux distribution. If you

6237
06:07:34,210 --> 06:07:36,910
choose to do so. And you'll see
the request set operation is

6238
06:07:36,910 --> 06:07:40,120
successful changes will not be
effective until the system is

6239
06:07:40,120 --> 06:07:43,210
rebooted. So you'll want to go
ahead and restart your computer.

6240
06:07:43,300 --> 06:07:46,450
There's also a troubleshooting
guide in the GitHub repository.

6241
06:07:46,450 --> 06:07:49,420
If you run into issues after you
restart your computer, you'll be

6242
06:07:49,420 --> 06:07:52,810
prompted for a name for your new
system and a password. This can

6243
06:07:52,810 --> 06:07:55,000
be different from your Windows
name and password, and then just

6244
06:07:55,000 --> 06:07:57,640
follow through with all the
prompts. And then once you're

6245
06:07:57,640 --> 06:08:00,880
done, you'll be dropped into a
Ubuntu shell, and you can run

6246
06:08:00,880 --> 06:08:04,720
Linux commands. Now you'll have
a Ubuntu instance, on your

6247
06:08:04,720 --> 06:08:07,930
machine. And you'll be able to
run Linux commands in your

6248
06:08:07,930 --> 06:08:11,650
terminal. Now that we have WsL
set up correctly, we're going to

6249
06:08:11,650 --> 06:08:15,520
head back over to Visual Studio
code. Once we have WsL, we'll

6250
06:08:15,520 --> 06:08:18,610
want to go ahead and install an
extension. So in our Visual

6251
06:08:18,610 --> 06:08:21,490
Studio code, we'll go to
Extensions, and we'll look up

6252
06:08:21,970 --> 06:08:28,210
remote development you can
install the whole thing or just

6253
06:08:28,210 --> 06:08:33,880
remote WsL we're gonna install
the whole thing you can follow

6254
06:08:33,880 --> 06:08:37,630
along to get started with remote
WsL if you like, or you can just

6255
06:08:37,630 --> 06:08:40,690
follow along with me right now.
Right now if I go to the

6256
06:08:40,690 --> 06:08:44,770
terminal and hit new terminal,
I'm still gonna get PowerShell

6257
06:08:45,220 --> 06:08:48,640
we actually want this to be our
Linux shell. So there are a

6258
06:08:48,640 --> 06:08:51,880
couple ways to open Visual
Studio code up in our Linux

6259
06:08:51,880 --> 06:08:57,520
environment. One way is you're
gonna hit Ctrl, Shift P and type

6260
06:08:57,520 --> 06:09:03,550
WsL. And then click remote WsL
new WsL window, and you'll get a

6261
06:09:03,550 --> 06:09:06,310
new window that looks like this,
you can also click the bottom

6262
06:09:06,310 --> 06:09:12,190
left and choose New WsL window.
Now if we go to our terminal and

6263
06:09:12,190 --> 06:09:15,280
hit new terminal, we'll be
dropped into a bash shell and we

6264
06:09:15,280 --> 06:09:18,670
can run Linux commands in here.
Awesome. Another way we can open

6265
06:09:18,670 --> 06:09:22,870
up Visual Studio code with WsL
on is we can go into our your

6266
06:09:22,870 --> 06:09:28,660
boon to application, we can make
a folder by typing MK dir

6267
06:09:29,470 --> 06:09:34,510
folder, we'll CD or change
directory into folder and type

6268
06:09:34,510 --> 06:09:38,470
code period. We'll go ahead and
trust the authors in here. And

6269
06:09:38,470 --> 06:09:42,100
this will open up Visual Studio
code already connected to the

6270
06:09:42,100 --> 06:09:45,670
folder that we're in. And we can
create files in this folder like

6271
06:09:45,700 --> 06:09:50,110
hi dot txt, and those will get
created inside the folder in our

6272
06:09:50,110 --> 06:09:53,650
WsL. Now that we're inside our
WsL environment, you'll notice

6273
06:09:53,650 --> 06:09:56,890
that node dash dash version
doesn't work anymore. That's

6274
06:09:56,890 --> 06:10:00,700
because we installed it on our
regular Windows machine and not

6275
06:10:00,790 --> 06:10:04,150
on our WsL or Linux environment.
The reason we installed it on a

6276
06:10:04,150 --> 06:10:07,000
Windows environment first is
that just in case you wanted to

6277
06:10:07,000 --> 06:10:10,000
go ahead and use PowerShell or
user Windows environment to run

6278
06:10:10,000 --> 06:10:12,880
everything you still can just
remember if you use the Windows

6279
06:10:12,880 --> 06:10:15,640
environment and PowerShell all
the commands that we use might

6280
06:10:15,640 --> 06:10:20,320
not work for you. So we're gonna
go ahead and install Node js on

6281
06:10:20,320 --> 06:10:22,960
our Linux environment. Now, all
the commands that we're going to

6282
06:10:22,960 --> 06:10:25,510
write are going to be in the
GitHub repo associated with this

6283
06:10:25,510 --> 06:10:30,970
course. We're going to do a curl
command to the nvm repository,

6284
06:10:31,630 --> 06:10:33,640
which stands for node version
manager.

6285
06:10:44,229 --> 06:10:47,049
And we're going to pipe the
install script into bash. And

6286
06:10:47,049 --> 06:10:52,869
this will go ahead and install
and VM. After running that, go

6287
06:10:52,869 --> 06:10:57,879
ahead and trash the terminal,
and then reopen it. And then we

6288
06:10:57,879 --> 06:11:02,409
can type MBM dash dash version
to see if it actually installed

6289
06:11:02,409 --> 06:11:05,529
correctly. Once we've installed
nvm, we can go ahead and install

6290
06:11:05,559 --> 06:11:13,029
no GS using nvm. Just type npm
install, and we'll do 16 point

6291
06:11:13,029 --> 06:11:16,899
14.2 Is that same long term
support version we installed on

6292
06:11:16,899 --> 06:11:20,739
our Windows machine. Once we
have it installed, we can type

6293
06:11:20,739 --> 06:11:24,609
in Node dash S version. And now
we have no JS installed. Now I

6294
06:11:24,609 --> 06:11:27,579
know there was a lot here, but
if you made it this far, this is

6295
06:11:27,609 --> 06:11:31,029
fantastic. You've done a great
job to push through to this

6296
06:11:31,029 --> 06:11:34,269
point and get everything set up
so you can code in the best

6297
06:11:34,269 --> 06:11:36,999
environment there is. So if
you've made it this far, huge

6298
06:11:36,999 --> 06:11:39,429
congratulations. Now the next
thing that we're going to

6299
06:11:39,429 --> 06:11:42,789
install is Git. And now we're
not going to use Git for this

6300
06:11:42,789 --> 06:11:45,369
lesson. However, we will
definitely be using it in the

6301
06:11:45,369 --> 06:11:48,879
future. See if gets installed
type git dash dash version,

6302
06:11:49,029 --> 06:11:51,279
sometimes Linux will
automatically come with Git

6303
06:11:51,279 --> 06:11:54,279
installed and you'll see
something output like this. If

6304
06:11:54,279 --> 06:11:58,899
you don't have Git, we can just
look up the get install. Which

6305
06:11:58,899 --> 06:12:01,869
again, link to this is in the
description. And you'll actually

6306
06:12:01,869 --> 06:12:06,369
run the installing on Linux. Now
again, now if you want to use

6307
06:12:06,369 --> 06:12:09,009
PowerShell, and you want to do
everything with Windows, you can

6308
06:12:09,009 --> 06:12:11,769
absolutely follow the installing
on Windows instructions here

6309
06:12:11,769 --> 06:12:15,519
instead, when you're working in
WsL, you'll want to use the

6310
06:12:15,519 --> 06:12:18,669
Linux commands instead of the
windows commands even though

6311
06:12:18,669 --> 06:12:21,789
you're on a Windows because WsL
makes it so that you're

6312
06:12:21,789 --> 06:12:24,579
basically running in a Linux
environment. And now if you've

6313
06:12:24,579 --> 06:12:27,069
made it this far, you should be
able to follow along with the

6314
06:12:27,069 --> 06:12:30,099
Mac and Linux instructions as if
you're running on a Mac and

6315
06:12:30,129 --> 06:12:33,729
Linux even though you're running
on Windows. Just be sure that

6316
06:12:33,729 --> 06:12:36,159
whenever you're in your VS code,
you take a look at the bottom

6317
06:12:36,159 --> 06:12:40,209
left and make sure you're on WsL
Ubuntu. Like I said before, if

6318
06:12:40,209 --> 06:12:42,789
you want to run in PowerShell,
or in a Windows environment,

6319
06:12:42,819 --> 06:12:45,549
you're more than free to do so.
But like I said, if you've made

6320
06:12:45,549 --> 06:12:48,549
it this far, huge
congratulations. Awesome work.

6321
06:12:51,339 --> 06:12:54,429
And then finally, our last setup
is going to be using a tool

6322
06:12:54,429 --> 06:12:57,399
called Git pod starting from
Lesson five. The lesson that

6323
06:12:57,399 --> 06:13:00,279
we're on right now, ethers,
jazz, simple storage, all of our

6324
06:13:00,279 --> 06:13:04,509
code repos are going to come
with a button in the repo scroll

6325
06:13:04,509 --> 06:13:08,499
down, they'll come with this
open in get pod button. Now git

6326
06:13:08,499 --> 06:13:11,949
pod is a cloud development
environment where you can

6327
06:13:11,949 --> 06:13:16,449
actually run your code on a
remote server, it's kind of

6328
06:13:16,449 --> 06:13:20,199
similar to remix IDE, but it
allows you to run Visual Studio

6329
06:13:20,199 --> 06:13:25,029
code in the browser or connected
to another server. This is good

6330
06:13:25,029 --> 06:13:27,939
because then you don't have to
do any installation on anything.

6331
06:13:28,149 --> 06:13:31,089
Since all the tools that you can
want to use are just going to be

6332
06:13:31,089 --> 06:13:34,839
running on this remote server.
This has its downsides, though,

6333
06:13:34,839 --> 06:13:39,039
obviously, since you'll only be
able to code if git pod is up

6334
06:13:39,039 --> 06:13:41,469
and working for you.
Additionally, when it comes to

6335
06:13:41,469 --> 06:13:45,669
private keys, you absolutely do
not want to run any code with a

6336
06:13:45,669 --> 06:13:49,479
private key that has real money
in good pop. Why? Well, once

6337
06:13:49,479 --> 06:13:53,259
again, since you're running your
scripts on a remote server,

6338
06:13:53,529 --> 06:13:57,519
those servers have access to
your private keys. But since

6339
06:13:57,519 --> 06:14:00,849
you've Pinky promise that for
this course, you're not going to

6340
06:14:00,849 --> 06:14:03,789
be using a meta mask or a
private key with actual money in

6341
06:14:03,789 --> 06:14:07,119
it, it should be fine. The other
downside is that these often

6342
06:14:07,119 --> 06:14:11,289
cost money to use and get pot
isn't free. But it's an option

6343
06:14:11,319 --> 06:14:15,129
if you absolutely cannot get any
of the installation working. So

6344
06:14:15,129 --> 06:14:18,069
if you go ahead and you hit this
opening get pod button, you'll

6345
06:14:18,069 --> 06:14:20,919
get a welcome to get pods
showing up. We're gonna go ahead

6346
06:14:20,919 --> 06:14:24,009
and continue with GitHub. Since
you've signed up for GitHub

6347
06:14:24,009 --> 06:14:29,319
here, you want to go ahead and
authorize get pod. And it'll go

6348
06:14:29,319 --> 06:14:32,859
ahead and start creating this
workspace for you. And you'll

6349
06:14:32,859 --> 06:14:36,939
notice it looks exactly like
Visual Studio Code. Since I

6350
06:14:36,939 --> 06:14:41,889
opened the repo up in Git pod,
it came with all the code, and

6351
06:14:41,889 --> 06:14:47,049
you can even open this workspace
up in VS code desktop. So this

6352
06:14:47,049 --> 06:14:50,109
is might be a little bit
confusing. But basically, you

6353
06:14:50,109 --> 06:14:54,309
can run off of Git pod using
your local Visual Studio code.

6354
06:14:54,519 --> 06:14:57,159
And if you see git pod here,
that's how you know that you're

6355
06:14:57,159 --> 06:15:00,639
running off of Git pod. If you
see this pop up, do you want to

6356
06:15:00,639 --> 06:15:04,809
open this workspace in VS code
desktop, you can hit Open. And

6357
06:15:04,809 --> 06:15:07,299
it'll ask you if you want to
open up Visual Studio Code,

6358
06:15:07,569 --> 06:15:10,299
which I'm going to go ahead and
hit yes. And you'll get

6359
06:15:10,299 --> 06:15:13,239
something that looks like this
on your Visual Studio Code.

6360
06:15:13,449 --> 06:15:16,389
It'll tell you that it wants to
install the Git pod extension,

6361
06:15:16,809 --> 06:15:20,619
and then open that Git pod URL.
So you can go ahead and install

6362
06:15:20,619 --> 06:15:25,809
it. Reload window and open and
it's going to go ahead and start

6363
06:15:25,809 --> 06:15:29,739
connecting to our the Git pod
workspace. And this is going to

6364
06:15:29,739 --> 06:15:34,419
be the same as running git pod
in the browser here. Or you can

6365
06:15:34,419 --> 06:15:38,079
also do it manually by hitting
the Git pod in the bottom left,

6366
06:15:38,799 --> 06:15:42,219
and then type in open in VS code

6367
06:15:43,660 --> 06:15:45,820
And then you should be able to
run it in your Visual Studio

6368
06:15:45,820 --> 06:15:48,430
code. For now, I'm going to
recommend that if you're using

6369
06:15:48,430 --> 06:15:51,670
Git pod, just stay in the
browser, just so that you know,

6370
06:15:51,700 --> 06:15:55,420
okay, I am running this on a
remote server. And just as a

6371
06:15:55,420 --> 06:15:59,710
reminder for you that you're not
actually locally developing. And

6372
06:15:59,710 --> 06:16:02,440
hopefully, this will be a
trigger to not actually put any

6373
06:16:02,440 --> 06:16:05,380
special private keys or anything
like that. But you can make

6374
06:16:05,380 --> 06:16:08,080
workspaces, you can make new
folders, and you should be able

6375
06:16:08,080 --> 06:16:11,740
to run all the commands on here,
as if you are running locally

6376
06:16:11,740 --> 06:16:14,980
with Visual Studio code. To open
up the terminal, you can hit

6377
06:16:14,980 --> 06:16:20,500
this little bar at the top left,
go to terminal, new terminal, or

6378
06:16:20,530 --> 06:16:25,780
use CTRL tilde exact same as Mac
OS and Linux keyboard shortcuts

6379
06:16:25,930 --> 06:16:30,580
to create a new folder, we can
change directory, CD, dot.mk,

6380
06:16:30,580 --> 06:16:36,070
dir, new folder, MK dir makes
make directory called New

6381
06:16:36,070 --> 06:16:39,490
Folder. And then we're going to
change our directory into a new

6382
06:16:39,490 --> 06:16:42,940
folder, and hit enter. And now
we're in that new folder. For

6383
06:16:42,940 --> 06:16:46,270
each section, you can either
open up the entire source code

6384
06:16:46,300 --> 06:16:50,200
right into GitHub, or you can
create a new folder for each

6385
06:16:50,230 --> 06:16:53,770
section yourself and start from
blank. And then you would just

6386
06:16:53,800 --> 06:17:01,480
type code period. And you'd be
in a brand new folder. All

6387
06:17:01,480 --> 06:17:04,780
right, this is fantastic. At
this point, you should be set up

6388
06:17:04,780 --> 06:17:09,520
with Visual Studio Code no Jas
and get. And I'm going to be

6389
06:17:09,520 --> 06:17:12,550
working out of a folder called
Hard Hat Free Code Camp at this

6390
06:17:12,550 --> 06:17:18,700
point, you should have node,
dash dash version, get dash dash

6391
06:17:18,700 --> 06:17:22,930
version. And if you're using
Windows, this should say WsL or

6392
06:17:22,930 --> 06:17:26,050
your boon to or something like
that. And if you have all that,

6393
06:17:26,080 --> 06:17:29,650
that means we're ready to go.
Now a quick note something that

6394
06:17:29,650 --> 06:17:33,340
you'll see me do a lot. And you
can do this as well. Oftentimes,

6395
06:17:33,490 --> 06:17:36,130
when my terminal gets really,
really big, or there's a ton of

6396
06:17:36,130 --> 06:17:39,160
commands in here gets a little
bit overwhelming for me. So one

6397
06:17:39,160 --> 06:17:42,580
thing that you can do is you can
type clear, and hit Enter to

6398
06:17:42,580 --> 06:17:47,560
clear it. Or what you can do is
you can hit Command K, if you're

6399
06:17:47,560 --> 06:17:52,300
on a Mac, or Ctrl K, if you're
on a Linux or a Windows, and

6400
06:17:52,300 --> 06:17:54,550
it's one of my favorite keyboard
shortcuts that I use all the

6401
06:17:54,550 --> 06:17:58,930
time. Additionally, the trash
can and the X here are very

6402
06:17:58,930 --> 06:18:02,590
different. If I go to a couple
of enters here, and we're down

6403
06:18:02,590 --> 06:18:06,280
here, if I hit the trashcan, and
then pull my terminal back up,

6404
06:18:06,580 --> 06:18:10,090
by doing the toggle, or by doing
terminal new terminal, you'll

6405
06:18:10,090 --> 06:18:13,870
see all those lines are still
here. But if I hit the trashcan,

6406
06:18:14,260 --> 06:18:17,320
and then pull the terminal back
up, you'll see it actually

6407
06:18:17,320 --> 06:18:22,090
refreshes mine a special command
that prints stuff out. trashing

6408
06:18:22,090 --> 06:18:24,400
your terminal is basically
deleting whatever's running in

6409
06:18:24,400 --> 06:18:29,380
it, and the x is just hiding it.
And as hitting Ctrl tilde or

6410
06:18:29,380 --> 06:18:32,170
toggling our terminal or
whatever command it is on your

6411
06:18:32,170 --> 06:18:35,470
environment, that's equivalent
to hitting the hide, not the

6412
06:18:35,470 --> 06:18:38,860
trash. So if we want to remove
and start a terminal over, we

6413
06:18:38,860 --> 06:18:42,670
hit the trashcan, and then we
pull it back up. Alright, so now

6414
06:18:42,670 --> 06:18:44,980
we're gonna start working with
ethers. And we're going to start

6415
06:18:44,980 --> 06:18:48,670
learning to code, our
transactions and our contract

6416
06:18:48,670 --> 06:18:51,730
deployments and everything
programmatically at a relatively

6417
06:18:51,730 --> 06:18:54,460
low level. And we're gonna learn
how to deploy and interact with

6418
06:18:54,460 --> 06:18:58,030
the contracts using the ethers
JS package. Now to get started,

6419
06:18:58,060 --> 06:19:00,670
I'm going to recommend you
create a folder where you're

6420
06:19:00,670 --> 06:19:02,740
going to put all of your
projects in it, I'm going to

6421
06:19:02,740 --> 06:19:07,960
create a new directory called H
H. hyphen, FCC, which stands for

6422
06:19:07,960 --> 06:19:11,110
hard hat Free Code Camp. And
once we run that command, we can

6423
06:19:11,110 --> 06:19:15,520
cd into hh FCC. And this is
where we'll create all of our

6424
06:19:15,520 --> 06:19:18,430
projects for this course moving
forward, so that we have them

6425
06:19:18,430 --> 06:19:21,640
all in one place. Now to get
started, whenever you create a

6426
06:19:21,640 --> 06:19:25,210
new project, you always want to
create a new folder. So to

6427
06:19:25,210 --> 06:19:28,450
create a new folder, we're going
to do MK dir, and we're going to

6428
06:19:28,450 --> 06:19:35,950
call this ethers, simple
storage, like that. And now, if

6429
06:19:35,950 --> 06:19:40,900
you type ls, you'll see that
there is one folder named

6430
06:19:40,930 --> 06:19:45,670
ethers, simple storage. ls is
how you list all the contents of

6431
06:19:45,850 --> 06:19:49,450
your folder. You might have a
lot of other folders in here, I

6432
06:19:49,450 --> 06:19:52,210
only have the one since I
created this new folder for

6433
06:19:52,210 --> 06:19:57,490
this. Now what you can do, you
can type code, ethers simple.

6434
06:19:57,880 --> 06:20:01,690
And then if you hit tab, it
should autocomplete for you. And

6435
06:20:01,690 --> 06:20:06,940
if you enter, Visual Studio code
should open up a new Visual

6436
06:20:06,940 --> 06:20:12,700
Studio code for you. That is
inside of either simple storage

6437
06:20:13,060 --> 06:20:16,060
if you open up your terminal
now, your home directory for

6438
06:20:16,060 --> 06:20:19,240
this workspace is going to be
through simple storage as this

6439
06:20:19,240 --> 06:20:23,020
is what pops up. If that doesn't
work for you, we can also do is

6440
06:20:23,020 --> 06:20:28,900
you can hit File, Open folder
and then open the folder that

6441
06:20:28,900 --> 06:20:32,530
you just created or that you
want to open this again we'll

6442
06:20:32,530 --> 06:20:35,680
open up VS code. And if we open
up our terminal we see we're

6443
06:20:35,680 --> 06:20:38,980
inside of ether simple storage.
This is so powerful because as

6444
06:20:38,980 --> 06:20:40,030
we create files

6445
06:20:41,560 --> 06:20:45,760
we'll be able to See those files
in our Explorer here, this

6446
06:20:45,760 --> 06:20:48,850
button here stands for the
Explorer. If we click it, we can

6447
06:20:48,850 --> 06:20:51,220
see the different files in here.
And I'm going to go ahead and

6448
06:20:51,220 --> 06:20:54,700
actually delete this file dot
txt, because we're not actually

6449
06:20:54,700 --> 06:20:57,430
going to use that. Now it's this
part of the course, where we're

6450
06:20:57,430 --> 06:21:01,180
actually going to start jumping
into some JavaScript. Since this

6451
06:21:01,180 --> 06:21:04,270
course is in JavaScript course,
if you're unfamiliar with

6452
06:21:04,270 --> 06:21:07,630
JavaScript, it might be a little
bit tricky. If you want to come

6453
06:21:07,630 --> 06:21:10,000
into this with a better
understanding of JavaScript and

6454
06:21:10,000 --> 06:21:14,230
Node js, there is a Free Code
Camp YouTube video teaching No,

6455
06:21:14,230 --> 06:21:17,530
Jas for beginners. And a link to
this will be in the GitHub repo

6456
06:21:17,530 --> 06:21:20,800
associated with this course.
There's also a JavaScript Free

6457
06:21:20,800 --> 06:21:23,680
Code Camp video that I'm also
going to put in the description

6458
06:21:23,680 --> 06:21:26,770
for this course, keep in mind
that JavaScript and Node js are

6459
06:21:26,770 --> 06:21:29,710
slightly different. And we are
going to go over some of the

6460
06:21:29,710 --> 06:21:33,190
differences as we code along
here. But for the most part,

6461
06:21:33,190 --> 06:21:35,680
learning one means you've
learned the majority of the

6462
06:21:35,680 --> 06:21:38,590
other. So if you want to pause
and go through these videos,

6463
06:21:38,590 --> 06:21:42,280
before continuing here, please
feel free to do so you don't

6464
06:21:42,310 --> 06:21:45,910
have to, you can absolutely
continue on with the course as

6465
06:21:45,910 --> 06:21:50,470
is. And if you get confused or
stuck on some JavaScript piece,

6466
06:21:50,620 --> 06:21:54,100
feel free to pause, Google it
and come back. But just to

6467
06:21:54,100 --> 06:21:56,170
reiterate, you can check out the
JavaScript programming full

6468
06:21:56,170 --> 06:22:00,130
course. And also the Node js
full course, as those are both

6469
06:22:00,130 --> 06:22:03,400
going to help you. Like I was
saying before, Node js is a

6470
06:22:03,400 --> 06:22:08,230
JavaScript runtime. So it's not
exactly JavaScript. But we're

6471
06:22:08,230 --> 06:22:10,990
going to write our code in
JavaScript. And if that's

6472
06:22:10,990 --> 06:22:14,230
confusing, just don't worry
about it right now. And as we go

6473
06:22:14,230 --> 06:22:17,110
through this course, I'll show
you where the differences are.

6474
06:22:17,440 --> 06:22:20,320
But basically, you can think of
no Jas and JavaScript kind of

6475
06:22:20,320 --> 06:22:23,800
being the same thing. The big
thing about Node js is it allows

6476
06:22:23,800 --> 06:22:27,970
us to write JavaScript code in
the back end, as opposed to

6477
06:22:28,000 --> 06:22:31,090
running JavaScript on the front
end, JavaScript is made to be a

6478
06:22:31,090 --> 06:22:35,200
browser run language, like
running inside of, you know,

6479
06:22:35,200 --> 06:22:40,780
Chrome, brave Firefox, etc. No,
Jas allows it to become a a

6480
06:22:40,780 --> 06:22:43,840
scripting language, a back end
language, which is why the

6481
06:22:43,840 --> 06:22:46,930
syntax between the front end
JavaScript and the back end

6482
06:22:46,930 --> 06:22:49,330
JavaScript or the no JS
JavaScript are going to be a

6483
06:22:49,330 --> 06:22:52,120
little bit different.
Additionally, as we go along in

6484
06:22:52,120 --> 06:22:56,290
this code, if you're familiar
with TypeScript, all of our code

6485
06:22:56,290 --> 06:22:59,200
is going to come with a
TypeScript edition. TypeScript

6486
06:22:59,200 --> 06:23:03,340
is what's known as a statically
typed version of JavaScript. And

6487
06:23:03,340 --> 06:23:05,650
it'll be it'll be this one.
It'll be TypeScript, not

6488
06:23:05,650 --> 06:23:08,440
TypeScript edition. I'll go
ahead and fix that and remove

6489
06:23:08,440 --> 06:23:11,260
this one to make it clear.
TypeScript is a type safe

6490
06:23:11,290 --> 06:23:14,350
version of JavaScript, which is
that's confusing, don't worry

6491
06:23:14,350 --> 06:23:17,110
too much about that. But we are
going to do all of our

6492
06:23:17,110 --> 06:23:20,170
programming in JavaScript. And
then if the code is different

6493
06:23:20,170 --> 06:23:22,600
enough, I'll show you how to do
it in TypeScript as well.

6494
06:23:22,690 --> 06:23:24,460
However, for most of them, we're
not going to show you the

6495
06:23:24,460 --> 06:23:26,950
TypeScript editions, because
it's going to be really similar.

6496
06:23:27,040 --> 06:23:30,250
But you can always refer back to
the GitHub repository to see all

6497
06:23:30,250 --> 06:23:32,980
the code for the TypeScript.
Now, if you're new to this

6498
06:23:32,980 --> 06:23:36,850
space, I actually do recommend
you go ahead and start with

6499
06:23:36,850 --> 06:23:40,180
JavaScript and learn how to do
TypeScript later on. TypeScript

6500
06:23:40,180 --> 06:23:45,430
actually catches bugs early on,
making it a lot easier to code

6501
06:23:45,460 --> 06:23:48,820
your projects in the long run.
However, it does take a lot of

6502
06:23:48,820 --> 06:23:52,330
extra typing. And it can be a
little bit frustrating learning

6503
06:23:52,330 --> 06:23:55,600
how types work for beginners,
JavaScript is a little bit more

6504
06:23:55,600 --> 06:23:59,080
loose as a language and lets us
kind of do whatever we want, but

6505
06:23:59,080 --> 06:24:01,840
it can cause a headache later
on. So if you do run into some

6506
06:24:01,840 --> 06:24:04,870
issues, and you do run into some
bugs, it might be a good idea to

6507
06:24:04,870 --> 06:24:08,380
try TypeScript on for size, and
see how that fares. Well. Let's

6508
06:24:08,380 --> 06:24:11,290
go ahead and begin working on
our local development

6509
06:24:11,290 --> 06:24:14,710
environment and getting set up
to do everything in ethers Jas

6510
06:24:14,710 --> 06:24:17,710
and in JavaScript. Oops. And I
actually went and renamed this

6511
06:24:17,710 --> 06:24:22,750
folder to ether symbol storage
dash, FCC. Reason I added this

6512
06:24:22,750 --> 06:24:26,500
dash FCC is all the GitHub
repositories associated with

6513
06:24:26,500 --> 06:24:30,220
this course, all the GitHub
repos that have this dash FCC to

6514
06:24:30,220 --> 06:24:33,160
know that it is part of this
hard hat JavaScript course.

6515
06:24:33,250 --> 06:24:36,550
Awesome. Let's jump in. Let's
start working with solidity and

6516
06:24:36,550 --> 06:24:39,970
our smart contracts locally in
Visual Studio code, as you can

6517
06:24:39,970 --> 06:24:43,870
probably tell by the name of
this folder. And of course, if

6518
06:24:43,870 --> 06:24:46,960
you looked at the code, this
project is going to be our

6519
06:24:46,960 --> 06:24:51,970
simple storage project, but
developed locally using ethers.

6520
06:24:52,000 --> 06:24:54,820
So the first thing that we want
to do is want to get in that

6521
06:24:54,820 --> 06:24:57,760
smart contract code. So what we
can do is make sure we have the

6522
06:24:57,760 --> 06:25:01,900
Explorer selected, we can go
ahead and right click and select

6523
06:25:01,930 --> 06:25:09,490
new file and do simple storage.
So just close this for now. And

6524
06:25:10,270 --> 06:25:13,060
we can copy paste our simple
storage code from our last

6525
06:25:13,060 --> 06:25:14,350
section into VS code.

6526
06:25:15,670 --> 06:25:18,640
If you closed remix or you
forgot where it is, you can just

6527
06:25:18,640 --> 06:25:23,230
go to the ethers simple storage
FCC repo, it's simple storage

6528
06:25:23,230 --> 06:25:27,760
dot Sol, and we can just copy
all the code in here and then

6529
06:25:27,760 --> 06:25:31,840
come back over select Symbol
storage that Saul and paste it

6530
06:25:31,840 --> 06:25:35,560
in. Now an important note about
Visual Studio code is that when

6531
06:25:35,560 --> 06:25:39,430
you see this little white.up
here, it means that this file

6532
06:25:39,460 --> 06:25:45,610
isn't saved to save your Git
file. To save, and it'll go away

6533
06:25:45,610 --> 06:25:50,680
like that. Or what you can do is
you can hit command S or Ctrl S,

6534
06:25:51,340 --> 06:25:55,840
depending on if you're on a
Windows, Mac, or Linux. Now

6535
06:25:55,840 --> 06:25:58,540
you'll see here that this code
is a little bit hard to read the

6536
06:25:58,540 --> 06:26:01,660
simple storage dot salt, it
doesn't have the syntax

6537
06:26:01,660 --> 06:26:04,420
highlighting that we saw in
remix. So we want to go ahead

6538
06:26:04,420 --> 06:26:08,830
and add a Visual Studio Code
extension to give this syntax

6539
06:26:08,830 --> 06:26:11,830
highlighting. So what we can do
is come over to this bar over

6540
06:26:11,830 --> 06:26:14,830
here looks like this. And if you
don't see it on the left hand

6541
06:26:14,830 --> 06:26:17,560
bar, you should click these
three dots, and it should be in

6542
06:26:17,560 --> 06:26:20,950
here. But we'll go ahead and
click Extensions. And what we're

6543
06:26:20,950 --> 06:26:27,010
going to do is we're going to
look up, solidity plus hard hat.

6544
06:26:27,790 --> 06:26:30,940
And we're going to install this
solidity plus hard hat

6545
06:26:30,940 --> 06:26:35,080
extension. For VS code. Now that
we have this installed, if we go

6546
06:26:35,080 --> 06:26:38,830
back over to our simple storage
dot sole, you'll see that all

6547
06:26:38,830 --> 06:26:42,670
the highlighting is back in. And
now it's much easier to read.

6548
06:26:42,850 --> 06:26:45,220
Right? So this is good. We have
our code in here we have our

6549
06:26:45,220 --> 06:26:49,570
syntax highlighting. Now let's
add an auto format or or default

6550
06:26:49,570 --> 06:26:52,810
format or right now our code is
pretty good with the way that

6551
06:26:52,810 --> 06:26:57,730
it's formatted. But what if we,
we accidentally do some stuff

6552
06:26:57,730 --> 06:27:05,170
like this or like this, or maybe
even like this, we add a ton of

6553
06:27:05,170 --> 06:27:08,830
new lines, etc, our code can
start to look pretty gross. And

6554
06:27:08,830 --> 06:27:12,610
even though the code itself is
fine, and it'll run the exact

6555
06:27:12,610 --> 06:27:15,760
same way, with all this extra
whitespace, it doesn't look very

6556
06:27:15,760 --> 06:27:18,520
good, right. And due to that, it
can be a little bit hard to

6557
06:27:18,520 --> 06:27:22,660
read. What we want to do, then,
we want to open up our settings

6558
06:27:22,720 --> 06:27:26,230
and adjust our vias code so that
it auto formats whenever we

6559
06:27:26,230 --> 06:27:30,580
save, so whenever we save, so
that whenever it goes from the

6560
06:27:30,580 --> 06:27:34,120
little white dot here to no
white dot, this whole thing gets

6561
06:27:34,150 --> 06:27:38,740
automatically formatted to some
looks really nice. Okay. So what

6562
06:27:38,740 --> 06:27:42,970
we can do is we can open up our
command palette to open up our

6563
06:27:42,970 --> 06:27:46,930
command palette, you can hit
View command palette, and we'll

6564
06:27:46,930 --> 06:27:50,050
get a little pop up that looks
like this. Another way to open

6565
06:27:50,050 --> 06:27:52,870
up your command palette is
you're gonna hit Command, Shift

6566
06:27:52,900 --> 06:27:57,040
P, or Ctrl, Shift P, depending
on your Mac, or Linux or

6567
06:27:57,040 --> 06:28:00,370
Windows. And what we want to do
is we want to type in settings,

6568
06:28:00,400 --> 06:28:03,490
and we're going to open Settings
JSON, we don't want to open the

6569
06:28:03,490 --> 06:28:07,690
default settings JSON. We don't
want to touch these. But we want

6570
06:28:07,690 --> 06:28:10,360
to open our JSON settings.
You'll also notice there are

6571
06:28:10,360 --> 06:28:13,720
user settings and workspace
settings. These are pieces that

6572
06:28:13,720 --> 06:28:16,960
we can adjust as well. But we're
going to just go right into the

6573
06:28:16,960 --> 06:28:20,470
JSON settings. So So I already
have some stuff in here, but

6574
06:28:20,470 --> 06:28:23,500
yours might be blank. Or you
might have some stuff in here as

6575
06:28:23,500 --> 06:28:25,750
well. So what we're going to do
is if you have stuff in here

6576
06:28:25,750 --> 06:28:29,320
already, we're going to add a
comma, then we're going to do

6577
06:28:29,350 --> 06:28:36,820
quotes, solidity. Close the
brackets, we're gonna do a

6578
06:28:36,820 --> 06:28:39,610
little colon and something like
this. This means that we're

6579
06:28:39,610 --> 06:28:43,000
going to apply some settings to
our Visual Studio Code. Whenever

6580
06:28:43,000 --> 06:28:45,790
we're working with solidity, one
of the things we're going to add

6581
06:28:45,790 --> 06:28:50,260
in here is going to be an
editor, Doc's default, for

6582
06:28:50,260 --> 06:28:55,660
matter. And you might even get a
pop up that tells you some

6583
06:28:55,660 --> 06:28:58,570
different things that we can use
for a default format or our

6584
06:28:58,570 --> 06:29:03,670
default format, or is going to
be Nanak, foundation, dot hard

6585
06:29:03,670 --> 06:29:09,070
hat, hyphens solidity. This will
mean that any time we go to

6586
06:29:09,070 --> 06:29:13,660
format our code, it'll use the
hard hat solidity plug in, as

6587
06:29:13,660 --> 06:29:18,160
its default format, or the hard
hat solidity plugin comes with

6588
06:29:18,190 --> 06:29:22,810
some formatting, and a lot of
other really useful tools for us

6589
06:29:22,810 --> 06:29:26,080
writing our code. So now that we
have this part in, the next

6590
06:29:26,080 --> 06:29:29,530
thing we're going to do is add
format on Save. If we haven't

6591
06:29:29,530 --> 06:29:33,370
already, we could add it in here
in our JSON, but I'm going to

6592
06:29:33,370 --> 06:29:36,760
add it not in the JSON file, I'm
going to add it in the overall

6593
06:29:36,760 --> 06:29:40,930
file. So if we open that command
palette back up, and we type in

6594
06:29:40,930 --> 06:29:45,280
settings, open user settings,
this is another really good

6595
06:29:45,280 --> 06:29:48,940
place where we can look in add
settings with the UI. So these

6596
06:29:48,940 --> 06:29:51,790
two do essentially the same
thing. It's just that this one

6597
06:29:51,790 --> 06:29:54,730
has dials and a little bit more
context versus settings that

6598
06:29:54,730 --> 06:29:57,850
JSON just says Okay, give me the
raw code for it. This tells us a

6599
06:29:57,850 --> 06:30:00,220
little bit more. So you can use
either one. But we're going to

6600
06:30:00,220 --> 06:30:05,350
look for format, on save. And
you're going to want this

6601
06:30:05,380 --> 06:30:09,040
checked if you haven't already.
This means that every time we

6602
06:30:09,040 --> 06:30:14,020
save VS code is going to try to
format our code for us. So now

6603
06:30:14,020 --> 06:30:16,960
that we have this checked, we
have settings dot JSON added in.

6604
06:30:16,960 --> 06:30:19,270
And remember, we want to save
this. Remember, if you see this

6605
06:30:19,270 --> 06:30:21,730
white dot, that means not saved.
So you're gonna want to save it

6606
06:30:22,600 --> 06:30:25,990
and close it out. Let me close
this out too. If we come back in

6607
06:30:25,990 --> 06:30:28,870
here and we add a bunch of
random new spaces or whatever,

6608
06:30:28,870 --> 06:30:31,390
you want to make it look a
little bit ugly, and then we

6609
06:30:31,390 --> 06:30:36,550
save it. It should automatically
reformat to look much nicer,

6610
06:30:36,580 --> 06:30:40,180
right. So if we do something
like this, we'd save it

6611
06:30:40,180 --> 06:30:43,030
reformats it to look much nicer
this one make them more readable

6612
06:30:43,030 --> 06:30:46,240
for you, and more readable for
anybody else who looks at your

6613
06:30:46,240 --> 06:30:50,650
code. And it's just really nice.
And this line of code for your

6614
06:30:50,650 --> 06:30:54,040
settings dot JSON is located in
the full blockchain study

6615
06:30:54,040 --> 06:30:57,340
course.js. So you can also just
copy paste it, we are going to

6616
06:30:57,340 --> 06:31:01,870
end up overriding that default
format or with another format

6617
06:31:01,870 --> 06:31:05,770
are called prettier pretty soon.
But it's great to have a default

6618
06:31:05,770 --> 06:31:08,830
format or so that if you don't
feel like adding the prettier

6619
06:31:08,830 --> 06:31:12,130
code sometime in the future, you
can just rely on your default

6620
06:31:12,130 --> 06:31:16,030
formatter. Awesome. While we're
doing formatting, let's also add

6621
06:31:16,030 --> 06:31:19,480
a default format or for our
JavaScript code. And just to

6622
06:31:19,480 --> 06:31:22,480
test it out, let's go ahead and
create our new file, we'll call

6623
06:31:22,480 --> 06:31:27,550
it deploy dot Jas. And in here,
we can do something like

6624
06:31:28,120 --> 06:31:29,470
function Hi,

6625
06:31:30,910 --> 06:31:37,630
console dot log, hi, and then
just add and then just make it

6626
06:31:37,630 --> 06:31:40,570
look kind of gross, maybe
something like this. If you hit

6627
06:31:40,570 --> 06:31:43,990
save, and it does some auto
formatting, that's great, you

6628
06:31:43,990 --> 06:31:46,390
can actually turn that off by
going back to your command

6629
06:31:46,390 --> 06:31:51,490
palette, and saying, Save
without formatting. And that way

6630
06:31:51,490 --> 06:31:54,190
it will be saved and not
formatted. The way we can add

6631
06:31:54,190 --> 06:31:56,980
some other formatting here is
we're gonna install another

6632
06:31:56,980 --> 06:32:01,330
extension, this one is going to
be called prettier. So we can

6633
06:32:01,330 --> 06:32:04,780
just look up prettier and
extensions here. And you'll want

6634
06:32:04,780 --> 06:32:08,260
to install this prettier code
formatter. So we're gonna go

6635
06:32:08,260 --> 06:32:11,620
ahead and install this. And
great, now it's installed

6636
06:32:11,680 --> 06:32:15,370
prettier is a form is a code
format, or that works for many

6637
06:32:15,370 --> 06:32:18,790
languages like Python,
JavaScript, and even solidity.

6638
06:32:19,000 --> 06:32:22,180
And pretty soon we're going to
use prettier for both JavaScript

6639
06:32:22,270 --> 06:32:25,240
and solidity. But for now, we're
just going to use prettier for

6640
06:32:25,240 --> 06:32:28,600
JavaScript, we can enable this
by opening back up our command

6641
06:32:28,600 --> 06:32:32,740
palette, we'll go to
preferences, open Settings. And

6642
06:32:32,740 --> 06:32:36,550
the same way we added a solidity
section, we're going to add a

6643
06:32:36,550 --> 06:32:41,080
JavaScript section. So we're
going to add a comma here, some

6644
06:32:41,080 --> 06:32:45,850
quotes, brackets, we're going to
type in JavaScript, close that

6645
06:32:46,750 --> 06:32:50,980
colon brackets. And we're going
to do the same thing at the door

6646
06:32:51,010 --> 06:32:58,720
dot default, or matter. Net
we're going to do and then in

6647
06:32:58,720 --> 06:33:04,870
here, we're going to do e s
BENP, that prettier, hyphen VS

6648
06:33:04,870 --> 06:33:08,590
code. And this will make
prettier the default editor for

6649
06:33:08,590 --> 06:33:11,320
JavaScript. Now, like I said,
pretty soon, we're going to have

6650
06:33:11,350 --> 06:33:15,370
prettier override both of these
for solidity and JavaScript. And

6651
06:33:15,370 --> 06:33:18,040
we're going to give prettier
some parameters so that no

6652
06:33:18,040 --> 06:33:21,940
matter who uses your code, they
will always have the exact same

6653
06:33:21,970 --> 06:33:25,000
formatting. But now that we have
prettier in here as the default

6654
06:33:25,000 --> 06:33:28,990
editor, if we come back to
deploy dot j s, and we hit save,

6655
06:33:29,410 --> 06:33:32,710
it should format to look a
little something like this. Now,

6656
06:33:33,100 --> 06:33:36,640
we go ahead and we do something
like this. If we go ahead and do

6657
06:33:36,640 --> 06:33:39,370
something like this, it'll
reformat to look like look like

6658
06:33:39,370 --> 06:33:43,360
that. And then additionally, if
you want to go back to the

6659
06:33:43,360 --> 06:33:47,680
command palette, open user
settings, not in JSON mode, and

6660
06:33:47,680 --> 06:33:52,000
we go to default format, or you
can actually even select the

6661
06:33:52,000 --> 06:33:56,230
default format or for all
languages, if you want to use

6662
06:33:56,230 --> 06:33:59,560
prettier for all formatters.
Feel free to go ahead. Alright,

6663
06:33:59,560 --> 06:34:02,950
great, got our JavaScript
format, or in as well, let's

6664
06:34:02,950 --> 06:34:05,020
start writing some JavaScript
code.

6665
06:34:07,870 --> 06:34:10,750
Awesome. So now that we have our
code in here, it's time for us

6666
06:34:10,750 --> 06:34:14,920
to learn how to actually deploy
our contract using JavaScript.

6667
06:34:15,220 --> 06:34:17,800
This is going to teach us a lot
about transactions and what's

6668
06:34:17,800 --> 06:34:21,160
going on under the hood, and
even what's going on under the

6669
06:34:21,160 --> 06:34:24,820
hood in remix, and remix, we
usually just hit a compile

6670
06:34:24,820 --> 06:34:28,390
button, and then hit a Deploy
button. And that's really it. In

6671
06:34:28,390 --> 06:34:31,120
JavaScript, we're actually going
to create our own functions that

6672
06:34:31,120 --> 06:34:33,910
are going to help us do both of
those. And as I mentioned, this

6673
06:34:33,910 --> 06:34:35,830
is the part of the course we're
going to start working with

6674
06:34:35,830 --> 06:34:39,250
JavaScript, and optionally,
TypeScript if you like. Like I

6675
06:34:39,250 --> 06:34:42,490
said, all of these sections come
with a TypeScript edition as

6676
06:34:42,490 --> 06:34:47,170
well. So let's set up our
deployed out js script to

6677
06:34:47,170 --> 06:34:50,710
actually deploy our simple
storage dot soul. So how can we

6678
06:34:50,740 --> 06:34:53,680
get started here? Well, let's
first learn how to run a script

6679
06:34:53,740 --> 06:34:57,280
using JavaScript and Node J S.
So if you want to do a print

6680
06:34:57,280 --> 06:35:00,580
line, or just print something
out to your terminal, we can do

6681
06:35:00,610 --> 06:35:04,450
something called a console dot
log. And if I do console dot

6682
06:35:04,450 --> 06:35:10,270
log, hi, I hit Save. And I open
up my terminal. I can now run

6683
06:35:10,270 --> 06:35:16,750
Node deploy.js. And it'll print
out high node is how we say hey,

6684
06:35:16,780 --> 06:35:21,280
we want to run this JavaScript
code using Node js. Other

6685
06:35:21,280 --> 06:35:24,400
languages you might be familiar
with, sometimes we'll do Python,

6686
06:35:24,400 --> 06:35:30,280
you know, deployed up py, or
Java, C deploy dot Java, you

6687
06:35:30,280 --> 06:35:34,090
know, etc. But with JavaScript,
since the front end and back end

6688
06:35:34,120 --> 06:35:37,540
JavaScript are different. We run
code on the back end with node.

6689
06:35:37,750 --> 06:35:40,090
And with JavaScript, you can do
a lot of things that you'd see

6690
06:35:40,090 --> 06:35:43,030
in something like solidity with
a little bit looser have a

6691
06:35:43,030 --> 06:35:46,240
structure. If I wanted to create
some variable, I could say let

6692
06:35:46,420 --> 06:35:51,220
variable equals five, this kind
of similar into solidity like

6693
06:35:51,220 --> 06:35:57,640
you and 256, variable equals
five. But in JavaScript, we use

6694
06:35:57,640 --> 06:36:01,690
let or var or const. And then I
can print this out, I can do

6695
06:36:01,690 --> 06:36:08,890
console dot log variable. And I
had saved JavaScript is optional

6696
06:36:08,920 --> 06:36:11,260
on whether or not you actually
want to have semicolons. Here, I

6697
06:36:11,260 --> 06:36:14,380
think prettier, defaults to
putting semicolons. And we'll

6698
06:36:14,380 --> 06:36:17,710
get rid of those in the near
future in your terminal. Once

6699
06:36:17,710 --> 06:36:22,060
you start typing the name of a
file, if you hit tab, it could

6700
06:36:22,090 --> 06:36:26,860
autocomplete the rest of the
file name for you node deploy

6701
06:36:26,860 --> 06:36:31,030
hit Tab, it'll autocomplete and
if we hit enter, now, we get Hi,

6702
06:36:31,090 --> 06:36:34,150
and then we get five. Since this
prints out Hi, and then it

6703
06:36:34,150 --> 06:36:37,810
prints out five. JavaScript
automatically starts with

6704
06:36:37,930 --> 06:36:40,540
whatever code you have at the
top of the file. So it does

6705
06:36:40,540 --> 06:36:43,720
console dot log first and
variable. And then this one as

6706
06:36:43,720 --> 06:36:47,500
well. However, a good practice
is to actually wrap everything

6707
06:36:47,500 --> 06:36:51,220
you want to do in a main
function, and then run that main

6708
06:36:51,220 --> 06:36:55,300
function. But what we could do
is up at the top here, we'd say

6709
06:36:55,300 --> 06:37:01,570
function, mean, add parentheses
and some brackets, a closing

6710
06:37:01,570 --> 06:37:05,290
bracket at the bottom, and hit
save for its auto format. Right

6711
06:37:05,290 --> 06:37:07,750
now, if we run this, nothing
will happen, because we've

6712
06:37:07,750 --> 06:37:11,410
wrapped all of our code in a
main function. So if I run it

6713
06:37:11,410 --> 06:37:15,640
now node deployed to Jess,
nothing happens, because I need

6714
06:37:15,640 --> 06:37:19,180
something to call the main
function. So if I then take

6715
06:37:19,180 --> 06:37:24,220
this, this main function down
here, and I call main, our jobs

6716
06:37:24,220 --> 06:37:26,800
from code is actually going to
say, ah, the first line of the

6717
06:37:26,800 --> 06:37:30,040
script is actually this main
function here. So now if I do

6718
06:37:30,040 --> 06:37:33,970
node deploy dot j, s, it'll run
high and five, which is what we

6719
06:37:33,970 --> 06:37:36,580
want. Now, this is going to be
the setup for most of our

6720
06:37:36,580 --> 06:37:39,610
scripts moving forward,
including the scripts that we

6721
06:37:39,610 --> 06:37:41,830
write, when we get to hard hat,
however, there is going to be

6722
06:37:41,830 --> 06:37:45,580
one major difference. Instead of
regular functions, we're

6723
06:37:45,580 --> 06:37:48,370
actually going to use something
called async functions. And

6724
06:37:48,370 --> 06:37:50,950
we're going to do something
called asynchronous programming

6725
06:37:50,980 --> 06:37:54,250
to do this. Now, if what I say
next is really confusing for you

6726
06:37:54,280 --> 06:37:57,040
don't let it slow you down, feel
free to go ahead and watch that

6727
06:37:57,040 --> 06:38:00,400
JavaScript course to learn more
about this. But I'll also let

6728
06:38:00,400 --> 06:38:03,880
you know, hey, this is an async
function. Here's what we need to

6729
06:38:03,880 --> 06:38:05,290
be aware of when working with
it,

6730
06:38:05,410 --> 06:38:16,660
okay. But I do want to give you
a quick bit background on

6731
06:38:16,660 --> 06:38:19,210
asynchronous programming. So
far, the programming that we've

6732
06:38:19,210 --> 06:38:22,480
done has been synchronous. And
solidity is an example of a

6733
06:38:22,480 --> 06:38:25,210
programming language, that
synchronous, Synchronous means

6734
06:38:25,210 --> 06:38:28,120
it just goes one line after
another. If our code looks like

6735
06:38:28,120 --> 06:38:32,710
this, this is synchronous write,
our main function is the first

6736
06:38:32,710 --> 06:38:36,010
thing that actually gets called.
Then we do console dot log, that

6737
06:38:36,010 --> 06:38:38,650
variable equals five, and then
console dot log. Again, this is

6738
06:38:38,650 --> 06:38:41,470
synchronous programming in
JavaScript, all of our solidity

6739
06:38:41,500 --> 06:38:44,080
is synchronously programmed.
There will be some exceptions to

6740
06:38:44,080 --> 06:38:46,570
this when working with oracles.
But for now, everything is

6741
06:38:46,570 --> 06:38:50,680
synchronous. JavaScript can be
asynchronous, meaning that we

6742
06:38:50,680 --> 06:38:54,460
can actually have code running
at the same time. A good example

6743
06:38:54,460 --> 06:38:58,510
I like to use to understand the
difference is with cooking. In

6744
06:38:58,510 --> 06:39:02,530
synchronous programming, for
cooking, you might put popcorn

6745
06:39:02,560 --> 06:39:08,500
in microwave, wait for popcorn
to finish. And then, and then

6746
06:39:08,500 --> 06:39:11,410
maybe you'll pour drinks for
everyone. And now this is

6747
06:39:11,410 --> 06:39:14,350
synchronous programming. Now, it
might be a little bit weird for

6748
06:39:14,350 --> 06:39:17,110
you just to put the popcorn in
the microwave, and then just

6749
06:39:17,110 --> 06:39:19,900
stare at it, waiting for it to
finish. And then pour the

6750
06:39:19,900 --> 06:39:24,220
drinks, you typically can pour
the drinks while your popcorn is

6751
06:39:24,220 --> 06:39:27,160
in the microwave. And this is
where asynchronous programming

6752
06:39:27,160 --> 06:39:30,280
comes in. If setting up for this
movie night, we're asynchronous,

6753
06:39:30,340 --> 06:39:34,510
what you would do is you'd put
popcorn in the microwave. And

6754
06:39:34,510 --> 06:39:37,990
while the popcorn is in the
microwave, or drinks for

6755
06:39:37,990 --> 06:39:42,910
everyone, and then you'd wait
for popcorn finish, since

6756
06:39:42,910 --> 06:39:45,310
there's nothing left for you to
do, but it doesn't make sense

6757
06:39:45,310 --> 06:39:48,490
for you to wait for the popcorn
to finish to pour your drinks,

6758
06:39:48,550 --> 06:39:51,400
you can just go ahead and pour
the drinks right away and then

6759
06:39:51,400 --> 06:39:54,280
wait for the popcorn to finish.
So asynchronous programming is

6760
06:39:54,280 --> 06:39:57,430
way for us to do stuff without
waiting around for things to

6761
06:39:57,430 --> 06:40:00,190
finish. And this is really
advantageous in JavaScript by

6762
06:40:00,190 --> 06:40:02,770
default allows us to do this
asynchronous programming,

6763
06:40:02,800 --> 06:40:05,380
however, sometimes we do want to
wait for our popcorn to finish.

6764
06:40:05,410 --> 06:40:09,730
For example, if instead of just
pouring drinks, maybe the next

6765
06:40:09,730 --> 06:40:14,350
thing instead of pouring drinks
was placed salt on popcorn. Of

6766
06:40:14,350 --> 06:40:17,740
course, if we want to play salt
on our popcorn, we do have to

6767
06:40:17,740 --> 06:40:20,620
wait for the popcorn to get out
of the microwave. So even though

6768
06:40:20,620 --> 06:40:24,100
placing popcorn in the microwave
has this wait time we need to be

6769
06:40:24,100 --> 06:40:27,640
able to tell our code I want you
to actually wait for it or No,

6770
06:40:27,640 --> 06:40:31,720
you're good. You can go on and
do another task. So that's kind

6771
06:40:31,720 --> 06:40:34,360
of the difference here. And I'll
leave some links in the GitHub

6772
06:40:34,360 --> 06:40:36,760
repo associated with this course
to understand this a little bit

6773
06:40:36,760 --> 06:40:39,730
better functions that have
functions that come with this

6774
06:40:39,730 --> 06:40:43,450
waiting period return something
called a problem. This, if put

6775
06:40:43,450 --> 06:40:46,330
popcorn in the microwave was a
function in JavaScript, it would

6776
06:40:46,330 --> 06:40:50,620
be a promise based function. A
promise can be either pending,

6777
06:40:51,100 --> 06:40:55,390
fulfilled, or rejected. And this
is how we know if our popcorn is

6778
06:40:55,390 --> 06:40:58,990
done. If our popcorn was a
method, putting popcorn in the

6779
06:40:58,990 --> 06:41:01,930
microwave, were a function in
JavaScript, when we're waiting

6780
06:41:01,930 --> 06:41:04,840
for the popcorn to finish, it's
in a pending state. When it's

6781
06:41:04,870 --> 06:41:08,710
when the popcorn is finished, it
would be fulfilled. And if we

6782
06:41:08,710 --> 06:41:11,740
aborted halfway through, and we
stopped waiting, it would be

6783
06:41:11,770 --> 06:41:14,740
rejected. So putting the popcorn
in the microwave returns a

6784
06:41:14,740 --> 06:41:18,670
promise. With this promise, we
have to tell our code, hey, we

6785
06:41:18,670 --> 06:41:22,180
want you to wait for the popcorn
to finish or you can go ahead

6786
06:41:22,180 --> 06:41:24,610
and you can just keep doing
stuff. So let's put this all

6787
06:41:24,610 --> 06:41:27,970
together with some JavaScript
syntax here. Let's say again,

6788
06:41:27,970 --> 06:41:30,670
we're going to be setting up
this movie night. And we need to

6789
06:41:30,700 --> 06:41:34,090
cook popcorn, pour drinks for
everybody. And then we need to

6790
06:41:34,090 --> 06:41:37,300
start a movie. So let's write
some pseudocode to pretend what

6791
06:41:37,300 --> 06:41:40,240
this code would look like if
this was actually a function. So

6792
06:41:40,270 --> 06:41:45,580
we create some function called
setup, Movie Night. And in here,

6793
06:41:45,610 --> 06:41:48,070
we would say okay, what's the
first thing we need to do? Okay,

6794
06:41:48,070 --> 06:41:50,260
we need to cook popcorn. So
let's say we have some cook

6795
06:41:50,260 --> 06:41:54,100
popcorn function. So we'll say,
okay, cook popcorn, then the

6796
06:41:54,100 --> 06:41:55,930
next thing we're gonna have to
do is we're gonna have to pour

6797
06:41:55,930 --> 06:42:00,430
drinks, or drink. So we'll call
some pour drinks function. Now

6798
06:42:00,430 --> 06:42:03,640
here's the thing, we only want
to start the movie once our

6799
06:42:03,640 --> 06:42:07,690
popcorn has been cooked. And
once our drinks have been

6800
06:42:07,720 --> 06:42:11,560
poured, so if either one of
these returned a promise, so if

6801
06:42:11,590 --> 06:42:14,680
either one of these returns a
promise, like cook popcorn, for

6802
06:42:14,680 --> 06:42:18,550
example, we would need to tell
our code here to actually wait

6803
06:42:18,730 --> 06:42:21,580
for the popcorn to finish
because cook popcorn is going to

6804
06:42:21,580 --> 06:42:25,840
be a function where we could say
let status equals cook popcorn.

6805
06:42:25,900 --> 06:42:29,710
And while the popcorn is being
cooked, the status is going to

6806
06:42:29,710 --> 06:42:33,250
be ending. Once the popcorn gets
cooked, it'll be fulfilled. If

6807
06:42:33,250 --> 06:42:35,890
the popcorn breaks, the
microwave explodes, the status

6808
06:42:35,890 --> 06:42:39,130
would be rejected. But we don't
want the status to be in a

6809
06:42:39,130 --> 06:42:42,430
pending situation. Before we
move on, we only want to start

6810
06:42:42,430 --> 06:42:45,580
our movie once these two
functions have completed. And

6811
06:42:45,580 --> 06:42:48,700
let's say both of these return
these promises things. So we

6812
06:42:48,700 --> 06:42:52,630
need to tell our code, hey, you
have to wait. Or you have to

6813
06:42:52,630 --> 06:42:56,050
wait for cook popcorn and for
poor drinks to finish. So what

6814
06:42:56,050 --> 06:42:59,050
we can do now without getting
too deep into the weeds on how

6815
06:42:59,050 --> 06:43:01,840
all this works, one of the
easiest things that we can do

6816
06:43:01,840 --> 06:43:04,630
and you'll see us use this
syntax quite often is we'll turn

6817
06:43:04,630 --> 06:43:08,470
this function into an async
function. When our functions are

6818
06:43:08,500 --> 06:43:12,790
async, we get access to a
keyword called await the await

6819
06:43:12,790 --> 06:43:17,680
keyword tells any promise based
function to wait for that

6820
06:43:17,680 --> 06:43:20,530
promise to be fulfilled or
rejected. So we say okay, we

6821
06:43:20,530 --> 06:43:24,520
want to await for our popcorn to
cook. And then we want to await

6822
06:43:24,550 --> 06:43:27,280
to pour drinks. And then we can
just go ahead and start the

6823
06:43:27,280 --> 06:43:31,240
movie. And we only start the
movie here once these two have

6824
06:43:31,270 --> 06:43:34,450
been completed. And this is why
throughout all of our code,

6825
06:43:34,450 --> 06:43:37,330
you'll see this await keyword
used a lot. But it can only be

6826
06:43:37,330 --> 06:43:40,600
used in async functions. So
basically, whenever you see this

6827
06:43:40,600 --> 06:43:44,230
await keyword just now Ah, okay,
the function that's being called

6828
06:43:44,260 --> 06:43:47,980
is promise based. And we don't
want to move on to the next step

6829
06:43:48,010 --> 06:43:50,980
until that function has
completed. So that's a little

6830
06:43:50,980 --> 06:43:53,590
bit more about promises and
asynchronous programming.

6831
06:43:53,620 --> 06:43:56,410
Hopefully, that's clear. If not,
like I said, there's some links

6832
06:43:56,410 --> 06:43:58,840
in the description to learn more
about asynchronous programming.

6833
06:43:59,050 --> 06:44:01,570
The reason I wanted to go
through this is because most of

6834
06:44:01,570 --> 06:44:03,460
the functions that we're going
to be working with are going to

6835
06:44:03,460 --> 06:44:07,810
be asynchronous. For example,
when we deploy a contract, what

6836
06:44:07,810 --> 06:44:13,240
do we have to do? Well, we have
to wait for it to be deployed.

6837
06:44:14,200 --> 06:44:16,840
If we don't use synchronous
programming, and we just leave

6838
06:44:16,840 --> 06:44:20,530
our function main like this,
what would happen is we would

6839
06:44:20,530 --> 06:44:24,610
write some code like contract
dot deploy, and we wouldn't wait

6840
06:44:24,700 --> 06:44:29,620
for it to finish. Obviously, if
we don't wait for it to finish,

6841
06:44:29,710 --> 06:44:32,500
and we try to run some code on a
contract that hasn't finished

6842
06:44:32,500 --> 06:44:35,110
deploying it, it's not going to
work. So we want to do this, we

6843
06:44:35,110 --> 06:44:38,740
want to have our main function
be an async function, so that we

6844
06:44:38,740 --> 06:44:42,010
can we can wait for our
contracts to deploy, we can wait

6845
06:44:42,010 --> 06:44:45,310
for things to happen, we can
wait for our popcorn to finish,

6846
06:44:45,340 --> 06:44:48,550
we can have the flexibility to
tell our code to either wait for

6847
06:44:48,550 --> 06:44:51,400
our popcorn to finish or
continue on. So now that we have

6848
06:44:51,400 --> 06:44:54,970
our main function as an async
function, we're going to add

6849
06:44:54,970 --> 06:44:57,460
some code to our main function
down here. And the code that's

6850
06:44:57,460 --> 06:45:00,040
added here is some syntax for
working with asynchronous

6851
06:45:00,040 --> 06:45:02,590
functions. And if this part is
confusing, I'm just going to say

6852
06:45:02,590 --> 06:45:05,170
for now, absolute, don't worry
about this. If you want to try

6853
06:45:05,170 --> 06:45:07,750
to understand that later. That's
fine. But for those who are

6854
06:45:07,750 --> 06:45:09,580
following along, we're just
going to add an add

6855
06:45:09,610 --> 06:45:25,360
then catch air air you can
follow along typing this

6856
06:45:25,360 --> 06:45:28,300
yourself or you can just copy
paste it into your code.

6857
06:45:28,420 --> 06:45:31,900
Basically what this allows us to
do is we have our main function,

6858
06:45:31,930 --> 06:45:34,630
that's an asynchronous function.
So when we call the main

6859
06:45:34,630 --> 06:45:37,840
function, this is some other
syntax for waiting for it to

6860
06:45:38,020 --> 06:45:41,020
basically finish and then
printing any errors it gets. And

6861
06:45:41,020 --> 06:45:44,980
that's why we do this but Again,
if this big lump of code, if

6862
06:45:44,980 --> 06:45:46,690
you're like what is going on
with this big clump of code,

6863
06:45:46,720 --> 06:45:49,180
honestly, for now, just copy
paste it. So great. We have our

6864
06:45:49,180 --> 06:45:52,690
asynchronous function main, we
have some code. And then we have

6865
06:45:52,780 --> 06:45:55,840
this lump of code, which
basically just calls our main

6866
06:45:55,870 --> 06:45:58,690
asynchronous function. Okay,
great. I'm gonna delete all this

6867
06:45:58,690 --> 06:46:01,810
for now. But you can still find
that common in the GitHub repo

6868
06:46:01,840 --> 06:46:04,960
associated with this course.
Awesome. Okay, so now that we

6869
06:46:04,960 --> 06:46:07,990
have our real basic setup, let's
go ahead and start coding. And

6870
06:46:08,020 --> 06:46:11,110
if this set apart is confusing,
and the async await stuff is

6871
06:46:11,110 --> 06:46:14,020
confusing, don't worry too much
about it. It'll make more sense

6872
06:46:14,020 --> 06:46:19,840
as we progress. All of our code
basically is going to be inside

6873
06:46:19,840 --> 06:46:22,270
of this async function main,
which is going to be our main

6874
06:46:22,270 --> 06:46:25,900
script for deploying our simple
storage dot soul store deploy

6875
06:46:25,900 --> 06:46:29,350
script is going to replicate
exactly what goes on in remix,

6876
06:46:29,410 --> 06:46:32,320
in remix, what was the first
thing that we always did? Well,

6877
06:46:32,320 --> 06:46:35,830
the first thing that we would do
is actually compile all of our

6878
06:46:35,830 --> 06:46:38,860
code. So we're going to want to
compile our code in our

6879
06:46:38,860 --> 06:46:42,040
JavaScript project as well. In
order for us to compile our

6880
06:46:42,040 --> 06:46:45,520
simple storage contract, we're
going to use a tool called Silk

6881
06:46:45,550 --> 06:46:48,670
Jas, and JavaScript actually has
a way to install projects

6882
06:46:48,670 --> 06:46:52,090
directly into our setups and
into our folders. If we scroll

6883
06:46:52,090 --> 06:46:55,450
down this silk Jas is exactly
what we're looking for. Because

6884
06:46:55,450 --> 06:46:58,390
it has a way to compile a
contract that imports other

6885
06:46:58,390 --> 06:47:02,620
contracts via relative paths,
you can see a section in this

6886
06:47:02,620 --> 06:47:05,080
readme and most documentation
will have something like this,

6887
06:47:05,110 --> 06:47:09,220
if it's JavaScript compatible.
For Node js usage, it says to

6888
06:47:09,220 --> 06:47:11,980
use the latest stable version of
the solidity compiler via Node

6889
06:47:11,980 --> 06:47:17,860
js, you can install it via NPM
npm install. So NPM is what's

6890
06:47:17,860 --> 06:47:22,330
known as a package manager. And
we actually installed NPM just

6891
06:47:22,330 --> 06:47:26,650
by installing no Jess, right, if
we do no dash dash version, you

6892
06:47:26,650 --> 06:47:30,700
should also be able to do NPM
dash dash version. Another tool

6893
06:47:30,700 --> 06:47:33,310
that it comes with is something
called core pack. And you can

6894
06:47:33,310 --> 06:47:36,730
type core pack dash dash
version, now we can install with

6895
06:47:36,730 --> 06:47:40,990
NPM using npm install silk,
however, I like the yarn package

6896
06:47:40,990 --> 06:47:44,590
manager a little bit better. So
we're actually going to install

6897
06:47:44,620 --> 06:47:47,950
the yarn package manager instead
to do all of our package

6898
06:47:47,950 --> 06:47:51,190
management. If you go to the
installation page, the newer way

6899
06:47:51,190 --> 06:47:54,610
to install yarn is just by
running core pack enable. And

6900
06:47:54,640 --> 06:47:58,390
the older way is to install with
NPM. If you go ahead and run

6901
06:47:58,420 --> 06:48:01,600
core pack enable after that
finishes, you should be able to

6902
06:48:01,600 --> 06:48:07,150
run yarn dash dash version.
Alternatively, you can just run

6903
06:48:07,210 --> 06:48:12,850
NPM i dash g core pack, and then
you can run core pack enable.

6904
06:48:13,000 --> 06:48:17,440
The last option you have is you
can run NPM i dash g

6905
06:48:17,860 --> 06:48:21,850
yarn. This will install yarn
globally for your system. But

6906
06:48:21,850 --> 06:48:25,720
this is considered the outdated
way to install yarn. And ideally

6907
06:48:25,720 --> 06:48:29,560
you run core pack enable. But in
any case, after you run those,

6908
06:48:29,590 --> 06:48:31,960
if you run yarn dash dash
version, you should get

6909
06:48:31,960 --> 06:48:35,380
something that looks like this.
Now that we have yarn, we can

6910
06:48:35,380 --> 06:48:39,580
actually use yarn to install all
of our projects, instead of NPM.

6911
06:48:39,940 --> 06:48:44,440
Back in silk Jas where it says
npm install soak, we can do the

6912
06:48:44,440 --> 06:48:48,550
yarn equivalents of NPM install
sock, which is going to be yarn,

6913
06:48:49,240 --> 06:48:55,330
add sock, this will actually go
ahead and install solc to our

6914
06:48:55,330 --> 06:48:58,990
project. If we open up our
folders, you'll actually see

6915
06:48:59,020 --> 06:49:01,930
that this added a couple of
different folders, it first

6916
06:49:01,930 --> 06:49:06,010
added a package dot JSON package
dot JSON is a file that tells us

6917
06:49:06,040 --> 06:49:09,610
a lot about our project and the
dependencies that it works with.

6918
06:49:09,640 --> 06:49:14,920
For example, we've installed the
soap package of 0.8 point 13.

6919
06:49:15,130 --> 06:49:18,880
Our yarn dot lock tells us the
exact version of all the

6920
06:49:18,880 --> 06:49:22,840
different packages of our
project. For example, the reason

6921
06:49:22,840 --> 06:49:25,840
this is so important too, is
solc has a ton of dependencies

6922
06:49:25,840 --> 06:49:29,800
as well. So yarn dot lock tells
us exactly what version of solc

6923
06:49:30,010 --> 06:49:32,380
and all the different
dependencies of solchen. Any

6924
06:49:32,380 --> 06:49:36,310
other project that we add. This
is autogenerated file, don't

6925
06:49:36,340 --> 06:49:39,910
edit the file directly. The
final bit is we got this node

6926
06:49:39,910 --> 06:49:43,960
modules folder. This node
modules folder is going to be

6927
06:49:44,020 --> 06:49:47,950
where all the installed code
that we just downloaded is, for

6928
06:49:47,950 --> 06:49:51,010
example, if we look at node
modules, we can see there's a

6929
06:49:51,010 --> 06:49:55,570
sock folder. And inside this
sock folder is all the code

6930
06:49:55,600 --> 06:49:59,290
associated with this soap
package that we just installed.

6931
06:49:59,350 --> 06:50:03,370
And since we're working with
zero point 8.7 of slowly, we

6932
06:50:03,370 --> 06:50:06,670
actually want to install that
specific version. So we're going

6933
06:50:06,670 --> 06:50:17,230
to do yarn add solc at zero
point 8.7 Dash fixed and you'll

6934
06:50:17,230 --> 06:50:21,910
see in our package dot JSON you
can now see zero point 8.7 Dash

6935
06:50:21,910 --> 06:50:25,780
fixed in our dependencies
section for sulk. Normally you

6936
06:50:25,780 --> 06:50:29,530
can just add your salt version
like yarn add zero point 8.7 But

6937
06:50:29,530 --> 06:50:33,100
there was an issue with zero
point 8.7 So we had to do zero

6938
06:50:33,460 --> 06:50:35,140
point 8.7 Dash fixed.

6939
06:50:36,430 --> 06:50:38,200
You can find the different
releases and the different

6940
06:50:38,200 --> 06:50:41,740
versions if you go to sulk Jas
releases and then to tags

6941
06:50:42,940 --> 06:50:45,730
Alright, great. Now that we have
sold, we have the ability to

6942
06:50:45,730 --> 06:50:50,590
actually compile our contracts,
we could either compile them in

6943
06:50:50,590 --> 06:50:54,190
our code and have it
automatically run whenever we

6944
06:50:54,190 --> 06:51:00,130
hit Deploy, or, or we could
compile them separately. If you

6945
06:51:00,130 --> 06:51:03,310
want to go back after this
section is an example in the

6946
06:51:03,310 --> 06:51:07,120
sculpt Jas repository that shows
you how to actually compile silk

6947
06:51:07,150 --> 06:51:09,790
right in your code. We are
actually going to compile them

6948
06:51:09,790 --> 06:51:14,020
separately using a soap Jas
command. The yarn command is

6949
06:51:14,020 --> 06:51:17,740
both used to install
dependencies and it can be used

6950
06:51:17,770 --> 06:51:21,910
to run scripts. If you go to
sulk Jas and you scroll down, it

6951
06:51:21,910 --> 06:51:24,370
says in order to use the command
line, you actually need to

6952
06:51:24,370 --> 06:51:27,580
install it globally. If you want
to install this globally using

6953
06:51:27,580 --> 06:51:33,250
yarn Global Add solc at zero
point 8.7 Dash fixed you can

6954
06:51:33,250 --> 06:51:36,850
absolutely go ahead. However,
since we're inside of this

6955
06:51:36,850 --> 06:51:40,450
folder here, which has the yarn
dot lock the package json and

6956
06:51:40,450 --> 06:51:44,230
the node modules yarn will be
smart enough to know i You're

6957
06:51:44,230 --> 06:51:48,250
looking for the soak in this
folder. So we can actually go

6958
06:51:48,250 --> 06:51:52,300
ahead and compile our contract
using yarn and solc Jess if you

6959
06:51:52,300 --> 06:51:55,540
want to see all the different
commands soak Jas allows we can

6960
06:51:55,540 --> 06:52:00,970
just run yarn. So Jas dash dash
help, and you'll see it'll spit

6961
06:52:00,970 --> 06:52:06,340
out a list of all the different
options that soft Jas has. You

6962
06:52:06,340 --> 06:52:11,200
can also run yarn, so Jas dash
dash version to just make sure

6963
06:52:11,200 --> 06:52:14,200
that we're on the correct
version, which is indeed zero

6964
06:52:14,740 --> 06:52:18,130
point 8.7. Now to actually
compile our simple storage at

6965
06:52:18,130 --> 06:52:23,710
soul, let's run the compliation
command we will run yarn, so J

6966
06:52:23,710 --> 06:52:29,380
S, dash dash bin since we want
the binary dash dash ABI since

6967
06:52:29,380 --> 06:52:37,090
we also want the ABI dash dash
include path node modules. Since

6968
06:52:37,150 --> 06:52:41,290
we want to include any contracts
or files in our node modules, we

6969
06:52:41,290 --> 06:52:43,870
aren't using any for this
project, but in the future, you

6970
06:52:43,870 --> 06:52:46,870
will need to include this dash
dash include path node modules

6971
06:52:47,530 --> 06:52:52,330
do dash dash base path of
period, this period means that

6972
06:52:52,330 --> 06:52:56,260
the base path is going to be
this folder dash O period, which

6973
06:52:56,260 --> 06:53:00,640
means we're going to output the
compiled binary and ABI to this

6974
06:53:00,670 --> 06:53:05,410
folder. And then finally, simple
storage dot soul. Since this is

6975
06:53:05,410 --> 06:53:08,680
the contract that we want to
compile, auto completed it from

6976
06:53:08,680 --> 06:53:11,770
simple storage to simple
storage. So by typing simple,

6977
06:53:12,520 --> 06:53:15,310
and then hitting Tab, but let's
go ahead and hit enter, you'll

6978
06:53:15,310 --> 06:53:19,870
see it's running this command to
compile this contract. And

6979
06:53:19,870 --> 06:53:24,370
you'll see two files get output.
One called Simple Storage soul

6980
06:53:24,400 --> 06:53:27,850
underscore simple storage that
API in simple storage Sol

6981
06:53:27,880 --> 06:53:31,660
underscore simple storage dot
bin, the ABI is obviously the

6982
06:53:31,660 --> 06:53:35,920
ABI of this contract, which will
need in the future. And then the

6983
06:53:35,920 --> 06:53:39,670
bin is going to be the binary,
or the really low level of this

6984
06:53:39,670 --> 06:53:42,520
code back and remix. If you
compile simple storage, that

6985
06:53:42,520 --> 06:53:46,570
soul, you can actually look at
compliation details, like the

6986
06:53:46,570 --> 06:53:51,850
ABI which we just got, or the
bytecode, which if you look at

6987
06:53:51,850 --> 06:53:59,080
this object 60806 That's the
same as the binary here 60806.

6988
06:53:59,110 --> 06:54:02,140
Alright, great. So now we've
compiled our contracts here.

6989
06:54:02,320 --> 06:54:05,890
Now, obviously, now if you hit
up on your keyboard, you can

6990
06:54:05,890 --> 06:54:09,640
actually cycle through your most
recent terminal commands. And if

6991
06:54:09,640 --> 06:54:12,520
you hit up enough, we can see
this command that we just ran

6992
06:54:12,550 --> 06:54:15,580
typing this out or hitting up a
whole bunch every single time,

6993
06:54:15,790 --> 06:54:18,820
it's going to be really annoying
to do anytime we want to

6994
06:54:18,850 --> 06:54:22,840
recompile. So what we can do is
we can add a script section in

6995
06:54:22,840 --> 06:54:26,680
our package dot JSON to shorten
some yarn scripts for us. So

6996
06:54:26,680 --> 06:54:29,530
what we'll do is back in our
package, dot JSON, a lot of

6997
06:54:29,530 --> 06:54:33,970
comma, and we'll add a section
called scripts, add the colon

6998
06:54:34,000 --> 06:54:37,000
and the brackets. And in here,
we'll say anytime we say

6999
06:54:37,000 --> 06:54:42,340
compile, we will run this long
command. So I'd compile we'll

7000
06:54:42,340 --> 06:54:46,390
put some quotes. And we'll paste
that in there. So now instead of

7001
06:54:46,390 --> 06:54:49,660
typing that whole thing out, as
long as we're in the same folder

7002
06:54:49,660 --> 06:54:54,340
that our package json is in, we
can run yarn compile. And this

7003
06:54:54,340 --> 06:54:57,880
will run that whole script for
us without us having to type the

7004
06:54:57,880 --> 06:55:00,550
whole thing out scripts are a
really useful way to make it

7005
06:55:00,580 --> 06:55:03,760
easier for us to run long
commands. All right, great. Now

7006
06:55:03,760 --> 06:55:07,270
we have our code compiled, this
is going to be equivalent to US

7007
06:55:07,270 --> 06:55:10,300
hitting this compile button for
us to actually go ahead and

7008
06:55:10,300 --> 06:55:10,780
deploy.

7009
06:55:13,570 --> 06:55:16,060
So now we have our simple
storage. That's all compiled,

7010
06:55:16,330 --> 06:55:19,750
let's learn how we can actually
deploy this thing. Remember, in

7011
06:55:19,750 --> 06:55:22,780
remix, we actually deployed it
to one of two different places,

7012
06:55:22,900 --> 06:55:27,250
we deployed it to either a
JavaScript VM, or with our

7013
06:55:27,250 --> 06:55:31,180
injected web three, with our
Metamask. Let's learn first ad,

7014
06:55:31,180 --> 06:55:34,450
do the JavaScript VM. And then
we'll learn how to use the

7015
06:55:34,450 --> 06:55:38,410
injected web three, or a meta
mask or some connection to an

7016
06:55:38,410 --> 06:55:41,530
actual test net. So in order to
deploy this to a JavaScript

7017
06:55:41,530 --> 06:55:44,710
virtual invite I'm in or kind of
a fake blockchain, we're gonna

7018
06:55:44,710 --> 06:55:48,190
need to get a fake blockchain.
Now in the future, we're going

7019
06:55:48,190 --> 06:55:51,550
to be using the Hardhead runtime
environment as our JavaScript

7020
06:55:51,550 --> 06:55:55,810
virtual machine or aka our fake
blockchain. But for this

7021
06:55:55,810 --> 06:55:59,440
section, I want us to use a tool
called ganache. There's a link

7022
06:55:59,440 --> 06:56:02,320
to this in the GitHub
repository. Ganache is similar

7023
06:56:02,320 --> 06:56:06,220
to a virtual machine in remix.
It's a fake blockchain that we

7024
06:56:06,220 --> 06:56:10,390
can run locally to actually
test, deploy and run code. It's

7025
06:56:10,390 --> 06:56:14,200
also a nice way to see things
that are going on in a

7026
06:56:14,200 --> 06:56:17,500
blockchain. Let's go ahead and
spin up the ganache application

7027
06:56:17,500 --> 06:56:20,320
after you install it, the
ganache application will look a

7028
06:56:20,320 --> 06:56:24,220
little something like this. And
to spin up a fake blockchain

7029
06:56:24,220 --> 06:56:28,150
really quickly, you can just go
ahead and click Quickstart. This

7030
06:56:28,150 --> 06:56:31,390
will spin up a fake blockchain
that's running locally on your

7031
06:56:31,390 --> 06:56:35,170
computer right here, which is
fantastic. It comes with a whole

7032
06:56:35,170 --> 06:56:39,370
bunch of fake accounts exactly
like how remix comes with a ton

7033
06:56:39,370 --> 06:56:42,940
of fake accounts with 100 ether
each ganache comes with a bunch

7034
06:56:42,940 --> 06:56:46,750
of fake accounts with 100 ether
each. They also come with the

7035
06:56:46,750 --> 06:56:50,770
private keys that we can use in
our applications to actually

7036
06:56:50,800 --> 06:56:54,310
take control of these fake
accounts. Remember, don't use

7037
06:56:54,310 --> 06:56:56,620
these private keys on a public
blockchain. They're for

7038
06:56:56,620 --> 06:56:59,530
development purposes only
because a lot of people know

7039
06:56:59,530 --> 06:57:02,710
these private keys in our code.
One of the first things that

7040
06:57:02,710 --> 06:57:05,440
we're going to need to do is
actually connect to our

7041
06:57:05,440 --> 06:57:09,100
blockchain remix does this a
little bit behind the scenes, if

7042
06:57:09,100 --> 06:57:12,160
we're choosing JavaScript
virtual machine remix chooses

7043
06:57:12,160 --> 06:57:15,760
its own fake blockchain that it
runs. If we choose injected web

7044
06:57:15,760 --> 06:57:19,420
three, as we know, meta mask
pops up, and it connects to our

7045
06:57:19,420 --> 06:57:22,120
meta mask, this connection that
remix does, is actually doing

7046
06:57:22,120 --> 06:57:25,600
something really interesting.
It's not just connecting to our

7047
06:57:25,600 --> 06:57:29,140
meta mask by some magical
powers. It's actually connecting

7048
06:57:29,140 --> 06:57:32,530
to our meta mask, which has a
connection to the blockchain

7049
06:57:32,560 --> 06:57:36,040
behind the scenes. If you open
up your meta mask, and you go

7050
06:57:36,040 --> 06:57:39,580
down to you select the networks
and you select ad networks,

7051
06:57:40,000 --> 06:57:43,570
you'll get popped up into a UI
that looks like this. If we go

7052
06:57:43,570 --> 06:57:47,530
back and hit select networks
over here, we can actually see

7053
06:57:47,650 --> 06:57:50,290
information about these
different networks. One of the

7054
06:57:50,290 --> 06:57:53,230
main things that we can see is
that all these networks have

7055
06:57:53,260 --> 06:57:58,480
something called an RPC URL. RPC
stands for remote procedure

7056
06:57:58,480 --> 06:58:03,820
call. And then URL is uniform
resource locator. This RPC URL

7057
06:58:04,030 --> 06:58:07,750
stands for a connection to a
blockchain node that somebody is

7058
06:58:07,750 --> 06:58:12,370
running this this URL connects
us to make API calls and to

7059
06:58:12,370 --> 06:58:15,790
interact with a blockchain node.
Blockchain nodes run with

7060
06:58:15,790 --> 06:58:19,810
software, and some of them
expose an API call. If you look

7061
06:58:19,810 --> 06:58:23,590
at the NGO Aetherium website,
there actually are instructions

7062
06:58:23,620 --> 06:58:26,560
for you to run your own
blockchain node for a real

7063
06:58:26,560 --> 06:58:30,370
blockchain like Aetherium. Most
of these have flags like dash

7064
06:58:30,370 --> 06:58:36,250
HTTP dot ADR to expose these RPC
endpoints. So if you ever want

7065
06:58:36,250 --> 06:58:39,430
to run your own node, your own
real blockchain node, instead of

7066
06:58:39,430 --> 06:58:42,250
using meta masks or any other
the providers that we're going

7067
06:58:42,250 --> 06:58:44,410
to go through, you can use go
Aetherium, or whatever

7068
06:58:44,410 --> 06:58:47,080
blockchain you're working with
software to run your own notes.

7069
06:58:47,110 --> 06:58:50,770
But it's this RPC URL that
allows us to connect to Rinkeby,

7070
06:58:50,800 --> 06:58:54,730
if on Rinkeby ropsten, if we're
on ropsten main net if we're on

7071
06:58:54,730 --> 06:58:57,550
Main net, etc. And it's going to
be the way that we're going to

7072
06:58:57,550 --> 06:59:01,210
connect to our ganache
blockchain that we're running

7073
06:59:01,270 --> 06:59:04,660
inside of this application. So
if you look at the top of your

7074
06:59:04,660 --> 06:59:08,710
ganache here, there's a section
called the RPC server. And this

7075
06:59:08,710 --> 06:59:11,830
is the endpoint of our ganache
node right now. So what we can

7076
06:59:11,830 --> 06:59:16,420
do is we can copy this and go
back to our VS code, and paste

7077
06:59:16,420 --> 06:59:20,110
it in here to see if we can
connect instead of HTTP. With

7078
06:59:20,110 --> 06:59:22,240
these capitals, we're gonna have
a B lowercase instead of the

7079
06:59:22,270 --> 06:59:25,270
uppercase, because the lowercase
is more correct, and it looks

7080
06:59:25,270 --> 06:59:27,910
nicer. But now we have the
endpoint. Hypothetically, with

7081
06:59:27,910 --> 06:59:31,870
just this, we can start making
calls and API calls to this

7082
06:59:31,870 --> 06:59:35,740
endpoint, go to this JSON RPC
specification. Again, link will

7083
06:59:35,740 --> 06:59:38,950
be in the GitHub repo, we can
actually see different calls we

7084
06:59:38,950 --> 06:59:42,310
can make directly to our node to
get different information. eath

7085
06:59:42,310 --> 06:59:45,910
get blocked by hash eath get
blocked by number. And all of

7086
06:59:45,910 --> 06:59:49,450
these wonderful pieces in here.
Making these API calls directly

7087
06:59:49,450 --> 06:59:52,630
is is a little bit annoying to
do ourselves. If you want to do

7088
06:59:52,630 --> 06:59:56,680
it yourself, you absolutely can
using an API endpoint like Axios

7089
06:59:56,770 --> 06:59:59,560
or fetch. However, we're going
to use a rapper to interact with

7090
06:59:59,560 --> 07:00:02,710
our node and do things like
deploy and interact and other

7091
07:00:02,710 --> 07:00:06,280
such things with our blockchain
node. This is finally where

7092
07:00:06,460 --> 07:00:07,420
ethers comes

7093
07:00:07,420 --> 07:00:13,780
into play. Ethers js is one of
the most popular JavaScript

7094
07:00:13,780 --> 07:00:16,840
based tooling kits, that allows
us to interact with different

7095
07:00:16,840 --> 07:00:20,590
blockchains and has all these
rappers that make all these API

7096
07:00:20,590 --> 07:00:24,190
calls and do all these things
with Aetherium, and polygon and

7097
07:00:24,190 --> 07:00:27,430
avalanche and any EVM compatible
chain. The other incredibly

7098
07:00:27,430 --> 07:00:30,100
popular package that does the
same thing is going to be web

7099
07:00:30,100 --> 07:00:32,500
three.js. And you've probably
heard about this and you'll

7100
07:00:32,500 --> 07:00:34,840
probably see it a little bit
more throughout this course and

7101
07:00:34,840 --> 07:00:36,940
throughout your web three
journey. The reason that we're

7102
07:00:36,940 --> 07:00:40,540
using ethers is that ethers is
the main tool that powers the

7103
07:00:40,540 --> 07:00:43,780
hard hat environment and I
really enjoy it myself. And

7104
07:00:43,780 --> 07:00:46,060
remember, if you ever get lost
with any of this, you can always

7105
07:00:46,060 --> 07:00:49,360
come back to their documentation
to install it. As you can see

7106
07:00:49,360 --> 07:00:52,480
here, you can just run npm
install ethers, we're just going

7107
07:00:52,480 --> 07:00:55,330
to do yarn, add ethers.

7108
07:00:56,950 --> 07:01:01,030
And now you should see in your
package json, we now have ethers

7109
07:01:01,030 --> 07:01:04,150
added in here. Awesome. Now back
in our code, we're going to

7110
07:01:04,150 --> 07:01:07,090
import ethers into our
deployed.js script so that we

7111
07:01:07,090 --> 07:01:09,640
can use all the wonderful tools
that comes with so we'll say

7112
07:01:09,640 --> 07:01:16,090
const ethers equals require
ethers. For those of you doing

7113
07:01:16,090 --> 07:01:18,730
the TypeScript edition of this
course, this will be import

7114
07:01:18,730 --> 07:01:21,430
instead of require now that we
have ethers in here, we can

7115
07:01:21,430 --> 07:01:25,390
create our provider object in
our main function. The reason we

7116
07:01:25,420 --> 07:01:28,270
we pull ethers outside of the
main function is because we do

7117
07:01:28,270 --> 07:01:32,080
want to pull our package into
our script. Before we call main,

7118
07:01:32,110 --> 07:01:35,260
we want to make sure all of this
is done first. So you'll see

7119
07:01:35,290 --> 07:01:38,560
this is kind of the the normal
setup of our scripts. At the

7120
07:01:38,560 --> 07:01:42,310
top, we import any dependencies
or external packages, we'll have

7121
07:01:42,310 --> 07:01:45,220
our main function, and then
we'll call our main function at

7122
07:01:45,220 --> 07:01:49,270
the bottom. const is a keyword
similar to let the const keyword

7123
07:01:49,300 --> 07:01:52,690
makes it so that ethers can't be
changed. So we can't change

7124
07:01:52,690 --> 07:01:56,440
this. Our ethers variable,
anytime we use const require is

7125
07:01:56,440 --> 07:01:59,620
a function for us to import the
ethers package. Now remix does

7126
07:01:59,650 --> 07:02:02,170
all this behind the scenes. But
the way we're going to do it in

7127
07:02:02,170 --> 07:02:07,780
our code here is we're going to
say const provider equals new

7128
07:02:08,320 --> 07:02:15,040
ethers dot providers dot JSON
RPC provider. And then we're

7129
07:02:15,040 --> 07:02:20,440
going to pass this string as our
provider. So we're saying hey,

7130
07:02:20,470 --> 07:02:24,520
we're going to connect to this
URL right here. Awesome. So this

7131
07:02:24,520 --> 07:02:27,850
is the way that our script is
going to connect to our

7132
07:02:27,850 --> 07:02:30,580
blockchain, our local
blockchain. Now let's get an

7133
07:02:30,580 --> 07:02:33,730
actual wallet here. With a
private key and a balance and

7134
07:02:33,730 --> 07:02:37,720
everything, we can see all of
our wallets and private keys in

7135
07:02:37,720 --> 07:02:40,960
our ganache here. So the way to
get this set up is we can say

7136
07:02:40,960 --> 07:02:47,650
const. Wallet equals new ethers
dot wallet. And this wallet

7137
07:02:47,650 --> 07:02:50,890
function takes in a couple of
input parameters, like a private

7138
07:02:50,890 --> 07:02:55,210
key, and a provider, the private
key will go to Kenosha and just

7139
07:02:55,210 --> 07:02:57,580
choose one of these private
keys. And we're going to paste

7140
07:02:57,580 --> 07:03:00,670
this right into our code. And
then we're gonna do comma

7141
07:03:00,880 --> 07:03:04,930
provider and save that. Now
pasting your private key

7142
07:03:04,960 --> 07:03:08,170
directly into your code is a
huge nono. And we're going to

7143
07:03:08,170 --> 07:03:11,410
learn how to avoid this in the
future. It's okay right now,

7144
07:03:11,440 --> 07:03:14,440
since we're just using one of
the ganache private keys, and

7145
07:03:14,470 --> 07:03:17,290
you have no risk of having any
money associated with this

7146
07:03:17,290 --> 07:03:20,950
account. These two lines alone
give us everything that we need

7147
07:03:20,980 --> 07:03:24,340
to interact with smart contract,
they give us our connection to

7148
07:03:24,340 --> 07:03:28,060
the blockchain, and they give us
a wallet with a private key so

7149
07:03:28,060 --> 07:03:30,640
we can sign different
transactions. If you remember

7150
07:03:30,640 --> 07:03:34,090
back to our blockchain basics
section. This is the private key

7151
07:03:34,270 --> 07:03:37,720
that we're using to sign all of
our transactions to encrypt our

7152
07:03:37,720 --> 07:03:40,960
transactions. Now that we have a
provider and a wallet, let's go

7153
07:03:40,960 --> 07:03:44,830
ahead and grab our contract
objects from these two files

7154
07:03:44,830 --> 07:03:47,800
here. In order to deploy our
contract, we're gonna need the

7155
07:03:47,800 --> 07:03:52,300
ABI and we're going to need the
binary compiled code of the

7156
07:03:52,300 --> 07:03:55,630
contract. So we're going to need
to read from these two files to

7157
07:03:55,630 --> 07:03:58,360
read from these two files, we're
going to need to use a package

7158
07:03:58,360 --> 07:04:03,280
called Fs. So back at the top,
we're gonna do const Fs equals

7159
07:04:03,280 --> 07:04:08,290
require Fs extra I autosave, all
the time, you'll see like, I'll

7160
07:04:08,290 --> 07:04:11,800
do something and then my white
dot will go away a lot. It's

7161
07:04:11,800 --> 07:04:14,920
because my fingers have a habit
of pretty much anytime I stop

7162
07:04:14,920 --> 07:04:18,910
typing I save so so please
remember to save early and

7163
07:04:18,910 --> 07:04:22,600
often, this Fs extra should come
directly with your node project.

7164
07:04:22,600 --> 07:04:26,920
But if not, you can always add
it with yarn, add Fs extra, and

7165
07:04:26,920 --> 07:04:31,510
you should see it in our package
dot JSON. Now we can get the ABI

7166
07:04:31,510 --> 07:04:37,900
and the binary, we can say
const, abi equals Fs dot read

7167
07:04:38,620 --> 07:04:42,880
file sync, which means we're
going to synchronously read from

7168
07:04:42,880 --> 07:04:46,240
this file, we could do it
asynchronously. But we want to

7169
07:04:46,240 --> 07:04:48,790
wait for this file to get done.
So we're gonna say read file

7170
07:04:48,790 --> 07:04:52,330
sync. And depending on your VS
code, if you scroll over, you

7171
07:04:52,330 --> 07:04:55,900
might even get some information
about this function popup like

7172
07:04:55,900 --> 07:04:58,450
this, which can be really
helpful, we can see that we need

7173
07:04:58,450 --> 07:05:01,810
the path for the file we want to
read. And then any options as

7174
07:05:01,810 --> 07:05:04,930
well path the file that we want
to read the at the ABI located

7175
07:05:04,930 --> 07:05:11,140
at dot slash simple storage,
underscore soul underscore

7176
07:05:11,170 --> 07:05:17,980
simple storage dot AVI and then
we're going to do a comma of U

7177
07:05:18,070 --> 07:05:22,270
T, F eight is UTF. Eight is the
encoding that we do for this

7178
07:05:22,270 --> 07:05:24,940
file here. Don't worry too much
about what that means for now.

7179
07:05:24,970 --> 07:05:29,860
So we need the ABI. And we also
need the binary, which is in

7180
07:05:29,980 --> 07:05:34,300
this second file. Simple Storage
underscore soul underscore

7181
07:05:34,300 --> 07:05:38,710
simple storage dot bin. So we're
gonna say const binary equals Fs

7182
07:05:38,740 --> 07:05:43,150
dot read file sync. We're gonna
give it the path Hear, which is

7183
07:05:43,150 --> 07:05:51,100
going to be dot slash, simple
storage soul, simple storage dot

7184
07:05:51,100 --> 07:05:54,280
bin, and then the encoding
option, which again is going to

7185
07:05:54,280 --> 07:05:57,100
be, and it should look like
this. Now that we have the

7186
07:05:57,100 --> 07:06:00,820
binary, we have the ABI, we can
create something called a

7187
07:06:00,820 --> 07:06:04,090
contract factory, which is not
to be confused with the factory

7188
07:06:04,090 --> 07:06:07,720
pattern in ethers. A contract
factory is just an object that

7189
07:06:07,720 --> 07:06:10,900
you can use to deploy contracts.
So we're gonna say const,

7190
07:06:11,530 --> 07:06:20,800
contract factory equals new
ethers dot contract, factory.

7191
07:06:21,670 --> 07:06:28,300
And we're going to pass it, the
API binary. And the wallet, we

7192
07:06:28,300 --> 07:06:31,420
pass the ABI so that our code
knows how to interact with the

7193
07:06:31,420 --> 07:06:34,180
contract the binary, obviously,
because this is the main

7194
07:06:34,180 --> 07:06:37,690
compiled code in our wallet so
that we have a private key we

7195
07:06:37,690 --> 07:06:41,200
can use to sign deploying this
contract, then I usually like to

7196
07:06:41,200 --> 07:06:44,890
write a little console dot log,
saying something like deploying

7197
07:06:45,190 --> 07:06:50,890
these wait. And we can actually
deploy this contract with ethers

7198
07:06:50,950 --> 07:06:59,020
by doing const. Contract equals
await, contract factory dot

7199
07:06:59,020 --> 07:07:02,770
deploy. Now, this is the first
time we've seen this await

7200
07:07:02,770 --> 07:07:06,820
keyword and you can only use the
await keyword inside of an async

7201
07:07:06,850 --> 07:07:10,030
function. The reason we want
this await keyword we're telling

7202
07:07:10,030 --> 07:07:16,270
our code to stop here, wait for
contract to deploy. And this

7203
07:07:16,270 --> 07:07:19,840
await keyword means that this
will resolve the promise

7204
07:07:19,870 --> 07:07:22,600
contract in this contract
factory dot deploy with the

7205
07:07:22,600 --> 07:07:26,050
await here returns a contract
object. So now I could do

7206
07:07:26,050 --> 07:07:30,580
something like console dot log
contract. Let's see what happens

7207
07:07:30,580 --> 07:07:37,810
when we run this code node
deploy dot j s, we scroll up, we

7208
07:07:37,810 --> 07:07:42,400
see deploying, please wait. And
then we see this massive object

7209
07:07:42,400 --> 07:07:45,970
that gets printed out. This is
the contract object that we just

7210
07:07:45,970 --> 07:07:50,830
deployed. And in fact, if we go
over to our ganache, we can see

7211
07:07:50,920 --> 07:07:54,100
that the address that we're used
for our wallet has a little bit

7212
07:07:54,100 --> 07:07:57,820
less balance and has a
transaction count of one. If we

7213
07:07:57,820 --> 07:08:00,550
were working with truffle, we'd
be able to see the contracts

7214
07:08:00,550 --> 07:08:02,920
here we're working with hard
hat, so you won't be able to see

7215
07:08:02,920 --> 07:08:05,950
the contracts in here. But if
you go to transactions, we can

7216
07:08:05,950 --> 07:08:09,160
indeed see the transaction that
we just created. This is similar

7217
07:08:09,160 --> 07:08:12,550
to ether scan. But for our local
blockchain, we can see the

7218
07:08:12,550 --> 07:08:15,970
sender address, the creation
address, the value, gas price,

7219
07:08:16,000 --> 07:08:19,840
all this stuff associated with
this contract. You can also see

7220
07:08:19,870 --> 07:08:22,480
the different blocks. Since
we've only made one transaction

7221
07:08:22,510 --> 07:08:25,900
only one block has been mined.
And this is awesome. We have all

7222
07:08:25,900 --> 07:08:30,100
this other stuff associated with
it. Great job. You just deployed

7223
07:08:30,340 --> 07:08:35,170
a contract to your own local
blockchain with ethers. Jas.

7224
07:08:35,200 --> 07:08:41,680
This is fantastic, Awesome work.
Now let me show you what happens

7225
07:08:41,710 --> 07:08:45,010
if we don't use the await
keyword here. We're not telling

7226
07:08:45,010 --> 07:08:48,520
our code to stop. We're saying
hey, deploy this contract and

7227
07:08:48,520 --> 07:08:51,250
then just keep going. So we
never actually checked to see if

7228
07:08:51,250 --> 07:08:53,980
this deploy function finished.
So let's see what happens when

7229
07:08:53,980 --> 07:08:57,970
we run this instead. Instead of
that big contract object, we get

7230
07:08:57,970 --> 07:09:01,630
this promise in its pending
state because our code actually

7231
07:09:01,630 --> 07:09:05,650
finished before our contract
could finish deploying. So we

7232
07:09:05,650 --> 07:09:09,490
see promise pending here
instead, this is why the await

7233
07:09:09,490 --> 07:09:12,580
keyword is so important. We're
saying hey, wait for this to

7234
07:09:12,580 --> 07:09:17,710
finish the await keyword also
resolves a promise. So it'll

7235
07:09:17,710 --> 07:09:21,340
wait for the promise to exit
it's pending state. And then

7236
07:09:21,340 --> 07:09:25,000
it'll return whatever the
pending promise returns. So

7237
07:09:25,000 --> 07:09:29,080
contract factory to deploy
returns a promise that returns a

7238
07:09:29,080 --> 07:09:32,680
contract. In fact, if we go to
the ethers documentation, we

7239
07:09:32,680 --> 07:09:36,040
look up deploy. And here we can
see contract factory methods

7240
07:09:36,040 --> 07:09:40,420
contract factory dot deploy. If
we look at the definition of the

7241
07:09:40,420 --> 07:09:43,720
function, it says contract
factory dot deploy takes a whole

7242
07:09:43,720 --> 07:09:47,440
bunch of arguments and some
overrides this arrow is saying

7243
07:09:47,440 --> 07:09:52,120
this is what it returns, it
returns a promise that resolves

7244
07:09:52,120 --> 07:09:55,570
to a contract. And that's why we
need this await keyword because

7245
07:09:55,570 --> 07:09:59,440
contract factory to deploy by
itself just returns a promise.

7246
07:09:59,710 --> 07:10:03,250
But if we do await contract
factory dot deploy, we're saying

7247
07:10:03,250 --> 07:10:06,490
it returns a promise that
resolves to a contract. And

7248
07:10:06,490 --> 07:10:09,520
we're waiting for it to finish
deploying to resolve to a

7249
07:10:09,520 --> 07:10:12,760
contract object. So that's gonna
be a major difference here.

7250
07:10:12,790 --> 07:10:15,820
Awesome work. So that's gonna be
why this await keyword is so

7251
07:10:15,820 --> 07:10:18,730
important. And again, you can
only do that in asynchronous

7252
07:10:18,730 --> 07:10:21,910
functions. So you need this
async keyword at the top of your

7253
07:10:21,910 --> 07:10:28,390
function names. Awesome work. So
we've deployed a contract to our

7254
07:10:28,390 --> 07:10:31,240
ganache. Shane, this is
fantastic. Let's play with this

7255
07:10:31,240 --> 07:10:34,810
a little bit more. So what else
can we do? Remember how in remix

7256
07:10:34,810 --> 07:10:38,020
and in Metamask, we could add a
whole bunch of stuff. We could

7257
07:10:38,020 --> 07:10:41,770
add a gas limit, we could add
some value when we were doing

7258
07:10:41,770 --> 07:10:44,440
our trends. that we could press
the transact button. We know

7259
07:10:44,440 --> 07:10:47,140
that when we're working with
Metamask, and we want to send

7260
07:10:47,140 --> 07:10:48,730
some money between our accounts,

7261
07:10:50,980 --> 07:10:53,740
we can actually choose our gas
price, our priority fee, all

7262
07:10:53,740 --> 07:10:56,620
this other stuff, we can
actually do all that in ethers

7263
07:10:56,620 --> 07:11:00,130
as well. So if we wanted to
await contract factory to

7264
07:11:00,130 --> 07:11:03,370
deploy, but with a certain gas
price, we can add these

7265
07:11:03,400 --> 07:11:06,010
overrides in this deploy
function here. Another really

7266
07:11:06,010 --> 07:11:09,160
neat trick that your Visual
Studio code might have is if you

7267
07:11:09,190 --> 07:11:13,480
click Command or Control,
depending on your setup, you can

7268
07:11:13,480 --> 07:11:17,890
actually click into a function
and see where it's defined and

7269
07:11:17,890 --> 07:11:20,770
see everything about this
function. So if I command

7270
07:11:20,770 --> 07:11:23,680
clicked, I could see that I'm
now in Node modules ethers

7271
07:11:23,680 --> 07:11:28,120
project contract source of Ts,
all this stuff. And I can see

7272
07:11:28,150 --> 07:11:33,160
exactly the function definition
of this deploy function on the

7273
07:11:33,160 --> 07:11:36,610
contract factory object, which
shows us the same code as what

7274
07:11:36,610 --> 07:11:40,600
we saw in the documentation. We
see we have a deploy function,

7275
07:11:40,630 --> 07:11:44,230
it takes some arguments, and
then it returns this little

7276
07:11:44,470 --> 07:11:47,290
semicolon means it returns a
promise that resolves to a

7277
07:11:47,290 --> 07:11:50,920
contract, which is really nice.
These are in here are actually a

7278
07:11:50,920 --> 07:11:54,820
list of overrides that we can
specify with some brackets. So

7279
07:11:54,820 --> 07:11:57,790
what we can do is we can put
some brackets in our deploy

7280
07:11:57,790 --> 07:12:01,300
function here and specify
certain things like for example,

7281
07:12:01,330 --> 07:12:06,460
we can specify the gas price to
being some number. And now if we

7282
07:12:06,460 --> 07:12:09,070
were to run this, we would
deploy this contract with a gas

7283
07:12:09,070 --> 07:12:12,160
price of this, we could add a
gas limit, we can add a whole

7284
07:12:12,160 --> 07:12:18,490
bunch of different overrides in
our deploy function here. Well,

7285
07:12:18,490 --> 07:12:21,670
what else can we do? Well, we
can wait for a certain number of

7286
07:12:21,670 --> 07:12:25,120
blocks for our contract finish
with so we've deployed the

7287
07:12:25,120 --> 07:12:28,960
contract. But maybe we want to
wait one block to make sure it

7288
07:12:28,960 --> 07:12:32,290
actually gets attached to the
chain. So we can say const.

7289
07:12:33,010 --> 07:12:39,850
Deployment received equals
await, contract dot deploy

7290
07:12:40,240 --> 07:12:43,570
transaction dot Wait, and
specify the number of

7291
07:12:43,570 --> 07:12:46,780
confirmations that we want to
actually wait. So we'll wait one

7292
07:12:46,780 --> 07:12:50,140
block confirmation to make sure
that this happened. And then we

7293
07:12:50,140 --> 07:12:55,420
can do console dot log, this
deployment receipt option. So if

7294
07:12:55,420 --> 07:13:01,030
we run the code now, we can see
all this information about our

7295
07:13:01,060 --> 07:13:04,840
transaction, and we can see
exactly what our transaction

7296
07:13:04,840 --> 07:13:09,130
looks like, we can see there's
two is no because we're creating

7297
07:13:09,130 --> 07:13:13,630
a contract from is going to be
this ganache address that we got

7298
07:13:13,630 --> 07:13:17,110
the private key for, we see the
contract address that we created

7299
07:13:17,140 --> 07:13:21,250
transaction index, we can see
gas use gas use log bloom block

7300
07:13:21,250 --> 07:13:24,850
hash transaction, and we can see
all this information about our

7301
07:13:24,850 --> 07:13:27,550
transaction, something I want
you to take note of is the

7302
07:13:27,550 --> 07:13:31,480
deployment receipt and the
deployment transaction, I want

7303
07:13:31,480 --> 07:13:33,550
you to separate these two
because it's going to make your

7304
07:13:33,550 --> 07:13:36,640
life a lot easier. So we're
going to do quick console dot

7305
07:13:36,640 --> 07:13:43,990
log, here is the deployment
transaction. And then we'll do

7306
07:13:43,990 --> 07:13:50,620
console dot log contract, dot
deploy transaction. And then I'm

7307
07:13:50,620 --> 07:13:54,370
going to copy this whole line by
just typing Command C or Ctrl. C

7308
07:13:54,370 --> 07:13:59,890
right there. And then here is
the deployment. Here is the

7309
07:13:59,920 --> 07:14:04,690
transaction receipt. And then
this deployment is receipt is

7310
07:14:04,690 --> 07:14:07,120
the transaction receipt. So I'm
just going to rename this to

7311
07:14:07,120 --> 07:14:10,960
transaction receipt. To make it
a little bit clearer, which ones

7312
07:14:10,960 --> 07:14:15,040
which, and we'll run this one
more time. You only get a

7313
07:14:15,040 --> 07:14:19,090
transaction receipt, when you
wait for a block confirmation.

7314
07:14:19,150 --> 07:14:21,880
Otherwise, you're gonna get the
contract object, which has the

7315
07:14:21,880 --> 07:14:24,610
deploy transaction with it, this
distinction will be more

7316
07:14:24,610 --> 07:14:27,460
important later on. But I wanted
you to know what the difference

7317
07:14:27,460 --> 07:14:30,850
between the two transaction
receipt is what you get when you

7318
07:14:30,850 --> 07:14:34,240
wait for a block confirmation,
the deployment transaction or

7319
07:14:34,240 --> 07:14:38,650
the transaction response,
transaction response is what you

7320
07:14:38,650 --> 07:14:41,680
get just when you create your
transaction. So transaction

7321
07:14:41,680 --> 07:14:44,560
receipts transactional response,
they're different receipt is

7322
07:14:44,560 --> 07:14:47,140
what you get when you wait for a
transaction to finish. And then

7323
07:14:47,140 --> 07:14:49,990
response is just what you
initially get. Make sense? Okay,

7324
07:14:49,990 --> 07:14:52,600
great. We're gonna go ahead and
delete those. But those lines

7325
07:14:52,600 --> 07:14:58,570
will be in the code associated
with the GitHub. Now you saw

7326
07:14:58,810 --> 07:15:01,600
when we actually printed out
those receipts, we got all this

7327
07:15:01,600 --> 07:15:04,990
stuff in here, because deploying
a contract is actually just

7328
07:15:04,990 --> 07:15:08,260
sending a transaction, as we've
said before, so if we want to

7329
07:15:08,260 --> 07:15:12,700
see what's really going on under
the hood, we can actually create

7330
07:15:12,730 --> 07:15:16,960
a transaction ourselves and
create a contract ourselves just

7331
07:15:16,960 --> 07:15:20,200
by specifying the transaction
information. So how will we do

7332
07:15:20,200 --> 07:15:24,760
that? Let's deploy this contract
again, but only purely using

7333
07:15:24,790 --> 07:15:27,640
transaction data. So we'll do a
console dot log.

7334
07:15:28,900 --> 07:15:34,600
Let's deploy with only
transaction data. And this is

7335
07:15:34,600 --> 07:15:37,120
going to be the way you can
actually deploy or send

7336
07:15:37,120 --> 07:15:39,910
transactions purely with
transaction data you can send

7337
07:15:39,940 --> 07:15:43,330
any transaction this gives you
unlimited flux. ability with the

7338
07:15:43,330 --> 07:15:46,720
transactions you want to send,
what we can do is we can say

7339
07:15:46,720 --> 07:15:50,680
const, or let TX which is going
to stand for our transaction

7340
07:15:51,130 --> 07:15:54,370
equals, and we can just add all
of our transaction information

7341
07:15:54,400 --> 07:15:57,790
in here. So the first thing that
we're going to need is our nuts,

7342
07:15:57,820 --> 07:16:01,000
or the number that we only use
once we go back to our

7343
07:16:01,000 --> 07:16:05,110
transaction count, we're on four
transactions here. So we'll use

7344
07:16:05,110 --> 07:16:07,630
the nonce five, because that's
going to be a nonce that we

7345
07:16:07,630 --> 07:16:11,320
haven't used before. Every time
you send a transaction, it comes

7346
07:16:11,320 --> 07:16:15,070
with one of those nonces. Right,
so the nonce is a bit of a over

7347
07:16:15,130 --> 07:16:18,730
overused term, we saw it back in
our blockchain basics that we

7348
07:16:18,730 --> 07:16:23,650
use the nonce to solve that hard
problem. nonces are also used in

7349
07:16:23,650 --> 07:16:26,920
wallets and in signers, to send
transactions and they use a

7350
07:16:26,920 --> 07:16:30,340
different nones for every
transaction. So nonce, when

7351
07:16:30,340 --> 07:16:33,190
we're talking about wallets
talks about a number associated

7352
07:16:33,190 --> 07:16:36,490
with a unique transaction.
nonce, when we're talking about

7353
07:16:36,490 --> 07:16:40,060
blockchain mining is a value
used to solve that hard problem,

7354
07:16:40,150 --> 07:16:42,670
they both mean the same thing.
They both mean a number only

7355
07:16:42,670 --> 07:16:45,910
used once. But they're different
in these different contexts. So

7356
07:16:45,910 --> 07:16:48,550
we're going to use this number
only use once this unique number

7357
07:16:48,550 --> 07:16:51,130
for a transaction to send this,
so we're going to say nonce is

7358
07:16:51,130 --> 07:16:55,780
going to be five, we're going to
pick a gas price of, of this

7359
07:16:55,780 --> 07:16:58,720
right here, we're just going to
use the gas price of ganache

7360
07:16:59,170 --> 07:17:02,920
like that, we're going to pick a
gas limit of some big number,

7361
07:17:02,920 --> 07:17:08,620
we'll use 1123456, we'll just
use that we're gonna say two is

7362
07:17:08,620 --> 07:17:13,000
going to be no, right, exactly
like what we saw in our receipts

7363
07:17:13,000 --> 07:17:17,470
and responses down here. Since
we're creating a contract value

7364
07:17:17,500 --> 07:17:20,200
is going to be zero. Since we're
creating a contract, we don't

7365
07:17:20,200 --> 07:17:25,090
want to send an ether polygon or
avalanche. And then data is

7366
07:17:25,090 --> 07:17:30,790
going to be that massive binary
object in our binary bit. So in

7367
07:17:30,790 --> 07:17:34,540
the binary section, we're gonna
copy this massive binary piece,

7368
07:17:34,840 --> 07:17:37,090
and we're going to put some
quotes in here, we're gonna do

7369
07:17:37,090 --> 07:17:42,460
0x, and paste that in here. So
this massive, massive data piece

7370
07:17:42,490 --> 07:17:44,800
is the binary that we're
sending. Whenever you send a

7371
07:17:44,800 --> 07:17:47,920
transaction, you have this this
data object that you can fill

7372
07:17:47,920 --> 07:17:51,340
this stuff, we're filling our
data object with the binary with

7373
07:17:51,340 --> 07:17:54,760
the code that tells the theory
that tells our blockchain to

7374
07:17:54,760 --> 07:17:58,630
deploy our smart contract that's
going to look exactly like this.

7375
07:17:58,690 --> 07:18:01,120
And then finally, we want to add
the chain ID.

7376
07:18:02,470 --> 07:18:05,680
As we've seen before with
Metamask, if we go back over to

7377
07:18:05,680 --> 07:18:09,970
our networks, each one of these
EVM chains has a different chain

7378
07:18:09,970 --> 07:18:13,870
ID Etherium. Main net is one
ropsten is three Rinke, B is

7379
07:18:13,870 --> 07:18:18,820
four COVID is 42, etc. And other
EVM chains like avalanche like

7380
07:18:18,820 --> 07:18:22,570
polygon, are going to have their
unique chain IDs as well, or

7381
07:18:22,570 --> 07:18:27,640
ganache, we can see the network
ID appear is 1337 in some

7382
07:18:27,640 --> 07:18:30,490
people, so we can just paste
that in here. Some people have

7383
07:18:30,490 --> 07:18:33,430
run into some issues where the
chain ID and the network ID are

7384
07:18:33,430 --> 07:18:38,290
different. And the chain ID is
actually 31337. So if you have a

7385
07:18:38,290 --> 07:18:43,420
problem with this, try 31337
instead, but it should be 1337.

7386
07:18:43,510 --> 07:18:46,780
Now this is a transaction with
all this information propagated,

7387
07:18:46,930 --> 07:18:50,770
which is awesome. However, this
transaction isn't signed. So

7388
07:18:50,770 --> 07:18:52,720
nobody's sending this
transaction right now this is

7389
07:18:52,720 --> 07:18:55,900
just the transaction details of
what somebody wants to do, we

7390
07:18:55,900 --> 07:18:59,080
actually need to sign this
transaction, and then send it to

7391
07:18:59,080 --> 07:19:09,160
our blockchain. Cons sign, TX
response equals await, wallet

7392
07:19:09,190 --> 07:19:15,970
dot sign transaction, and we can
pass that TX object. And then

7393
07:19:15,970 --> 07:19:20,800
we'll do a console dot log of
the sign TX response in

7394
07:19:20,800 --> 07:19:25,570
JavaScript. Same as solidity. If
you type two backslashes, before

7395
07:19:25,570 --> 07:19:29,380
some code, it won't run that
code. So I'm gonna go ahead and

7396
07:19:29,380 --> 07:19:33,040
comment out the three lines
above. And the way that I'm

7397
07:19:33,040 --> 07:19:35,590
doing it is by highlighting the
sections and hitting Command

7398
07:19:35,590 --> 07:19:39,040
backslash, or you might hit Ctrl
backslash, but this is a

7399
07:19:39,040 --> 07:19:42,910
keyboard shortcut you can use to
quickly comment out entire

7400
07:19:42,910 --> 07:19:45,310
sections. And the reason I'm
doing this is because I want to

7401
07:19:45,310 --> 07:19:49,120
show you what happens when we
just run scientex response

7402
07:19:49,150 --> 07:19:53,110
wallet that signed transaction
back in nosh, we see that we

7403
07:19:53,110 --> 07:19:56,440
have four blocks in here. Let me
ask if we do this sign

7404
07:19:56,440 --> 07:19:59,320
transaction and we get the
signed transaction response,

7405
07:19:59,470 --> 07:20:03,280
will we propagate another block?
Well, let's find out run no

7406
07:20:03,280 --> 07:20:08,950
deploy.js, we get this massive
thing here. But if we go back to

7407
07:20:08,950 --> 07:20:13,360
ganache refresh, we actually
don't see another transaction

7408
07:20:13,360 --> 07:20:17,140
sent. That's because we're only
signing a transaction here,

7409
07:20:17,140 --> 07:20:20,200
we're not actually sending it.
So the signed transaction

7410
07:20:20,200 --> 07:20:25,150
response. This big number here
represents a signed transaction

7411
07:20:25,180 --> 07:20:28,060
but not a cent transaction,
which is different. You can

7412
07:20:28,060 --> 07:20:31,030
actually send one of these
transactions by changing this

7413
07:20:31,030 --> 07:20:35,020
line a little bit. So instead of
scientex response, we'll change

7414
07:20:35,020 --> 07:20:39,550
this to send TX response equals
await wallet dot send

7415
07:20:39,550 --> 07:20:44,440
transaction TX then once We send
the transaction here, we can do

7416
07:20:44,470 --> 07:20:50,020
a wait, send transaction
response, that Wait, one, we're

7417
07:20:50,020 --> 07:20:53,230
gonna wait one block
confirmation to make sure this

7418
07:20:53,230 --> 07:20:57,640
transaction actually goes
through. And we can run node.js.

7419
07:20:58,210 --> 07:21:01,270
And it looks like it's done. But
if we actually scroll up, we

7420
07:21:01,270 --> 07:21:05,380
actually got an error here. So
there's this huge, massive thing

7421
07:21:05,380 --> 07:21:10,600
here. And if we scroll up, we'll
eventually see TX reject error,

7422
07:21:10,630 --> 07:21:13,990
the TX doesn't have the correct
nuts, which just for some

7423
07:21:13,990 --> 07:21:18,040
practice, let's go ahead, type
this into Google and see what we

7424
07:21:18,040 --> 07:21:22,660
get. We actually get a web three
Jas from four years ago, trying

7425
07:21:22,660 --> 07:21:25,960
to call leaf picked, blah, blah,
blah, blah, blah, blah, blah,

7426
07:21:25,960 --> 07:21:29,200
blah. It looks like this is a
meta mask issue that they ran

7427
07:21:29,200 --> 07:21:32,020
into. And they said, you have to
reset your account in meta mask,

7428
07:21:32,020 --> 07:21:35,260
which we could do. But let's
make this a little bit more

7429
07:21:35,260 --> 07:21:40,780
specific. Let's say ethers. JS
looks like we don't get it looks

7430
07:21:40,780 --> 07:21:44,290
like as of right now, from this
recording, we don't get a Stack

7431
07:21:44,290 --> 07:21:46,900
Exchange eath or a Stack
Overflow question for this

7432
07:21:46,930 --> 07:21:49,360
trolley, because this is pretty
straightforward. We don't have

7433
07:21:49,360 --> 07:21:51,940
the correct nonce for our
transaction. But this would be a

7434
07:21:51,940 --> 07:21:55,480
good time to actually make this
a question on Stack Overflow or

7435
07:21:55,480 --> 07:21:58,720
Stack Exchange Aetherium so that
it shows up first. So we

7436
07:21:58,720 --> 07:22:00,700
actually don't get the correct
nuts, we're going to want to

7437
07:22:00,700 --> 07:22:03,490
make this a nonce of four you
can see here account has a nonce

7438
07:22:03,490 --> 07:22:07,390
of four TX has a nonce of five.
So we actually would want this

7439
07:22:07,390 --> 07:22:10,900
to be four. Now an easier way to
always get the correct nonce

7440
07:22:10,900 --> 07:22:14,050
here is going to be actually
just calling the transaction

7441
07:22:14,050 --> 07:22:16,810
count from the wallet. So back
in the ethers documentation,

7442
07:22:16,840 --> 07:22:19,780
there's actually some good
samples here on how to assigning

7443
07:22:19,780 --> 07:22:23,200
a message and then how to
actually send these messages. So

7444
07:22:23,200 --> 07:22:26,980
we can do a weight wallet dot
get transaction count to get the

7445
07:22:26,980 --> 07:22:32,260
nuts. So back in our code, we
could do const nuns equals

7446
07:22:32,320 --> 07:22:37,060
await, oops, copy pasted, await
wallet dot get transaction

7447
07:22:37,060 --> 07:22:39,940
count. And then we can just
place the nonce right here.

7448
07:22:40,300 --> 07:22:44,200
Now, let's try running this
again. And it looks like this

7449
07:22:44,200 --> 07:22:48,460
one did indeed go through. We
can verify on ganache here. We

7450
07:22:48,460 --> 07:22:51,370
do indeed see we're currently on
block five now and we have one

7451
07:22:51,370 --> 07:22:54,370
extra transaction. Now we could
go ahead and just run this

7452
07:22:54,370 --> 07:22:57,130
again. And we'll never have to
worry about actually updating

7453
07:22:57,340 --> 07:23:00,340
this nonce ourselves. Since
we're just calling wallet dot

7454
07:23:00,340 --> 07:23:03,820
get transaction count to keep
updating it current block is six

7455
07:23:03,850 --> 07:23:06,400
and the our additional
transaction has indeed gone

7456
07:23:06,400 --> 07:23:09,100
through awesome. I showed you
how to actually sign the

7457
07:23:09,100 --> 07:23:12,130
transaction. But we didn't sign
the transaction for our central

7458
07:23:12,130 --> 07:23:16,330
injection. Well, why not? If you
command click or control click,

7459
07:23:16,390 --> 07:23:20,380
or you go to the documentation
for ethers, we can see the code

7460
07:23:20,380 --> 07:23:23,080
for send transaction. So first,
it does some check provider

7461
07:23:23,080 --> 07:23:25,930
stuff. There's some stuff to
populate the transaction. But we

7462
07:23:25,930 --> 07:23:29,890
can actually see that before it
sends the transaction even in

7463
07:23:29,920 --> 07:23:34,480
ethers, it signs the transaction
first, and then calls this dot

7464
07:23:34,480 --> 07:23:37,480
provider dot send transaction.
So if you just call send

7465
07:23:37,480 --> 07:23:41,950
transaction with the transaction
details like we did here, it's

7466
07:23:41,950 --> 07:23:44,650
the same as signing it first and
then sending it with the

7467
07:23:44,650 --> 07:23:47,050
provider. Okay, great. So we've
learned how to send a

7468
07:23:47,050 --> 07:23:50,620
transaction using pure
JavaScript and using pure

7469
07:23:50,770 --> 07:23:53,800
ethers. One of the main
takeaways from this is that

7470
07:23:53,950 --> 07:23:56,830
every time we change the
blockchain, every time we change

7471
07:23:56,830 --> 07:24:00,220
state, every time we use gas,
we're sending a transaction that

7472
07:24:00,220 --> 07:24:04,120
looks pretty much exactly like
this, the data is going to be

7473
07:24:04,120 --> 07:24:07,360
the differentiator, the data for
us here was data saying to

7474
07:24:07,360 --> 07:24:11,320
create a new contract, when we
make transactions, like adding

7475
07:24:11,320 --> 07:24:14,620
people or storing the data that
we're going to be passing in our

7476
07:24:14,620 --> 07:24:17,980
transaction is going to be data
associated with calling these

7477
07:24:17,980 --> 07:24:21,310
functions. And when we actually
call functions in ethers, or in

7478
07:24:21,310 --> 07:24:24,670
Hardhead. We're not going to do
this kind of raw const, TX, and

7479
07:24:24,880 --> 07:24:27,400
list out all the stuff like here
and list out the raw data,

7480
07:24:27,400 --> 07:24:30,220
right? Because that's really,
really hard ethers and hard hat

7481
07:24:30,250 --> 07:24:33,640
are going to make this process a
lot easier. So for now, let's go

7482
07:24:33,640 --> 07:24:36,820
ahead, comment out this whole
section, which again, if we copy

7483
07:24:36,820 --> 07:24:40,120
this whole thing, and then hit
Command, slash, or control

7484
07:24:40,120 --> 07:24:42,670
slash, or whatever the shortcut
is on your environment, that'll

7485
07:24:42,670 --> 07:24:45,220
actually comment this out. Let's
go ahead and uncomment this

7486
07:24:45,220 --> 07:24:48,340
section so that we deploy our
contract using kind of the ether

7487
07:24:48,340 --> 07:24:52,540
is much easier to read way than
this weird TX stuff. Oh, cool.

7488
07:24:52,540 --> 07:24:55,690
So we've changed our script back
to deploy our contracts like

7489
07:24:55,690 --> 07:25:00,430
this. Now that we've actually
deployed our contract, we can

7490
07:25:00,430 --> 07:25:03,130
learn how to interact with our
contract through code as well,

7491
07:25:03,160 --> 07:25:06,700
the same way that we click these
buttons in remix, we're going to

7492
07:25:06,730 --> 07:25:10,330
code it out for ourselves here.
So if we look at symbol storage,

7493
07:25:10,600 --> 07:25:14,050
we have a button for add person
for store. And then we have

7494
07:25:14,050 --> 07:25:16,720
these view functions as well.
The easiest one is going to be

7495
07:25:16,720 --> 07:25:19,450
the Retrieve function, which
grabs our favorite number,

7496
07:25:19,660 --> 07:25:23,590
retrieve returns favorite
number. So we can call that in

7497
07:25:23,590 --> 07:25:31,090
ethers by doing const. current
favorite number equals await.

7498
07:25:31,900 --> 07:25:37,960
contract.we retrieve. The
contract object that we have is

7499
07:25:37,960 --> 07:25:40,750
what's returned from our
contract factory as long as

7500
07:25:40,750 --> 07:25:43,480
we've awaited it the contract
object is going to come with all

7501
07:25:43,480 --> 07:25:46,630
the functionality described in
our API. That's why we had to

7502
07:25:46,630 --> 07:25:51,010
pass the API to our contract
factory. If we look inside our

7503
07:25:51,010 --> 07:25:55,180
API piece here, we can see it
has a ton of information on the

7504
07:25:55,180 --> 07:25:58,270
different functions that we can
call and the types that it has

7505
07:25:58,270 --> 07:26:00,670
and the return types and
everything like that. For

7506
07:26:00,670 --> 07:26:05,890
example, if I look up retrieve,
I can see down here, we have

7507
07:26:05,920 --> 07:26:08,710
retrieve, we can see that the
name of this function is going

7508
07:26:08,710 --> 07:26:13,060
to be retrieved. And the outputs
are going to be a un 256, of

7509
07:26:13,060 --> 07:26:16,840
type Nuun 256. Now, this is a
little bit difficult to read

7510
07:26:16,840 --> 07:26:19,960
because it's not formatted.
Since we call this dot API, it's

7511
07:26:19,960 --> 07:26:22,930
going to be a little bit hard to
read. But we could change it the

7512
07:26:22,960 --> 07:26:27,100
dot JSON. And then you'll see
it's highlighted a little bit, I

7513
07:26:27,310 --> 07:26:32,110
can even do format document with
prettier. And you'll see it

7514
07:26:32,110 --> 07:26:35,170
actually formats to be a lot
easier to read now and go back

7515
07:26:35,170 --> 07:26:40,480
to retrieve. And we can see,
this block of code here defines

7516
07:26:40,720 --> 07:26:43,210
what the Retrieve function can
and can't do. I'm going to

7517
07:26:43,210 --> 07:26:46,210
change it back to abi. And it
looks like my formatting has

7518
07:26:46,210 --> 07:26:49,150
stayed, which is great. This is
much easier to read than it was

7519
07:26:49,150 --> 07:26:52,690
before. As I said, the ABI or
the application binary interface

7520
07:26:52,720 --> 07:26:55,330
is incredibly important for
working with our contracts. If

7521
07:26:55,330 --> 07:26:58,480
we give our code just this huge
bytecode thing, it's gonna be

7522
07:26:58,480 --> 07:27:03,040
really hard for any processor to
decompile this or understand

7523
07:27:03,040 --> 07:27:05,860
what exactly what the functions
are that are going on here.

7524
07:27:05,950 --> 07:27:09,610
There are decompiler options out
there, like ether VM, that IO

7525
07:27:09,610 --> 07:27:13,840
slash decompile. That can
decompile some bytecode into the

7526
07:27:13,840 --> 07:27:17,320
solidity. But it can be really
tricky to get it exactly right.

7527
07:27:17,350 --> 07:27:20,860
So it's much easier just to have
the ABI to say, hey, this lump

7528
07:27:20,860 --> 07:27:25,330
of code, this lump of numbers
and garbled nonsense is this.

7529
07:27:25,360 --> 07:27:28,000
When we deploy this bytecode to
the blockchain, and we call

7530
07:27:28,000 --> 07:27:30,610
functions on it, the code will
automatically allow those

7531
07:27:30,610 --> 07:27:33,910
functions to get called if they
do exist. But in order for our

7532
07:27:33,910 --> 07:27:36,640
code to know that they exist,
it's much easier just to give it

7533
07:27:36,640 --> 07:27:39,850
the API. So we can get our
current favorite number like

7534
07:27:39,850 --> 07:27:44,410
this. Let's go ahead and console
dot log, the current favorite

7535
07:27:44,410 --> 07:27:48,790
number. Now that we've edited
this code, we're going to let me

7536
07:27:48,790 --> 07:27:51,430
zoom out a little bit. Now that
we've edited this code, we're

7537
07:27:51,430 --> 07:27:54,460
going to connect organ nosh
instance, we're going to connect

7538
07:27:54,490 --> 07:27:58,210
a wallet with a private key that
we got from the top of our

7539
07:27:58,210 --> 07:28:01,510
ganache here, we're gonna grab
the ABI and the binary of our

7540
07:28:01,510 --> 07:28:05,830
contracts, and connect them to a
new contract factory object,

7541
07:28:05,890 --> 07:28:09,010
which is connected to that
wallet. So that wallet will be

7542
07:28:09,010 --> 07:28:12,130
the one to actually deploy the
contract, we'll deploy the

7543
07:28:12,130 --> 07:28:15,130
contract with const contract
equals await contract factory

7544
07:28:15,130 --> 07:28:18,940
dot deploy, we will wait one
block for that transaction to

7545
07:28:18,940 --> 07:28:20,980
finish. And in fact, we're not
going to use transaction

7546
07:28:20,980 --> 07:28:24,610
receipt. So for now, we're just
going to delete that part. We're

7547
07:28:24,610 --> 07:28:27,130
not going to do any of this
here. So I'm going to delete it

7548
07:28:27,130 --> 07:28:29,680
for now. However, I'll leave
this section commented out in

7549
07:28:29,680 --> 07:28:33,280
the GitHub repo. And then we're
going to call contract retrieve

7550
07:28:33,280 --> 07:28:36,100
which should return our current
favorite number. Since this is a

7551
07:28:36,100 --> 07:28:40,990
view function, this contract
call won't cost us any gas. If

7552
07:28:40,990 --> 07:28:44,560
we look at simple storage, that
soul we can see retrieve is a

7553
07:28:44,560 --> 07:28:48,460
view function. And remember view
and pure functions, if called

7554
07:28:48,490 --> 07:28:52,390
outside of a contract function
call don't cost any gas, we're

7555
07:28:52,390 --> 07:28:55,450
just reading up the blockchain,
we're not changing any variables

7556
07:28:55,450 --> 07:28:58,780
on chain, we're not changing the
state of the blockchain. So this

7557
07:28:58,780 --> 07:29:00,730
won't cost any gas. So let's go

7558
07:29:00,730 --> 07:29:06,730
ahead and run this. Perfect, we
get deploying, please wait. And

7559
07:29:06,730 --> 07:29:09,700
then we get this big number
response. So what's this big

7560
07:29:09,700 --> 07:29:13,660
number response here? Big number
is a library that comes with the

7561
07:29:13,660 --> 07:29:16,840
ethers application that helps us
work with numbers. If you

7562
07:29:16,840 --> 07:29:20,290
actually scroll down, they even
have a section saying why can I

7563
07:29:20,290 --> 07:29:23,080
just use numbers, you'd expect
current favorite number to just

7564
07:29:23,080 --> 07:29:25,930
be zero, but it returns this
weird hex thing that says his

7565
07:29:25,930 --> 07:29:29,230
big number true this weird, big
number thing. So solidity can't

7566
07:29:29,230 --> 07:29:32,350
use decimal places, and
JavaScript has a hard time with

7567
07:29:32,350 --> 07:29:35,800
decimal places. And this is kind
of the more specific rationale

7568
07:29:35,800 --> 07:29:38,950
for why not to use numbers, what
you'll see a lot of the time

7569
07:29:38,980 --> 07:29:42,970
instead of numbers is you'll see
strings like zero, you'll see

7570
07:29:42,970 --> 07:29:47,110
JavaScript use strings like
this, or big numbers. Now, if I

7571
07:29:47,110 --> 07:29:51,040
were to try to pass a number
like this in JavaScript, this

7572
07:29:51,040 --> 07:29:53,920
number would be too big for
JavaScript to understand. So we

7573
07:29:53,920 --> 07:29:56,320
want to use big numbers or
strings when working with

7574
07:29:56,320 --> 07:29:59,800
ethers. Now we can make this
more readable by adding.to

7575
07:29:59,800 --> 07:30:03,220
string at the end and printing
out the string version of this

7576
07:30:03,220 --> 07:30:08,320
big number. Now, if I rerun this
code, we can see we get zero,

7577
07:30:08,350 --> 07:30:11,680
which makes sense again, because
our favorite number gets

7578
07:30:11,710 --> 07:30:16,030
initialized to the zero value,
if not specified, and we haven't

7579
07:30:16,030 --> 07:30:19,870
called store yet. So awesome. So
that is, that's working

7580
07:30:19,870 --> 07:30:22,480
perfectly. So this is what our
current favorite number is.

7581
07:30:22,540 --> 07:30:25,720
Let's make this console dot log
a little bit more syntactical.

7582
07:30:25,750 --> 07:30:28,150
We're going to use something
called string interpolation. So

7583
07:30:28,150 --> 07:30:32,320
we can interpolate our string
here with variables. Typically

7584
07:30:32,320 --> 07:30:34,960
in JavaScript when working with
strings, use double quotes.

7585
07:30:34,990 --> 07:30:39,460
However, if you want to mix
variables with actual strings,

7586
07:30:39,490 --> 07:30:42,250
you can use backticks instead.
So we're going to use some that

7587
07:30:42,250 --> 07:30:47,500
backticks here, and we're gonna
say current favorite number to

7588
07:30:47,500 --> 07:30:50,980
call in here. And to tell
JavaScript that this is a

7589
07:30:50,980 --> 07:30:54,400
variable that we want to read,
we put a little dollar sign and

7590
07:30:54,400 --> 07:30:59,320
a bracket around it, like this.
Now, if we run this code again,

7591
07:30:59,860 --> 07:31:02,530
it's saying deploying, please
wait, and we get current

7592
07:31:02,530 --> 07:31:05,710
favorite number is zero, because
JavaScript goes, Okay, this is a

7593
07:31:05,710 --> 07:31:09,610
string, ah, dollar sign, curly
brace looks like this is going

7594
07:31:09,610 --> 07:31:12,310
to be some variable or some
JavaScript that you want me to

7595
07:31:12,340 --> 07:31:16,060
interpret and close it off, and
then backtick. Cool. So our

7596
07:31:16,060 --> 07:31:18,700
current favorite number is going
to be zero. Great. So let's

7597
07:31:18,730 --> 07:31:21,490
update on the contract the
number by calling the store

7598
07:31:21,490 --> 07:31:27,760
function. So we'll say const,
transaction response equals

7599
07:31:27,910 --> 07:31:32,980
await, contract dot store, and
we'll add seven. Now since seven

7600
07:31:32,980 --> 07:31:35,980
is a small number, you can just
pass it like seven. But passing

7601
07:31:35,980 --> 07:31:39,640
it like seven in a string also
works. Again, this is because if

7602
07:31:39,640 --> 07:31:43,210
we want to pass some crazy
massive number, JavaScript would

7603
07:31:43,210 --> 07:31:47,380
get confused. So it's usually
best practice to pass variables

7604
07:31:47,410 --> 07:31:49,960
to contract functions as
strings, even though that might

7605
07:31:49,960 --> 07:31:52,870
be a little bit confusing ethers
is smart enough to know that

7606
07:31:53,020 --> 07:31:56,650
this seventh string is actually
seven the number then we can do

7607
07:31:56,650 --> 07:32:03,190
const. Transaction received
equals await transaction

7608
07:32:03,820 --> 07:32:09,520
response that Wait, one. So
we'll wait one block here. This

7609
07:32:09,520 --> 07:32:12,970
is similar to us doing contract
dot deploy transaction dot Wait,

7610
07:32:13,510 --> 07:32:16,240
the syntax here is a little bit
different than what we saw up

7611
07:32:16,240 --> 07:32:18,940
here. Because this is using a
contract factory. And this is

7612
07:32:18,940 --> 07:32:22,180
calling a function on a
contract. So when we call the

7613
07:32:22,180 --> 07:32:25,330
function on the contract, we get
a transaction response. When we

7614
07:32:25,330 --> 07:32:27,940
wait for the transaction
response to finish, we get the

7615
07:32:27,940 --> 07:32:32,590
transaction receipt. Now I can
do const, updated, favorite

7616
07:32:32,590 --> 07:32:39,880
number two equals await on track
dot retrieve. And then console

7617
07:32:39,880 --> 07:32:46,750
dot log updated. favorite number
is, and we'll do a little string

7618
07:32:46,750 --> 07:32:51,010
interpolation, updated, favorite
number like that? Now let's go

7619
07:32:51,010 --> 07:32:53,830
ahead and run this. So in this
process, what are we doing,

7620
07:32:54,220 --> 07:32:57,550
we're deploying the contract,
we're getting the initial value,

7621
07:32:57,730 --> 07:33:01,360
we're going to update our
contract by calling store which

7622
07:33:01,390 --> 07:33:05,110
is going to cost gas. So this is
a transaction, we're going to

7623
07:33:05,110 --> 07:33:07,810
get the transaction response,
then we're gonna get the

7624
07:33:07,810 --> 07:33:10,570
transaction receipt, we're not
going to do anything with the

7625
07:33:10,570 --> 07:33:13,660
transaction receipt, I want to
ingrain in you all that these

7626
07:33:13,660 --> 07:33:16,600
two are different transaction
response and transaction

7627
07:33:16,600 --> 07:33:19,450
receipt, and you'll see why in
the future. And then we'll get

7628
07:33:19,450 --> 07:33:21,610
the updated favorite number, and
then we're just going to print

7629
07:33:21,610 --> 07:33:26,560
it out. So let's do this. Boom,
and perfect. Deploying, please

7630
07:33:26,560 --> 07:33:30,400
wait, current favorite number is
zero, updated favorite number is

7631
07:33:30,400 --> 07:33:33,430
seven. And if we go to our
ganache instance, we go to

7632
07:33:33,430 --> 07:33:38,230
transactions, we can see, we now
have a contract call at the top,

7633
07:33:38,680 --> 07:33:42,220
we have the sender, the contract
address, the gas price, all this

7634
07:33:42,220 --> 07:33:46,060
stuff, and we see our
transaction data right here. So

7635
07:33:46,060 --> 07:33:49,960
this transaction data is what
gets sent in that data slot of

7636
07:33:49,960 --> 07:33:53,170
our transaction object. Ethers
is just doing that on the back

7637
07:33:53,170 --> 07:33:56,560
end for us so that we don't have
to make that big transaction

7638
07:33:56,560 --> 07:33:59,680
object there. All right,
awesome. You've successfully

7639
07:33:59,680 --> 07:34:04,360
deployed a contract to your own
local ganache instance, or your

7640
07:34:04,360 --> 07:34:07,120
own JavaScript virtual machine.
This is great.

7641
07:34:09,790 --> 07:34:12,820
Now let's clean this up a little
bit. Because if we look up here,

7642
07:34:12,850 --> 07:34:17,470
we have both our connection to
the blockchain and our private

7643
07:34:17,470 --> 07:34:21,550
key stored directly in our code,
we were to push this code up to

7644
07:34:21,580 --> 07:34:24,250
a GitHub or some other code
repository, if you will, will be

7645
07:34:24,280 --> 07:34:27,760
able to see our code. If we look
into ploy dot j s of my code,

7646
07:34:28,120 --> 07:34:31,360
ah, there's something else in
here, we don't actually see the

7647
07:34:31,360 --> 07:34:34,720
private key or the RPC URL in
here. So what's going on?

7648
07:34:34,810 --> 07:34:37,360
Remember, if you give out your
private key, whoever has your

7649
07:34:37,360 --> 07:34:40,960
private key owns your funds. So
even though this is a fake,

7650
07:34:40,960 --> 07:34:43,540
private key that doesn't have
any real money in it, we still

7651
07:34:43,540 --> 07:34:46,030
don't want to have to hard code
our private keys into our code,

7652
07:34:46,060 --> 07:34:49,090
just in case we accidentally
share code with somebody. So

7653
07:34:49,090 --> 07:34:52,510
what can we do? Well, one of the
most popular methods is actually

7654
07:34:52,540 --> 07:34:55,900
creating something called a dot
EMV file or an environment

7655
07:34:55,900 --> 07:34:58,570
variable. And if you're familiar
with environment variables, you

7656
07:34:58,570 --> 07:35:01,600
can actually set them right in
your terminal, but we're gonna

7657
07:35:01,600 --> 07:35:04,630
set them in our dot env. So what
you want to do is you're gonna

7658
07:35:04,630 --> 07:35:07,990
want to create a dot env file.
And this is going to be a file

7659
07:35:07,990 --> 07:35:10,450
where you store its sensitive
information. And this is going

7660
07:35:10,450 --> 07:35:13,180
to be a file, we're never going
to share this with anybody. This

7661
07:35:13,180 --> 07:35:16,810
dot env file will stick
variables of our choosing into

7662
07:35:16,840 --> 07:35:20,410
the environment of our code. So
for example, if I pull up my

7663
07:35:20,410 --> 07:35:25,570
terminal here, and I do echo
cat, this is going to reflect

7664
07:35:25,870 --> 07:35:29,320
what the cat environment
variable is for us. Right now

7665
07:35:29,350 --> 07:35:32,380
there is no cat environment
variable. However, if I do

7666
07:35:32,410 --> 07:35:41,920
export, cat equals dog, and now
I do echo dollar sign cat, I get

7667
07:35:41,980 --> 07:35:45,010
dog output. This is what an
environment variable is, it's a

7668
07:35:45,010 --> 07:35:48,670
variable in our terminal or in
our scripting environment, since

7669
07:35:48,700 --> 07:35:52,720
I don't want to have to type
export, private key equals blah,

7670
07:35:52,720 --> 07:35:55,750
blah, blah, every time, what
we're going to do instead is

7671
07:35:55,750 --> 07:35:58,870
we're going to stick them into
this dot env file. So when this

7672
07:35:58,870 --> 07:36:04,900
dot env, we can put private key
equals. And we can grab this

7673
07:36:04,900 --> 07:36:08,440
private key from our script, and
paste it in like this. And a

7674
07:36:08,440 --> 07:36:11,680
note, some tools look for the
0x, at the beginning of the

7675
07:36:11,680 --> 07:36:14,890
private key ethers, and hard hat
is smart enough that either one

7676
07:36:14,890 --> 07:36:18,490
works, but if you run into some
issues, just know that sometimes

7677
07:36:18,490 --> 07:36:21,460
you might have to put your 0x at
the front of this. Great. So now

7678
07:36:21,460 --> 07:36:23,950
we have a private key in an
environment variable. What do we

7679
07:36:23,950 --> 07:36:28,570
do now? Well, in our deploy.js,
we want to grab this environment

7680
07:36:28,570 --> 07:36:32,140
variable and stick it into our
script here, so that our script

7681
07:36:32,140 --> 07:36:34,930
can then stick it into our
environment. So we're going to

7682
07:36:34,930 --> 07:36:38,920
add a tool called dot env. To
make this easier, so we're gonna

7683
07:36:38,920 --> 07:36:44,620
do yarn, add dot env. And if we
look at the dot env package, can

7684
07:36:44,620 --> 07:36:47,470
read more about it and read
about how to add it with NPM.

7685
07:36:47,500 --> 07:36:51,220
Again, we're just using yarn
add. But then we can just call

7686
07:36:51,220 --> 07:36:54,670
this require dot E and V dot
config. And this will pull in

7687
07:36:54,880 --> 07:36:58,240
all our environment variables.
So we can just do require

7688
07:36:59,260 --> 07:37:04,060
dot EMV config, we should see
this on our package that JSON,

7689
07:37:04,180 --> 07:37:07,750
we do. Excellent. Now that we
pulled it in, we actually get

7690
07:37:07,750 --> 07:37:11,290
access to our private key
environment variable, you can

7691
07:37:11,290 --> 07:37:14,500
access environment variables in
JavaScript, are using process

7692
07:37:14,500 --> 07:37:17,800
dot EMV. So instead of putting
our private key here, we're

7693
07:37:17,800 --> 07:37:21,190
gonna delete that whole thing
and substitute it with process

7694
07:37:21,370 --> 07:37:26,860
dot EMV, that private key, and
we'll save and it'll reformat

7695
07:37:26,860 --> 07:37:29,890
for us to make sure this is
actually working, we can just

7696
07:37:29,890 --> 07:37:34,660
hit up after we save up, up up
up up a bunch and go back to no

7697
07:37:34,660 --> 07:37:38,710
deploy to Jas. And we see we get
the exact same setup. And if we

7698
07:37:38,710 --> 07:37:41,350
scroll back, you can see a
transaction has indeed gone

7699
07:37:41,350 --> 07:37:43,750
through. If you want to double
check that this is actually

7700
07:37:43,750 --> 07:37:47,320
printing out your private key,
we could do console dot log,

7701
07:37:47,860 --> 07:37:51,640
press study and via private key
we run, we see that that is

7702
07:37:51,640 --> 07:37:54,640
indeed the private key coming
from our environment variable

7703
07:37:54,640 --> 07:37:59,110
here. Awesome. Now our RPC URL
here is isn't really something

7704
07:37:59,110 --> 07:38:01,510
that we need to secure however,
maybe we're going to use a

7705
07:38:01,510 --> 07:38:05,140
certain API key or maybe a
certain endpoint that only we

7706
07:38:05,140 --> 07:38:07,480
want to have access to. And we
don't want anybody else to be

7707
07:38:07,480 --> 07:38:11,350
using our RPC endpoint. So we're
going to add this to our dot env

7708
07:38:11,350 --> 07:38:16,720
file as well. So in our dot env.
When I copy this here, I'm gonna

7709
07:38:16,720 --> 07:38:22,300
say RPC URL equals, and I paste
that in there, just like that.

7710
07:38:22,900 --> 07:38:25,600
And we're gonna delete here. And
we're gonna do the exact same

7711
07:38:25,600 --> 07:38:30,490
thing, say process dot e NV dot
RPC URL. And now we're going to

7712
07:38:30,490 --> 07:38:33,550
run this again. And I'm going to
take out that console dot log.

7713
07:38:33,820 --> 07:38:37,360
And we should get the exact same
response because all we did was

7714
07:38:37,360 --> 07:38:41,080
swap out our RPC URL with our
environment variable, which is

7715
07:38:41,080 --> 07:38:43,600
going to be exactly what it was
before. So we go ahead and run

7716
07:38:43,600 --> 07:38:46,930
this, and we get the exact same
response. And if we go to

7717
07:38:46,930 --> 07:38:50,260
ganache, we see that we do
indeed get a transaction here,

7718
07:38:50,500 --> 07:38:54,070
which is perfect. Awesome. So
we've learned how to add

7719
07:38:54,070 --> 07:38:58,030
environment variables to our dot
env file. So that so that just

7720
07:38:58,030 --> 07:39:00,670
in case, we want to share our
code, or we push our code up to

7721
07:39:00,670 --> 07:39:03,610
GitHub, which we'll do in later
sections, we don't accidentally

7722
07:39:03,610 --> 07:39:07,450
expose our private keys or our
RPC URLs. Now all the code that

7723
07:39:07,450 --> 07:39:11,080
we have in our project here, if
we push it up to GitHub, or

7724
07:39:11,320 --> 07:39:14,230
share it with somebody else, all
this code will get pushed up,

7725
07:39:14,260 --> 07:39:17,710
including our dot env file.
However, if you look at my code

7726
07:39:17,710 --> 07:39:22,120
samples here for this course, we
don't see a dot env file in

7727
07:39:22,120 --> 07:39:25,630
here. So how is that possible?
Well, what we want to do

7728
07:39:25,660 --> 07:39:30,400
whenever we have a project is
create a dot Git ignore file.

7729
07:39:30,580 --> 07:39:34,450
And in here, we want to put in
v. And we also want to put in

7730
07:39:34,480 --> 07:39:38,530
Node modules. This means that
when working with Git and

7731
07:39:38,530 --> 07:39:40,720
working with version control,
which we're going to do a little

7732
07:39:40,720 --> 07:39:44,680
bit later, we won't push our dot
env file up to GitHub. And we

7733
07:39:44,680 --> 07:39:47,710
also won't push up known
modules. So if we go back to my

7734
07:39:47,710 --> 07:39:52,300
example here, we don't see, we
don't see a dot env file, but we

7735
07:39:52,300 --> 07:39:56,020
do see a dot env dot example,
just to show you what one would

7736
07:39:56,020 --> 07:39:58,570
look like. So it doesn't really
matter that I have them in here.

7737
07:40:01,270 --> 07:40:03,400
Now, if you're really paranoid,
there's something else you can

7738
07:40:03,400 --> 07:40:05,590
actually do when running your
scripts and running your

7739
07:40:05,590 --> 07:40:08,560
commands. Let's say you didn't
want to put your private key

7740
07:40:08,560 --> 07:40:11,230
into a dot env file because you
were nervous that you would

7741
07:40:11,230 --> 07:40:13,540
accidentally push it up or
something. What you can do is

7742
07:40:13,540 --> 07:40:16,870
you can add your private key in
your RPC URL as environment

7743
07:40:16,870 --> 07:40:20,200
variables right in the command
line. So before you run Node

7744
07:40:20,200 --> 07:40:25,450
deploy, that's as well you can
do, you can say RPC URL equals,

7745
07:40:25,870 --> 07:40:32,020
paste your RPC around. And then
you can say private key. equals

7746
07:40:32,290 --> 07:40:36,610
and then paste your private key
and then do node deploy.js.

7747
07:40:37,240 --> 07:40:40,390
Setting these right before we
run our script is the exact same

7748
07:40:40,390 --> 07:40:43,690
as if we had set them into dot
env. Here If we hit run, we see

7749
07:40:43,690 --> 07:40:46,690
the exact same output, which
means that our RPC URL and our

7750
07:40:46,690 --> 07:40:49,360
private key went through
successfully. This way for key

7751
07:40:49,360 --> 07:40:52,060
management is fine. But our
rights doing this, it's going to

7752
07:40:52,060 --> 07:40:55,390
be much better. But it still
makes me a little bit nervous in

7753
07:40:55,390 --> 07:40:57,700
our development environments
with our fake private keys,

7754
07:40:57,730 --> 07:41:01,060
having our code in the dot env
file like this is, is okay,

7755
07:41:01,090 --> 07:41:04,030
right? Because we don't really
care if this key gets hacked,

7756
07:41:04,060 --> 07:41:06,790
like nobody's using it. But when
we move to a more professional

7757
07:41:06,790 --> 07:41:10,630
setup, this can be a little bit
scary. So how can we make this

7758
07:41:10,660 --> 07:41:14,050
even more secure? Well, what we
can do is actually we can

7759
07:41:14,050 --> 07:41:17,890
encrypt our private key and
store our encrypted key locally.

7760
07:41:17,950 --> 07:41:20,980
That way, if for some reason
somebody does get into our

7761
07:41:20,980 --> 07:41:23,560
account, our private key isn't
just sitting around in plain

7762
07:41:23,560 --> 07:41:26,410
text, it's encrypted. And you'll
need to know a password that

7763
07:41:26,410 --> 07:41:29,860
only you know to get into it. So
how do we add that? Well, first,

7764
07:41:29,860 --> 07:41:36,010
we're going to create a new file
called encrypt key.js. And this

7765
07:41:36,010 --> 07:41:39,250
is some code that we're going to
use to actually encrypt a key.

7766
07:41:39,520 --> 07:41:41,920
And we'll store that locally
instead of our private key in

7767
07:41:41,920 --> 07:41:45,100
plain text. This will make us
even more secure so that we

7768
07:41:45,100 --> 07:41:47,290
don't have our private key just
hanging around in plain text

7769
07:41:47,290 --> 07:41:50,200
here. So let's go ahead and
build the script to encrypt our

7770
07:41:50,200 --> 07:41:52,780
private key. So we're going to
use the exact same setup as we

7771
07:41:52,780 --> 07:41:55,690
did for our deploy script. We're
going to do an async function

7772
07:41:55,690 --> 07:41:56,110
main.

7773
07:41:57,460 --> 07:41:59,650
And then down here, I'm just
gonna go ahead and copy from

7774
07:41:59,650 --> 07:42:03,730
deployed J S. We're gonna use
this exact same setup, and paste

7775
07:42:03,730 --> 07:42:07,330
it. Okay, great. We're gonna be
using ethers J, s, and r dot E

7776
07:42:07,330 --> 07:42:10,420
and V again. So we're going to
add these in const ethers equals

7777
07:42:10,420 --> 07:42:20,170
require ethers const, FS equals
require Fs extra. And then

7778
07:42:20,170 --> 07:42:27,880
require dot env. Config.
Alright, so right now, in our

7779
07:42:27,880 --> 07:42:30,850
dot env, we do have this private
key. And again, if you don't

7780
07:42:30,850 --> 07:42:33,340
want to have the private key in
their way you can just do is you

7781
07:42:33,340 --> 07:42:36,610
can do private key equals and
then you know, node, whatever

7782
07:42:36,610 --> 07:42:39,790
script you want to run. So we're
going to set this script up to

7783
07:42:39,790 --> 07:42:43,600
run our encrypt key one time.
And then we can remove our

7784
07:42:43,600 --> 07:42:46,420
private key from anywhere in our
workspace so that it's no longer

7785
07:42:46,420 --> 07:42:48,730
in plain text anywhere. So what
we want to do is we want to say

7786
07:42:48,730 --> 07:42:53,260
const wallet, and we're gonna
create a new wallet, but a

7787
07:42:53,260 --> 07:42:56,950
little bit differently. We're
gonna say equals new ethers dot

7788
07:42:56,980 --> 07:43:03,580
wallet, process dot E and V dot
private key. So we do need our

7789
07:43:03,580 --> 07:43:06,250
private key to stick in here.
But then once we create this

7790
07:43:06,250 --> 07:43:13,810
wallet, we're gonna say const.
Encrypted JSON key equals await

7791
07:43:14,230 --> 07:43:19,030
ethers dot encrypt, this encrypt
function is going to return an

7792
07:43:19,030 --> 07:43:23,170
encrypted JSON key that we can
store locally and that we can

7793
07:43:23,170 --> 07:43:26,350
only decrypt it with the
password. And it takes two

7794
07:43:26,350 --> 07:43:30,190
parameters. It takes a private
key password and a private key.

7795
07:43:30,250 --> 07:43:33,430
So in our dot EMV, just for
right, now we're going to create

7796
07:43:33,430 --> 07:43:38,500
a private key password. And I'm
going to say it's password. But

7797
07:43:38,500 --> 07:43:40,540
obviously, this is a terrible
password. And you should never

7798
07:43:40,540 --> 07:43:43,600
use password as your password.
But for now, we're just going to

7799
07:43:43,600 --> 07:43:46,720
leave it as password since I'm
encrypting this big key anyways.

7800
07:43:46,780 --> 07:43:49,660
So we're going to encrypt it by
passing the password process

7801
07:43:49,660 --> 07:43:53,890
study and v dot private key
password. And we're also going

7802
07:43:53,890 --> 07:43:56,500
to pass the private key, it's
going to be ethers, it's going

7803
07:43:56,500 --> 07:44:00,640
to be wallet dot encrypt. We're
also going to pass it process

7804
07:44:00,670 --> 07:44:04,990
dot EMV dot private key. Now
let's go ahead and run this

7805
07:44:04,990 --> 07:44:08,140
right now. And then we'll
console dot log out this

7806
07:44:08,140 --> 07:44:12,040
encrypted JSON key and see what
happens when we run this. So to

7807
07:44:12,040 --> 07:44:16,240
run this, we're going to do
node, encrypt key.js. And hit

7808
07:44:16,240 --> 07:44:19,270
enter. And we'll see what
happens when we console log it

7809
07:44:19,270 --> 07:44:23,260
out this JSON object here is
what our key looks like,

7810
07:44:23,530 --> 07:44:27,640
encrypted. So it's got the
address this ID version, all

7811
07:44:27,640 --> 07:44:31,060
this other stuff. And all this
other stuff is the encrypted

7812
07:44:31,060 --> 07:44:34,270
version of this key. If somebody
gets into our account and they

7813
07:44:34,270 --> 07:44:38,590
see this, they'll have to know
the password to decrypt this

7814
07:44:38,620 --> 07:44:40,930
private key, they'll need to
know the password to decrypt

7815
07:44:40,930 --> 07:44:44,260
this JSON object back into a
private key. So what we're going

7816
07:44:44,260 --> 07:44:47,140
to do, now that we've encrypted
it, we're going to save it. So

7817
07:44:47,140 --> 07:44:52,120
we'll do Fs dot write, file
sync, we're going to pass it to

7818
07:44:52,120 --> 07:44:59,320
dot slash dot encrypted key dot
JSON, comma encrypted JSON key.

7819
07:44:59,680 --> 07:45:02,950
So we're saving it to a new file
called dot encrypted key dot

7820
07:45:02,950 --> 07:45:06,340
JSON. And we're passing it this
encrypted key that we just made.

7821
07:45:06,700 --> 07:45:09,430
So if we open up our file
explorer, and we run this

7822
07:45:09,430 --> 07:45:10,150
command,

7823
07:45:12,160 --> 07:45:15,940
you'll see we get a new file
called dot encrypted key dot

7824
07:45:15,940 --> 07:45:19,570
JSON. And it's this encrypted
key here, which is awesome. So

7825
07:45:19,570 --> 07:45:22,900
now what we want to do in our
dot Git ignore is add dot

7826
07:45:22,900 --> 07:45:28,270
encrypted key dot JSON, so that
we don't accidentally push this

7827
07:45:28,270 --> 07:45:31,450
up to GitHub. And now we have an
encrypted key and we can go to

7828
07:45:31,450 --> 07:45:35,950
our private key and delete this
from our dot env file. We can

7829
07:45:35,950 --> 07:45:39,250
also delete our private key
password from our WMV file so

7830
07:45:39,250 --> 07:45:41,710
that the password isn't just
hanging around in plain text.

7831
07:45:41,860 --> 07:45:45,580
Now that We have an encrypted
key. Back in our deploy script,

7832
07:45:45,880 --> 07:45:49,570
we can change the way that we
actually get a wallet. So at the

7833
07:45:49,570 --> 07:45:52,210
top, we're getting our wallet
just by passing in the private

7834
07:45:52,210 --> 07:45:54,820
key like this, we're not going
to do that, we're going to use

7835
07:45:54,850 --> 07:45:58,300
our encrypted key that we just
created. So we're going to do is

7836
07:45:58,300 --> 07:46:03,160
we're going to say const
encrypted JSON equals Fs dot

7837
07:46:03,190 --> 07:46:11,470
read file sync. That slash dot
encrypted key dot JSON, comma

7838
07:46:12,100 --> 07:46:16,510
UTF eight, this Fs dot read file
sync is just going to read from

7839
07:46:16,510 --> 07:46:20,320
our encrypted key dot JSON into
this encrypted JSON variable

7840
07:46:20,320 --> 07:46:24,040
here. Next, we're going to
create a wallet from this

7841
07:46:24,040 --> 07:46:30,460
encrypted key. We're gonna say
let wallet equals new ethers dot

7842
07:46:30,460 --> 07:46:38,860
wallet, dot from encrypted JSON
sync. And all these commands

7843
07:46:38,920 --> 07:46:42,700
that we're working with ethers,
we can of course, find them in

7844
07:46:42,700 --> 07:46:46,000
the documentation from encrypted
JSON sync takes the encrypted

7845
07:46:46,000 --> 07:46:49,600
JSON and a password and returns
a Wallet Object. So we're going

7846
07:46:49,600 --> 07:46:53,530
to pass it that encrypted JSON
that we just read. And then

7847
07:46:53,530 --> 07:46:57,190
we're going to pass it password
which we're going to do process

7848
07:46:57,220 --> 07:47:03,340
dot EMP dot private key
password. And then finally, the

7849
07:47:03,340 --> 07:47:06,130
reason I use let here is because
now we have to connect this

7850
07:47:06,130 --> 07:47:09,520
wallet back to our provider. If
you look here, we're not

7851
07:47:09,520 --> 07:47:11,860
connecting our wallet with a
provider. When we make our

7852
07:47:11,860 --> 07:47:14,710
transactions with our contract
factory, we need to make sure

7853
07:47:14,710 --> 07:47:17,830
the wallet knows about the
provider here. So we can just

7854
07:47:17,830 --> 07:47:24,850
say wallet equals await wallet
dot connect provider. Now, if we

7855
07:47:24,850 --> 07:47:28,720
run our deploy dot j s with our
private key password as an

7856
07:47:28,720 --> 07:47:31,480
environment variable, it should
still deploy. So we can do

7857
07:47:31,480 --> 07:47:34,840
private key password equals
password, which yes, we know is

7858
07:47:34,840 --> 07:47:38,500
terrible. But that's what we're
using for now node deploy dot j

7859
07:47:38,500 --> 07:47:41,680
s, we should get the same output
we've been seeing this whole

7860
07:47:41,680 --> 07:47:47,050
time and we do we're able to no
longer have our private key in

7861
07:47:47,050 --> 07:47:49,990
our dot env file not in
plaintext anymore, it's in this

7862
07:47:49,990 --> 07:47:52,840
encrypted key. So that just in
case somebody hacks our

7863
07:47:52,840 --> 07:47:55,900
computer, they still won't be
able to send in new transactions

7864
07:47:55,930 --> 07:47:58,900
unless they know the password.
This is awesome. One more thing

7865
07:47:58,900 --> 07:48:02,620
to know, if you type history, if
somebody got into your computer,

7866
07:48:02,650 --> 07:48:05,170
a hacker could actually see
private key password equals

7867
07:48:05,170 --> 07:48:10,600
password in your bash history.
If you run history, dash c, you

7868
07:48:10,600 --> 07:48:14,080
actually will clear your
history. Now if I type history,

7869
07:48:14,080 --> 07:48:16,300
I can just see that the most
recent command I wrote was

7870
07:48:16,300 --> 07:48:19,150
history, this is really just
some of the bare minimum for

7871
07:48:19,180 --> 07:48:21,940
encryption and keeping your key
safe. And it might seem

7872
07:48:21,940 --> 07:48:24,310
ridiculous that somebody might
be able to hack your computer

7873
07:48:24,340 --> 07:48:26,680
and read your encrypted private
keys and everything. But as your

7874
07:48:26,680 --> 07:48:29,230
projects get bigger and bigger,
it is really important to know

7875
07:48:29,260 --> 07:48:32,710
about private key security and
private key safety and, and for

7876
07:48:32,710 --> 07:48:35,110
this course really just giving
you the bare minimum here and

7877
07:48:35,110 --> 07:48:38,170
showing you how to encrypt keys
and how to be a little bit safer

7878
07:48:38,170 --> 07:48:41,320
here. Now for the rest of this
course, we are going to be just

7879
07:48:41,320 --> 07:48:46,360
using this syntax with our
private key in a dot env file.

7880
07:48:46,390 --> 07:48:48,340
The reason why we're doing like
this for the rest of the course

7881
07:48:48,340 --> 07:48:51,070
is it is a little bit easier,
I'm really hoping Hardhead add

7882
07:48:51,070 --> 07:48:53,830
some additional features to make
private key encryption much

7883
07:48:53,830 --> 07:48:56,590
safer and also easier to use in
the future. And they probably

7884
07:48:56,590 --> 07:48:58,810
will. And the other reason that
we're okay to do this here is

7885
07:48:58,810 --> 07:49:01,360
because you've solemnly sworn
that you're not going to use an

7886
07:49:01,360 --> 07:49:03,760
account that has any real money
in it for the duration of this

7887
07:49:03,760 --> 07:49:06,160
course, you're only going to use
private keys that have tests on

7888
07:49:06,160 --> 07:49:08,800
Aetherium or are fake private
keys like this one that we got

7889
07:49:08,800 --> 07:49:12,790
from ganache. In fact just to
really hone this in in the smart

7890
07:49:12,790 --> 07:49:16,330
contract kit slash full blocked
in solidity course, Jas GitHub

7891
07:49:16,330 --> 07:49:20,710
repo in the discussions tab, you
go to announcements, I've

7892
07:49:20,710 --> 07:49:23,980
created one called the dot end
pledge. Because recently I've

7893
07:49:23,980 --> 07:49:27,070
seen too many people follow a
tutorial that doesn't tell them

7894
07:49:27,070 --> 07:49:30,370
about the security risks of
doing this. And I've made this

7895
07:49:30,370 --> 07:49:33,460
dot EMV pledge, I would love
everyone to jump on and read.

7896
07:49:33,460 --> 07:49:37,030
And if you agree, at the bottom,
leave a comment saying I will be

7897
07:49:37,030 --> 07:49:41,170
safe, I will be safe, make sure
you read and you understand

7898
07:49:41,170 --> 07:49:44,320
what's going on in here. And I'm
not doing this to scare you.

7899
07:49:44,350 --> 07:49:47,320
Because again, at the end of the
day, if you use a Metamask that

7900
07:49:47,350 --> 07:49:50,530
only has tests that funds for
the duration of this course, you

7901
07:49:50,530 --> 07:49:52,750
will never have to be worried
because of your key gets

7902
07:49:52,750 --> 07:49:56,170
compromised. It's just test it.
So who cares? This is if you're

7903
07:49:56,170 --> 07:49:58,810
using a meta mask or you're
working with a meta mask that

7904
07:49:58,810 --> 07:50:02,260
has real funds. So I'm going to
read up the pledge because it is

7905
07:50:02,350 --> 07:50:05,260
really important. You understand
this when you're working with

7906
07:50:05,260 --> 07:50:07,900
real funds. And if you're like,
Hey, I'm not working with real

7907
07:50:07,900 --> 07:50:11,920
funds, I don't care, great move
past this, whatever. But when

7908
07:50:11,920 --> 07:50:14,590
you do work with real funds,
when you do decide, hey, I

7909
07:50:14,590 --> 07:50:17,590
actually want to deploy this to
a real network. Now I need real

7910
07:50:17,590 --> 07:50:21,310
money to do that. Come back to
this pledge. Scroll the bottom

7911
07:50:21,310 --> 07:50:24,370
say I will be safe and make sure
you read and you understand

7912
07:50:24,370 --> 07:50:28,270
this. Okay, so the pledge is, I
solemnly swear that I will never

7913
07:50:28,270 --> 07:50:32,320
place a private key or secret
phrase or pneumonic in a dot env

7914
07:50:32,320 --> 07:50:35,980
file that is associated with any
real funds. Basically, you

7915
07:50:36,610 --> 07:50:39,340
basically never have your
private key or your pneumonic

7916
07:50:39,340 --> 07:50:43,840
phrase, in plain text, anywhere.
You'll all only place private

7917
07:50:43,840 --> 07:50:48,040
keys in a web file that only
have tested e FF link or other

7918
07:50:48,040 --> 07:50:51,790
cryptocurrencies. Because again,
if your private key has only

7919
07:50:51,790 --> 07:50:54,670
test net funds, then that's
great. I don't care, we are

7920
07:50:54,670 --> 07:50:58,540
aware that if we forget a dot
Git ignore, and we push our key

7921
07:50:58,540 --> 07:51:02,350
phrase to GitHub, even for a
split second, or even show our

7922
07:51:02,350 --> 07:51:05,590
key slash phrase on the
internet, wherever it may be for

7923
07:51:05,590 --> 07:51:08,680
a split second, it should be
considered compromised. And you

7924
07:51:08,680 --> 07:51:11,740
should remove all funds
immediately. So even if you

7925
07:51:11,770 --> 07:51:14,410
deploy your private key to a
website, and then immediately

7926
07:51:14,410 --> 07:51:17,620
delete your website and think,
Oh, nobody probably got to it,

7927
07:51:17,830 --> 07:51:20,350
you should consider that private
key compromised, and you should

7928
07:51:20,470 --> 07:51:23,440
remove all your funds. And
again, this is just for real

7929
07:51:23,440 --> 07:51:25,960
funds. If your private key was
only tested, funds gets

7930
07:51:25,960 --> 07:51:28,690
compromised. Well, who cares? I
do that all the time, you've

7931
07:51:28,690 --> 07:51:30,790
been seeing me do that all the
time, because it only has tested

7932
07:51:30,790 --> 07:51:33,040
funds in it. If at the end of
this course, you want to steal

7933
07:51:33,040 --> 07:51:36,250
all of my tests that funds I
mean, have a blast, it would be

7934
07:51:36,250 --> 07:51:39,910
annoying to me at worst. If I'm
unsure if my account has real

7935
07:51:39,910 --> 07:51:43,090
funds in it, I will assume it
has real funds in it. So if you

7936
07:51:43,090 --> 07:51:46,270
don't know if it has real funds,
assume it has real funds, and

7937
07:51:46,270 --> 07:51:48,940
you will not use it for
developing purposes. And then

7938
07:51:48,940 --> 07:51:52,600
finally, I am aware that even if
I hit Add Account on my meta

7939
07:51:52,600 --> 07:51:55,810
mask or other eath wallet, I
will get a new private key, but

7940
07:51:55,810 --> 07:51:59,620
it will share the same secret
phrase slash pneumonic of all

7941
07:51:59,620 --> 07:52:02,500
the other accounts generated in
the meta mask or other eath

7942
07:52:02,500 --> 07:52:06,580
Wallet. So if I'm in my meta
mask here, and I hit Create

7943
07:52:06,610 --> 07:52:09,850
account, I will get a new
private key with the new

7944
07:52:09,850 --> 07:52:13,210
account. However, all of these
accounts that I've created with

7945
07:52:13,210 --> 07:52:16,570
this Create Account button have
the exact same pneumonic phrase

7946
07:52:16,570 --> 07:52:20,080
or secret phrase. If I import an
account with a private key, it's

7947
07:52:20,080 --> 07:52:22,570
going to have a different
pneumonic phrase. But all of the

7948
07:52:22,570 --> 07:52:25,480
ones that I generate inside the
wallet are all going to have the

7949
07:52:25,480 --> 07:52:28,750
same phrase. Okay, great.
Hopefully that'll make sense. I

7950
07:52:28,750 --> 07:52:31,900
have some pledge additions here.
For this course, I will only use

7951
07:52:31,900 --> 07:52:34,780
funds associated with a brand
new never before use meta mask

7952
07:52:34,810 --> 07:52:37,870
or other eath wallet. Again,
this is not to scare you, if you

7953
07:52:37,870 --> 07:52:40,180
just work with a brand new meta
mask, you don't have to worry

7954
07:52:40,180 --> 07:52:42,910
about any of this and just refer
back to this when you start

7955
07:52:42,910 --> 07:52:46,300
looking at real money and real
private keys. I'm aware that my

7956
07:52:46,300 --> 07:52:49,420
account associated with my
private key is the same on test

7957
07:52:49,420 --> 07:52:53,200
nets that it is on Main nets. So
like I was showing you, my

7958
07:52:53,200 --> 07:52:55,870
private key on Rinkeby is going
to be the same as my private key

7959
07:52:55,870 --> 07:52:58,990
I'm on a main net, if I must use
a private key associated with

7960
07:52:58,990 --> 07:53:02,710
real funds in the future, until
I am 100% sure what I am doing,

7961
07:53:02,770 --> 07:53:06,250
I will always either use one of
the encrypted methods that

7962
07:53:06,250 --> 07:53:09,610
Patrick showed you some better
encryption stuff that I didn't

7963
07:53:09,610 --> 07:53:13,330
show or use the command line way
to pass private keys and then

7964
07:53:13,330 --> 07:53:16,330
delete the command line history
right after. If I'm never

7965
07:53:16,330 --> 07:53:18,910
actually deploying anything to
make that myself or work with a

7966
07:53:18,910 --> 07:53:21,340
private key with real funds. I
do not need to be concerned.

7967
07:53:21,520 --> 07:53:24,670
Take a look at this. Read this
internalize it, it should make

7968
07:53:24,670 --> 07:53:27,070
you confident. Now again, I'm
not saying this to scare you.

7969
07:53:27,100 --> 07:53:30,250
I'm saying this to instill
confidence in you that these are

7970
07:53:30,250 --> 07:53:33,610
some of the things that we want
to think about. Okay, great. In

7971
07:53:33,610 --> 07:53:36,250
here, I will be safe.

7972
07:53:37,900 --> 07:53:41,440
Boom, I will be safe. And if you
want to copy paste this on

7973
07:53:41,440 --> 07:53:44,860
Twitter, put this in a huge
tweet thread. Go for it. The

7974
07:53:44,860 --> 07:53:48,370
more people who know about this,
the more people who understand

7975
07:53:48,520 --> 07:53:51,700
the security risks of their WMV
files and their private keys,

7976
07:53:51,850 --> 07:53:54,430
the better. So thank you for
listening to this. I know I

7977
07:53:54,430 --> 07:53:57,160
definitely belabor the point,
but it is really important.

7978
07:53:57,550 --> 07:54:02,590
Let's continue with the course.
Alright, so we're just about

7979
07:54:02,590 --> 07:54:05,020
done here. However, there's one
or two more things we want to do

7980
07:54:05,020 --> 07:54:07,930
just to clean this all up right
now when we're auto saving

7981
07:54:07,960 --> 07:54:11,830
reason, the VS code plugin for
us to auto format. However, in

7982
07:54:11,830 --> 07:54:14,650
the future, if anybody else
comes across our repository,

7983
07:54:14,950 --> 07:54:18,010
they might not have the Vyas
code auto format or on. So we

7984
07:54:18,010 --> 07:54:21,760
want to give users a way to
format their code. So it matches

7985
07:54:21,790 --> 07:54:25,870
the styles that we use. So we
have prettier the extension

7986
07:54:25,870 --> 07:54:31,420
installed. We can also add
prettier as a Node js module

7987
07:54:31,480 --> 07:54:35,290
that can tell other users who
don't have a Vyas code exactly

7988
07:54:35,290 --> 07:54:38,170
how to format both their
JavaScript and the solidity.

7989
07:54:38,290 --> 07:54:41,440
There is a prettier plugin
solidity located here, there

7990
07:54:41,440 --> 07:54:44,350
will be a link to it in our
GitHub repo. And if we scroll

7991
07:54:44,350 --> 07:54:47,980
down, we can see how to install
with npm install dash dash save

7992
07:54:47,980 --> 07:54:50,950
Dev, which again, we're just
going to use yarn, so we're

7993
07:54:50,950 --> 07:54:58,960
going to do yarn, add prettier,
and then prettier plugin

7994
07:54:58,960 --> 07:55:03,430
solidity. So we're installing
both prettier, and the solidity

7995
07:55:03,430 --> 07:55:07,060
plugin for prettier. And if we
check our package, JSON, we can

7996
07:55:07,060 --> 07:55:09,820
see that these two have been
added. And what we can do now is

7997
07:55:09,820 --> 07:55:17,770
we can create a new file called
dot prettier, R C. And in this

7998
07:55:17,770 --> 07:55:22,000
file, we can define some little
curly braces. And here, we can

7999
07:55:22,000 --> 07:55:26,710
define what we want for both our
solidity and for a JavaScript,

8000
07:55:26,860 --> 07:55:30,610
so for example, our simple
storage has a tab width of

8001
07:55:30,640 --> 07:55:37,210
412344 spaces. Maybe we want to
change that. We want tab width

8002
07:55:38,020 --> 07:55:41,830
to be two. So we would save it
here and come back to simple

8003
07:55:41,830 --> 07:55:45,850
storage To save it here, and it
would get auto formatted to r

8004
07:55:45,850 --> 07:55:51,670
dot prettier RC. So in our
settings here, we have the

8005
07:55:51,670 --> 07:55:55,090
default editor for solidity, our
hard hat, solidity plugin, and

8006
07:55:55,090 --> 07:55:57,580
the default for meta for
JavaScript being the prettier

8007
07:55:57,580 --> 07:56:01,300
vs. Code one, when we add
prettier RC in here, this file

8008
07:56:01,300 --> 07:56:05,620
will take precedent over the
default configuration, so long

8009
07:56:05,650 --> 07:56:09,940
as we have downloaded the module
in our node modules, which we

8010
07:56:09,940 --> 07:56:13,270
can see it right here. And we
have this dot prettier rc file.

8011
07:56:14,890 --> 07:56:17,350
I'm going to keep the tab with
form. So we're going to update

8012
07:56:17,350 --> 07:56:20,200
it to that one thing that we
currently do have that I do not

8013
07:56:20,200 --> 07:56:25,450
like is these semicolons at the
end, so we're going to do semi

8014
07:56:27,100 --> 07:56:31,510
boss, and I'm going to save
this, come back to deploy it

8015
07:56:31,510 --> 07:56:34,690
save and you'll see the
semicolon automatically goes

8016
07:56:34,690 --> 07:56:38,470
away. I'm also going to add use
tabs false, since I want to use

8017
07:56:38,470 --> 07:56:43,960
spaces or spacing, and then
single quote, false. This way,

8018
07:56:43,960 --> 07:56:46,750
we'll always use a double quote,
instead of a single quote, in

8019
07:56:46,750 --> 07:56:49,330
JavaScript, you can actually use
the single quote or double

8020
07:56:49,330 --> 07:56:52,210
quote, to define strings, but
we're going to make it so that

8021
07:56:52,240 --> 07:56:54,790
no matter what quote you use,
it'll always be double quote.

8022
07:56:55,120 --> 07:56:58,060
And then for all your open
source repos, and for all your

8023
07:56:58,060 --> 07:57:02,530
projects that you make, you want
to make a readme.md readme files

8024
07:57:02,560 --> 07:57:05,530
are generally where people put
instructions or information

8025
07:57:05,530 --> 07:57:08,680
about your project or anything
like that. This way, whenever

8026
07:57:08,680 --> 07:57:11,200
anybody comes across your
project, they'll know what it's

8027
07:57:11,200 --> 07:57:15,790
about your readme dot MDs, our
Markdown syntax again, remember

8028
07:57:15,790 --> 07:57:19,960
how when we made that trial
discussion, we use some

8029
07:57:19,960 --> 07:57:23,560
interesting tips to format our
solidity in our code here. Well,

8030
07:57:23,560 --> 07:57:27,880
that formatting process is the
exact same for.md files for

8031
07:57:27,880 --> 07:57:31,450
markdown. They're both going to
use markdown. In fact, if we hit

8032
07:57:31,450 --> 07:57:35,380
Ctrl, Shift V, you'll enter
preview mode for the markdown

8033
07:57:35,440 --> 07:57:38,950
you'll see pound sign here in my
preview of the hard hat. This

8034
07:57:38,950 --> 07:57:42,790
ethers simple storage FCC is
huge. And it looks like a

8035
07:57:42,790 --> 07:57:47,710
heading at the top. So Command
Shift V to view your.md files or

8036
07:57:47,770 --> 07:57:51,100
or MIP Ctrl, Shift V for Windows
and Linux users.

8037
07:57:53,680 --> 07:57:56,890
The last thing that we're going
to do is we're going to deploy

8038
07:57:56,890 --> 07:58:00,940
this to a test net and interact
with this on a test net, we're

8039
07:58:00,940 --> 07:58:03,850
going to use the Rinkeby test
net. But be sure to use whatever

8040
07:58:03,850 --> 07:58:07,000
recommended test net the GitHub
repository for this coerce

8041
07:58:07,030 --> 07:58:10,990
recommends. Now looking at our
code, you might already have a

8042
07:58:10,990 --> 07:58:15,040
good idea of how to actually
make this slight change. Based

8043
07:58:15,040 --> 07:58:18,790
off of our last section, we know
that all we need is an RPC URL

8044
07:58:18,880 --> 07:58:21,820
and a private key and we can
begin making transactions on a

8045
07:58:21,820 --> 07:58:25,600
blockchain. So we're probably
going to need a rink B RPC URL,

8046
07:58:26,020 --> 07:58:29,680
and a rinky private key. Where
can we find both of those, if

8047
07:58:29,680 --> 07:58:32,050
you want to do everything on
your own, and in full

8048
07:58:32,050 --> 07:58:37,060
decentralized context, we could
run a rink B version of geth, we

8049
07:58:37,060 --> 07:58:39,490
could run it locally, and then
just connect to our guest node,

8050
07:58:39,640 --> 07:58:42,340
we're not going to be showing
how to do this here. However,

8051
07:58:42,370 --> 07:58:45,400
this is 100%, something that you
could do. Instead, we're gonna

8052
07:58:45,400 --> 07:58:49,540
use a third party RPC URL in the
GitHub repo associated with this

8053
07:58:49,540 --> 07:58:55,180
course. Go to Lesson five, we
can scroll down to get a link

8054
07:58:55,180 --> 07:58:59,800
for alchemy. Alchemy has a node
as a service and allows us to

8055
07:58:59,800 --> 07:59:02,800
connect to any blockchain that
they have support for two

8056
07:59:02,800 --> 07:59:06,520
alternates might be quick node,
Morales, or infura. These all

8057
07:59:06,520 --> 07:59:09,190
have node as a service options.
But we're going to work with

8058
07:59:09,190 --> 07:59:11,710
Alchemy, because it's the one
that I liked the best, we can go

8059
07:59:11,710 --> 07:59:14,620
ahead and get started for free
or login or create a new

8060
07:59:14,620 --> 07:59:17,950
account, I'm going to go ahead
and sign up with our hard hat

8061
07:59:18,040 --> 07:59:22,060
Free Code Camp user. And we're
going to select the Ethereum

8062
07:59:22,150 --> 07:59:25,210
blockchain ecosystem. Let's go
ahead and create our first app.

8063
07:59:25,270 --> 07:59:29,710
This is going to be we'll call
it Free Code Camp. RT hat. Our

8064
07:59:29,710 --> 07:59:36,730
app name will be ethers, simple
storage, FCC, and the network is

8065
07:59:36,730 --> 07:59:40,390
where we're going to choose rink
B. But you can see in here, we

8066
07:59:40,390 --> 07:59:43,120
can actually choose more than
just rink B, we can choose

8067
07:59:43,450 --> 07:59:48,280
really Kovan, rink B, ropsten.
And layer twos like arbitrage

8068
07:59:48,310 --> 07:59:51,730
and optimism, we're going to be
using rink B. So let's go ahead

8069
07:59:51,730 --> 07:59:55,300
and create this app. We're going
to choose the free plan and hit

8070
07:59:55,300 --> 07:59:59,920
Continue. We're going to skip
adding payments. If you want to

8071
07:59:59,920 --> 08:00:02,650
tweet your referral code, feel
free to tweet your referral

8072
08:00:02,650 --> 08:00:05,620
code. We're going to skip for
now. And we're going to keep it

8073
08:00:05,620 --> 08:00:08,530
at capped capacity. Since we
don't have a we don't have a key

8074
08:00:08,530 --> 08:00:11,110
in here. And then how did you
hear about us go ahead and give

8075
08:00:11,110 --> 08:00:13,660
me that shout out at Patrick and
Free Code Camp and then hit

8076
08:00:13,660 --> 08:00:16,990
Let's go. Now we get to the
alchemy dashboard, where we can

8077
08:00:16,990 --> 08:00:20,410
see a ton of information about
our node and different ways to

8078
08:00:20,410 --> 08:00:23,200
connect to the nodes and and
stuff like that. This is going

8079
08:00:23,200 --> 08:00:29,050
to be really similar to to this
RPC server endpoint of ganache,

8080
08:00:29,080 --> 08:00:31,720
except it's going to be a
connection, except it's going to

8081
08:00:31,720 --> 08:00:34,990
be a connection to a real test
net or real main net. What we

8082
08:00:34,990 --> 08:00:39,130
can do now is we can select our
our app that we just made. And

8083
08:00:39,130 --> 08:00:42,700
we can hit View key. And we can
see here we get an API key Key,

8084
08:00:43,120 --> 08:00:46,840
we add an HTTP endpoint and we
also get a WebSocket. We're only

8085
08:00:46,840 --> 08:00:50,230
concerned with the HTTP
endpoint. This is going to be

8086
08:00:50,230 --> 08:00:54,760
our RPC URL that connects to
rink B. So what we can do now is

8087
08:00:54,760 --> 08:00:58,540
we can copy this and come over
to our Visual Studio code. And

8088
08:00:58,540 --> 08:01:02,380
in our dot env, we can
substitute these out for their

8089
08:01:02,380 --> 08:01:06,310
actual tests and values. So for
RPC URL, we're going to delete

8090
08:01:06,310 --> 08:01:10,660
this and replace it with our
Rigby RPC row. And now how do we

8091
08:01:10,660 --> 08:01:14,230
get a private key for an actual
test set that has actual rank be

8092
08:01:14,230 --> 08:01:18,280
on it? Well, here is where we
can use our meta masks. So back

8093
08:01:18,280 --> 08:01:21,790
in your browser, go over to your
meta mask, select the three

8094
08:01:21,790 --> 08:01:27,700
dots, go to Account Details,
export private key. And this is

8095
08:01:27,700 --> 08:01:31,180
where you can export your
private key, type in your

8096
08:01:31,180 --> 08:01:34,270
password and boom, you now have
your private key for your

8097
08:01:34,270 --> 08:01:38,260
account on meta mask. Now
remember, please, please, please

8098
08:01:38,620 --> 08:01:43,090
don't continue with a meta mask
that has actual money in it. A

8099
08:01:43,090 --> 08:01:46,480
quick way to check is by going
to your networks tab and seeing

8100
08:01:46,900 --> 08:01:50,230
if on any of the main nets or
the networks with actual money

8101
08:01:50,230 --> 08:01:53,140
in it, you see any money, I
don't have any money in this. So

8102
08:01:53,140 --> 08:01:55,630
I know I'm good to go. If you
have tests that money, that's

8103
08:01:55,630 --> 08:01:58,540
fine, because that's fake money
anyways. And again, most

8104
08:01:58,540 --> 08:02:01,180
browsers have a profile
mechanism where you can create a

8105
08:02:01,180 --> 08:02:05,260
new profile for you to use. But
here now that I've copied my

8106
08:02:05,470 --> 08:02:08,800
private key, we can come back to
our Visual Studio code, paste

8107
08:02:08,800 --> 08:02:12,640
the key in here. And now I have
a private key that has actual

8108
08:02:12,670 --> 08:02:16,450
rink be in it. Awesome. And
remember, if you ever get low,

8109
08:02:16,750 --> 08:02:20,950
just come over to faucets dot
chain dot link slash Rigby get

8110
08:02:20,950 --> 08:02:25,780
some tests eath I'm not a robot
will send the request. Now that

8111
08:02:25,780 --> 08:02:29,530
we have our private key in our
rink being here, we can now try

8112
08:02:29,530 --> 08:02:33,250
to run this on an actual test.
Net, we look at our code, we see

8113
08:02:33,280 --> 08:02:36,760
we're grabbing an RPC URL, which
is going to be from r dot end,

8114
08:02:37,000 --> 08:02:38,860
we're grabbing a private key
which is going to be from our

8115
08:02:38,860 --> 08:02:42,190
daughter Yun V, which points to
our rink D Metamask. And our

8116
08:02:42,190 --> 08:02:47,380
rink B blockchain. So let's just
add a console dot log under our

8117
08:02:47,380 --> 08:02:50,770
contract deployment so that we
know what address it's at. So

8118
08:02:50,770 --> 08:02:55,090
we'll do console dot log, we'll
do some string interpolation,

8119
08:02:55,540 --> 08:02:58,120
contract, address,

8120
08:02:59,560 --> 08:03:04,600
contract dot address. All right,
great. Now let's go ahead and

8121
08:03:04,600 --> 08:03:09,160
run this. So we'll do node
deploy dot J. S deploying Please

8122
08:03:09,160 --> 08:03:12,490
wait, you'll notice this takes a
lot longer. Because we're

8123
08:03:12,490 --> 08:03:15,790
deploying to a test net instead
of our own fake local

8124
08:03:15,790 --> 08:03:19,000
blockchain, test nets and real
networks often will take a

8125
08:03:19,000 --> 08:03:21,670
little bit longer because they
need to wait for the blocks to

8126
08:03:21,670 --> 08:03:25,510
propagate the transaction to go
through, etc. But after a brief

8127
08:03:25,510 --> 08:03:29,350
delay, we will indeed see that
we get a contract address here.

8128
08:03:29,500 --> 08:03:31,900
And we have a current favorite
number. And it's being a little

8129
08:03:31,900 --> 08:03:34,570
slow again, because we're
waiting for our next transaction

8130
08:03:34,570 --> 08:03:37,690
to go through to update the
number and boom, looks like

8131
08:03:37,720 --> 08:03:40,690
we've successfully updated it.
Now something that's important

8132
08:03:40,690 --> 08:03:45,460
to know if ever you run command,
and you want to kill it, you can

8133
08:03:45,460 --> 08:03:49,780
do Ctrl C, and that will stop
it. So any command in the

8134
08:03:49,780 --> 08:03:54,250
terminal that you want to just
abort Ctrl. C is your Get Out of

8135
08:03:54,250 --> 08:03:56,530
Jail Free card and that will
kill it. That'll stop it

8136
08:03:56,530 --> 08:04:00,460
wherever it is. So we'll use
Ctrl C a lot in the future. So

8137
08:04:00,460 --> 08:04:04,540
now let's grab this contract
address and go over to Frank V

8138
08:04:04,540 --> 08:04:12,190
ether scan and paste it in, we
can see our two transactions

8139
08:04:12,190 --> 08:04:15,970
here, we can see we have a
contract creation. And we can

8140
08:04:15,970 --> 08:04:19,870
also see we call a store
function. This is awesome. We've

8141
08:04:19,870 --> 08:04:24,430
successfully deployed a contract
to the wrinkly chain using our

8142
08:04:24,430 --> 08:04:31,150
own code. Congratulations, this
is massive. Now on ether scan,

8143
08:04:31,180 --> 08:04:34,840
we actually can verify and
publish our contract code. What

8144
08:04:34,840 --> 08:04:39,010
is verifying and publishing your
code? Well, right now, our code

8145
08:04:39,010 --> 08:04:42,820
looks like a huge gerbil of
bytecode. And anybody looking at

8146
08:04:42,820 --> 08:04:45,730
our contract directly on chain
will just see this huge jumble

8147
08:04:45,730 --> 08:04:49,000
of bytecode, we can use a
decompiler to try to decompile

8148
08:04:49,000 --> 08:04:51,670
the bytecode into what it looks
like in solidity. But this can

8149
08:04:51,670 --> 08:04:55,540
often take a long time and, and
a lot of processing power. So

8150
08:04:55,540 --> 08:04:58,570
instead, we can just make it
much easier by verifying and

8151
08:04:58,570 --> 08:05:02,320
publishing the code ourself, you
go ahead and hit verify and

8152
08:05:02,320 --> 08:05:06,310
publish. We can scroll down and
we can add compiler information

8153
08:05:06,310 --> 08:05:09,610
to compile this on ether scan
and other block explorers. This

8154
08:05:09,640 --> 08:05:14,170
is a single file compiler
version is zero point 8.7. And

8155
08:05:14,170 --> 08:05:17,560
it's open source is licensed is
MIT. Let's go ahead and

8156
08:05:17,560 --> 08:05:21,550
continue. And we're going to
copy paste our solidity code

8157
08:05:22,450 --> 08:05:26,470
into this large section. Paste.
We don't have any constructor

8158
08:05:26,470 --> 08:05:30,250
arguments so we can skip this
section. We don't have any

8159
08:05:30,250 --> 08:05:33,910
libraries or any other
miscellaneous settings. So we'll

8160
08:05:33,910 --> 08:05:38,890
select I'm not a robot and we'll
hit verify and publish. You

8161
08:05:38,890 --> 08:05:41,530
might have to wait a few
minutes, but awesome. Our

8162
08:05:41,530 --> 08:05:45,790
contract was successfully
compiled. Now if we go back to

8163
08:05:45,820 --> 08:05:50,500
contract source code, we can see
all the code in here. And if we

8164
08:05:50,500 --> 08:05:54,970
grab our contract address, place
it into place into the search

8165
08:05:54,970 --> 08:05:58,390
now, and we go to contract, we
get a little green checkmark.

8166
08:05:58,420 --> 08:06:01,750
And we can see, anybody can now
read our source code.

8167
08:06:02,050 --> 08:06:05,080
Additionally, those buttons that
we saw and remix for reading

8168
08:06:05,080 --> 08:06:08,320
from our contract, and writing
to our contract, are in this

8169
08:06:08,320 --> 08:06:11,410
read contract and this write
contract. If we read the

8170
08:06:11,410 --> 08:06:15,460
contract, and we retrieve the
most recent number, we do indeed

8171
08:06:15,460 --> 08:06:17,740
see that we have seven here
because we recently stored

8172
08:06:17,740 --> 08:06:21,910
seven. Awesome, quick note, this
might already be verified for

8173
08:06:21,910 --> 08:06:24,790
you, since ether scan might get
smart enough to notice that a

8174
08:06:24,790 --> 08:06:27,280
lot of people are deploying the
same bytecode it's already

8175
08:06:27,280 --> 08:06:29,620
verified for you just go ahead
and walk through these steps

8176
08:06:29,620 --> 08:06:32,290
anyways. Now the code
verification we just did was

8177
08:06:32,320 --> 08:06:34,900
pretty simple and
straightforward, because our

8178
08:06:34,900 --> 08:06:37,630
code was pretty simple and
straightforward. Using larger

8179
08:06:37,630 --> 08:06:41,230
and more complex code can make
the verification process a

8180
08:06:41,230 --> 08:06:44,290
little bit harder. Additionally,
we don't always want to have to

8181
08:06:44,320 --> 08:06:47,770
click buttons on ether scan. To
verify our code, we want to do

8182
08:06:47,770 --> 08:06:50,770
it programmatically. So in later
sections, we'll learn how to

8183
08:06:50,770 --> 08:06:55,390
verify all of our code directly
through our code editor, you can

8184
08:06:55,390 --> 08:06:59,410
imagine the process is this easy
for deploying to any EVM chain

8185
08:06:59,590 --> 08:07:02,590
in our alchemy, we could easily
create a new app and change our

8186
08:07:02,590 --> 08:07:05,860
network. And you could see how
easy it would be to just switch

8187
08:07:05,860 --> 08:07:08,860
out this RPC URL and your
private key to work on a

8188
08:07:08,860 --> 08:07:12,460
different chain. This process is
also the same for harmony

8189
08:07:12,490 --> 08:07:16,480
Phantom, avalanche, etc. And if
we wanted to switch chains, we

8190
08:07:16,480 --> 08:07:20,620
would just switch the RPC URL
and switch the private key, and

8191
08:07:20,650 --> 08:07:26,950
everything else would stay
exactly the same. Now, Alchemy

8192
08:07:26,980 --> 08:07:30,700
also shows us and can teach us a
lot about transactions and about

8193
08:07:30,700 --> 08:07:33,910
things that are going on behind
the scenes, including a concept

8194
08:07:33,910 --> 08:07:36,850
called the mempool. To help us
understand a little bit more

8195
08:07:36,850 --> 08:07:39,460
about those transactions that we
just sent, and how to work with

8196
08:07:39,460 --> 08:07:42,280
Alchemy. To see more about our
transactions, we have Albert

8197
08:07:42,280 --> 08:07:44,380
from the alchemy team to give us
a little demonstration.

8198
08:07:45,070 --> 08:07:50,530
Hello, Albert here from alchemy,
I'm that guy in tech on Twitter,

8199
08:07:51,070 --> 08:07:53,320
feel free to follow if you want
to engage and ask any questions

8200
08:07:53,320 --> 08:07:56,080
about this section of the video.
But super excited to join

8201
08:07:56,080 --> 08:07:59,380
Patrick here to explain a little
bit of what goes on behind the

8202
08:07:59,380 --> 08:08:02,380
scenes when you are using
alchemy to submit a transaction.

8203
08:08:02,710 --> 08:08:05,860
And we have a ton of tools to
actually provide a window of

8204
08:08:05,860 --> 08:08:09,850
visibility into what's going on
so that you can actually debug

8205
08:08:09,940 --> 08:08:13,240
in case there are usage errors
on your website, or there are

8206
08:08:13,240 --> 08:08:16,510
pending transactions that are
stuck. Whatever it is, we

8207
08:08:16,510 --> 08:08:19,900
provide that window into the
data that you control. Remember

8208
08:08:20,050 --> 08:08:22,330
that all the transactions that
you submit are recorded on the

8209
08:08:22,330 --> 08:08:24,280
blockchain. They're not
controlled by alchemy, they're

8210
08:08:24,280 --> 08:08:27,490
not controlled by any other
service provider. We are just a

8211
08:08:27,490 --> 08:08:31,570
window, we're just the plumbing
the piping to be useful to you.

8212
08:08:32,020 --> 08:08:35,020
So let me show you exactly what
that means. Right now I have a

8213
08:08:35,020 --> 08:08:37,510
bunch of applications in my
dashboard. You can see here that

8214
08:08:37,540 --> 08:08:40,210
there are different projects
that I've used over time. This

8215
08:08:40,210 --> 08:08:43,030
one is the most recently active,
and it is the one that I have

8216
08:08:43,030 --> 08:08:46,570
currently set up to connect to
my meta mask. So actually use a

8217
08:08:46,570 --> 08:08:49,720
custom RPC provider here. And
let me make my face a little

8218
08:08:49,720 --> 08:08:53,020
smaller. And you can see here,
I've misspelled Rinkeby. But

8219
08:08:53,020 --> 08:08:56,530
this right now, my my network is
actually connected to the

8220
08:08:56,530 --> 08:09:00,580
Rinkeby test network via
alchemy. So this is actually

8221
08:09:00,580 --> 08:09:02,740
this application. So if I click
into here in the dashboard, you

8222
08:09:02,740 --> 08:09:05,800
can see here, a bunch of really
interesting statistics, this is

8223
08:09:05,800 --> 08:09:08,680
the first thing that you'll
probably use. If you're trying

8224
08:09:08,680 --> 08:09:11,740
to understand more about your
application, you'll go here and

8225
08:09:11,740 --> 08:09:15,040
you can see how many compute
units per second your

8226
08:09:15,040 --> 08:09:18,550
application is currently using.
And this is kind of great for

8227
08:09:18,580 --> 08:09:22,420
specifically alchemy usage,
understanding. But then this is

8228
08:09:22,420 --> 08:09:25,330
also really useful to see like,
what's the median response time,

8229
08:09:25,660 --> 08:09:29,350
and so 33 milliseconds is pretty
good. If that starts to

8230
08:09:29,350 --> 08:09:31,810
increase, then you might want to
figure out, you know, what's

8231
08:09:31,810 --> 08:09:35,230
going on here, success rate, it
has been kind of low. So that is

8232
08:09:35,230 --> 08:09:39,310
a clue for me to click on this
tab to view recent invalid

8233
08:09:39,310 --> 08:09:42,370
requests. And that I can
actually see oh, there's a bunch

8234
08:09:42,370 --> 08:09:42,640
of

8235
08:09:44,260 --> 08:09:47,590
failed transactions where the
transaction has already been

8236
08:09:47,590 --> 08:09:51,010
sent or the nonce is too low, or
whatever it is, I can actually

8237
08:09:51,010 --> 08:09:54,700
use this tab to debug. So that
success rate is pretty useful.

8238
08:09:54,970 --> 08:09:58,330
Throughput that's been limited.
So if you are sending too many

8239
08:09:58,330 --> 08:10:00,910
requests or your website is
getting spammed, you might start

8240
08:10:00,910 --> 08:10:05,230
getting some requests blocked.
So that's what's useful to view

8241
08:10:05,230 --> 08:10:09,370
their concurrent requests over
here, success rate in the past

8242
08:10:09,370 --> 08:10:12,940
24 hours versus the past one
hour, the total number of

8243
08:10:12,940 --> 08:10:15,730
requests in the last 24 hours.
And this is different than

8244
08:10:15,880 --> 08:10:18,670
compute units, because each
request can have a different

8245
08:10:18,670 --> 08:10:22,420
level of computing cost. And
computing cost as measured by

8246
08:10:22,420 --> 08:10:26,410
compute units. Total requests is
just the actual number of

8247
08:10:26,410 --> 08:10:29,410
absolute requests. And then of
course, the number of invalid

8248
08:10:29,410 --> 08:10:33,550
request. Cool. So one thing I do
want to show you that's

8249
08:10:33,580 --> 08:10:36,460
interesting is when I do submit
a transaction, and I actually

8250
08:10:36,490 --> 08:10:40,120
have one right here, I want to
send so let's transfer between

8251
08:10:40,120 --> 08:10:43,000
my accounts, and I'm just gonna
send it to tiny amount of

8252
08:10:43,000 --> 08:10:47,920
Rinkeby eath. But I'm going to
purposefully edit my gas fees to

8253
08:10:47,920 --> 08:10:53,320
be super, super low so that the
node will actually not muck send

8254
08:10:53,320 --> 08:10:55,810
the transaction to be mined, or
there are no miners that will

8255
08:10:55,810 --> 08:10:58,810
actually pick it up. So you can
see here I've divided the the

8256
08:10:58,810 --> 08:11:02,500
priority fee and the max fee by
a ton. So it's super low. And it

8257
08:11:02,500 --> 08:11:05,800
might confirm that in the MME
Max UI, you'll see that the

8258
08:11:05,800 --> 08:11:08,590
transaction has been pending for
a bit. And we'll go over to this

8259
08:11:08,590 --> 08:11:12,970
mempool tab. This is another
really useful visualization. And

8260
08:11:12,970 --> 08:11:17,080
what the mempool is, is a kind
of a holding ground, I like to

8261
08:11:17,080 --> 08:11:20,470
think of it as the waiting room
of a restaurant, where if you're

8262
08:11:20,470 --> 08:11:23,470
a transaction, and you're
waiting to get mined, the

8263
08:11:23,470 --> 08:11:25,510
mempool is kind of like the
waiting room where you're

8264
08:11:25,510 --> 08:11:29,320
waiting to get seated. So there
are different statuses for your

8265
08:11:29,320 --> 08:11:32,500
each of your transactions, the
ones that you always want to see

8266
08:11:32,530 --> 08:11:35,290
are the mines transactions,
because that says that your

8267
08:11:35,290 --> 08:11:37,990
transaction is successful. And
it's now part of the blockchain.

8268
08:11:38,500 --> 08:11:42,010
Now, the mempool, every node has
its own, you know, holding

8269
08:11:42,010 --> 08:11:44,230
ground. So I can actually show
you this quick visualization.

8270
08:11:44,230 --> 08:11:48,460
Remember, blockchains are run by
a network of nodes. And each

8271
08:11:48,460 --> 08:11:51,280
node or each computer that's
running the theorem, software

8272
08:11:51,310 --> 08:11:55,570
maintains a copy of the
blockchain. And as a developer,

8273
08:11:55,570 --> 08:11:58,600
you have to use these nodes to
make requests to the blockchain.

8274
08:11:58,630 --> 08:12:01,750
Now you can use alchemy, you can
use another RPC provider, you

8275
08:12:01,750 --> 08:12:04,600
can spin up your own node if you
want to. But regardless, you

8276
08:12:04,600 --> 08:12:07,420
need to use a node to
communicate with the chain. Now

8277
08:12:07,450 --> 08:12:11,890
each node beyond having a copy
of the entire blockchain state,

8278
08:12:11,920 --> 08:12:16,420
it also has a local memory of
transaction. And that's called

8279
08:12:16,450 --> 08:12:19,330
mempool. So if there are pending
transactions that are waiting to

8280
08:12:19,330 --> 08:12:23,080
be mined, you can consider them
as being in the mempool. Now

8281
08:12:23,080 --> 08:12:25,750
that's what we're looking at
right here. If we click on the

8282
08:12:25,750 --> 08:12:29,980
app that I am currently using
for my Metamask RPC, then you

8283
08:12:29,980 --> 08:12:34,750
can see here that there are,
this is not the right one, this

8284
08:12:34,750 --> 08:12:37,660
one is the right one for
wrinkling. For all the

8285
08:12:37,660 --> 08:12:39,670
transactions here, you can see
some more drop in placed

8286
08:12:39,670 --> 08:12:42,400
somewhere mind and there's one
that's pending, and this

8287
08:12:42,400 --> 08:12:45,580
pending, one actually matches up
with the one that is pending,

8288
08:12:45,700 --> 08:12:49,510
here, it's being sent to 0x, C,
BB. And if we click on this

8289
08:12:49,510 --> 08:12:52,210
transaction hash, you get all
the information that you need to

8290
08:12:52,210 --> 08:12:56,050
debug. So you can see here that
it's from my current address,

8291
08:12:56,680 --> 08:13:01,390
0x, five F, and then it's two
0x, C, BB. And here's the value

8292
08:13:01,390 --> 08:13:05,350
that I'm trying to send. Here's
the gas fee that I've attached

8293
08:13:05,380 --> 08:13:08,200
to this transaction. And you'll
notice that that is super low,

8294
08:13:08,230 --> 08:13:11,560
even for the Rinkeby test
network. So knowing this, and

8295
08:13:11,560 --> 08:13:14,140
seeing, wow, this transaction
has been pending for one minute

8296
08:13:14,140 --> 08:13:18,070
and 46 seconds, it was sent at
this time, I should probably fix

8297
08:13:18,070 --> 08:13:22,630
that. And so over here, you can
actually use the metamath RPC,

8298
08:13:23,110 --> 08:13:27,220
meta meta mask API. And speeded
up. And then I'm just going to

8299
08:13:27,220 --> 08:13:31,900
use the auto high speed up to
update the gas fees. And then if

8300
08:13:31,900 --> 08:13:36,160
we go back to our dashboard back
to our application, you can see

8301
08:13:36,160 --> 08:13:39,310
that there are some new recent
invalid requests. And this is

8302
08:13:39,310 --> 08:13:42,820
because we've resubmitted a
transaction, and then in their

8303
08:13:43,000 --> 08:13:47,620
recent requests we have, let's
refresh that real quick. You can

8304
08:13:47,620 --> 08:13:50,770
see that we are sending a raw
transaction, this one's already

8305
08:13:50,770 --> 08:13:54,130
known. And there's another one
before, but it that's resulting

8306
08:13:54,160 --> 08:13:57,490
in a get transaction receipt
that is successful. And then if

8307
08:13:57,490 --> 08:14:00,340
we go back to the mempool, you
can see boom, no more pending

8308
08:14:00,340 --> 08:14:04,510
transactions only dropped and
replaced and mined. So this

8309
08:14:04,510 --> 08:14:07,450
transaction nonce number five is
now successful, and you're on

8310
08:14:07,450 --> 08:14:10,510
your way to developing and
maintaining the rest of your

8311
08:14:10,510 --> 08:14:13,750
application. So yeah, thanks
hope that was useful. Let me

8312
08:14:13,750 --> 08:14:14,800
know if you have any questions.

8313
08:14:19,990 --> 08:14:22,360
Now, other than the TypeScript
portion, which I'll do at the

8314
08:14:22,360 --> 08:14:26,110
end, you've successfully
completed this section. And wow,

8315
08:14:26,110 --> 08:14:29,740
you've learned a ton. Let's do a
quick review of everything that

8316
08:14:29,740 --> 08:14:32,050
we've learned. Well, first,
we've learned how to create new

8317
08:14:32,050 --> 08:14:35,380
projects with Node js, we've
learned what the node keyword

8318
08:14:35,380 --> 08:14:39,760
does and how we can use the node
keyword. To run JavaScript in

8319
08:14:39,760 --> 08:14:42,070
our local development
environment, we learned that we

8320
08:14:42,070 --> 08:14:45,970
can add different dependencies
of external packages into our

8321
08:14:45,970 --> 08:14:49,600
local package using yarn or NPM.
And we can see those

8322
08:14:49,720 --> 08:14:52,930
dependencies added in package
dot JSON, we know that they've

8323
08:14:52,930 --> 08:14:55,570
been installed because they get
installed into the node modules

8324
08:14:55,570 --> 08:14:58,450
folder, we can also create a
script section where we can

8325
08:14:58,450 --> 08:15:01,690
minimize long commands that we
need to run into a single

8326
08:15:01,690 --> 08:15:04,450
keyword, like compile for
example, we can just run yarn

8327
08:15:04,450 --> 08:15:08,290
compile. To compile all of our
code, we learned the basic setup

8328
08:15:08,320 --> 08:15:11,830
of our JavaScript scripts, we
import our packages at the top,

8329
08:15:12,070 --> 08:15:15,550
we have some main executor
function at the bottom. And then

8330
08:15:15,550 --> 08:15:19,570
we have our main function in the
middle, we use the async keyword

8331
08:15:19,660 --> 08:15:23,290
so that our function can use
asynchronous programming, and we

8332
08:15:23,290 --> 08:15:27,370
get access to the await keyword,
which basically means Hey, wait

8333
08:15:27,370 --> 08:15:31,300
for this promise to finish doing
its thing. We're able to connect

8334
08:15:31,300 --> 08:15:35,800
to any blockchain we want using
an RPC URL, and then we're able

8335
08:15:35,800 --> 08:15:39,970
to connect our provider to a
wallet or a private key in

8336
08:15:39,970 --> 08:15:42,610
ethers by doing something like
this. Speaking of So we've

8337
08:15:42,610 --> 08:15:45,100
learned about the ethers
package, which is a tool that

8338
08:15:45,100 --> 08:15:48,640
makes our life a lot easier to
interact with the blockchain in

8339
08:15:48,640 --> 08:15:51,610
JavaScript, if we decide to,
we've also learned we can

8340
08:15:51,610 --> 08:15:55,330
encrypt our private keys so that
even if our computers get

8341
08:15:55,330 --> 08:15:58,510
hacked, our private keys aren't
lying around in plaintext. And

8342
08:15:58,510 --> 08:16:02,500
we've learned how to run scripts
from our encrypted keys. We've

8343
08:16:02,500 --> 08:16:05,260
learned how to get the ABI or
the application binary

8344
08:16:05,260 --> 08:16:08,860
interface, and the binary of our
code to deploy to a blockchain,

8345
08:16:08,950 --> 08:16:11,560
we've learned how to deploy our
contracts to a blockchain

8346
08:16:11,560 --> 08:16:14,170
programmatically. And then we've
learned how to interact with our

8347
08:16:14,170 --> 08:16:16,750
contracts programmatically as
well. Additionally, we've

8348
08:16:16,750 --> 08:16:20,500
learned how to add a default
editor in our settings dot JSON

8349
08:16:20,530 --> 08:16:24,250
of our VS code. But we've also
learned how to override those

8350
08:16:24,250 --> 08:16:28,570
settings by adding prettier
using a dot prettier rc file

8351
08:16:28,600 --> 08:16:31,990
this way, we can auto format our
code to make it look a lot nicer

8352
08:16:31,990 --> 08:16:34,600
and much easier to read.
Finally, we learned how to

8353
08:16:34,600 --> 08:16:38,410
deploy one of these contracts to
a real test net or a real

8354
08:16:38,410 --> 08:16:42,400
network. And then we finally
learned the manual way to verify

8355
08:16:42,430 --> 08:16:45,100
our contract source code. Like I
said, we're going to learn a lot

8356
08:16:45,100 --> 08:16:47,530
of shortcuts. And a lot of ways
to make this all a little bit

8357
08:16:47,530 --> 08:16:51,940
easier in coming sections. Oh,
you have done a phenomenally to

8358
08:16:51,940 --> 08:16:54,730
reach this section, give
yourself a pat on the back, take

8359
08:16:54,730 --> 08:16:57,520
a break, go for a lap, and feel
really proud about yourself that

8360
08:16:57,520 --> 08:17:00,520
you made it this far, we've got
a lot more to go. But you have

8361
08:17:00,520 --> 08:17:04,420
come a phenomenally long way.
Congratulations. Or take that

8362
08:17:04,420 --> 08:17:06,790
five to 10 minute break and come
back when you're ready.

8363
08:17:09,610 --> 08:17:12,760
Now the one thing left I want to
show you all is the TypeScript

8364
08:17:12,760 --> 08:17:15,190
addition to this. However, if
you're not interested in the

8365
08:17:15,190 --> 08:17:17,560
TypeScript edition, which you
don't have to be, then you're

8366
08:17:17,560 --> 08:17:20,920
done, there's only a couple of
changes we need to make to make

8367
08:17:20,920 --> 08:17:23,980
this TypeScript compatible.
First, of course, we're going to

8368
08:17:23,980 --> 08:17:28,240
change our deploy.ts and encrypt
key, we're going to change our

8369
08:17:28,240 --> 08:17:33,370
deploy and our encrypt key from
dot j s two.ts. And then we're

8370
08:17:33,370 --> 08:17:37,360
also going to swap these
requires out for imports. So

8371
08:17:37,360 --> 08:17:43,180
we're going to import ethers
from ethers, we're going to

8372
08:17:43,180 --> 08:17:51,070
import star as Fs from Fs extra.
And then we're going to import

8373
08:17:51,430 --> 08:17:55,060
dot TMP slash config. And then
we're just going to copy these,

8374
08:17:55,270 --> 08:17:59,710
and we're gonna come over and
paste them into here, deleting

8375
08:17:59,710 --> 08:18:03,550
or commenting out the requires,
okay, great. Now, if we try to

8376
08:18:03,550 --> 08:18:07,750
run Node deploy.ts, we're going
to get cannot use input

8377
08:18:07,750 --> 08:18:11,320
statement outside of a module.
In JavaScript, if we'd want to

8378
08:18:11,320 --> 08:18:14,230
use an import statement outside
of a module, we'd come in here

8379
08:18:14,230 --> 08:18:19,630
and do some like type module
like that. But in TypeScript, we

8380
08:18:19,630 --> 08:18:23,860
actually don't even need that.
All we need to do is run this in

8381
08:18:23,920 --> 08:18:27,100
TypeScript note. So to add
TypeScript, we're going to do

8382
08:18:27,100 --> 08:18:32,920
yarn, add TypeScript. And we're
also going to add TS node. TS

8383
08:18:32,920 --> 08:18:36,550
node is the TypeScript edition
of node. So now that we've added

8384
08:18:36,550 --> 08:18:40,570
that we can try a TS node
deploy.ts. And we're still going

8385
08:18:40,570 --> 08:18:44,110
to run into an error. And if you
scroll up, we're gonna get a

8386
08:18:44,110 --> 08:18:47,710
couple errors here. We're gonna
say, could not find a

8387
08:18:47,710 --> 08:18:51,490
declaration file for Module Fs
extra, we need to add the

8388
08:18:51,490 --> 08:18:56,050
TypeScript version of them. So
we're gonna do yarn at types

8389
08:18:56,080 --> 08:19:01,360
slash Fs extra. That, and if we
run it again, it still shouldn't

8390
08:19:01,360 --> 08:19:03,910
work. But for a different
reason. Yes, we're gonna get

8391
08:19:03,910 --> 08:19:06,550
something like this type.
Undefined is not assignable to

8392
08:19:06,550 --> 08:19:10,540
type bytes. Like the reason we
get this is because process dot

8393
08:19:10,570 --> 08:19:15,850
EMV private key in TypeScript
technically, is type string, or

8394
08:19:15,850 --> 08:19:20,200
undefined. So we need to tell
Typescript and and the Wallet

8395
08:19:20,200 --> 08:19:22,990
Objects. And the Encrypt
function is looking for a type

8396
08:19:22,990 --> 08:19:26,170
string, not string or undefined.
So we just need to tell

8397
08:19:26,170 --> 08:19:29,230
TypeScript that this will not be
undefined. So we can just put a

8398
08:19:29,230 --> 08:19:32,560
bang here. And everywhere that
we use process, study and be,

8399
08:19:33,070 --> 08:19:38,830
oops, I got to do that on
deploy, as well. Bang, looks

8400
08:19:38,830 --> 08:19:41,620
good. Now that we've added
everything in here, we run TS

8401
08:19:41,620 --> 08:19:45,760
node deploy.ts, we're gonna see
the exact same output as we saw

8402
08:19:45,760 --> 08:19:48,880
with just using regular node.
And as long as our private key

8403
08:19:48,880 --> 08:19:52,480
password is in our dot env file.
If we run TS node and crypt

8404
08:19:52,480 --> 08:19:56,560
key.ts, we're gonna get the
exact same setup as before. And

8405
08:19:56,560 --> 08:19:59,680
we're gonna get a new encrypted
key dot JSON. And that's all you

8406
08:19:59,680 --> 08:20:02,230
need to do to make this
TypeScript compatible. And you

8407
08:20:02,230 --> 08:20:04,690
should give yourself a huge
round of applause for getting

8408
08:20:04,690 --> 08:20:08,260
this far and learning what's
going on underneath hardhat. The

8409
08:20:08,260 --> 08:20:11,080
next tool that we're going to
learn and learning all about

8410
08:20:11,080 --> 08:20:13,870
these transactions and how to
interact with these blockchains

8411
08:20:14,020 --> 08:20:17,080
this is absolutely massive, so
huge. Congratulations.

8412
08:20:19,989 --> 08:20:22,929
Alright, so now that we've
learned about ethers js and how

8413
08:20:22,929 --> 08:20:26,559
to do some more raw JavaScript
coding, we're now going to move

8414
08:20:26,559 --> 08:20:29,709
into hardhat. We saw with our
ether symbol storage that

8415
08:20:29,739 --> 08:20:32,529
deploying a contract can take a
lot of code. And there's a

8416
08:20:32,529 --> 08:20:35,379
number of things we didn't even
do in here. Like we didn't save

8417
08:20:35,409 --> 08:20:38,349
where this contract was
deployed. So we'd have to go

8418
08:20:38,349 --> 08:20:41,259
remember where it was deployed
every time. Instead of having it

8419
08:20:41,259 --> 08:20:44,139
just added programmatically. We
didn't write any tests here, and

8420
08:20:44,139 --> 08:20:46,869
we'd have to build our own
testing infrastructure. Maybe we

8421
08:20:46,869 --> 08:20:49,749
want to make this a cross chain
application. And we want more

8422
08:20:49,749 --> 08:20:52,929
than just one private key and
RPC URL, you can absolutely work

8423
08:20:52,929 --> 08:20:55,629
with your smart contracts in
JavaScript purely through ethers

8424
08:20:55,629 --> 08:20:59,469
and small scripts like this. But
we want a more robust framework

8425
08:20:59,469 --> 08:21:03,039
for doing all this. And that's
where hard hat comes into play.

8426
08:21:03,189 --> 08:21:06,669
Hardhead is easily one of the
most, if not the most popular

8427
08:21:06,669 --> 08:21:09,579
smart contract development
framework out there. It's used

8428
08:21:09,579 --> 08:21:13,119
by massive several billion
dollar protocols like Ave

8429
08:21:13,119 --> 08:21:16,749
uniswap, sushi swap, and more.
In fact, I recently did a poll

8430
08:21:16,749 --> 08:21:19,779
on Twitter. And even though a
lot of my content has been more

8431
08:21:19,779 --> 08:21:23,019
brownie and Pythonic, Hardhead
was well and beyond the most

8432
08:21:23,019 --> 08:21:26,019
popular framework, and Hardhead
has quickly become one of the

8433
08:21:26,019 --> 08:21:29,049
most advanced frameworks out
there. Hardhead is a development

8434
08:21:29,049 --> 08:21:31,809
environment, which allows for
JavaScript based development,

8435
08:21:31,809 --> 08:21:34,869
kind of like what we saw with
ethers, it gives us even more

8436
08:21:34,869 --> 08:21:38,349
tools to integrate our code with
common things that we want to

8437
08:21:38,349 --> 08:21:41,319
do. It's incredibly extensible,
and it has really nice debugging

8438
08:21:41,319 --> 08:21:44,559
features as well. And it's just
an overall fantastic tool. So

8439
08:21:44,589 --> 08:21:47,379
let's go ahead and let's jump
in. If you want to follow along

8440
08:21:47,379 --> 08:21:50,319
with the code, come over to the
GitHub repo and scroll down.

8441
08:21:50,649 --> 08:21:53,799
Lesson Six heart had simple
storage, and all the code is

8442
08:21:53,799 --> 08:21:57,009
located here. And a quick note
for the future ever, you want to

8443
08:21:57,009 --> 08:21:59,979
just download all the code from
one of these repositories, the

8444
08:21:59,979 --> 08:22:03,369
way you can do that is by doing
a git clone, what you do is you

8445
08:22:03,369 --> 08:22:06,069
come to the folder that you want
to put this code in, and you run

8446
08:22:06,069 --> 08:22:10,539
git clone. And then you grab the
URL that you want to clone,

8447
08:22:10,869 --> 08:22:16,299
paste it in. Now, you can CD
into your new folder here that

8448
08:22:16,299 --> 08:22:20,379
has everything downloaded
directly from GitHub, but only

8449
08:22:20,379 --> 08:22:23,259
do that as a backup or to just
download the code yourself. But

8450
08:22:23,259 --> 08:22:26,259
for now, just follow along with
me. Right, so let's do this.

8451
08:22:26,259 --> 08:22:30,429
Let's create our next project
using hard hat. The project that

8452
08:22:30,429 --> 08:22:33,039
we're going to be making is
called Hard Hat, simple storage

8453
08:22:33,039 --> 08:22:37,449
dash FCC or Free Code Camp. This
is going to be us working again

8454
08:22:37,449 --> 08:22:40,299
with that simple storage
contract. But in hard hat, we're

8455
08:22:40,299 --> 08:22:43,779
going to show you a ton of the
fantastic tools that we can use

8456
08:22:44,019 --> 08:22:50,799
to make our coding life way
easier. So I'm in a brand new VS

8457
08:22:50,799 --> 08:22:53,499
code, and we're going to create
a new folder for us to run all

8458
08:22:53,499 --> 08:22:56,829
this. Now what you can do to
create a brand new folder is you

8459
08:22:56,859 --> 08:23:03,729
once again you can do MK dir,
hard hat, simple storage of CC.

8460
08:23:04,329 --> 08:23:08,499
Now we can cd into hard hat
simple storage of CD, and type

8461
08:23:08,499 --> 08:23:13,629
code, period. And this will open
up a new Visual Studio code

8462
08:23:13,929 --> 08:23:18,069
inside of that folder. Now if we
open up our terminal, you'll see

8463
08:23:18,519 --> 08:23:22,029
that we are indeed inside that
folder. Now if that doesn't work

8464
08:23:22,029 --> 08:23:26,289
for you, you can still of course
to File, Open folder and select

8465
08:23:26,289 --> 08:23:29,019
the folder you'd like to open.
And you'll be inside of that

8466
08:23:29,019 --> 08:23:31,269
folder. Now that we have our
folder setup for working with

8467
08:23:31,269 --> 08:23:34,419
hard hat, we can begin setting
up our environment to be

8468
08:23:34,419 --> 08:23:37,809
incredibly professional using
the hard hat framework got a

8469
08:23:37,809 --> 08:23:41,229
link to the hard hat
documentation inside our whole

8470
08:23:41,259 --> 08:23:44,409
blockchain solidity course, yes,
the hard hat documentation is

8471
08:23:44,409 --> 08:23:47,229
phenomenal. And I highly
recommend everybody have it up

8472
08:23:47,229 --> 08:23:49,779
as they go through the section.
Because it's going to give you

8473
08:23:49,809 --> 08:23:52,089
pretty much everything that you
need to know for working with

8474
08:23:52,089 --> 08:23:55,299
hard hat, you can simply go
ahead over to tutorial and get

8475
08:23:55,299 --> 08:23:58,929
started. If you want to pause
the video here and read through

8476
08:23:58,929 --> 08:24:01,809
the tutorial, I recommend doing
so it'll give you a lot of

8477
08:24:01,809 --> 08:24:04,239
information about how to work
with hardhat. And more about

8478
08:24:04,239 --> 08:24:06,789
hardhat. However, we're just
going to jump right into setting

8479
08:24:06,819 --> 08:24:09,849
up the environment. We've
already installed no Gs on

8480
08:24:09,849 --> 08:24:14,649
Linux, or Mac OS. And those of
you who are using Windows, I set

8481
08:24:14,649 --> 08:24:18,249
you up with WsL. So you can just
follow the Linux instructions.

8482
08:24:19,539 --> 08:24:21,669
Now to create a new hard hat
project, you can actually just

8483
08:24:21,669 --> 08:24:24,849
go ahead and run these steps
right here. Instead of NPM,

8484
08:24:24,879 --> 08:24:27,519
we're going to be using yarn,
but if you want to use NPM, you

8485
08:24:27,519 --> 08:24:31,209
can absolutely do so the hard
hat Doc's say run npm init dash

8486
08:24:31,209 --> 08:24:34,719
dash, yes, we're just going to
run yarn in it, which is going

8487
08:24:34,719 --> 08:24:38,139
to create a new project for us
in this folder. So let's give it

8488
08:24:38,139 --> 08:24:42,129
a name, which if we want it set
to this hard hat symbol storage

8489
08:24:42,129 --> 08:24:45,759
FF FCC, we just hit enter, we'll
give it a version. And when if

8490
08:24:45,759 --> 08:24:49,389
we want it 1.0 point oh, we just
hit enter. We're going to skip

8491
08:24:49,389 --> 08:24:52,389
the description for now just by
hitting enter. And we're just

8492
08:24:52,389 --> 08:24:55,869
going to hit Enter for this as
well. And for this as well enter

8493
08:24:55,869 --> 08:24:59,799
for this as well and for this as
well and over this as well. Just

8494
08:24:59,799 --> 08:25:03,369
to keep those as blanks. And if
we look in package json, we now

8495
08:25:03,369 --> 08:25:06,459
see we have a name Hardhead
symbol storage that FCC we have

8496
08:25:06,459 --> 08:25:09,159
a version we have a main which
we're actually going to delete

8497
08:25:09,159 --> 08:25:12,069
the main and then we have a
license as well. yarn in it just

8498
08:25:12,099 --> 08:25:15,099
sets up this package json for
us. Now we're going to do yarn,

8499
08:25:15,759 --> 08:25:17,289
add dash dash dash

8500
08:25:17,320 --> 08:25:25,240
of our app. So far, we've just
been running yarn add, and then

8501
08:25:25,240 --> 08:25:27,850
whatever our package name is.
But for most of what we're

8502
08:25:27,850 --> 08:25:31,300
doing, we really want to do yarn
add dash dash Dev. The reasons

8503
08:25:31,300 --> 08:25:34,120
for this is a little bit
nuanced. But we can see some of

8504
08:25:34,120 --> 08:25:36,880
the information on this
StackOverflow question here. The

8505
08:25:36,880 --> 08:25:39,670
main difference is that
dependencies are required to run

8506
08:25:39,670 --> 08:25:43,000
your project. Whereas dev
dependencies are required only

8507
08:25:43,000 --> 08:25:45,460
to develop. For the most part,
we're going to be doing just

8508
08:25:45,460 --> 08:25:48,100
dash dash Dev, when we get to
the front end portion of this

8509
08:25:48,100 --> 08:25:51,040
course, we'll be installing more
packages that we don't need just

8510
08:25:51,040 --> 08:25:53,740
for development. Now in the same
directory where we install hard

8511
08:25:53,740 --> 08:25:58,450
hat, you can run MPX hard hat.
So a quick note about MPX is

8512
08:25:58,450 --> 08:26:03,130
that the yarn equivalent of NPM
is just yarn. So yarn goes NPM,

8513
08:26:03,280 --> 08:26:07,930
the yarn equivalent of MPX is
also yarn. So pretty much

8514
08:26:07,930 --> 08:26:11,140
anytime you see MPX, do
something, you can just replace

8515
08:26:11,140 --> 08:26:14,020
that MPX with yarn, and it'll do
the exact same thing. If you

8516
08:26:14,020 --> 08:26:17,020
want to run this with NPM or
MPX, you can absolutely do that

8517
08:26:17,020 --> 08:26:21,100
as well. So for us, we're going
to run yarn hardhat. And we'll

8518
08:26:21,100 --> 08:26:23,440
see we'll get prompted to
actually start creating a

8519
08:26:23,470 --> 08:26:27,730
hardhat project, run yarn
hardhat. And we'll get this

8520
08:26:27,730 --> 08:26:30,430
wonderfully cute prompt right
here and saying welcome to

8521
08:26:30,430 --> 08:26:32,920
Hardhead. What do you want to
do, create a basic sample

8522
08:26:32,920 --> 08:26:36,100
project, create an advanced
sample project can advance some

8523
08:26:36,100 --> 08:26:38,500
project uses type script or
create an empty

8524
08:26:38,500 --> 08:26:41,980
hardhat.config.js. For us, we're
just going to select create a

8525
08:26:41,980 --> 08:26:44,920
basic sample project. And this
is going to give us all the

8526
08:26:44,920 --> 08:26:48,460
boilerplate for a really simple
hardhat project. The hard hat

8527
08:26:48,460 --> 08:26:50,560
project route is going to be
this folder that we're in right

8528
08:26:50,560 --> 08:26:53,410
now. Do you want to add a Git
dot Git ignore? Yes, we

8529
08:26:53,410 --> 08:26:56,260
absolutely do. Because we're
going to be using dot env files.

8530
08:26:56,560 --> 08:26:59,230
Do you want to install this
sample projects dependencies

8531
08:26:59,230 --> 08:27:04,210
with yarn at nomic labs hard hat
at a theory and waffle at Chai?

8532
08:27:04,450 --> 08:27:06,670
We're going to go ahead and say
yes, and I'll explain what all

8533
08:27:06,670 --> 08:27:09,220
these dependencies are in a bit.
Let's go ahead and say yes for

8534
08:27:09,220 --> 08:27:15,490
now. And we're going to install
all these dependencies. Now, if

8535
08:27:15,490 --> 08:27:18,820
we look in our package, JSON, we
can see we've added a number of

8536
08:27:18,820 --> 08:27:22,390
dependencies like nomic labs,
Hardhead ethers, not MacLeods,

8537
08:27:22,390 --> 08:27:25,870
Hardhead, waffle, Chai,
Aetherium, waffle, and ethers.

8538
08:27:26,050 --> 08:27:28,150
Obviously, we're already
familiar with ethers, but the

8539
08:27:28,150 --> 08:27:30,370
rest of these might be a little
new. We'll talk about those

8540
08:27:30,370 --> 08:27:35,500
later. And great, we now have a
sample hardhat boilerplate

8541
08:27:35,500 --> 08:27:38,950
project. Let's walk through what
we just installed here. The

8542
08:27:38,950 --> 08:27:41,740
first thing we have is a
contracts folder, which comes

8543
08:27:41,740 --> 08:27:44,890
pre populated with greeted
outsole is really minimalistic

8544
08:27:44,890 --> 08:27:48,130
contract here. Next, you'll see
node modules, which of course is

8545
08:27:48,130 --> 08:27:50,740
our installed JavaScript
dependencies. Something I want

8546
08:27:50,740 --> 08:27:53,320
to know because it was really
confusing to me when I first

8547
08:27:53,350 --> 08:27:56,170
started working with this is
some of these node modules start

8548
08:27:56,170 --> 08:27:58,750
with an add sign, and then a lot
of them don't. What's the

8549
08:27:58,750 --> 08:28:01,600
difference between those two,
these outside node modules are

8550
08:28:01,600 --> 08:28:05,560
known as scoped packages, which
effectively allow NPM packages

8551
08:28:05,560 --> 08:28:08,680
to be namespace or yarn
packages. This allows

8552
08:28:08,710 --> 08:28:11,770
organizations to make it clear
what packages are official and

8553
08:28:11,770 --> 08:28:15,040
which ones are not. For example,
if a package has a scope at

8554
08:28:15,040 --> 08:28:17,200
Angular, you know, it's
published by the Angular core

8555
08:28:17,200 --> 08:28:20,290
team. So it's the same thing
with this anything with AP ens

8556
08:28:20,290 --> 08:28:23,650
domains we know is by the ens
domains team, anything with

8557
08:28:23,710 --> 08:28:27,400
abnormal Labs is going to be by
the team that created hard hat.

8558
08:28:27,460 --> 08:28:30,400
So that's why this at nomic
labs, hard hat ethers and at

8559
08:28:30,400 --> 08:28:33,910
nomic labs, hard at Waffle has
this at sign, because we know

8560
08:28:33,910 --> 08:28:37,060
it's published by the nomic labs
team, then we have a scripts

8561
08:28:37,090 --> 08:28:40,030
section. This is going to be
where we're adding any and all

8562
08:28:40,030 --> 08:28:43,270
of our scripts that we want to
write like deploying contracts,

8563
08:28:43,300 --> 08:28:46,630
interacting with contracts, etc.
And then we have a test folder.

8564
08:28:46,720 --> 08:28:49,510
We haven't started building any
tests yet. But tests are

8565
08:28:49,510 --> 08:28:52,600
incredibly important for working
with smart contracts. And this

8566
08:28:52,600 --> 08:28:56,230
sample test folder gives us a
minimalistic test for testing

8567
08:28:56,230 --> 08:28:59,350
our smart contracts. We of
course have Git ignore, which of

8568
08:28:59,350 --> 08:29:02,950
course comes pre populated with
some important things to ignore

8569
08:29:02,980 --> 08:29:06,400
like Dotty and V. And also node
modules because node modules

8570
08:29:06,400 --> 08:29:09,670
might get too huge push up to
GitHub. And one of the biggest

8571
08:29:09,670 --> 08:29:14,560
changes here is it adds this
hard hat.config.js. This file

8572
08:29:14,590 --> 08:29:17,290
even though it's minimalistic,
right now, you can think of as

8573
08:29:17,290 --> 08:29:20,200
the entry point for all the
scripts that we write, it's the

8574
08:29:20,200 --> 08:29:22,990
configuration file that
determines how the rest of our

8575
08:29:22,990 --> 08:29:24,970
code is going to work and
interact with the blockchain.

8576
08:29:25,270 --> 08:29:28,660
Then of course, we have package
dot JSON, we get started with a

8577
08:29:28,660 --> 08:29:31,900
readme. Remember how the first
time we ran yarn hard hat, we

8578
08:29:31,900 --> 08:29:35,050
were prompted with this Getting
Started piece. Now if we run

8579
08:29:35,050 --> 08:29:38,680
yarn Hardhead, we're actually
going to get output of all the

8580
08:29:38,680 --> 08:29:40,630
different options and commands
we can use

8581
08:29:40,660 --> 08:29:46,570
with running hard hat. Now, if
you run into an issue where you

8582
08:29:46,570 --> 08:29:50,200
run yarn, hard hat, and this
pops up, but you don't see a

8583
08:29:50,230 --> 08:29:53,950
hard hat.config.js in your
folder, it likely means that

8584
08:29:53,950 --> 08:29:57,010
there's a hard hat dot config
dot j s in a higher level

8585
08:29:57,010 --> 08:30:00,070
folder, or there's a node
modules with hard hat in a

8586
08:30:00,070 --> 08:30:04,030
higher level folder. So if that
happens, maybe CD down a

8587
08:30:04,030 --> 08:30:07,810
directory and do a little LS and
look to see if you've got a hard

8588
08:30:07,810 --> 08:30:12,100
hat.config.js or node modules in
earlier folder. And because I've

8589
08:30:12,100 --> 08:30:14,920
actually seen a number of
engineers have a couple of

8590
08:30:14,920 --> 08:30:17,320
different problems here. My
friend CAMI is going to explain

8591
08:30:17,320 --> 08:30:19,090
A couple of different
troubleshooting tips you can

8592
08:30:19,090 --> 08:30:21,430
take to try to avoid these
common errors.

8593
08:30:21,490 --> 08:30:23,860
As a developer the most annoying
thing to deal with our

8594
08:30:23,860 --> 08:30:26,950
environment set of issues. My
name is Camila Ramos. I'm a

8595
08:30:26,950 --> 08:30:30,040
DevRel engineer at edge node
supporting the Graph Protocol.

8596
08:30:30,040 --> 08:30:32,230
And I'm going to show you how to
solve two common problems that

8597
08:30:32,230 --> 08:30:35,350
you might see when working on
this project. After installing

8598
08:30:35,350 --> 08:30:38,020
hardhat. And running the command
and px hard hat in your new

8599
08:30:38,020 --> 08:30:40,450
project folder, you're going to
expect to get back a menu of

8600
08:30:40,450 --> 08:30:42,880
options like this, but sometimes
you're not going to get that

8601
08:30:42,880 --> 08:30:46,300
back. And when you run into this
error, there is a solution for

8602
08:30:46,300 --> 08:30:48,520
you. And it usually just means
that you have a config file

8603
08:30:48,520 --> 08:30:51,160
somewhere that it shouldn't be,
and deleting it will get rid of

8604
08:30:51,160 --> 08:30:53,590
that error. What you're going to
do in order to find this file

8605
08:30:53,590 --> 08:30:57,160
that you need to delete is run
the command MPX hardhats space,

8606
08:30:57,370 --> 08:31:00,850
hyphen, hyphen verbose. And this
is going to spit out where this

8607
08:31:00,850 --> 08:31:03,460
file is if you have one, and
it's going to tell you exactly

8608
08:31:03,460 --> 08:31:05,620
where it is so that you can
delete it. After you've deleted

8609
08:31:05,620 --> 08:31:08,950
this config file, you should be
able to run MPX hardhat in your

8610
08:31:08,950 --> 08:31:11,890
project folder and get back that
many that we were expecting.

8611
08:31:12,370 --> 08:31:15,250
Another problem that is pretty
common. And I still run into all

8612
08:31:15,250 --> 08:31:18,610
the time is forgetting to npm
install, whenever you're working

8613
08:31:18,610 --> 08:31:21,490
with a repo that other people
have been working on on GitHub.

8614
08:31:21,490 --> 08:31:24,550
So let's say you're pulling down
some code that you and some

8615
08:31:24,580 --> 08:31:27,070
collaborators were working on
together, and then suddenly,

8616
08:31:27,070 --> 08:31:29,380
it's not working for you, you
probably just need to npm

8617
08:31:29,380 --> 08:31:32,980
install. So in your terminal, go
ahead and navigate to where this

8618
08:31:32,980 --> 08:31:36,550
project is located and then run
the command npm install. If

8619
08:31:36,550 --> 08:31:39,070
there are any new packages that
were installed in the time that

8620
08:31:39,070 --> 08:31:41,530
you weren't working on the code,
those will get installed locally

8621
08:31:41,530 --> 08:31:43,930
for you so that when you run the
code, it will be able to run

8622
08:31:43,930 --> 08:31:44,710
successfully.

8623
08:31:50,380 --> 08:31:53,200
What are some of the main things
we can do with hardhat in its

8624
08:31:53,200 --> 08:31:56,740
raw state here, these are some
of the main tasks that we can

8625
08:31:56,740 --> 08:31:59,770
run with hardhat different tasks
or just different commands, we

8626
08:31:59,770 --> 08:32:02,890
can run with hardhat. For
example, we can do yarn hardhat

8627
08:32:02,920 --> 08:32:07,450
counts, which will print out a
list of fake accounts we can use

8628
08:32:07,450 --> 08:32:10,420
with Hardhead. Similar to the
list of fake accounts that we

8629
08:32:10,420 --> 08:32:13,720
used with ganache, we can
compile our contracts by running

8630
08:32:13,720 --> 08:32:19,390
yarn Hardhead compile. Very
similar to what we did with

8631
08:32:19,420 --> 08:32:23,620
ethers Jas and soap Jas, you'll
see when we run compile, we get

8632
08:32:23,650 --> 08:32:27,160
a cache, which is just going to
be a quick way to access

8633
08:32:27,160 --> 08:32:30,820
solidity files, and we also get
an artifacts section. This

8634
08:32:30,850 --> 08:32:34,090
artifacts folder contains all
the information about our

8635
08:32:34,090 --> 08:32:38,080
compiled code we look in here
now we can, for example, look in

8636
08:32:38,080 --> 08:32:42,370
the build info and see a ton of
information about our compiled

8637
08:32:42,370 --> 08:32:45,610
contract. If you're looking
contracts, we can see more

8638
08:32:45,610 --> 08:32:49,390
compiled information. And then
if we look in the hardhat, slash

8639
08:32:49,390 --> 08:32:52,600
console.so, we can see more
compiled information. So all of

8640
08:32:52,600 --> 08:32:55,720
our compliation information is
going to be in this artifacts

8641
08:32:55,720 --> 08:32:59,830
folder. And whenever you want to
look to see what's going on on

8642
08:32:59,830 --> 08:33:03,100
the lower level when you compile
this artifacts folder is what

8643
08:33:03,100 --> 08:33:05,830
has everything. There are a
number of other hard hat tasks

8644
08:33:05,830 --> 08:33:11,710
that we can run as well. But
we'll get to them as we go. So

8645
08:33:11,710 --> 08:33:14,320
now that we have some of the
basics of hard head down, let's

8646
08:33:14,320 --> 08:33:16,960
go ahead and try doing some of
the same things we did with

8647
08:33:16,990 --> 08:33:20,170
ethers before but with hard hat.
So one of the first things we

8648
08:33:20,170 --> 08:33:23,170
want to do is we want to write
and interact with our smart

8649
08:33:23,170 --> 08:33:28,240
contracts. So let's go ahead and
rename greeter dot soul to

8650
08:33:28,600 --> 08:33:33,100
simple storage dot soul, you can
click on the file and hit enter

8651
08:33:33,160 --> 08:33:35,980
and should be able to rename it.
Otherwise, you can go ahead and

8652
08:33:35,980 --> 08:33:39,790
right click, delete it, and then
create a new file and call it

8653
08:33:39,790 --> 08:33:43,390
simple storage dot soul. We're
going to copy paste all of our

8654
08:33:43,390 --> 08:33:46,930
code from our previous simple
storage that saw into this file,

8655
08:33:47,320 --> 08:33:50,140
we can make sure that our simple
storage is compiling correctly

8656
08:33:50,170 --> 08:33:55,600
by running yarn hardhat compile.
Whoa, it looks like we ran into

8657
08:33:55,600 --> 08:33:59,230
an issue project cannot be
compiled. See reasons below the

8658
08:33:59,230 --> 08:34:01,750
solidity pragma version of the
file. It doesn't match any of

8659
08:34:01,750 --> 08:34:05,530
the configured compilers in your
config. Hmm, well, what's going

8660
08:34:05,530 --> 08:34:09,310
on contracts slash symbol
storage that's Sol zero point

8661
08:34:09,310 --> 08:34:13,480
8.8. Ah, okay, let's go ahead
and fix them. So we can open up

8662
08:34:13,570 --> 08:34:17,020
our hard hat dot config dot j s.
Now a quick note on opening

8663
08:34:17,020 --> 08:34:21,220
files. If you're on Mac and you
hit Command P, you can actually

8664
08:34:21,220 --> 08:34:24,550
start typing in the names of
files to get them to them

8665
08:34:24,550 --> 08:34:28,840
quicker. Or if you're on Linux
or Windows, you can type Ctrl p,

8666
08:34:29,200 --> 08:34:32,080
this will bring up and
interestingly if you type man P

8667
08:34:32,080 --> 08:34:36,160
or ctrl p and then you hit the
greater than key. This will drop

8668
08:34:36,160 --> 08:34:39,430
you into the command palette,
know command palette, command

8669
08:34:39,430 --> 08:34:43,360
palette, search for files,
search for commands in our

8670
08:34:43,360 --> 08:34:46,420
Hardhead dot config. Jas, I'm
gonna scroll down to module dot

8671
08:34:46,420 --> 08:34:52,090
exports and change this to zero
point 8.8. So that the version

8672
08:34:52,090 --> 08:34:54,670
that we're going to compile for
simple storage, it's gonna be

8673
08:34:54,670 --> 08:34:58,030
the same version and that hard
hat is looking for. Let's run

8674
08:34:58,030 --> 08:35:00,670
that same command by just
hitting up yarn Hardhead

8675
08:35:00,670 --> 08:35:03,910
compile, and awesome we see
compiled one solidity file

8676
08:35:03,910 --> 08:35:07,300
successfully. We should now see
this in artifacts. If we go to

8677
08:35:07,300 --> 08:35:10,660
artifacts and contracts. We now
see two contracts in here,

8678
08:35:10,990 --> 08:35:13,630
greater and simple storage and
we can see a ton of the

8679
08:35:13,630 --> 08:35:16,960
information about simple storage
we can also see some more lower

8680
08:35:16,960 --> 08:35:19,690
level in Information and build
info. Alright, so now that we

8681
08:35:19,690 --> 08:35:22,330
have our simple storage contract
in here, the next thing we

8682
08:35:22,330 --> 08:35:24,790
probably want to do is learn how
to deploy it. This is where

8683
08:35:24,790 --> 08:35:28,150
we're going to write our deploy
script. Now, for this section,

8684
08:35:28,150 --> 08:35:30,730
I'm going to be showing you how
to write a deploy script. But in

8685
08:35:30,730 --> 08:35:33,100
the next section, we're going to
do it a little bit differently.

8686
08:35:33,100 --> 08:35:35,650
But this is still going to teach
you how to write scripts and

8687
08:35:35,650 --> 08:35:38,380
worked with scripts in heart
app. So we're going to come to

8688
08:35:38,380 --> 08:35:41,050
our sample script dot j s, and
we're gonna go ahead and hit

8689
08:35:41,050 --> 08:35:46,030
enter and renamed it to deploy
dot j s. And if you want to read

8690
08:35:46,030 --> 08:35:48,910
all the comments in here, you
absolutely can, we're just gonna

8691
08:35:48,910 --> 08:35:52,300
go ahead and delete them all. A
quick keyboard shortcut is if

8692
08:35:52,300 --> 08:35:56,890
you hit Command A or Ctrl, a,
you'll highlight all the text in

8693
08:35:56,890 --> 08:36:00,070
your file, and we're going to go
ahead and delete it all. So now

8694
08:36:00,070 --> 08:36:02,320
we're just going to start from
scratch here. Now the setup for

8695
08:36:02,320 --> 08:36:04,720
our deploy script in here is
going to look really similar to

8696
08:36:04,720 --> 08:36:07,810
the setup of our deploy script.
From our previous section, we're

8697
08:36:07,810 --> 08:36:10,600
going to do imports at the top,
we're going to have our async

8698
08:36:10,600 --> 08:36:13,600
main function, and then we're
going to call the main function.

8699
08:36:13,930 --> 08:36:16,840
So let's go ahead and define our
main function, we'll call it

8700
08:36:16,870 --> 08:36:20,680
async. function main, like that,
and then we'll call our main

8701
08:36:20,680 --> 08:36:23,170
function. And if you want to
just copy paste this from the

8702
08:36:23,170 --> 08:36:27,430
last section, you absolutely
can. So we'll domain that then.

8703
08:36:42,190 --> 08:36:45,160
Boom, just like that. And
because of these semicolons are

8704
08:36:45,160 --> 08:36:48,040
going to drive me absolutely
insane. We're also going to add

8705
08:36:48,040 --> 08:36:52,090
prettier, and our solidity
prettier plugins. So we'll do

8706
08:36:52,150 --> 08:37:01,660
yarn, add dash dash Dev,
prettier and prettier, plug in

8707
08:37:02,680 --> 08:37:09,730
solidity. Then we can go ahead
and create our dot prettier, rc

8708
08:37:09,730 --> 08:37:18,850
file, we're going to add tab
with four, use tabs, false, semi

8709
08:37:19,210 --> 08:37:24,310
false, and then single quote,
also false. Now we're going to

8710
08:37:24,310 --> 08:37:28,360
be using this prettier rc file
setup a lot. So in future

8711
08:37:28,360 --> 08:37:30,310
sections, if you want to just
copy paste it, you can

8712
08:37:30,310 --> 08:37:33,400
absolutely do that as well.
We're also going to add a dot

8713
08:37:33,400 --> 08:37:37,450
prettier, ignore, which tells
prettier not to format some

8714
08:37:37,450 --> 08:37:40,300
files, which we want, we don't
want prettier to spend a ton of

8715
08:37:40,300 --> 08:37:42,940
time formatting all of our
files, I'm just going to copy

8716
08:37:42,940 --> 08:37:46,120
paste from the GitHub repo. So
feel free to copy paste from the

8717
08:37:46,120 --> 08:37:48,970
GitHub repo as well, you'd find
all the code for this section,

8718
08:37:49,000 --> 08:37:51,850
like I said, in the GitHub repo
associated with this course.

8719
08:37:51,940 --> 08:37:54,520
Now, unlike in our last section,
where we had to grab our

8720
08:37:54,520 --> 08:37:58,240
contract code a little bit more
manually, with hard hat, it's

8721
08:37:58,240 --> 08:38:00,850
actually a number of different
ways to grab compiled contracts.

8722
08:38:00,880 --> 08:38:02,860
The first way we're going to do
it, we're actually going to use

8723
08:38:03,310 --> 08:38:06,040
ethers. And now this is where
one of the first confusing

8724
08:38:06,040 --> 08:38:11,530
changes actually comes in.
Previously, we did const ethers

8725
08:38:11,770 --> 08:38:16,540
equals require ethers. And that
was how we went ahead and worked

8726
08:38:16,540 --> 08:38:20,890
with ethers. However, you'll
notice in our dev dependencies,

8727
08:38:21,280 --> 08:38:24,820
we have this dependency called
Hard Hat ethers. Hard Hat ethers

8728
08:38:24,820 --> 08:38:28,480
is a package that actually wraps
hard hat with its own built in

8729
08:38:28,510 --> 08:38:31,030
ethers. This is really
advantageous because it allows

8730
08:38:31,030 --> 08:38:33,760
hard hat to keep track of
different deployments at

8731
08:38:33,760 --> 08:38:36,610
different scripts and all these
other things for us. So instead

8732
08:38:36,610 --> 08:38:39,730
of importing ethers directly
from ethers, we're actually

8733
08:38:39,730 --> 08:38:43,750
going to import ethers directly
from hard hat instead. This

8734
08:38:43,750 --> 08:38:46,570
might seem a little confusing at
first, but just know if we want

8735
08:38:46,570 --> 08:38:49,210
to work with ethers and heart
it, it's usually much better to

8736
08:38:49,210 --> 08:38:52,690
pull it in from heart and you
can still do this and ethers

8737
08:38:52,690 --> 08:38:56,140
will still work the same. But
hard hat won't necessarily know

8738
08:38:56,170 --> 08:38:58,570
about different contract
factories in different pieces

8739
08:38:58,570 --> 08:39:00,850
and, and you'll see that in
action in a second. Now that

8740
08:39:00,850 --> 08:39:04,360
we're pulling in ethers, we can
actually immediately grab a

8741
08:39:04,360 --> 08:39:10,480
contract factory using ethers.
We can say const simple storage

8742
08:39:10,480 --> 08:39:22,240
factory equals await ethers dot
get contract. Factory simple

8743
08:39:22,780 --> 08:39:26,500
storage. So in order to get a
simple storage, contract

8744
08:39:26,500 --> 08:39:29,800
factory, we can just do await
ethers dot get contract factory.

8745
08:39:29,950 --> 08:39:33,250
Now if we pulled right from
ethers, the package ethers

8746
08:39:33,280 --> 08:39:35,740
doesn't know about this
contracts folder and ethers

8747
08:39:35,740 --> 08:39:38,620
doesn't know we've already
compiled simple storage dot

8748
08:39:38,620 --> 08:39:42,400
soul. And it's in our artifacts.
Hard Hat, on the other hand,

8749
08:39:42,490 --> 08:39:45,310
does know about the contracts
folder and does know that it's

8750
08:39:45,310 --> 08:39:48,760
already compiled, which is why
this simple storage factory

8751
08:39:48,760 --> 08:39:51,910
grabbing work so well. Once we
have our factory here, we can do

8752
08:39:51,910 --> 08:39:54,730
the same thing that we did in
our previous section and deploy

8753
08:39:54,730 --> 08:39:59,320
the contract. So we'll do a
quick console dot log. Deploy

8754
08:40:00,460 --> 08:40:06,130
flooring, contract done, and
then we'll do Kant's simple

8755
08:40:06,130 --> 08:40:16,240
storage equals await simple
store edge factory dot deploy

8756
08:40:17,320 --> 08:40:20,950
And boom, with that little bit
of code, we're already able to

8757
08:40:20,950 --> 08:40:25,090
deploy our simple storage
contract, then to wait to make

8758
08:40:25,090 --> 08:40:30,010
sure it gets deployed, we can do
await, simple storage, deployed.

8759
08:40:30,640 --> 08:40:33,880
And that's it. Now let's see
what happens when we go ahead

8760
08:40:33,880 --> 08:40:37,000
and run this deploy script. As
you know, in our last section,

8761
08:40:37,030 --> 08:40:40,030
we had to put in a private key,
and we had to put an RPC URL.

8762
08:40:40,420 --> 08:40:44,020
Right now, we don't have either
one of those defined. So what do

8763
08:40:44,020 --> 08:40:46,660
you think should the script
actually work? Or do you think

8764
08:40:46,660 --> 08:40:49,930
it'll break because we, we
didn't define what blockchain

8765
08:40:49,930 --> 08:40:52,660
we're going to deploy you. We
also didn't find a private key.

8766
08:40:52,960 --> 08:40:56,200
Well, let's go ahead and try
this out. We can run the script

8767
08:40:56,230 --> 08:41:03,430
in our terminal by running yarn,
hard hat, run, scripts slash

8768
08:41:04,120 --> 08:41:07,510
deploy dot j, s. And again, I'm
hitting tab here to do a little

8769
08:41:07,510 --> 08:41:11,410
auto completion and see what
happens. Well, we got deploying

8770
08:41:11,410 --> 08:41:15,460
contract, it says done, but
that's really it. So what really

8771
08:41:15,460 --> 08:41:18,160
happened? Well, let's add one
more line in here.

8772
08:41:18,339 --> 08:41:23,079
Let's do console dot log. We'll
do some string interpolation

8773
08:41:24,399 --> 08:41:31,569
deployed, contract to. And then
we'll add simple storage. That

8774
08:41:31,569 --> 08:41:36,219
address. Let's run this now. We
get deployed contract, and then

8775
08:41:36,219 --> 08:41:40,179
we get deployed contract to, and
then we get a contract address.

8776
08:41:40,539 --> 08:41:47,769
Hmm, what's going on here.
Hardhead has this fantastic tool

8777
08:41:47,769 --> 08:41:51,639
built in called The Hard Hat
Network hard hat comes built in

8778
08:41:51,639 --> 08:41:54,819
with Hard Hat Network, a local
Aetherium network node designed

8779
08:41:54,819 --> 08:41:58,149
for development, akin to
ganache, that allows you to

8780
08:41:58,149 --> 08:42:00,789
deploy your contracts and run
your tests and debug your code.

8781
08:42:00,879 --> 08:42:04,839
Whenever we run a command in
hard hat, or a script and hard

8782
08:42:04,839 --> 08:42:08,349
hat or a task and hard hat, we
by default deploy to this fake

8783
08:42:08,379 --> 08:42:11,439
Hard Hat Network. This Hard Hat
Network is very similar to

8784
08:42:11,469 --> 08:42:15,039
ganache, except for instead of
having this UI, it runs in the

8785
08:42:15,039 --> 08:42:18,549
background for our scripts. In
fact, if we go to our hard

8786
08:42:18,549 --> 08:42:22,509
hat.config.js, we can scroll
down to the bottom to this

8787
08:42:22,509 --> 08:42:26,409
module that exports section and
add more information about our

8788
08:42:26,409 --> 08:42:29,709
default networks. So right now,
if we don't have anything in

8789
08:42:29,709 --> 08:42:32,739
this module that export, by
default, it adds this piece

8790
08:42:32,739 --> 08:42:39,129
called default network hardhat.
So anytime we run a script,

8791
08:42:39,249 --> 08:42:42,459
without specifying a network, it
automatically uses this fake

8792
08:42:42,459 --> 08:42:45,399
Hard Hat Network. And this fake
Hard Hat Network comes

8793
08:42:45,429 --> 08:42:49,509
automatically with an RPC URL
and a private key for you. So

8794
08:42:49,509 --> 08:42:52,959
you don't even have to add one
in. This is one of the major

8795
08:42:52,959 --> 08:42:56,049
advantages of working with
Hardhead. It just automatically

8796
08:42:56,049 --> 08:42:59,829
gives you this fake blockchain.
And these fake private keys, if

8797
08:42:59,829 --> 08:43:02,349
you want to be a little bit more
explicit. And I always recommend

8798
08:43:02,349 --> 08:43:06,369
being more explicit, we can add
the default network in to the

8799
08:43:06,369 --> 08:43:09,909
module that are experts. So now
our default network is

8800
08:43:09,939 --> 08:43:13,569
explicitly stated as hard hat.
However, in any script, you run,

8801
08:43:13,599 --> 08:43:16,629
you can choose whatever network
you want to work with. So if I

8802
08:43:16,629 --> 08:43:20,349
want to explicitly say I want to
run our deploy script on our

8803
08:43:20,349 --> 08:43:25,479
fake Hard Hat Network, I can do
yarn, hard hat, run scripts,

8804
08:43:25,899 --> 08:43:31,689
deploy dot j s, dash dash
network, hard hat, this is us

8805
08:43:31,689 --> 08:43:34,719
telling her that, hey, we want
to run this script on the Hard

8806
08:43:34,719 --> 08:43:37,119
Hat Network. Hopefully, you
might be able to see where this

8807
08:43:37,119 --> 08:43:41,289
is going. Having this network
flag makes it incredibly easy to

8808
08:43:41,289 --> 08:43:44,469
switch across different chains,
different block chains,

8809
08:43:44,469 --> 08:43:48,039
different private keys, etc. So
we have our default network set

8810
08:43:48,039 --> 08:43:51,489
the hard hat here, we can add
other networks in here as well.

8811
08:43:51,489 --> 08:43:56,349
The way we do that is we're
going to add a networks section.

8812
08:43:56,379 --> 08:43:58,659
And we're going to define any of
the network sections that we

8813
08:43:58,659 --> 08:44:01,539
want. And remember to put a
comment there so that your

8814
08:44:01,539 --> 08:44:04,269
Visual Studio code doesn't get
mad at you. So recently, we

8815
08:44:04,269 --> 08:44:08,829
worked with Rigby so let's go
ahead and add a Rinkeby network

8816
08:44:08,829 --> 08:44:12,159
in here. So we're gonna say
another network is gonna be

8817
08:44:12,489 --> 08:44:16,119
really cool. So I should just be
able to change the network flag

8818
08:44:16,119 --> 08:44:24,429
to Rigby now, right? Well, not
quite. If you try to run that,

8819
08:44:24,699 --> 08:44:28,179
you're gonna get invalid value
undefined for hardhat config

8820
08:44:28,239 --> 08:44:32,259
networks. Rigby, that URL, it's
expecting you to tell it, hey,

8821
08:44:32,289 --> 08:44:35,619
what the URL is, since this
isn't the hard hat network, we

8822
08:44:35,619 --> 08:44:38,619
need to tell hard hat exactly
how we're going to connect to

8823
08:44:38,619 --> 08:44:41,739
rink B. And this is where a lot
of what we learned before is

8824
08:44:41,739 --> 08:44:44,439
going to come in handy, again,
exactly the same as what we did

8825
08:44:44,439 --> 08:44:48,279
before. We're going to create a
new Dotty v file, and we're

8826
08:44:48,279 --> 08:44:52,749
going to add our Rigby URL in
this dot env file. Just

8827
08:44:52,749 --> 08:44:56,199
remember, dot env is an r dot
get ignore just in case. So in

8828
08:44:56,199 --> 08:44:59,979
our Dotty env, we're going to
add that RPC URL from alcmi back

8829
08:44:59,979 --> 08:45:04,449
in here before we just said RPC
URL. But since we might want to

8830
08:45:04,449 --> 08:45:07,359
work across multiple networks,
it's usually good to specify

8831
08:45:07,389 --> 08:45:11,409
exactly what network each URL
stands for. So we're gonna say

8832
08:45:12,249 --> 08:45:18,699
Rynkeby RPC URL equals and then
paste that URL in here. Now, as

8833
08:45:18,699 --> 08:45:22,059
you probably have guessed, we
can add our URL to our Rinkeby

8834
08:45:22,059 --> 08:45:25,719
network here. for readability, I
usually like to add them as

8835
08:45:25,719 --> 08:45:29,679
variables right above the module
that experts. So I'll say const

8836
08:45:29,979 --> 08:45:40,269
Rynkeby. RPC URL equals process
dot E and V dot Rynkeby RPC URL.

8837
08:45:40,719 --> 08:45:43,869
And once again, we're going to
be pulling that Rinckey RPC URL

8838
08:45:44,079 --> 08:45:47,679
from our environment variable.
Of course, in order to pull that

8839
08:45:47,679 --> 08:45:50,709
environment variable in, we're
going to need to use that dot

8840
08:45:50,709 --> 08:45:54,789
env package again. So to add
that in, we're going to yarn add

8841
08:45:54,789 --> 08:46:00,609
dash dash dev dot EMV. And at
the top of our Hardhead config,

8842
08:46:00,909 --> 08:46:08,649
we're going to add require dot
EMV, and then do dot config to

8843
08:46:08,649 --> 08:46:11,769
enable the config. Now this
means we should be able to pull

8844
08:46:11,769 --> 08:46:15,849
our rink the RPC URL from our
dot env. Now that we have that

8845
08:46:15,879 --> 08:46:20,829
in our Rinkeby network, we can
add URL Rinckey RPC URL.

8846
08:46:21,489 --> 08:46:24,999
Awesome. So we have an RPC URL
for different network. But what

8847
08:46:24,999 --> 08:46:27,969
else do we usually need? Well,
we usually need a private key to

8848
08:46:27,969 --> 08:46:30,909
work with an actual network, or
that doesn't automatically give

8849
08:46:30,909 --> 08:46:33,939
us a private key for rugby,
because Hardhead can't just give

8850
08:46:33,939 --> 08:46:36,729
us test and the Etherium, we
need to have an actual account

8851
08:46:36,849 --> 08:46:40,089
an actual test nets. Hardhead
doesn't control those. So we

8852
08:46:40,089 --> 08:46:43,749
have to actually give it a real
URL and a real private key. So

8853
08:46:43,749 --> 08:46:46,089
to add private keys, you
actually add something called

8854
08:46:46,119 --> 08:46:50,259
accounts, you add a list of
accounts that you want to give

8855
08:46:50,259 --> 08:46:53,169
to hard hat for us, we're only
going to add one, which is going

8856
08:46:53,169 --> 08:46:55,629
to be our private key. And for
our private key, we're going to

8857
08:46:55,629 --> 08:46:59,199
do the exact same thing. We're
gonna say const private key

8858
08:46:59,859 --> 08:47:05,949
equals process dot e NV dot
private key. And since this

8859
08:47:05,949 --> 08:47:09,159
private key is going to be a
real private key for a real test

8860
08:47:09,159 --> 08:47:12,339
net, again, we are going to have
to grab this from our meta mask.

8861
08:47:12,369 --> 08:47:15,939
So it will go to our meta mask,
three dots, account details,

8862
08:47:15,969 --> 08:47:18,639
export private key, and we'll
add our password in here.

8863
08:47:20,710 --> 08:47:25,720
And then in our dot env will add
private key equals and then add

8864
08:47:25,720 --> 08:47:28,870
our private key. Now I know I've
said this 100 times, but please,

8865
08:47:28,870 --> 08:47:33,700
please, please, for learning
this, do not use a real key that

8866
08:47:33,700 --> 08:47:37,270
is connected to any real money
just in case, please use a new

8867
08:47:37,270 --> 08:47:40,180
meta mask. I've know I've said
it a bunch. But some people go

8868
08:47:40,180 --> 08:47:43,630
no, I'm going to be okay, I'll
be safe. Just to be super, super

8869
08:47:43,630 --> 08:47:47,020
safe here, please use a brand
new meta mask. So now that we

8870
08:47:47,020 --> 08:47:49,870
have a private key, we're going
to add it in here account

8871
08:47:50,260 --> 08:47:53,650
private key. And now we have an
account here. One more thing I

8872
08:47:53,650 --> 08:47:58,390
like to do is I like to give the
chain ID of the network, which

8873
08:47:58,390 --> 08:48:02,890
for Rigby is going to be for
every single EVM base network as

8874
08:48:02,920 --> 08:48:06,700
a new chain ID and EVM network
basically just means solidity

8875
08:48:06,700 --> 08:48:10,390
works on it. This includes all
test nets, there's a good site

8876
08:48:10,390 --> 08:48:13,510
called chainless.org, which may
or may not be going down at some

8877
08:48:13,510 --> 08:48:16,780
point, it has a list of all
these different networks. For

8878
08:48:16,780 --> 08:48:19,630
example, you can see on here a
theory main net has a chain ID

8879
08:48:19,630 --> 08:48:24,760
of one byte and smart chain is
56, avalanches, 4311 for

8880
08:48:24,790 --> 08:48:29,830
Phantom, opera 250, Polygon,
137, etc. Each one of these EVM

8881
08:48:29,830 --> 08:48:33,850
compatible chains has their own
chain ID, rank V, the chain ID

8882
08:48:33,850 --> 08:48:38,020
is for adding the chain ID is
helpful here for later on. And

8883
08:48:38,020 --> 08:48:40,390
we'll get to that in the future.
But for now, just go ahead and

8884
08:48:40,390 --> 08:48:43,510
make sure to add your chain IDs.
Okay, now that we have the RPC

8885
08:48:43,510 --> 08:48:47,050
URL, we have the private key, we
can go ahead and test deploying

8886
08:48:47,050 --> 08:48:51,040
this to an actual test net, and
actually did something incorrect

8887
08:48:51,040 --> 08:48:54,220
here. And we're gonna get an
error here. And I want you to go

8888
08:48:54,220 --> 08:48:57,970
ahead and try to figure out and
debug this error yourself.

8889
08:48:58,030 --> 08:49:03,610
You're ready. Alright, let's do
it. We'll do yarn, hard hat, run

8890
08:49:03,610 --> 08:49:11,470
scripts, deploy dot j s, dash
dash network Rinkeby. And we get

8891
08:49:11,470 --> 08:49:16,240
this wonderfully weird error,
which we see we have deployed

8892
08:49:16,240 --> 08:49:20,200
contract. So we know that in our
deploy script, we get to at

8893
08:49:20,200 --> 08:49:23,680
least this line, but then we're
getting an error, I highly

8894
08:49:23,680 --> 08:49:26,890
likely hear what's going on
saying cannot read properties

8895
08:49:26,890 --> 08:49:30,280
have no reading send
transaction, if you want, you

8896
08:49:30,280 --> 08:49:33,340
can absolutely go to this spot.
But it basically it looks like

8897
08:49:33,340 --> 08:49:36,340
it's having a hard time
understanding what the private

8898
08:49:36,340 --> 08:49:40,540
key or what the account of this
is. And what do you think I'm

8899
08:49:40,540 --> 08:49:43,630
going to recommend we do? Well,
if it's not clear, after doing a

8900
08:49:43,630 --> 08:49:46,090
little bit of triaging and
debugging, we're going to copy

8901
08:49:46,090 --> 08:49:49,600
this air. And we're going to
come on over to Google and paste

8902
08:49:49,600 --> 08:49:54,250
that right in. It looks like we
do get a question here from

8903
08:49:54,250 --> 08:49:57,520
stackexchange Etherium. And it
looks like it's really similar

8904
08:49:57,790 --> 08:50:01,660
to what we're doing. We scroll
down. They're running nearly the

8905
08:50:01,660 --> 08:50:04,180
exact same script that we're
running, they're using MPX

8906
08:50:04,180 --> 08:50:08,440
instead of yarn. They've got a
pretty minimalistic deploy file.

8907
08:50:08,740 --> 08:50:11,380
Let's scroll down and see what
the answers have to say. I've

8908
08:50:11,380 --> 08:50:14,950
seen this error where my private
key wasn't properly populated. I

8909
08:50:14,950 --> 08:50:17,500
would also use an environment
variable I'm pretty sure Are

8910
08:50:17,500 --> 08:50:20,560
environment variables good. But
we have a second one saying in

8911
08:50:20,560 --> 08:50:24,010
your heart head, I can think
that Jas, it should be accounts

8912
08:50:24,040 --> 08:50:27,820
instead of account, it works for
me, let's go back to our head

8913
08:50:27,820 --> 08:50:31,870
config and see if that's what's
going on. Uh huh, we put account

8914
08:50:32,260 --> 08:50:34,570
in this should be accounts. So
let's swap that over to

8915
08:50:34,570 --> 08:50:37,870
accounts. We'll clear our
terminal. And we'll run this

8916
08:50:37,870 --> 08:50:41,620
again. Uh huh. And now it's
reading a little bit longer,

8917
08:50:41,950 --> 08:50:44,590
which is good. This means that
we're probably deploying this to

8918
08:50:44,590 --> 08:50:47,740
rink B, which is what we want to
see. Awesome. And now we can see

8919
08:50:47,740 --> 08:50:51,250
deployed contract to, and we
have a contract address here. So

8920
08:50:51,250 --> 08:50:54,400
we'll grab this contract. And
we'll pop on over to bring the

8921
08:50:54,400 --> 08:50:57,580
ether scan, that's numbering the
ether scan. And we'll go ahead

8922
08:50:57,580 --> 08:51:00,610
and we'll paste this in.
Awesome. And we see our contract

8923
08:51:00,610 --> 08:51:04,690
was created about 26 seconds
ago. Perfect. Now for this part,

8924
08:51:04,720 --> 08:51:07,600
you don't have to deploy this to
rink be with me, if you follow

8925
08:51:07,600 --> 08:51:10,630
along here. That's good enough.
So remember, the flying to test

8926
08:51:10,630 --> 08:51:13,960
that's can take a long time. So
for this one, you don't have to

8927
08:51:13,960 --> 08:51:19,720
deploy with me. Alright, great.
So we've deployed to rink be

8928
08:51:19,750 --> 08:51:22,540
using hard hat. This is
fantastic. Now something that we

8929
08:51:22,540 --> 08:51:26,740
notice, once again is oof, our
contract isn't verified? Do we

8930
08:51:26,740 --> 08:51:29,890
have to go back through and do
this verify and publish and all

8931
08:51:29,890 --> 08:51:33,490
that stuff again? Luckily for
us, we actually don't need to do

8932
08:51:33,490 --> 08:51:36,790
that. So what can we do? Well,
back in our deploy script, we

8933
08:51:36,790 --> 08:51:40,030
can add some code to
automatically verify right after

8934
08:51:40,030 --> 08:51:43,510
we deploy. So let's go ahead and
do that. Right below our main

8935
08:51:43,510 --> 08:51:47,050
function, we're gonna create a
new function called verify,

8936
08:51:47,200 --> 08:51:52,810
we're gonna say async function,
verify. And we're gonna have

8937
08:51:52,810 --> 08:51:55,390
this function get past some
arguments, we're gonna have to

8938
08:51:55,390 --> 08:52:00,580
get past a contract, address,
and some arguments or the

8939
08:52:00,580 --> 08:52:02,740
contract. Since our simple
storage doesn't have a

8940
08:52:02,740 --> 08:52:05,860
constructor, the arguments for
simple storage are just gonna be

8941
08:52:05,860 --> 08:52:09,070
blank. But in the future, when
we have contracts that do have

8942
08:52:09,070 --> 08:52:12,670
constructors, the arguments are
going to be populated. And when

8943
08:52:12,670 --> 08:52:15,100
we get there, you'll see what I
mean, we need at least the

8944
08:52:15,100 --> 08:52:17,740
contract address, and we're
going to add some code in here

8945
08:52:18,040 --> 08:52:20,770
to automatically verify our
contracts after they've been

8946
08:52:20,770 --> 08:52:25,840
deployed. This auto verification
process works on block explorers

8947
08:52:25,870 --> 08:52:28,720
like ether scan, it might not
work on block explorers like

8948
08:52:28,750 --> 08:52:31,480
eath, pler, or other block
explorers. But if you want to

8949
08:52:31,480 --> 08:52:33,790
verify on these other block
explorers, I'm sure they have an

8950
08:52:33,790 --> 08:52:37,150
API to allow you to do that as
well. Now, ether scan in most

8951
08:52:37,150 --> 08:52:41,680
other block explorers have a
section on their website called

8952
08:52:41,710 --> 08:52:45,610
API documentation, or something
to do with API's. These are ways

8953
08:52:45,640 --> 08:52:48,790
for us to programmatically
interact with ether scan, and do

8954
08:52:48,790 --> 08:52:51,550
stuff with them. One of the main
things that we can do is we can

8955
08:52:51,550 --> 08:52:56,800
actually verify our contracts
through this API. Ether scan

8956
08:52:56,830 --> 08:52:59,500
even has a tutorial in here
called verifying contracts

8957
08:52:59,500 --> 08:53:01,780
programmatically. And the link
to this will be in the GitHub

8958
08:53:01,780 --> 08:53:04,720
repo, they have an API endpoint
that we can make some requests

8959
08:53:04,720 --> 08:53:08,860
to to go ahead and verify our
contracts. Now, we could

8960
08:53:08,860 --> 08:53:11,980
absolutely make the raw API
calls and follow the tutorial

8961
08:53:11,980 --> 08:53:14,980
here. But there's actually an
easier way than even going

8962
08:53:14,980 --> 08:53:17,800
through this tutorial here.
Hardhead is an extensible

8963
08:53:17,800 --> 08:53:21,430
framework, meaning you can add
something called plugins to it.

8964
08:53:21,670 --> 08:53:24,670
There's even an advanced section
in the documentation called

8965
08:53:24,670 --> 08:53:27,910
Building plugins. If we scroll
down to the bottom, we can see

8966
08:53:27,910 --> 08:53:31,030
some popular plugins that the
nomic labs team or the Hardhead

8967
08:53:31,030 --> 08:53:34,240
team has created. And also a
number of community plugins as

8968
08:53:34,240 --> 08:53:36,760
well. One of the most used
Hardhead plugins is going to be

8969
08:53:36,760 --> 08:53:40,420
this hard hat ether scan plugin
that makes this verification

8970
08:53:40,420 --> 08:53:44,350
process much, much easier.
Install it, you can just run npm

8971
08:53:44,350 --> 08:53:48,130
install bash, just save dev at
nomic labs harden ether scan,

8972
08:53:48,400 --> 08:53:51,250
and then add it to our hard hat
dot config. Since we're using

8973
08:53:51,250 --> 08:53:54,670
yarn, we're just going to go
ahead and use yarn. So back in

8974
08:53:54,670 --> 08:54:00,970
our code, we'll do yarn, add
dash dash Dev, at nomic, labs,

8975
08:54:02,350 --> 08:54:08,620
slash hard hat slash hyphen,
ether scan. Now that we have

8976
08:54:08,620 --> 08:54:12,460
this plugin, we can go to our
hard hat dot config, scroll to

8977
08:54:12,460 --> 08:54:22,270
the top and add this plugin do
require at nomic labs slash hard

8978
08:54:22,270 --> 08:54:26,560
hat, ether scan. Now that we
have this plugin, the hard hat

8979
08:54:26,560 --> 08:54:29,890
documentation has some more
information about the usage, how

8980
08:54:29,890 --> 08:54:33,460
to actually use this plugin, and
how to run different commands

8981
08:54:33,460 --> 08:54:36,490
with it. In order for us to use
this verification, we actually

8982
08:54:36,490 --> 08:54:40,660
need an API key from ether scan.
This is basically a password for

8983
08:54:40,780 --> 08:54:44,320
allowing us to use the ether
scan API. So we're going to come

8984
08:54:44,320 --> 08:54:47,500
to ether scan. And we're going
to go ahead and sign in. And

8985
08:54:47,500 --> 08:54:50,050
actually we're going to click to
sign up and create an account.

8986
08:54:51,820 --> 08:54:54,280
And we'll go ahead and create an
account. We'll go ahead and

8987
08:54:54,280 --> 08:54:57,190
verify our registration by
clicking the verification link.

8988
08:54:57,490 --> 08:55:00,190
And we'll click the Login. Now
that we're logged in. On the

8989
08:55:00,190 --> 08:55:03,760
left hand side, we can scroll
down to API keys. And we can go

8990
08:55:03,760 --> 08:55:09,370
ahead and create a new API key.
We call this H H hyphen sec,

8991
08:55:09,400 --> 08:55:12,400
which stands for hardhat Free
Code Camp. Great, this new API

8992
08:55:12,400 --> 08:55:16,120
key will copy this and we'll go
back to our code and we'll add

8993
08:55:16,120 --> 08:55:18,970
this somewhere since the API
keys basically considered a

8994
08:55:18,970 --> 08:55:21,700
password. Where do you think we
should add this? That's right in

8995
08:55:21,700 --> 08:55:25,990
our dot env. So in our dot env,
we're going to add a new entry

8996
08:55:25,990 --> 08:55:31,480
called ether scan API key. And
we're going to add that API key

8997
08:55:31,480 --> 08:55:34,870
that we just got. Now that we
have our API key, back in our

8998
08:55:34,870 --> 08:55:38,410
Hardhead, config, we're going to
create a new section in a module

8999
08:55:38,410 --> 08:55:42,520
dot exports, tell hardhat that
we have this ether scan API key,

9000
08:55:42,910 --> 08:55:44,770
or new section is going to be
called ether scan.

9001
08:55:46,390 --> 08:55:50,350
And in here, we're gonna say API
key is going to be ether scan

9002
08:55:50,980 --> 08:55:55,870
API key that we're going to
define up here the same way we

9003
08:55:55,870 --> 08:55:59,680
define these other keys. So
we'll say const, ether scan API

9004
08:55:59,680 --> 08:56:05,950
key equals process dot e NV dot
ether scan API key. And if

9005
08:56:05,950 --> 08:56:08,530
something like this pops up, you
can generally just hit enter,

9006
08:56:08,560 --> 08:56:12,130
and it will autocomplete it for
you, which is awesome. Great. So

9007
08:56:12,130 --> 08:56:14,980
now we have an ether scan API
key back in the heart had

9008
08:56:14,980 --> 08:56:18,010
documentation, it tells us by
adding this, we actually get a

9009
08:56:18,010 --> 08:56:22,840
new task called verify. Let's
try that out. So open our

9010
08:56:22,840 --> 08:56:27,880
terminal back up. And we'll do
yarn, RT hat. Let's see what

9011
08:56:27,880 --> 08:56:32,110
pops up. Wow, we did get a new
verification here. When we run

9012
08:56:32,140 --> 08:56:35,590
yarn hard hat harder, it
actually looks into our hard

9013
08:56:35,590 --> 08:56:38,980
hat.config.js and checks for any
plugins. If there are new

9014
08:56:38,980 --> 08:56:42,850
plugins there, it'll add them as
a new task that we can do. You

9015
08:56:42,850 --> 08:56:46,630
can manually verify your
contract by doing yarn or MPX

9016
08:56:46,660 --> 08:56:50,230
Harnett verify dash dash
network, the deployed contract

9017
08:56:50,230 --> 08:56:53,890
address and any constructor
arguments yourself. But we want

9018
08:56:53,890 --> 08:56:56,440
to be a little bit more
programmatic than this. So what

9019
08:56:56,440 --> 08:56:58,600
we're going to do is we're going
to go back and create this

9020
08:56:58,630 --> 08:57:01,570
verification function, it is
good to know how to do it via

9021
08:57:01,570 --> 08:57:03,670
command line so that if you want
to verify something in the

9022
08:57:03,670 --> 08:57:07,420
future, manually, you can, let's
build this verify function

9023
08:57:07,420 --> 08:57:10,120
though. So we're going to take
the our contract address and

9024
08:57:10,120 --> 08:57:13,090
some arguments. And for our
sake, we're going to do console

9025
08:57:13,660 --> 08:57:18,970
dot log verifying contract that
that just so that we know we

9026
08:57:18,970 --> 08:57:22,090
might have to wait for a little
bit. And in our code, we can

9027
08:57:22,090 --> 08:57:28,210
actually run any task from hard
hat using a run package. So up

9028
08:57:28,210 --> 08:57:32,410
at the top, we're actually going
to import run from hard hat as

9029
08:57:32,410 --> 08:57:37,690
well run allows us to run any
hard hat task. So in our code

9030
08:57:37,690 --> 08:57:42,940
here, we're going to do a wait
to run. And then we can do there

9031
08:57:43,090 --> 08:57:46,810
it thought. Now part of that
allows you to add different

9032
08:57:46,810 --> 08:57:49,420
parameters as well in this run.
And it's usually best that you

9033
08:57:49,420 --> 08:57:52,750
go ahead and add them in here so
that we're really specific with

9034
08:57:52,750 --> 08:57:57,970
what we're doing. If we do yarn
hardhat verify dash dash help,

9035
08:57:58,120 --> 08:58:01,060
we can see what parameters we
can actually pass. Well, it

9036
08:58:01,060 --> 08:58:04,330
looks like we can pass the
Verify parameter. So we'll do

9037
08:58:04,540 --> 08:58:08,800
colon, verify. If you go to the
actual GitHub for the

9038
08:58:08,800 --> 08:58:11,200
verification tasks, you can
actually see you can do more

9039
08:58:11,200 --> 08:58:14,290
than just verify, you can do
verify, get minimum build,

9040
08:58:14,500 --> 08:58:17,770
verify, get constructor
arguments, verify, verify, which

9041
08:58:17,770 --> 08:58:19,720
is what we're going to be
working with, and a couple of

9042
08:58:19,720 --> 08:58:23,050
other subtasks as well. The
second parameter that goes

9043
08:58:23,050 --> 08:58:26,110
inside run is going to be a list
of actual parameters. This

9044
08:58:26,140 --> 08:58:28,720
second parameter here is just
kind of the sub task, if you

9045
08:58:28,720 --> 08:58:32,500
will, of our verify task. And
this is going to be an object

9046
08:58:32,500 --> 08:58:34,990
that contains the actual
parameters. And this is where we

9047
08:58:34,990 --> 08:58:40,480
pass in an address, which is
going to be our contract

9048
08:58:40,480 --> 08:58:47,770
address, and then our construct
or arguments, which is going to

9049
08:58:47,770 --> 08:58:52,330
be arcs. Now normally just this
right here should be enough for

9050
08:58:52,330 --> 08:58:55,540
us to go ahead and use this
verify contract in our main

9051
08:58:55,540 --> 08:58:58,330
function, but we're going to add
one additional thing to it.

9052
08:58:58,330 --> 08:59:00,940
Because in practice, sometimes
there's some errors that can

9053
08:59:00,940 --> 08:59:03,250
come up. One of the errors that
often comes up when running a

9054
08:59:03,250 --> 08:59:05,770
wait is that the contract has
already been verified. And

9055
08:59:05,920 --> 08:59:08,740
you'll actually likely run into
this, because ether scan will

9056
08:59:08,740 --> 08:59:11,680
get smart enough by seeing
enough bytecode that is exactly

9057
08:59:11,680 --> 08:59:14,350
simple storage that it will
start to just automatically

9058
08:59:14,350 --> 08:59:17,470
verify any bytecode that looks
like simple storage. And then

9059
08:59:17,470 --> 08:59:21,070
this await will throw an error,
which we want to avoid. So what

9060
08:59:21,070 --> 08:59:27,340
we can do is we can add a try
catch onto this await. So

9061
08:59:27,340 --> 08:59:30,550
outside of the way, we're going
to add a try. And we're going to

9062
08:59:30,550 --> 08:59:34,540
add these little brackets that
wrap around our weight. And then

9063
08:59:34,540 --> 08:59:40,270
we're going to put a catch. This
is known as a try, catch and

9064
08:59:40,270 --> 08:59:44,380
solidity also has tried catches.
But basically, this e is going

9065
08:59:44,380 --> 08:59:47,620
to be any error that this
section throws. So we're going

9066
08:59:47,620 --> 08:59:51,160
to do is we're going to say if
this message is already

9067
08:59:51,160 --> 08:59:53,920
verified, then we're just going
to continue. So we're gonna say

9068
08:59:53,950 --> 09:00:00,460
if e.message.to lowercase, we're
going to make sure it's to

9069
09:00:00,460 --> 09:00:06,850
lowercase that includes already
there. If five, then we're just

9070
09:00:06,850 --> 09:00:10,450
going to console dot log already
verified

9071
09:00:11,500 --> 09:00:16,810
like that. Otherwise, we're just
going to console dot log e. The

9072
09:00:16,810 --> 09:00:20,650
reason we do This is because of
this errors, our verification

9073
09:00:20,650 --> 09:00:23,110
function will break, and our
whole script will end. And we

9074
09:00:23,110 --> 09:00:25,690
don't want our whole script to
end, we want our script to keep

9075
09:00:25,690 --> 09:00:28,480
continuing if the verification
doesn't work, because it's not

9076
09:00:28,480 --> 09:00:30,940
really a big deal. So I know
this might seem like a lot of

9077
09:00:30,940 --> 09:00:34,450
code, feel free to copy and
paste it from the GitHub repo to

9078
09:00:34,450 --> 09:00:38,170
just move along. But awesome. So
we now have a verify function

9079
09:00:38,200 --> 09:00:42,040
using the Verify task in
hardhat. Let's go ahead and use

9080
09:00:42,040 --> 09:00:45,730
this now in our main function,
right below our deploy, we'll do

9081
09:00:45,730 --> 09:00:48,490
console dot log deployed
contract two, and then the

9082
09:00:48,490 --> 09:00:51,940
contract address. But before we
call this main function, let's

9083
09:00:51,970 --> 09:00:57,580
think for a quick second. What
happens when we deploy to our RT

9084
09:00:57,580 --> 09:01:01,090
Hat Network? Well, remember, if
we deploy to our Hard Hat

9085
09:01:01,090 --> 09:01:04,480
Network, will our contract need
to be verified I need to scan?

9086
09:01:04,720 --> 09:01:08,110
Well, we know there's a we know
there's a rink ether scan, we

9087
09:01:08,110 --> 09:01:10,450
know there's a COVID ether scan,
we know there's a main net easy

9088
09:01:10,450 --> 09:01:14,680
scan. But is there a Hardhead
ether scan? No, of course not.

9089
09:01:14,740 --> 09:01:18,070
Right? The hard at runtime
environment is a network local

9090
09:01:18,070 --> 09:01:21,580
to our machine. So it doesn't
make sense for us to verify a

9091
09:01:21,580 --> 09:01:24,880
hard hat network deployed
contract on ether scan. So we

9092
09:01:24,880 --> 09:01:28,690
actually don't want to call this
verify function, when we're

9093
09:01:28,690 --> 09:01:31,750
working with our local network.
This is where these chain IDs

9094
09:01:31,750 --> 09:01:34,180
are going to come in quite
useful. What we can do is we can

9095
09:01:34,180 --> 09:01:37,270
check to see if the network that
we're running on is a live

9096
09:01:37,300 --> 09:01:40,120
network or it's a test net, or
it's a network that actually can

9097
09:01:40,120 --> 09:01:42,580
be verified, we can actually get
network configuration

9098
09:01:42,580 --> 09:01:48,640
information by importing a
network like this. And we can do

9099
09:01:49,240 --> 09:01:56,260
something like console dot log
network dot config. Now, if I

9100
09:01:56,260 --> 09:02:01,930
run yarn, art, hit run scripts
deploy.js. On our Hard Hat

9101
09:02:01,930 --> 09:02:05,890
Network, since I'm not passing a
network flag, we get this

9102
09:02:05,890 --> 09:02:09,460
massive output that looks like
this. Our network dot config

9103
09:02:09,490 --> 09:02:12,460
contains a ton of information
about the current network that

9104
09:02:12,460 --> 09:02:15,310
we're on, you'll see here that
the chain ID of the Hardhead

9105
09:02:15,310 --> 09:02:20,080
network is actually 31337 gas
price, which gets set to auto

9106
09:02:20,440 --> 09:02:23,770
block gas limit the current fork
of Aetherium that we're working

9107
09:02:23,770 --> 09:02:27,490
with, and all these other pieces
here. This chain ID is really

9108
09:02:27,490 --> 09:02:30,880
important. Because we can use
this chain ID to figure out

9109
09:02:31,000 --> 09:02:33,700
which one is a test net, or
which one is a live network. And

9110
09:02:33,700 --> 09:02:36,550
remember, running the script is
going to be the same as doing

9111
09:02:36,580 --> 09:02:39,310
dash dash network, hard hat,

9112
09:02:40,720 --> 09:02:44,530
you'll see our channel ID is
still 31337. Again, that's

9113
09:02:44,530 --> 09:02:47,800
because the default network in
our heart had config, it's hard

9114
09:02:47,800 --> 09:02:51,190
hat, which is the same as saying
every single time we run a

9115
09:02:51,190 --> 09:02:54,190
script, we're secretly running
it with dash dash network hard

9116
09:02:54,190 --> 09:02:57,730
hat. So now we only want to
verify on our test net. So what

9117
09:02:57,730 --> 09:03:02,110
we can do is we can say if
network dot config, that chain

9118
09:03:02,110 --> 09:03:07,570
ID equals equals equals four,
which is going to be rank B, ad.

9119
09:03:08,320 --> 09:03:12,040
And a JavaScript equals equals
equals is nearly the same as

9120
09:03:12,040 --> 09:03:15,910
equals equals, except no type
conversion is done, which just

9121
09:03:15,910 --> 09:03:21,820
means in JavaScript, four equals
four, and four equals equals the

9122
09:03:21,820 --> 09:03:26,110
string of four, but four, but if
you were to use four equals

9123
09:03:26,110 --> 09:03:30,910
equals equals four, this is
false. This is true equals

9124
09:03:30,910 --> 09:03:34,990
equals four equals equals would
be true, four equals equals to

9125
09:03:34,990 --> 09:03:38,050
the string of four would also be
true, but four equals equals

9126
09:03:38,110 --> 09:03:41,200
equals to the string of four is
going to be false. So you can

9127
09:03:41,200 --> 09:03:43,540
kind of do whatever you want
here equals equals or equals

9128
09:03:43,540 --> 09:03:46,870
equals equals. So we want to say
if the network dot config dot

9129
09:03:46,870 --> 09:03:52,030
Trinity is four, so if we're on
Rinkeby, then we can go ahead

9130
09:03:52,030 --> 09:03:57,100
and actually verify. But we also
want to make sure we only verify

9131
09:03:57,130 --> 09:04:01,570
if our ether scan API key
exists. So we can also in here

9132
09:04:01,570 --> 09:04:05,890
is site and this double
ampersand means and we can say

9133
09:04:05,920 --> 09:04:12,670
process dot e NV dot ether scan
API key. This is some Boolean

9134
09:04:12,670 --> 09:04:15,040
tricks that we're doing here,
basically, so our first

9135
09:04:15,070 --> 09:04:18,190
conditional we're saying if
network dot config chinati

9136
09:04:18,310 --> 09:04:22,000
equals equals equals four, this
section can be true or false,

9137
09:04:22,030 --> 09:04:25,060
obviously, right? The chain ID
that we're running on can be the

9138
09:04:25,060 --> 09:04:28,660
hardest network, which would
mean this doesn't equal four, or

9139
09:04:28,660 --> 09:04:31,360
it would be Rinckey, which means
this does equal four. But

9140
09:04:31,390 --> 09:04:34,120
there's no conditional on this
side. So how does this side

9141
09:04:34,120 --> 09:04:37,360
work? In JavaScript, if an
object exists, and you try to

9142
09:04:37,360 --> 09:04:41,380
cast it as a Boolean, it will be
converted to true. If it doesn't

9143
09:04:41,380 --> 09:04:44,320
exist, it will be converted to
false. So in JavaScript,

9144
09:04:44,320 --> 09:04:49,690
basically, if either scan API
key exists, if we have this in

9145
09:04:49,690 --> 09:04:53,680
our data in VI, this will be
true. And if not, this will be

9146
09:04:53,680 --> 09:04:57,130
false. So another way to read
this line here is saying if

9147
09:04:57,190 --> 09:05:01,480
network dot config that Trinity
is for AKA, if we're on rink B,

9148
09:05:01,960 --> 09:05:07,150
and our ether scan API key
exists, then do some stuff. And

9149
09:05:07,180 --> 09:05:09,790
that's what we're going to do
here. So in here, we'd want to

9150
09:05:09,790 --> 09:05:15,910
run verify, or verify function
and pass it the contract address

9151
09:05:15,970 --> 09:05:20,170
which is going to be Simple
Storage dot address and the

9152
09:05:20,170 --> 09:05:23,350
constructor arguments which we
know are going to be blank. And

9153
09:05:23,350 --> 09:05:27,370
since our verify function is an
async function, and it deals

9154
09:05:27,370 --> 09:05:31,120
with promises and stuff, we want
to add the await keyword here.

9155
09:05:31,510 --> 09:05:34,810
Awesome. So we've added a way to
actually verify our contract.

9156
09:05:34,810 --> 09:05:38,740
But we're not quite done. See on
ether scan and all these block

9157
09:05:38,740 --> 09:05:42,430
explorers the instant we deploy
the contract and the instant we

9158
09:05:42,430 --> 09:05:46,210
send the contract, ether scan
might not know about the

9159
09:05:46,210 --> 09:05:50,260
transaction yet, it might take a
hot second for ether scan to be

9160
09:05:50,260 --> 09:05:53,020
up to speed with where the
blockchain is. So it's usually

9161
09:05:53,020 --> 09:05:57,220
best practice to wait for a few
blocks to be mined, until you

9162
09:05:57,220 --> 09:06:00,280
actually run your verification
process. We've actually learned

9163
09:06:00,280 --> 09:06:04,000
how to do this already with the
deploy transaction. So before we

9164
09:06:04,000 --> 09:06:09,640
actually verify we run, we want
to run a weight, simple storage.

9165
09:06:10,900 --> 09:06:19,180
Deploy transaction Wait, six. So
we will wait six blocks, and

9166
09:06:19,180 --> 09:06:22,360
then we'll run our verification
process. Now, if you want to go

9167
09:06:22,360 --> 09:06:25,450
and test this out right now, you
absolutely can. I'm going to

9168
09:06:25,450 --> 09:06:28,480
keep going, though, because
again, testing all these on a

9169
09:06:28,480 --> 09:06:31,840
test net takes a little bit of
extra time. So I'm going to

9170
09:06:31,840 --> 09:06:34,120
finish the rest of our main
function, and then I'm going to

9171
09:06:34,120 --> 09:06:39,820
run everything all together.
Okay, cool. So we've deployed

9172
09:06:39,820 --> 09:06:42,730
our contract, we've
automatically programmatically

9173
09:06:42,760 --> 09:06:46,300
verified our contract. What's
next? Well, what did we do last

9174
09:06:46,300 --> 09:06:50,320
time, we started interacting
with the contract. So let's do

9175
09:06:50,710 --> 09:06:56,980
const. Current Value equals
await simple storage dot

9176
09:06:56,980 --> 09:07:01,780
retrieve. To get the current
value, simple storage, that's

9177
09:07:01,780 --> 09:07:05,650
all. We have a retrieve
function, which returns the

9178
09:07:05,650 --> 09:07:09,430
favorite number, so let's get
the current value. And we'll do

9179
09:07:09,460 --> 09:07:18,730
console dot log, the current
value is and then some string

9180
09:07:18,730 --> 09:07:23,230
interpolation, current value.
And then we'll go ahead and

9181
09:07:23,230 --> 09:07:31,780
update the current value by
doing cons. Transaction response

9182
09:07:31,870 --> 09:07:39,040
equals await simple storage,
that store will store the number

9183
09:07:39,040 --> 09:07:45,580
seven, and then we'll await
transaction response dot Wait,

9184
09:07:45,760 --> 09:07:49,810
we'll wait one block for that
transaction to go through. And

9185
09:07:49,810 --> 09:07:53,980
we'll grab the updated value by
saying const updated value

9186
09:07:54,730 --> 09:07:57,700
equals await simple storage

9187
09:07:58,960 --> 09:08:10,030
dot retrieve. Then we'll do
console log. The added value is

9188
09:08:11,200 --> 09:08:14,980
updated value. Awesome. And this
is going to be our whole script.

9189
09:08:15,370 --> 09:08:17,920
So if I can zoom out for a
little bit, I know it will be a

9190
09:08:17,920 --> 09:08:22,360
little bit small here, we've got
this huge main function, which

9191
09:08:22,390 --> 09:08:26,230
does what? Well it deploys our
contract. If we're on a test

9192
09:08:26,230 --> 09:08:29,560
net, it then verifies our
contract. And then it updates

9193
09:08:29,590 --> 09:08:33,670
the value to seven. And we have
our verify function down here.

9194
09:08:33,970 --> 09:08:37,180
And we have a section of our
code that calls our main

9195
09:08:37,180 --> 09:08:40,240
function. Now for run this on
the hard hat network. What do

9196
09:08:40,240 --> 09:08:44,260
you think will happen? Well,
let's try yarn, or net run

9197
09:08:44,350 --> 09:08:48,760
scripts. Deploy dot j s.
Alright, awesome, we get exactly

9198
09:08:48,760 --> 09:08:52,210
what we saw before we get
deploying contract deployed

9199
09:08:52,210 --> 09:08:56,110
contract to current value is
zero, update value seven. And

9200
09:08:56,110 --> 09:08:58,630
there's nothing in here about
verification. That's exactly

9201
09:08:58,630 --> 09:09:02,590
what we want. Now, moment of
truth. Let's try this on

9202
09:09:02,620 --> 09:09:08,290
Rinkeby. We'll do yarn, RT hat
run scripts, deploy dot j s,

9203
09:09:08,770 --> 09:09:16,540
dash dash network Rinkeby. And
it's gonna go a lot slower,

9204
09:09:16,570 --> 09:09:19,330
because obviously now we're
deploying to an actual test net,

9205
09:09:19,360 --> 09:09:21,970
where the blocks actually need
to be mined. And we see we

9206
09:09:21,970 --> 09:09:24,580
haven't deployed the contract.
Now that our contract is

9207
09:09:24,580 --> 09:09:27,610
deployed. We know that we're
currently waiting six block

9208
09:09:27,610 --> 09:09:30,610
confirmations for us to go ahead
and verify. And actually I

9209
09:09:30,610 --> 09:09:37,210
should add console dot log,
waiting for block the x's so

9210
09:09:37,210 --> 09:09:40,060
that we don't get campus weird.
Oh, wait, what are we doing now?

9211
09:09:42,970 --> 09:09:45,550
That it looks like we ran into
this error, no such file or

9212
09:09:45,550 --> 09:09:48,610
directory, it looks like our
code might not have compiled

9213
09:09:48,610 --> 09:09:51,430
correctly here. So here's what
I'm gonna do. We're gonna go

9214
09:09:51,430 --> 09:09:55,180
ahead and delete our artifacts
to trash. We're gonna delete our

9215
09:09:55,180 --> 09:09:58,810
cache as well. And we're going
to try rerunning this whenever

9216
09:09:58,810 --> 09:10:01,540
you run a script with the hard
drive command Hardhead will

9217
09:10:01,540 --> 09:10:04,870
automatically recompile it for
you, especially if there's no

9218
09:10:04,870 --> 09:10:08,170
artifacts folder. So we're going
to rerun this command and

9219
09:10:08,170 --> 09:10:11,050
heartbeat, it's going to compile
first and we can see that it

9220
09:10:11,050 --> 09:10:14,320
does exactly that. And then it's
going to go ahead and redeploy.

9221
09:10:15,010 --> 09:10:17,830
Hopefully this time, it should
be able to find the contract

9222
09:10:17,830 --> 09:10:26,170
that had just compiled looks
like this time after I deleted

9223
09:10:26,170 --> 09:10:29,200
the artifacts folder, we
actually did indeed get some

9224
09:10:29,200 --> 09:10:32,680
successful compilation. And we
can see here successfully

9225
09:10:32,680 --> 09:10:35,770
submitted source code for
contract or verification on the

9226
09:10:35,770 --> 09:10:38,290
block explore waiting for
verification results,

9227
09:10:38,800 --> 09:10:41,590
successfully verified contracts
simple storage on ether scan,

9228
09:10:41,890 --> 09:10:45,040
and even gives us a link that we
can go ahead and Command click

9229
09:10:45,040 --> 09:10:48,400
or control click into. And we
can see the contract indeed

9230
09:10:48,400 --> 09:10:55,360
being verified. This is awesome.
This is perfect. We've now got a

9231
09:10:55,360 --> 09:11:00,700
successful deploy dot j s script
that can deploy, verify, and

9232
09:11:00,700 --> 09:11:04,300
then interact with our code.
This is fantastic. This hard hat

9233
09:11:04,300 --> 09:11:06,760
thing seems pretty cool. What
else can we do with hard hat

9234
09:11:06,820 --> 09:11:11,650
like I showed you before. Hard
Hat comes with these tasks. And

9235
09:11:11,650 --> 09:11:13,900
the number of tasks that
Hardhead can come with can be

9236
09:11:13,900 --> 09:11:17,620
extended by us writing plugins,
we can actually write our own

9237
09:11:17,620 --> 09:11:21,190
tasks in hardhat. And in our
Hardhead dot config, it can

9238
09:11:21,190 --> 09:11:24,250
defaulted with this task
account, we can see task

9239
09:11:24,280 --> 09:11:28,510
accounts, prints the list of
accounts, and just prints a list

9240
09:11:28,510 --> 09:11:31,960
of accounts here actually go to
the heart had documentation to

9241
09:11:31,960 --> 09:11:34,690
learn more about creating our
own tasks, one of the ways that

9242
09:11:34,690 --> 09:11:39,640
you can define tasks is directly
in our heart head.config.js. But

9243
09:11:39,640 --> 09:11:43,450
typically, what people do is
they have a new folder called

9244
09:11:43,480 --> 09:11:47,530
tasks where they put all their
tasks. So for now, I'm gonna go

9245
09:11:47,530 --> 09:11:49,900
ahead and delete this section
here. And we're going to create

9246
09:11:49,930 --> 09:11:52,840
our own task. You'll notice that
now that we've deleted that

9247
09:11:52,840 --> 09:11:58,750
section, if we run yarn RDAP, we
no longer see the accounts task

9248
09:11:58,750 --> 09:12:01,660
in here, because we've just
deleted that task. So let's

9249
09:12:01,660 --> 09:12:08,140
create our own new task. We'll
call this block number.js. And

9250
09:12:08,140 --> 09:12:10,900
we'll use this to get the
current block number or whatever

9251
09:12:10,900 --> 09:12:13,810
blockchain that we're working
with. So let's create this task.

9252
09:12:14,080 --> 09:12:17,320
First, we need to import the
task function, we can get it by

9253
09:12:17,320 --> 09:12:24,730
saying const task equals require
arhat slash config. The hard hat

9254
09:12:24,730 --> 09:12:28,870
slash config has the task
function. To define a task, we

9255
09:12:28,870 --> 09:12:33,460
can now just say task, give it a
name and a description, the name

9256
09:12:33,490 --> 09:12:34,630
is going to be blocked number.

9257
09:12:36,010 --> 09:12:39,550
And then the description is
going to be prints the current

9258
09:12:40,930 --> 09:12:45,700
block number. Now that we have
this task, there's a couple of

9259
09:12:45,700 --> 09:12:48,040
things we can actually do with
it, we can add different

9260
09:12:48,040 --> 09:12:51,280
parameters to it by using the
dot add command, which allow us

9261
09:12:51,280 --> 09:12:54,400
to pass parameters to the task.
And then we could also set

9262
09:12:54,400 --> 09:12:58,180
actions which define what the
task should actually do for us,

9263
09:12:58,210 --> 09:13:03,340
we're just going to do dot set
action. And define what we want

9264
09:13:03,340 --> 09:13:07,660
this function to do. So we're
going to make this an async

9265
09:13:07,660 --> 09:13:11,620
function, that's going to take
as an input, the task arguments,

9266
09:13:11,650 --> 09:13:15,790
which are going to be blank for
us, and the HR E, which I'll

9267
09:13:15,790 --> 09:13:19,570
define in a second. Now, let me
explain the syntax really

9268
09:13:19,570 --> 09:13:22,570
quickly. This might look a
little bit weird, but this is

9269
09:13:22,570 --> 09:13:26,110
what's known as a JavaScript
arrow function. In JavaScript,

9270
09:13:26,140 --> 09:13:29,170
you can actually define
functions without even using the

9271
09:13:29,170 --> 09:13:32,140
function keyword. For example,
if we go back to our deploy

9272
09:13:32,140 --> 09:13:36,670
function, we have our async
function verify down here.

9273
09:13:37,090 --> 09:13:40,330
However, another way we could
have defined this is is without

9274
09:13:40,330 --> 09:13:43,420
using the function word at all,
and actually turning this whole

9275
09:13:43,420 --> 09:13:47,560
thing into a variable, we could
have said instead, we could say

9276
09:13:48,070 --> 09:13:54,370
const verify is going to be an
async function that takes

9277
09:13:54,370 --> 09:14:00,010
contract addresses and
arguments. And here's the

9278
09:14:00,010 --> 09:14:03,700
function definition. These two
lines are essentially

9279
09:14:03,730 --> 09:14:07,900
equivalent. There's some slight
differences between between

9280
09:14:07,900 --> 09:14:10,630
using the function keyword and
having your function be a

9281
09:14:10,630 --> 09:14:13,060
variable. But for the purposes
of this course, they're

9282
09:14:13,060 --> 09:14:17,860
basically the same. Which means
though, that this by itself is a

9283
09:14:17,860 --> 09:14:21,340
function, just not assigned to a
variable. But essentially, the

9284
09:14:21,340 --> 09:14:24,760
two of these do are exactly the
same. And that's the syntax that

9285
09:14:24,760 --> 09:14:27,940
we're doing here. You can
imagine this sort of being like

9286
09:14:27,940 --> 09:14:35,440
const block task equals async
function, which takes the params

9287
09:14:35,920 --> 09:14:39,010
and then runs that arrow
function. Or you can think of it

9288
09:14:39,010 --> 09:14:45,880
as async. Function, block task
parameters, and then the

9289
09:14:45,880 --> 09:14:49,450
function definition, these are
all essentially the same. The

9290
09:14:49,450 --> 09:14:53,290
major difference is that we're
never giving our function a

9291
09:14:53,290 --> 09:14:56,170
name, we never give it this
block task variable. This is

9292
09:14:56,170 --> 09:14:59,650
known as an anonymous function
in JavaScript, because it

9293
09:14:59,650 --> 09:15:02,920
doesn't have a name. Now that we
have our function in here, we

9294
09:15:02,920 --> 09:15:06,940
can now call some function to
get the block number. Well, how

9295
09:15:06,940 --> 09:15:10,150
can we get the block number when
we run tasks, we automatically

9296
09:15:10,150 --> 09:15:13,480
pass our anonymous functions,
the task arguments, which in

9297
09:15:13,480 --> 09:15:18,040
this one, we don't have any, but
we also pass this HR II object.

9298
09:15:18,550 --> 09:15:23,560
This HRV is the heart hat
runtime environment. Back in our

9299
09:15:23,560 --> 09:15:27,820
deploy script, this is basically
the same as this require hard

9300
09:15:27,820 --> 09:15:32,320
hat in here. So this HRV can
access a lot of the same, this

9301
09:15:32,320 --> 09:15:36,940
HRV can access a lot of the same
packages that the hard hat

9302
09:15:37,060 --> 09:15:41,920
package can. So we can do Hae
dot ethers, just like how you

9303
09:15:41,920 --> 09:15:45,100
can import ethers from hard hat.
And in our ethers package,

9304
09:15:45,100 --> 09:15:47,740
there's actually a number of
functions we can use like dot

9305
09:15:47,740 --> 09:15:54,520
Pro, biter dot get block number.
Let's save this to a variable

9306
09:15:54,970 --> 09:15:59,890
const blocked number equals, and
this is going to be a

9307
09:15:59,890 --> 09:16:02,500
synchronous, so we're going to
want to add a weight here. And

9308
09:16:02,500 --> 09:16:06,940
then let's do console dot log
block number. Or better yet,

9309
09:16:07,540 --> 09:16:11,740
we'll string interpolate this
and say current block number

9310
09:16:12,760 --> 09:16:17,740
like this. Now though, if I try
to run this task, you'll notice

9311
09:16:17,770 --> 09:16:21,790
it doesn't show up in the heart
Atlas of tasks, let's do yarn.

9312
09:16:22,330 --> 09:16:26,920
Art app. Hmm, I don't see block
number in here. Well, this is

9313
09:16:26,920 --> 09:16:31,600
because we need to add it to our
config dot config will add

9314
09:16:31,990 --> 09:16:38,590
require dot slash tasks slash
block number.

9315
09:16:39,970 --> 09:16:43,420
And in order for us to import
it, and let's add a module that

9316
09:16:43,420 --> 09:16:47,080
exports I'll explain what this
does a little bit later. But now

9317
09:16:47,080 --> 09:16:50,890
that we've required it, if I run
yarn hard hat, and now see

9318
09:16:50,950 --> 09:16:54,490
blocked over is one of the tasks
that I can use. Now for a run

9319
09:16:54,490 --> 09:16:59,740
yarn, art hat block number, we
get current block number is

9320
09:16:59,740 --> 09:17:03,730
zero. And this makes sense
because this is defaulting to

9321
09:17:03,730 --> 09:17:08,230
our Hard Hat Network, which gets
reset every time we run it. But

9322
09:17:08,230 --> 09:17:11,770
if I run yarn, hard hat block
number A dash dash network

9323
09:17:11,770 --> 09:17:15,430
Rinkeby, what do you think I'm
gonna get? Again, a much larger

9324
09:17:15,430 --> 09:17:19,120
number, current block number is
right here. Because this is the

9325
09:17:19,120 --> 09:17:23,830
actual block number of Rigby
versus the block number of our

9326
09:17:23,830 --> 09:17:27,550
heart ad network is going to be
zero because it gets reset every

9327
09:17:27,550 --> 09:17:31,660
single time, we run one of these
scripts now scripts and tasks

9328
09:17:31,660 --> 09:17:35,500
both can basically do the same
thing. They both can interact

9329
09:17:35,500 --> 09:17:38,080
with contracts, they both can
deploy smart contracts, they can

9330
09:17:38,080 --> 09:17:41,830
both pretty much do everything.
I prefer scripts just as a

9331
09:17:41,830 --> 09:17:45,160
general rule of thumb, because I
don't always think adding a

9332
09:17:45,160 --> 09:17:48,310
special thing from the command
line makes sense. So I prefer

9333
09:17:48,310 --> 09:17:51,400
scripts, but you'll see a ton of
tasks and examples out there as

9334
09:17:51,400 --> 09:17:55,270
well. I think tasks are really
nice for specific use cases. But

9335
09:17:55,510 --> 09:17:58,270
for the most part, we're pretty
much going to use exclusively

9336
09:17:58,270 --> 09:18:01,960
scripts, but it is good to know
what a task looks like and how

9337
09:18:01,960 --> 09:18:05,260
to use it. I think tasks are
better for plugins and scripts

9338
09:18:05,290 --> 09:18:08,410
are better for your own local
development environment. But if

9339
09:18:08,410 --> 09:18:14,380
you want to do everything with
tasks, you absolutely can. As

9340
09:18:14,380 --> 09:18:18,160
you're starting to see, this
config piece is pretty powerful.

9341
09:18:18,550 --> 09:18:21,970
And we can use it to modify our
entire code base and our entire

9342
09:18:21,970 --> 09:18:25,330
project to give our project more
functionality. What else can

9343
09:18:25,330 --> 09:18:28,510
this do? Well, right now, as you
can see, every time we work with

9344
09:18:28,510 --> 09:18:31,360
a hard hat network, every time
we run a script, we run that

9345
09:18:31,360 --> 09:18:34,270
script, and then the Hard Hat
Network is deleted, right? We

9346
09:18:34,270 --> 09:18:36,760
can't interact with our
contracts anymore. Well, there's

9347
09:18:36,760 --> 09:18:40,840
actually a way for us to run a
hard hat network. Similar to how

9348
09:18:40,840 --> 09:18:44,530
we ran a ganache network with a
user interface. What we can do

9349
09:18:44,530 --> 09:18:51,430
in hard hat is run yarn, RT hat
node. And what this will do is

9350
09:18:51,430 --> 09:18:55,990
it'll spin up a node on a local
network, exactly the same as

9351
09:18:55,990 --> 09:19:00,460
ganache but in our terminal. So
you see here started HTTP and

9352
09:19:00,460 --> 09:19:04,930
WebSocket. JSON RPC server at
this address. And just like

9353
09:19:04,930 --> 09:19:08,320
nosh, it comes packed with all
these different accounts and

9354
09:19:08,320 --> 09:19:11,650
private keys, which is awesome.
You'll notice though,

9355
09:19:11,890 --> 09:19:16,540
interestingly enough that this
node that we're running isn't on

9356
09:19:16,540 --> 09:19:18,910
the Hard Hat Network, well, we
can actually create a new

9357
09:19:18,910 --> 09:19:22,510
terminal to try to interact with
this just by hitting this little

9358
09:19:22,510 --> 09:19:26,650
plus button and creating a new
terminal. Again, I'm using bash,

9359
09:19:26,650 --> 09:19:29,740
but based off of whatever your
operating system is, you can be

9360
09:19:29,740 --> 09:19:33,130
using a different shell. And
here, let's go ahead and run

9361
09:19:33,130 --> 09:19:39,100
yarn arhat run scripts, deploy
dot j s, and see what happens.

9362
09:19:39,250 --> 09:19:42,700
Well, our typical setup happens,
we deploy a contract, we get a

9363
09:19:42,700 --> 09:19:46,600
contract address, we update the
value. But if we look at our

9364
09:19:46,600 --> 09:19:49,840
node, it doesn't look like any
transactions went through what

9365
09:19:49,870 --> 09:19:53,770
we don't see any locking here.
So what's going on? Well, our

9366
09:19:53,770 --> 09:19:58,060
Hard Hat Network is actually
different from this locally

9367
09:19:58,060 --> 09:20:02,110
running network here. This
locally running network we often

9368
09:20:02,110 --> 09:20:05,590
want to refer to as our local
host. So it's slightly different

9369
09:20:05,590 --> 09:20:08,500
than the Hard Hat Network. It's
still using the hard hat runtime

9370
09:20:08,500 --> 09:20:11,380
environment, but it's just not
this default Hard Hat Network.

9371
09:20:11,380 --> 09:20:15,040
It's considered its own separate
network when we're running a

9372
09:20:15,040 --> 09:20:19,360
node that it's going to live. of
past the duration of a script.

9373
09:20:19,540 --> 09:20:23,410
So we can actually interact with
this by adding a new network to

9374
09:20:23,410 --> 09:20:27,280
our hardhead.config.js, we'll
create a new network and call it

9375
09:20:27,820 --> 09:20:28,690
local host.

9376
09:20:30,369 --> 09:20:35,139
And exactly as we did up here,
we'll give it a URL accounts and

9377
09:20:35,139 --> 09:20:40,929
a chain ID. So for URL, we can
get that URL right from our

9378
09:20:40,929 --> 09:20:44,319
terminal, I'll put a running
yarn hard hat node. by copying

9379
09:20:44,319 --> 09:20:48,399
that and pasting it in here, we
can then do a comma, we'll give

9380
09:20:48,399 --> 09:20:55,899
it a chain ID of 31337. Because
even though it's considered a

9381
09:20:55,899 --> 09:20:58,809
different network, it actually
has the same chain ID as hard

9382
09:20:58,809 --> 09:21:01,449
hat. Interestingly enough, I
know I just said we were going

9383
09:21:01,449 --> 09:21:03,549
to give it accounts, but we
actually don't need to give it

9384
09:21:03,549 --> 09:21:07,269
accounts. Because when we run
with this localhost hard hat

9385
09:21:07,269 --> 09:21:11,019
will automatically give us these
10 fake accounts for us. So you

9386
09:21:11,019 --> 09:21:14,199
can kind of think of the
accounts here for this localhost

9387
09:21:14,199 --> 09:21:19,359
as, as hard had already placing
them in thanks, hard hat. But

9388
09:21:19,359 --> 09:21:23,529
now, if we go back to our bash
here, let's clear the terminal.

9389
09:21:23,949 --> 09:21:28,659
Let's rerun the script. And
we'll do dash dash network local

9390
09:21:28,659 --> 09:21:33,369
host. Now we should be pointing
to this node. And when I run

9391
09:21:33,369 --> 09:21:38,139
this script, we should see some
logging output at the end of

9392
09:21:38,139 --> 09:21:42,369
this node. So let's go ahead and
hit enter. Well, we see our

9393
09:21:42,369 --> 09:21:46,089
normal stuff on our deploy
script, we flip back to our node

9394
09:21:46,119 --> 09:21:50,979
Wow, we see a ton of logging
here. Similar to ganache, we can

9395
09:21:50,979 --> 09:21:53,739
see a whole bunch of different
logs on what just happened, we

9396
09:21:53,739 --> 09:21:56,439
can see a contract was deployed,
we can see the address the

9397
09:21:56,439 --> 09:22:00,579
transaction hash from value,
gas, and the block number and

9398
09:22:00,579 --> 09:22:05,289
everything. We can also see our
contract call calling the store

9399
09:22:05,289 --> 09:22:09,639
function to update the value of
our favorite number. This is

9400
09:22:09,639 --> 09:22:13,689
incredibly powerful for quickly
testing and working with things

9401
09:22:13,689 --> 09:22:17,349
on a local JavaScript VM or hard
hat network to be able to see

9402
09:22:17,409 --> 09:22:20,769
how your contracts will interact
on a real test net. And this is

9403
09:22:20,769 --> 09:22:24,759
much quicker than working with a
real test net. Now additionally,

9404
09:22:24,849 --> 09:22:27,999
same as what we said before, any
process that's running in the

9405
09:22:27,999 --> 09:22:32,019
terminal, we can kill it with
Ctrl C. So if you want to stop

9406
09:22:32,019 --> 09:22:37,569
your node and then restart it,
you can hit Ctrl. C, to stop it,

9407
09:22:37,599 --> 09:22:41,349
and then just up and then rerun
that same command to re spin up

9408
09:22:41,349 --> 09:22:45,639
your node Ctrl C stops it. And
then you can up to start again.

9409
09:22:45,909 --> 09:22:47,949
Another way you can stop it, of
course, is if you hit the

9410
09:22:47,949 --> 09:22:50,619
trashcan, which deletes the
whole terminal, we pulled a

9411
09:22:50,619 --> 09:22:55,449
terminal back up, we can run it
again. And just remember, if you

9412
09:22:55,449 --> 09:22:58,869
hit the X that actually doesn't
delete the terminal, that just

9413
09:22:58,869 --> 09:23:02,139
hides it. So our hard hat node
right now is still running

9414
09:23:02,139 --> 09:23:04,629
because I just hit it. So I pull
it back up, I can see that it is

9415
09:23:04,629 --> 09:23:07,149
indeed still running. But if I
trashed candidate, and then it

9416
09:23:07,149 --> 09:23:09,369
pulled the terminal back up, I
can see that it is no longer

9417
09:23:09,369 --> 09:23:15,729
running. So running scripts is
great. But what if I don't want

9418
09:23:15,729 --> 09:23:19,449
to have to code an entire script
to do some things? What if I

9419
09:23:19,449 --> 09:23:23,079
want to just tinker around with
the blockchain? Well, hard hat

9420
09:23:23,079 --> 09:23:26,499
comes packed with this thing
called the console. The console

9421
09:23:26,499 --> 09:23:29,979
is a JavaScript environment. For
us to run JavaScript commands to

9422
09:23:29,979 --> 09:23:33,579
interact with any blockchain, we
can jump to the console by

9423
09:23:33,579 --> 09:23:38,709
running yarn, hardhat, console,
and then whatever network flag

9424
09:23:38,739 --> 09:23:41,739
if we want to work on rink B,
main net polygon, avalanche,

9425
09:23:41,739 --> 09:23:45,759
etc. That's just network local
host. And now we're dropped into

9426
09:23:45,759 --> 09:23:49,599
a shell him in the shell, we can
do everything that we do in a

9427
09:23:49,599 --> 09:23:52,809
deploy script. And we don't even
have to run these imports,

9428
09:23:52,809 --> 09:23:55,929
because everything with hard hat
is automatically imported into

9429
09:23:55,929 --> 09:23:59,169
our console. So for example,
let's say I wanted to get a

9430
09:23:59,169 --> 09:24:02,889
simple storage contract factory.
Well, I could run exactly this

9431
09:24:02,889 --> 09:24:08,109
line here. I could say const,
simple storage, factory equals

9432
09:24:08,139 --> 09:24:15,939
await ethers dot get contract
factory, have simple storage.

9433
09:24:16,239 --> 09:24:19,929
And now I can go ahead and even
deploy this. So I can even just

9434
09:24:19,929 --> 09:24:25,029
copy this line, paste it. And if
we flip back to our node, we'll

9435
09:24:25,029 --> 09:24:28,539
see that we just deployed a
nother simple storage. And now

9436
09:24:28,539 --> 09:24:36,219
we can do things like await
simple storage dot retrieve. And

9437
09:24:36,219 --> 09:24:39,159
I get the return value which is
going to be a big number with a

9438
09:24:39,159 --> 09:24:43,239
value of zero. I can also make
transactions so I can do a

9439
09:24:43,239 --> 09:24:52,179
weight, simple storage. That
store let's do 55 If I hit up

9440
09:24:52,179 --> 09:24:55,149
twice, I can go back to the
simple storage dot retrieve.

9441
09:24:55,599 --> 09:24:59,379
call that function and I can see
my big number has a value of 55.

9442
09:24:59,379 --> 09:25:01,809
Now, this is a great way to
quickly interact with any

9443
09:25:01,809 --> 09:25:04,629
blockchain that we want. Now you
can exit the shell by hitting

9444
09:25:04,629 --> 09:25:09,519
Ctrl C twice to get out. Or you
can also just you can also Trash

9445
09:25:09,519 --> 09:25:12,159
Can your terminal if you get
confused. This console works

9446
09:25:12,159 --> 09:25:18,339
with any network we can even do
yarn, hard hat console dash dash

9447
09:25:18,369 --> 09:25:22,869
network hard hat. And we'll get
dropped into a hard hat network.

9448
09:25:23,319 --> 09:25:26,289
Now this is not going to be the
same node that's running here,

9449
09:25:26,319 --> 09:25:30,159
this is going to be one that
only runs for the duration of

9450
09:25:30,219 --> 09:25:33,399
this command. So whenever we
cancel this command, this hard

9451
09:25:33,399 --> 09:25:37,449
hat network gets cancelled. And
close out that too. We can also

9452
09:25:37,449 --> 09:25:45,429
do yarn, hard hat, console, dash
dash network Rinkeby Rigby, or

9453
09:25:45,429 --> 09:25:48,729
polygon or test net or main net
or whatever we want. And we can

9454
09:25:48,729 --> 09:25:54,609
do things like ethers dot
provider that can do things like

9455
09:25:54,639 --> 09:25:59,439
await ethers dot provider dot
get block number, see the block

9456
09:25:59,439 --> 09:26:03,639
number of Rigby. We can also
deploy contracts, we can update

9457
09:26:03,639 --> 09:26:05,979
contracts, we can do anything
that we want, you can do

9458
09:26:06,009 --> 09:26:08,859
anything in these consoles, and
they're great ways to quickly

9459
09:26:08,859 --> 09:26:10,719
test and tinker in interact

9460
09:26:10,840 --> 09:26:16,060
with contracts. Now, there's a
couple other tasks that are

9461
09:26:16,060 --> 09:26:19,240
really helpful. You'll see
before I went ahead and just

9462
09:26:19,240 --> 09:26:22,450
deleted artifacts and deleted
the cache manually. Well, to do

9463
09:26:22,450 --> 09:26:28,840
that yourself, you can also just
run yarn Hardhead, clean. And

9464
09:26:28,840 --> 09:26:31,900
that'll delete the artifacts
folder and clear out your cache.

9465
09:26:31,990 --> 09:26:34,750
We already know what compiled
does. But one of the biggest

9466
09:26:34,750 --> 09:26:37,930
things that Hardhead is
fantastic for especially is

9467
09:26:37,930 --> 09:26:41,920
running tests. Now we haven't
run tests yet so far. However,

9468
09:26:41,920 --> 09:26:45,340
running tests is absolutely
critical to your smart contract

9469
09:26:45,340 --> 09:26:48,460
development journey. And we're
going to spend a lot of time in

9470
09:26:48,460 --> 09:26:51,490
the future writing really good
tests. The reason that writing

9471
09:26:51,490 --> 09:26:55,270
tests are so important is
because we want to make sure our

9472
09:26:55,270 --> 09:26:59,440
code does exactly what we want
it to do, especially in the

9473
09:26:59,440 --> 09:27:03,010
defy, and the decentralized,
smart contract world, all of our

9474
09:27:03,010 --> 09:27:06,400
code is going to be open source
for anybody to interact with,

9475
09:27:06,730 --> 09:27:10,540
and potentially exploit. There's
sites like req dot news, which

9476
09:27:10,570 --> 09:27:14,590
go through a ton of previous
hacks and how they actually got

9477
09:27:14,590 --> 09:27:17,890
hacked and what happened in the
smart contract to enable these

9478
09:27:17,890 --> 09:27:21,760
hacks to occur. So testing, so
writing really strong tests is

9479
09:27:21,760 --> 09:27:25,120
always going to be our first
line of defense. And we have

9480
09:27:25,120 --> 09:27:28,300
this sample test.js, that comes
default with the basic package

9481
09:27:28,300 --> 09:27:31,240
of hardhat. But as you probably
already know, we're going to

9482
09:27:31,240 --> 09:27:34,330
rename this and change it. So
we're going to rename this to

9483
09:27:34,840 --> 09:27:39,640
test deploy dot j s. And we're
going to delete everything in

9484
09:27:39,640 --> 09:27:43,030
here and start from scratch. We
want to be able to test all of

9485
09:27:43,030 --> 09:27:46,630
our solidity code locally, so
that we know exactly what it's

9486
09:27:46,630 --> 09:27:50,320
doing. And we can have a
programmatic way to make sure

9487
09:27:50,320 --> 09:27:54,700
that our code does what we want
it to do. So let's write a basic

9488
09:27:54,700 --> 09:27:58,870
test for our simple storage
contract. So that we can be sure

9489
09:27:58,870 --> 09:28:02,110
that it's doing exactly what we
want it to be doing. Hard Hat

9490
09:28:02,110 --> 09:28:06,130
testing works with the Mocha
framework, which is a JavaScript

9491
09:28:06,130 --> 09:28:09,760
based framework for running our
tests, you actually can write

9492
09:28:09,760 --> 09:28:13,900
tests directly in solidity, if
you'd like to, there's a bit of

9493
09:28:13,900 --> 09:28:16,630
back and forth on whether
testing with pure solidity is

9494
09:28:16,630 --> 09:28:19,720
better or testing with a modern
programming language. The

9495
09:28:19,720 --> 09:28:22,630
argument goes that testing with
a modern programming language,

9496
09:28:22,660 --> 09:28:27,010
you have more flexibility to do
more stuff to interact and test

9497
09:28:27,010 --> 09:28:29,230
your smart contracts. But the
argument for testing with us

9498
09:28:29,230 --> 09:28:32,200
with solidity is that we want to
be as close to the code as

9499
09:28:32,200 --> 09:28:35,980
possible. At the time of
recording, most projects do the

9500
09:28:35,980 --> 09:28:39,610
vast majority of their testing
in a modern programming language

9501
09:28:39,640 --> 09:28:42,520
like JavaScript. So that's what
we're going to be using here. So

9502
09:28:42,520 --> 09:28:45,610
to get started with our mocha
tests, we do, we're going to

9503
09:28:45,610 --> 09:28:50,050
write a describe function.
Describe is a keyword that

9504
09:28:50,050 --> 09:28:54,550
hardheaded mocha will recognize,
and it takes two parameters, it

9505
09:28:54,550 --> 09:28:58,180
takes a string, which we're
going to just write simple

9506
09:28:58,180 --> 09:29:02,500
storage for now. And then also
takes a function, we could make

9507
09:29:03,400 --> 09:29:09,670
function, test func and then
write some stuff in here, and

9508
09:29:09,670 --> 09:29:13,930
then pass it to our describe
here. But the common convention

9509
09:29:14,110 --> 09:29:17,740
is going to be to do is to make
it as an anonymous function,

9510
09:29:18,250 --> 09:29:22,510
which we can create by typing
function, putting an empty

9511
09:29:22,510 --> 09:29:25,390
parameter here, and then some
brackets like that. So our

9512
09:29:25,390 --> 09:29:29,560
describe function takes a name,
a string, and a function.

9513
09:29:29,890 --> 09:29:32,740
Another way that you'll often
see functions in describe is

9514
09:29:32,740 --> 09:29:37,000
using that anonymous function
syntax. So you might see just

9515
09:29:37,000 --> 09:29:41,440
these parentheses, an arrow, and
then some brackets, the two of

9516
09:29:41,440 --> 09:29:44,350
these are going to be basically
the same, there are some

9517
09:29:44,350 --> 09:29:47,830
differences. And this second one
is actually best practice, but

9518
09:29:47,830 --> 09:29:51,280
just know that you might see
this arrow syntax in other tests

9519
09:29:51,280 --> 09:29:54,010
as well. We have described a
sample storage and then our

9520
09:29:54,010 --> 09:29:56,680
function here, which is going to
have all of our tests in it.

9521
09:29:56,920 --> 09:29:59,530
Inside each one of our describe
blocks. We're gonna have

9522
09:29:59,530 --> 09:30:03,340
something called a before each,
and a bunch of It's Our before

9523
09:30:03,340 --> 09:30:07,030
each function is going to tell
us what to do before each of our

9524
09:30:07,060 --> 09:30:09,730
hits. So we're going to have a
ton of it and then we're going

9525
09:30:09,730 --> 09:30:13,030
to have a before each. All of
our IDs are going to be where we

9526
09:30:13,030 --> 09:30:15,940
actually write the code for
running our tests. And before

9527
09:30:15,940 --> 09:30:19,270
each is going to be some code
that tells us what to do before

9528
09:30:19,540 --> 09:30:23,710
each one of these hits, we can
also actually have describes,

9529
09:30:25,540 --> 09:30:29,470
inside of describes, which again
have more before each and more

9530
09:30:29,470 --> 09:30:33,550
before it's having these nested
describes can be really helpful

9531
09:30:33,550 --> 09:30:37,780
for separating and modularizing
our tests. But for this one,

9532
09:30:37,780 --> 09:30:41,080
we're just going to have a setup
that looks like this. And for

9533
09:30:41,080 --> 09:30:45,010
this demo, we're only going to
have one it. So in order to test

9534
09:30:45,010 --> 09:30:47,710
our smart contracts, before we
actually run our tests, we're

9535
09:30:47,710 --> 09:30:50,620
probably going to need to deploy
the smart contracts first. So

9536
09:30:50,620 --> 09:30:53,470
inside of our before each, we're
going to pass the our before

9537
09:30:53,470 --> 09:30:56,950
each a function, that's going to
tell our testing framework what

9538
09:30:56,950 --> 09:31:00,070
to do before each test. So we're
going to pass it an async

9539
09:31:00,100 --> 09:31:05,080
function like this. And in here,
we want to deploy our simple

9540
09:31:05,080 --> 09:31:08,410
storage contract. So to do that,
we're going to need to get the

9541
09:31:08,410 --> 09:31:12,520
ethers framework and do exactly
what we did in our deploy

9542
09:31:12,520 --> 09:31:15,670
script. So in here, we're at the
top we're gonna say const.

9543
09:31:16,180 --> 09:31:23,590
Ethers, equals require art have
an import ethers from hard hat.

9544
09:31:23,830 --> 09:31:29,800
Then in our before each
function, we'll say await ethers

9545
09:31:29,800 --> 09:31:37,510
dot get contract factory of
simple storage. And we'll assign

9546
09:31:37,510 --> 09:31:46,240
this to a const. Simple Storage
factory. And then we'll run

9547
09:31:46,960 --> 09:31:52,780
away, simple storage factory dot
deploy. Cool. And let's also

9548
09:31:52,810 --> 09:31:58,450
assign this to a variable cost
simple. Now, since right now,

9549
09:31:58,480 --> 09:32:02,470
our simple storage and simple
storage factory are scoped just

9550
09:32:02,470 --> 09:32:05,860
to inside the before each, we
actually need to stick these

9551
09:32:05,860 --> 09:32:09,940
variables outside of the before
each, so all of our events can

9552
09:32:09,970 --> 09:32:12,940
interact with them. So instead
of having simple storage,

9553
09:32:12,940 --> 09:32:16,660
factory, and simple storage, be
constant variables, we're going

9554
09:32:16,660 --> 09:32:20,140
to define them outside of them
for each with the let keyword.

9555
09:32:20,350 --> 09:32:25,540
And we're gonna say let simple
storage factory and we're going

9556
09:32:25,540 --> 09:32:29,860
to initialize it to nothing. And
then we'll say led simple

9557
09:32:29,920 --> 09:32:32,980
storage. Now, if you have a
whole bunch of let's just

9558
09:32:32,980 --> 09:32:35,380
initializing another way, you
can write them in JavaScript,

9559
09:32:35,410 --> 09:32:41,080
just let simple storage factory
comma, simple storage. And that

9560
09:32:41,080 --> 09:32:43,420
works exactly the same. And then
we can get rid of this const

9561
09:32:43,420 --> 09:32:47,770
keyword. Because it's not a
constant since we are assigning

9562
09:32:47,770 --> 09:32:50,050
it. And now we have simple
storage, factory and simple

9563
09:32:50,050 --> 09:32:53,200
storage that we can use inside
of our init function. Now we

9564
09:32:53,200 --> 09:32:56,140
have a before each section. So
before each one of our tests,

9565
09:32:56,200 --> 09:32:58,630
we're going to deploy our simple
storage contract. So we have a

9566
09:32:58,630 --> 09:33:02,200
brand new contract to interact
with for each one of our tests.

9567
09:33:02,260 --> 09:33:05,920
Now, inside of the ID, this is
where we're going to say what we

9568
09:33:05,920 --> 09:33:09,310
want this specific test to do,
and then describe the code

9569
09:33:09,550 --> 09:33:13,480
that's going to actually do
that. So we're going to say it

9570
09:33:13,870 --> 09:33:20,980
should start with a favorite
number of zero. So this is

9571
09:33:20,980 --> 09:33:24,190
saying what this test should do.
And then we're going to add our

9572
09:33:24,220 --> 09:33:27,910
async function to actually do
that. So we'll say async

9573
09:33:28,720 --> 09:33:34,060
function. And in here, this is
where we'll actually write the

9574
09:33:34,060 --> 09:33:38,020
code to make sure that our
contract does exactly this.

9575
09:33:38,080 --> 09:33:45,640
We're say const. Current Value,
equals await, simple storage.re

9576
09:33:46,840 --> 09:33:50,440
retrieve. And now in this test,
we want to say okay, now check

9577
09:33:50,440 --> 09:33:54,100
to see that this current value
is indeed zero. So how do we do

9578
09:33:54,100 --> 09:33:59,200
that? Well, we can say const,
expected value is going to equal

9579
09:33:59,830 --> 09:34:04,360
zero. And what we can do is we
can do either we can use either

9580
09:34:04,360 --> 09:34:08,170
the assert keyword, or the
expect keyword, which we're

9581
09:34:08,170 --> 09:34:12,970
going to import both of these
from a package called Chai. We

9582
09:34:12,970 --> 09:34:16,420
actually installed Chai
automatically when we downloaded

9583
09:34:16,420 --> 09:34:19,120
the basic parameters when we
downloaded the basic packages

9584
09:34:19,120 --> 09:34:23,050
for hardhats. So at the top,
we're gonna say const. Expect

9585
09:34:23,260 --> 09:34:24,310
and assert

9586
09:34:25,630 --> 09:34:30,760
equals require Chai, I'm a big
fan of using assert as much as

9587
09:34:30,760 --> 09:34:33,160
possible, because I think the
syntax makes a little bit more

9588
09:34:33,190 --> 09:34:36,010
sense. But there will be
scenarios where we need to use

9589
09:34:36,010 --> 09:34:39,130
expect instead. Now, assert has
a ton of functions that are

9590
09:34:39,130 --> 09:34:43,030
built in that help us make sure
this is what we expect it to be.

9591
09:34:43,060 --> 09:34:48,040
So I can do assert dot equal
current value.to string, because

9592
09:34:48,040 --> 09:34:51,130
remember, this is actually going
to be a big number, comma,

9593
09:34:51,370 --> 09:34:55,480
expected value. So I'm saying
I'm asserting this retrieve to

9594
09:34:55,480 --> 09:34:59,440
return zero, which is going to
be our expected value. Now to

9595
09:34:59,440 --> 09:35:04,570
actually run this, we're going
to run yarn, art hat test. And

9596
09:35:04,570 --> 09:35:07,840
we see we get an output that
looks like this should start

9597
09:35:07,840 --> 09:35:10,870
with favorite number of zero,
and it's indeed passing. You'll

9598
09:35:10,870 --> 09:35:14,620
notice that if I were to change
this to one, and this wasn't

9599
09:35:14,620 --> 09:35:18,220
correct, it would break and it
would say art Pass or not

9600
09:35:18,220 --> 09:35:23,890
passing assertion error expected
zero to equal one. It expected

9601
09:35:23,920 --> 09:35:29,260
zero to equal one, which is not
what we want. We want zero to

9602
09:35:29,260 --> 09:35:33,430
equal zero. So let's run this
again. Tada should start with

9603
09:35:33,430 --> 09:35:36,640
favorite number zero, and it's
passing. Alright, fantastic. So

9604
09:35:36,640 --> 09:35:40,030
that's how we wrote one of our
tests, let's write one more test

9605
09:35:40,060 --> 09:35:43,060
just to make sure that things
are good. So let's say it should

9606
09:35:43,060 --> 09:35:48,490
update when we call store,
because when we call the store

9607
09:35:48,490 --> 09:35:51,850
function, we want our favorite
number to update. And we'll make

9608
09:35:51,850 --> 09:35:56,560
this an async function as well.
And let's add our stuff in here.

9609
09:35:56,770 --> 09:36:01,360
So we'll say const. Expected
Value equals seven, we're

9610
09:36:01,360 --> 09:36:04,990
expecting that when we call
store it updates to seven. Now

9611
09:36:05,020 --> 09:36:11,620
we can say const. Transaction
response equals await simple

9612
09:36:11,620 --> 09:36:16,840
storage dot store. And we can
even just pass it the expected

9613
09:36:16,840 --> 09:36:21,670
value here. And then we'll do a
weight transaction response that

9614
09:36:21,670 --> 09:36:25,240
weight one. Now let's get the
current value. So we'll say

9615
09:36:25,240 --> 09:36:31,030
const. Current Value equals
weight, simple storage,

9616
09:36:32,080 --> 09:36:37,750
retrieve. And now we're going to
assert dot equal current

9617
09:36:37,750 --> 09:36:44,140
value.to string, comma expected
value. And now we can run all

9618
09:36:44,140 --> 09:36:47,440
these tests by running yarn
Hardhead test. And you'll see we

9619
09:36:47,440 --> 09:36:51,700
ran both of these tests. And now
if I have 10,000 tests, and I'm

9620
09:36:51,700 --> 09:36:55,000
only finagling with one test, I
can actually just run one test

9621
09:36:55,000 --> 09:37:01,570
by running yarn, art app, test,
dash dash grep. And I can search

9622
09:37:01,600 --> 09:37:06,160
for any keywords in any of the
text here. So I'm going to grep

9623
09:37:06,160 --> 09:37:10,660
for the store function. Because
the store keyword isn't in this

9624
09:37:10,660 --> 09:37:14,740
tax for this, it, it's only in
the text for this it. So if I do

9625
09:37:14,740 --> 09:37:18,550
grep store, it should only run
our second test, which does

9626
09:37:18,550 --> 09:37:22,840
indeed, one other way we can run
only specific tests is with the

9627
09:37:22,840 --> 09:37:28,030
only keyword. So we can type it
dot only like that. And then we

9628
09:37:28,030 --> 09:37:33,430
can run yarn, art hat test. And
it should only run, this should

9629
09:37:33,490 --> 09:37:36,820
update when we call store. And
it does indeed, then we'll go

9630
09:37:36,820 --> 09:37:40,750
ahead and delete this save, run
again, and it should run all

9631
09:37:40,750 --> 09:37:45,250
too. Fantastic. Now the other
way you'll see these tests

9632
09:37:45,250 --> 09:37:49,210
written is with instead of
assert, it'll use the expect

9633
09:37:49,210 --> 09:37:52,600
keyword. So you'll see something
like expect current

9634
09:37:52,600 --> 09:37:59,260
value.to string.to dot equal
expected value, the two of these

9635
09:37:59,290 --> 09:38:03,520
lines do exactly the same thing.
And it's sort of up to you on

9636
09:38:03,520 --> 09:38:06,160
which one you want to use. And
that's all we're going to do for

9637
09:38:06,160 --> 09:38:12,280
our testing. Now. This is
fantastic, great job. Now that

9638
09:38:12,280 --> 09:38:15,940
we have some tests, we can
actually start testing to see

9639
09:38:15,940 --> 09:38:19,660
how much gas each one of our
functions actually costs. One of

9640
09:38:19,660 --> 09:38:23,230
the most popular extensions for
hard hat is the hard hat gas

9641
09:38:23,230 --> 09:38:27,160
reporter. This is an extension
that gets attached to all of our

9642
09:38:27,160 --> 09:38:30,130
tests, and automatically gives
us an output that looks like

9643
09:38:30,130 --> 09:38:32,950
this, that tells us
approximately how much gas each

9644
09:38:32,950 --> 09:38:36,010
one of our functions cost. We
scroll down in here, we can read

9645
09:38:36,010 --> 09:38:38,620
the instructions on how to
actually install this npm

9646
09:38:38,620 --> 09:38:41,830
install Hardhead gas reporter
which we're going to use with

9647
09:38:41,860 --> 09:38:49,510
yarn. So we're gonna say yarn,
add hard hat, gas reporter, dash

9648
09:38:49,510 --> 09:38:50,440
dash Dev.

9649
09:38:52,930 --> 09:38:56,890
And now that that package is
installed, we can go over to our

9650
09:38:57,040 --> 09:39:01,480
config and add some parameters
in here so that we can work with

9651
09:39:01,480 --> 09:39:04,750
this gas pit. But our neath our
ether scan section, we're going

9652
09:39:04,750 --> 09:39:09,430
to add a new section called gas
reporter. To have it run,

9653
09:39:09,460 --> 09:39:12,940
whenever we run our tests we're
going to do enabled is going to

9654
09:39:12,940 --> 09:39:17,260
be true. And then up at the top,
we can add it by adding require

9655
09:39:18,250 --> 09:39:23,470
hardhat gas reporter. Now that
we have it in here, we can do

9656
09:39:23,470 --> 09:39:27,160
yarn hardhat test, and after we
run our tests, it'll

9657
09:39:27,190 --> 09:39:32,380
automatically run this gas
reporter. So we see our tests go

9658
09:39:32,380 --> 09:39:35,590
ahead and run. And then we get
this output that looks like this

9659
09:39:35,620 --> 09:39:39,610
that tells us how approximately
how much our contracts and

9660
09:39:39,610 --> 09:39:42,850
methods cost. So our store
function looks like It costs

9661
09:39:42,880 --> 09:39:45,910
approximately this much gas and
our simple storage costs

9662
09:39:45,940 --> 09:39:49,390
approximately this much gas.
This is incredibly helpful for

9663
09:39:49,390 --> 09:39:53,530
figuring out how to optimize our
gas as best as possible. Now I

9664
09:39:53,530 --> 09:39:56,650
usually like to take it a step
further though. Having the gas

9665
09:39:56,650 --> 09:40:00,460
output it like that is nice, but
we can make it even better. I

9666
09:40:00,460 --> 09:40:05,440
like to output it to a file by
doing output file. Yes, report

9667
09:40:05,470 --> 09:40:10,120
dot txt and then my dot get
ignore like to add it in here,

9668
09:40:10,210 --> 09:40:15,010
but doing gas report dot txt
sentence it's not really

9669
09:40:15,010 --> 09:40:18,190
important for the gas report to
get pushed up to GitHub. Do no

9670
09:40:18,190 --> 09:40:22,480
colors is true. The reason we
add this is because when we

9671
09:40:22,480 --> 09:40:26,890
output to a file, the colors can
get messed up basically. And

9672
09:40:26,890 --> 09:40:29,500
then the biggest addition we
could do is we can add a

9673
09:40:29,500 --> 09:40:34,840
currency in here. So that we can
get the cost of each function in

9674
09:40:34,840 --> 09:40:38,740
USD for a blockchain like
Aetherium. Now in order to get a

9675
09:40:38,740 --> 09:40:43,450
currency here, we actually need
to get an API key from corn

9676
09:40:43,450 --> 09:40:46,120
market cap, just like we did
with ether scan, you can go to

9677
09:40:46,120 --> 09:40:52,240
coin market cap, corn market cap
API, get your API key now, and

9678
09:40:52,240 --> 09:41:01,240
we'll go ahead and sign up.
Choose a basic plan. We'll agree

9679
09:41:01,660 --> 09:41:05,110
and create my account, we'll get
an email verification. And we'll

9680
09:41:05,110 --> 09:41:10,240
go ahead and verify. Now in the
coin market cap dashboard, we

9681
09:41:10,240 --> 09:41:14,050
can copy our key. And yep, you
guessed it exactly what we're

9682
09:41:14,050 --> 09:41:16,330
going to do with this key, we're
going to drop it into our dot

9683
09:41:16,330 --> 09:41:22,840
env file, or say coin market
cap, API key equals and then

9684
09:41:22,840 --> 09:41:25,750
paste it in there like that. Now
that we have our corn market cap

9685
09:41:25,780 --> 09:41:30,460
API key in here, we can go back
to our header dot config and add

9686
09:41:30,460 --> 09:41:33,490
it in this corn market cap
parameter. We're gonna do the

9687
09:41:33,490 --> 09:41:38,050
exact same way we did above,
we'll do const, coin, market

9688
09:41:38,050 --> 09:41:46,210
cap, API key equals process dot
EMV, that coin market cap API

9689
09:41:46,210 --> 09:41:49,930
key, and then we'll take this
sticking in here. So what this

9690
09:41:49,930 --> 09:41:52,930
is going to do is actually going
to make an API call to corn

9691
09:41:52,930 --> 09:41:56,680
market cap, whenever we run our
gas reporter. This is why

9692
09:41:56,710 --> 09:41:59,290
sometimes you'll see me comment
this out and uncomment it

9693
09:41:59,320 --> 09:42:02,440
because I don't always want it
to make this API calls. But now

9694
09:42:02,440 --> 09:42:05,410
what we can do now that it's
enabled, we have an output file,

9695
09:42:05,770 --> 09:42:08,740
we can see the currency and we
have our API key, all we can do

9696
09:42:08,740 --> 09:42:14,650
is run yarn hardhat test. And
after all our tests pass, we're

9697
09:42:14,650 --> 09:42:18,520
going to see a gas report.tx T
that we can go ahead and read

9698
09:42:18,520 --> 09:42:23,290
from which has that gas report.
And now it actually has the USD

9699
09:42:23,290 --> 09:42:26,200
price of each one of these
transactions, it looks like at

9700
09:42:26,200 --> 09:42:30,670
current prices, with Aetherium
being $3,000 per eath, and a gas

9701
09:42:30,670 --> 09:42:34,930
price of 43 Gwei, the store
function would cost $6. And the

9702
09:42:34,930 --> 09:42:38,440
simple storage function would
cost $64. The current the

9703
09:42:38,440 --> 09:42:40,540
Hardhead gas reporter actually
comes with some different

9704
09:42:40,540 --> 09:42:42,490
options, though, if you're going
to be deploying to different

9705
09:42:42,490 --> 09:42:46,180
network, for example, with
binance, Polygon, Avalanche or

9706
09:42:46,180 --> 09:42:49,630
hecho. For example, let's say we
wanted to deploy the polygon,

9707
09:42:49,900 --> 09:42:53,080
let's see how much deploying the
polygon would cost well in our

9708
09:42:53,080 --> 09:42:55,450
WMV UHD ad token,

9709
09:42:57,790 --> 09:43:03,580
Matic And now we'd rerun this
test. And if we look at our gas

9710
09:43:03,580 --> 09:43:07,570
report that takes T will now see
the gas price of polygon right

9711
09:43:07,570 --> 09:43:12,100
now is around 37 Gray per gas.
And the cost of Matic is 147

9712
09:43:12,190 --> 09:43:15,760
automatic and USD. Now we can
see the cost of calling the

9713
09:43:15,760 --> 09:43:20,440
simple storage method is going
to be $0.00. Now this of course

9714
09:43:20,440 --> 09:43:23,320
is rounded down, but it's going
to be really, really cheap to

9715
09:43:23,320 --> 09:43:26,890
call store versus deploying the
contract is going to cost three

9716
09:43:26,890 --> 09:43:30,640
cents, I make it a habit to
select false for my gas reporter

9717
09:43:30,850 --> 09:43:32,830
whenever I don't want to
actually work with the gas here.

9718
09:43:33,070 --> 09:43:36,160
Awesome. Now sometimes when
we're working with our code, if

9719
09:43:36,160 --> 09:43:39,550
we don't have these environment
variables specified Hardhead

9720
09:43:39,580 --> 09:43:43,360
might get a little bit upset
with us. So oftentimes, I'll add

9721
09:43:43,390 --> 09:43:47,440
some code in here. So that these
variables are always populated,

9722
09:43:47,470 --> 09:43:52,870
because we didn't specify our
rink prpc URL, ring P RPC URL is

9723
09:43:52,870 --> 09:43:56,140
going to be undefined. And that
might throw some errors blow. So

9724
09:43:56,140 --> 09:43:59,350
oftentimes, what we'll do is
I'll add an or parameter here,

9725
09:43:59,620 --> 09:44:03,610
these double pipes mean or, and
in JavaScript, if we say some

9726
09:44:03,610 --> 09:44:07,000
variable equals something or
something else, what is really

9727
09:44:07,000 --> 09:44:10,690
happening is we're gonna say,
okay, rink, the RPC URL is going

9728
09:44:10,690 --> 09:44:15,220
to be equal to process dot E and
V dot rink, the RPC URL. But if

9729
09:44:15,220 --> 09:44:18,640
this rink, the RPC URL doesn't
exist, it's going to be whatever

9730
09:44:18,640 --> 09:44:23,080
else is over here. And I might
write something like HTTPS eath

9731
09:44:23,080 --> 09:44:28,360
Rinkeby. Example, or something
like this, just so that I don't

9732
09:44:28,360 --> 09:44:31,270
make hard hat mad if I don't use
rank B. And we can do something

9733
09:44:31,270 --> 09:44:36,610
like that for all these. So
you'll see this syntax,

9734
09:44:36,640 --> 09:44:42,700
oftentimes in a lot of code
setups. Now the last thing that

9735
09:44:42,700 --> 09:44:45,340
I'm going to show you before
going into the TypeScript

9736
09:44:45,340 --> 09:44:48,820
edition of This is test
coverage. And as we progressed

9737
09:44:48,820 --> 09:44:51,460
to this course, I'm going to
show you more and more tools

9738
09:44:51,460 --> 09:44:54,370
that you can use to make sure
that our simple storage contract

9739
09:44:54,400 --> 09:44:58,390
is safe and secure. And we take
all the steps we can to prevent

9740
09:44:58,390 --> 09:45:01,180
any hacks from happening if we
deploy in real life. One of

9741
09:45:01,180 --> 09:45:04,210
those tools is a tool called
solidity coverage. And this is

9742
09:45:04,210 --> 09:45:07,420
also a hardhat plugin that we
can use for our code. solidity

9743
09:45:07,420 --> 09:45:10,480
coverage is a project that goes
through all of our tests and

9744
09:45:10,480 --> 09:45:15,550
sees exactly how many lines of
code in our sample store dot Sol

9745
09:45:15,580 --> 09:45:18,580
are actually covered. And this
can be a Good tip off. If we

9746
09:45:18,580 --> 09:45:21,640
don't cover some line of code,
solidity coverage will say, Hey,

9747
09:45:21,670 --> 09:45:23,830
you don't have any tests for
this line, maybe you should

9748
09:45:23,830 --> 09:45:26,320
write some tests for it. We can
add solidity coverage the same

9749
09:45:26,320 --> 09:45:29,770
way we've been adding all of our
packages. npm install dash, just

9750
09:45:29,770 --> 09:45:33,880
save Dev, or since we're using
yarn, yarn, add dash dash Dev,

9751
09:45:34,090 --> 09:45:41,170
solidity coverage. And we can
then add this to our config, the

9752
09:45:41,170 --> 09:45:43,900
same way we've been adding
everything to our config, go to

9753
09:45:43,900 --> 09:45:48,610
our config, and we'll write
require solidity coverage. And

9754
09:45:48,610 --> 09:45:50,890
there's some configuration
pieces we can add down here

9755
09:45:50,890 --> 09:45:53,530
below for this, but we're just
going to use the default now we

9756
09:45:53,530 --> 09:45:58,870
can do is run yarn, RT hat
coverage. And this is going to

9757
09:45:58,870 --> 09:46:01,750
go through our tests and print
out a file that looks like this,

9758
09:46:01,930 --> 09:46:04,780
we'll also get a file called
coverage dot JSON, which is

9759
09:46:04,780 --> 09:46:08,500
basically this chart broken down
a little bit more often put my

9760
09:46:08,740 --> 09:46:12,040
coverage dot JSON in my dot get
ignore. And I know we haven't

9761
09:46:12,040 --> 09:46:15,250
actually seen dot Git ignore, do
what it's supposed to do. But we

9762
09:46:15,250 --> 09:46:20,500
will soon we can see here that
about 50% of the code 50% of our

9763
09:46:20,500 --> 09:46:24,250
statements in simple storage dot
soul are covered. About two

9764
09:46:24,250 --> 09:46:27,700
thirds of our functions are and
50% of the lines, It'll even

9765
09:46:27,700 --> 09:46:30,940
give us exactly what lines
aren't tested right now, which

9766
09:46:30,940 --> 09:46:34,750
we can see exactly 31 and 32 of
simple swords, outsole aren't

9767
09:46:34,750 --> 09:46:38,560
covered, which makes a lot of
sense, because 31 to 32 is this

9768
09:46:38,590 --> 09:46:41,650
Add Person function, which we
didn't call and we didn't add to

9769
09:46:41,650 --> 09:46:45,310
our tests. If you want to take
this time to pause and try to

9770
09:46:45,310 --> 09:46:48,580
make this solidity coverage be
100% across the board, by

9771
09:46:48,580 --> 09:46:51,370
writing some more tests, I
highly recommend you do so it'll

9772
09:46:51,370 --> 09:46:54,370
be a great learning exercise.
We'll also add the coverage

9773
09:46:54,400 --> 09:46:57,460
folder. So covered adjacent and
the coverage folder, which

9774
09:46:57,490 --> 09:47:00,550
again, I'll explain what the dot
get ignore folder does a little

9775
09:47:00,550 --> 09:47:06,040
bit later. Now the last thing
that we didn't talk about and

9776
09:47:06,040 --> 09:47:10,090
here was what is this nomic labs
hard hat waffle. We talked about

9777
09:47:10,090 --> 09:47:13,600
Daddy and V heart and ether scan
tasks gas reports. So today,

9778
09:47:14,110 --> 09:47:18,130
what is this? Well, we can
actually Google search this and

9779
09:47:18,130 --> 09:47:21,730
find out exactly what this is
Hardhead waffle is actually a

9780
09:47:21,730 --> 09:47:25,240
plugin to work with the waffle
testing framework. waffle is one

9781
09:47:25,240 --> 09:47:27,730
of these frameworks that allow
us to do some really advanced

9782
09:47:27,760 --> 09:47:30,310
testing, we're going to be
working with some syntax that

9783
09:47:30,310 --> 09:47:33,070
looks really similar to this
really soon. And we'll be

9784
09:47:33,070 --> 09:47:35,470
showing you more and more of
this waffle tool

9785
09:47:35,500 --> 09:47:41,200
as we continue. Alright, the
next part of this section, I'm

9786
09:47:41,200 --> 09:47:43,750
actually going to go over the
TypeScript edition of this. But

9787
09:47:43,750 --> 09:47:46,330
for all intents and purposes,
you've successfully created your

9788
09:47:46,330 --> 09:47:50,620
first Hardhead project, you've
done a ton of amazing things. In

9789
09:47:50,620 --> 09:47:53,560
this lesson, let's do a quick
refresher of what we've learned

9790
09:47:53,560 --> 09:47:57,100
so far, we learned how to spin
up our own hard hat projects.

9791
09:47:57,340 --> 09:48:02,620
And now we can run yarn, hard
hat and see a list of the tasks

9792
09:48:02,650 --> 09:48:06,010
and different things that we can
do with hard hat. We learned

9793
09:48:06,010 --> 09:48:10,210
that hard hat looks for this
hard hat.config.js. And this is

9794
09:48:10,210 --> 09:48:13,330
sort of the entry point for any
task that we run that starts

9795
09:48:13,330 --> 09:48:16,150
with hard hat, we learned we can
add our contracts to this

9796
09:48:16,150 --> 09:48:20,020
contracts folder. And then we
compile it by running yarn, art

9797
09:48:20,020 --> 09:48:24,400
half compile, we learned that
all the compliation goes into

9798
09:48:24,400 --> 09:48:28,210
the artifacts and then the cache
as well. And if we want to clean

9799
09:48:28,210 --> 09:48:30,820
reset, we can either delete
these two files or just run

9800
09:48:30,820 --> 09:48:34,840
yarn, hard hat clean. So we
learned that we can use scripts

9801
09:48:34,870 --> 09:48:38,350
or tasks to actually deploy,
interact and do things with our

9802
09:48:38,350 --> 09:48:40,990
smart contracts. We also learned
that I'm going to be using

9803
09:48:40,990 --> 09:48:43,360
scripts for the rest of this
course. But if you want, you

9804
09:48:43,360 --> 09:48:46,360
could absolutely use tasks as
well. I've asked this question a

9805
09:48:46,360 --> 09:48:49,060
million times what's the
difference? Nobody really seems

9806
09:48:49,060 --> 09:48:51,760
to know what the main difference
is. But I think the main

9807
09:48:51,760 --> 09:48:54,220
difference is that tasks are for
plugins. And scripts are for

9808
09:48:54,220 --> 09:48:57,280
your local development Mart,
that is mind limiter, we learned

9809
09:48:57,280 --> 09:49:01,120
that we can import a whole bunch
of things, including tasks from

9810
09:49:01,150 --> 09:49:03,610
hard hat in our scripts, and we
can work with our async

9811
09:49:03,610 --> 09:49:07,390
functions to grab our contracts
and deploy them, we actually

9812
09:49:07,390 --> 09:49:11,410
then can programmatically verify
them using hard hat and using

9813
09:49:11,410 --> 09:49:14,230
hard hat plugins. And then
additionally, we can interact

9814
09:49:14,230 --> 09:49:17,260
with our contracts very similar
to how we did it with ethers. We

9815
09:49:17,260 --> 09:49:20,560
wrote a wonderful verification
script. And we also wrote our

9816
09:49:20,560 --> 09:49:24,790
own task, we wrote our first
test for this whole space. And

9817
09:49:24,790 --> 09:49:27,400
we showed what our tests are
going to look like moving

9818
09:49:27,400 --> 09:49:30,520
forward. And we talked a little
bit about their importance. And

9819
09:49:30,520 --> 09:49:33,430
I really should stress that
writing good tests is going to

9820
09:49:33,430 --> 09:49:35,860
be the difference between a
really professional environment

9821
09:49:36,010 --> 09:49:38,920
and kind of a side project.
Whenever I audit smart

9822
09:49:38,920 --> 09:49:41,860
contracts, or whenever I'm given
a project for someone to tell me

9823
09:49:41,860 --> 09:49:44,950
to take a look at. The first
thing I look at is the readme,

9824
09:49:45,010 --> 09:49:48,850
of course. And the second thing
I look at is the tests. And if

9825
09:49:48,850 --> 09:49:51,640
tests aren't good, I usually
tell them, hey, you need to go

9826
09:49:51,640 --> 09:49:54,460
back to the drawing board, and
you need to level up your tests.

9827
09:49:54,490 --> 09:49:57,040
So tests are really really
important, especially for this

9828
09:49:57,040 --> 09:50:00,040
space, we learned about a couple
of more environment variables we

9829
09:50:00,040 --> 09:50:03,070
can use. We learned about a
couple of tools to see how good

9830
09:50:03,100 --> 09:50:07,060
our tests are one of them being
coverage. We also learn about a

9831
09:50:07,060 --> 09:50:10,450
gas reporter to see how much
it's going to cost us when we

9832
09:50:10,450 --> 09:50:13,900
actually deploy to a real
network. We learned a ton about

9833
09:50:13,900 --> 09:50:16,870
the hard hat config, and how
there are multiple networks that

9834
09:50:16,870 --> 09:50:19,810
we can add add to our hard
heads, we can make our project

9835
09:50:19,840 --> 09:50:23,500
our EVM code, work with any
network out there, we started

9836
09:50:23,500 --> 09:50:26,170
working with dev dependencies
instead of regular dependencies.

9837
09:50:26,410 --> 09:50:29,440
Now, READMEs are something that
I'm not really going to go over

9838
09:50:29,530 --> 09:50:33,130
too deeply in here. But READMEs
are sort of like the welcome

9839
09:50:33,130 --> 09:50:36,490
page of your GitHub repository,
and really should give you an

9840
09:50:36,490 --> 09:50:39,970
understanding of what your code
does. Being a part of the web

9841
09:50:39,970 --> 09:50:42,280
through space. And being a part
of the blockchain ecosystem is

9842
09:50:42,280 --> 09:50:45,580
really more than just you coding
your stuff by yourself. You want

9843
09:50:45,610 --> 09:50:48,400
other people to interact and
engage with your code and engage

9844
09:50:48,400 --> 09:50:50,860
with your projects. I haven't
showed you how to use GitHub

9845
09:50:50,860 --> 09:50:53,350
yet. But don't worry, we're
going to but if you look at my

9846
09:50:53,350 --> 09:50:56,710
heart had simple storage readme.
If you scroll down, usually, you

9847
09:50:56,710 --> 09:50:59,620
really want to have a Getting
Started section where you define

9848
09:50:59,620 --> 09:51:02,920
how to set up all the code and
how to set everything up a

9849
09:51:02,920 --> 09:51:06,730
Quickstart section, and maybe a
usage section and some testing

9850
09:51:06,730 --> 09:51:09,640
section, which teaches people
how to actually use and interact

9851
09:51:09,640 --> 09:51:12,430
with your code. Since we're just
learning more of the code part

9852
09:51:12,430 --> 09:51:15,040
and not so much the readme part.
For now, we're not going to go

9853
09:51:15,040 --> 09:51:18,190
over how to make a fantastic
readme. However, I will leave a

9854
09:51:18,190 --> 09:51:20,680
link in the GitHub repository
associated with this course,

9855
09:51:20,800 --> 09:51:23,680
link to this best readme
template. It really is a

9856
09:51:23,680 --> 09:51:26,620
fantastic readme template that
you can copy to any of your

9857
09:51:26,620 --> 09:51:29,290
projects to make them look
really good and give them a

9858
09:51:29,290 --> 09:51:32,050
really good setup, so that other
developers can come to your

9859
09:51:32,050 --> 09:51:35,230
project, and learn and
participate with what you're

9860
09:51:35,230 --> 09:51:38,590
coding. But all right, you have
learned an absolute ton, you

9861
09:51:38,590 --> 09:51:41,530
should be incredibly proud of
yourself, and incredibly excited

9862
09:51:41,530 --> 09:51:44,110
that you've made it this far.
Now I'm going to jump into the

9863
09:51:44,110 --> 09:51:46,540
TypeScript section here. So for
those of you who are coding

9864
09:51:46,540 --> 09:51:49,300
along with TypeScript, feel free
to follow along. For those of

9865
09:51:49,300 --> 09:51:52,120
you who are not, you just
finished the Basic section on

9866
09:51:52,120 --> 09:51:55,270
hard hit, but stick around the
next to heart out sections are

9867
09:51:55,270 --> 09:51:58,540
going to be the ones that really
fine grain and hone your skills,

9868
09:51:58,750 --> 09:52:01,240
and give you all the
fundamentals for working with

9869
09:52:01,240 --> 09:52:04,090
these frameworks. So be sure to
follow along with the next two

9870
09:52:04,090 --> 09:52:07,780
sections, we've got a ton more
fantastic content for you, we

9871
09:52:07,780 --> 09:52:10,660
are just beginning to get deeper
into the smart contract

9872
09:52:10,660 --> 09:52:14,200
ecosystem. So take that lap, get
that coffee, and I'll see you

9873
09:52:14,200 --> 09:52:20,740
soon. Alright, also now let's do
this with TypeScript. So I am

9874
09:52:20,740 --> 09:52:22,930
going to go ahead and just start
this from our JavaScript

9875
09:52:22,930 --> 09:52:25,570
section. However, if in the
future, you want to start a new

9876
09:52:25,570 --> 09:52:28,000
Hardhead project, you can
actually start a new project

9877
09:52:29,050 --> 09:52:34,450
with yarn, hard hat. And then do
great and advanced sample

9878
09:52:34,450 --> 09:52:38,740
project that uses TypeScript,
you'll add a ton of plugins. And

9879
09:52:38,740 --> 09:52:41,380
you'll wait a while for
everything to get uploaded. And

9880
09:52:41,380 --> 09:52:43,120
you wait, and you wait a little
bit for everything to get

9881
09:52:43,120 --> 09:52:45,370
downloaded. We're not going to
do that though, because I'm

9882
09:52:45,370 --> 09:52:48,640
going to show you how to convert
this to JavaScript Anyways, if

9883
09:52:48,640 --> 09:52:51,130
in future hearted sections, as
we're coding along with

9884
09:52:51,130 --> 09:52:53,800
JavaScript, if you want to code
along with TypeScript, you

9885
09:52:53,800 --> 09:52:57,100
absolutely 100% can. But let's
go ahead and show you what the

9886
09:52:57,100 --> 09:52:59,620
main differences are. Now that
advanced TypeScript thing is

9887
09:52:59,620 --> 09:53:01,960
going to add a whole bunch of
packages that you may or may not

9888
09:53:01,960 --> 09:53:04,870
want, I will talk about some of
them in our next lesson. But

9889
09:53:04,870 --> 09:53:07,510
there are going to be some that
you absolutely do need. Those

9890
09:53:07,510 --> 09:53:14,650
are going to be at type chain
slash ethers, dash v five, at

9891
09:53:14,680 --> 09:53:20,470
type chain, slash hard hat, at
TypeScript, at types, slash

9892
09:53:20,470 --> 09:53:28,930
Chai, at types, slash node, at
types slash moko, TS node, type

9893
09:53:28,930 --> 09:53:33,790
chain and TypeScript. And I have
a link in the GitHub repo

9894
09:53:33,790 --> 09:53:36,640
associated with this course,
I've got this yarn ad that you

9895
09:53:36,640 --> 09:53:39,160
can just copy paste, if you want
to just copy paste that into

9896
09:53:39,160 --> 09:53:41,650
your project to run it. Oops,
and I should have added those as

9897
09:53:41,650 --> 09:53:44,260
dev dependencies. So we're going
to actually just make them dev

9898
09:53:44,260 --> 09:53:47,530
dependencies real quick, just by
deleting these two lines, and

9899
09:53:47,530 --> 09:53:51,310
adding a comma here. Awesome,
that looks much better. And then

9900
09:53:51,310 --> 09:53:54,400
of course, what we're going to
do is we're going to convert all

9901
09:53:54,400 --> 09:53:59,110
of our JavaScript to TypeScript.
So anywhere where we have J S,

9902
09:53:59,200 --> 09:54:01,690
we're going to put Ts,
obviously, if you're coding this

9903
09:54:01,690 --> 09:54:04,630
from scratch with TypeScript,
you would do the.ts From the get

9904
09:54:04,630 --> 09:54:08,110
go. This includes our hard hat
dot config, that's also going to

9905
09:54:08,110 --> 09:54:10,420
be TypeScript now. And
additionally, we're going to add

9906
09:54:10,420 --> 09:54:14,260
a TS config dot JSON. This is
going to be our TypeScript

9907
09:54:14,260 --> 09:54:16,840
configuration. Typically, for a
setup, we're gonna go with

9908
09:54:16,840 --> 09:54:19,420
something like this. And you can
copy this from the GitHub repo

9909
09:54:19,420 --> 09:54:21,580
associated with this course.
It's basically telling

9910
09:54:21,610 --> 09:54:24,130
TypeScript, what versions of
Typescript and what files to

9911
09:54:24,130 --> 09:54:27,100
include for working with
TypeScript. Now let's go ahead

9912
09:54:27,100 --> 09:54:30,370
and start with our deploy dot
TypeScript. For usual, instead

9913
09:54:30,370 --> 09:54:34,390
of using require, we're gonna go
ahead and use import, we're

9914
09:54:34,390 --> 09:54:37,990
gonna do the exact same thing.
We're gonna have import ethers

9915
09:54:37,990 --> 09:54:45,640
run network, from hard hat. And
then in our verify function,

9916
09:54:45,790 --> 09:54:48,070
we're going to add that we're
gonna add the types for these

9917
09:54:48,070 --> 09:54:52,540
arguments. So contract address,
is going to be a string. And

9918
09:54:52,570 --> 09:54:56,260
args is going to be an array of
arguments. So we're gonna say

9919
09:54:56,260 --> 09:54:59,410
it's gonna be any array, because
it could be string, it could be

9920
09:54:59,410 --> 09:55:02,200
numbers, it could be balloons,
it could be anything. We're also

9921
09:55:02,200 --> 09:55:04,840
going to say for IE, it could be
any, even though this is

9922
09:55:04,840 --> 09:55:08,230
technically an error type, we're
just going to put any for

9923
09:55:08,230 --> 09:55:12,160
simplicity. For now. All of our
TypeScript scripts are included

9924
09:55:12,520 --> 09:55:15,730
in our TS config, or any
TypeScript files are manually

9925
09:55:15,730 --> 09:55:18,700
added here, which we have Our
entire scripts folder here,

9926
09:55:18,730 --> 09:55:22,870
which is good. So now we need to
add ethers in here. Well, if we

9927
09:55:22,870 --> 09:55:26,980
look at our hardhead.config.ts,
we're using require here still,

9928
09:55:27,040 --> 09:55:30,550
and we need to swap this out for
import for Donnie V, you can use

9929
09:55:30,550 --> 09:55:34,720
dot env slash config for it to
grab your dot env file. Now that

9930
09:55:34,720 --> 09:55:38,050
we've imported everything, go
back to our deploy.ts, we can

9931
09:55:38,050 --> 09:55:41,020
see that that linting has gone
away. If you want to be even

9932
09:55:41,020 --> 09:55:45,190
more explicit, we can go ahead
and add import at nomic labs

9933
09:55:45,850 --> 09:55:50,470
slash hard hat ethers like so.
reason we don't need to import

9934
09:55:50,470 --> 09:55:54,040
it here is because these two
packages also work with Hardhead

9935
09:55:54,040 --> 09:55:56,830
ethers, so they automatically
import it. But if you want to be

9936
09:55:56,830 --> 09:56:00,220
super explicit, you can go ahead
and add it like so. Now, we're

9937
09:56:00,220 --> 09:56:03,730
almost good to go. But remember,
our Harnett dot config is also

9938
09:56:03,730 --> 09:56:06,460
importing our tasks. So we're
going to need to update our

9939
09:56:06,460 --> 09:56:10,990
tasks or block number to be
TypeScript fide. So of course,

9940
09:56:11,020 --> 09:56:16,720
instead of const require, we're
going to import task from our

9941
09:56:16,720 --> 09:56:19,630
that slash config. And we're
going to be sure to export our

9942
09:56:19,630 --> 09:56:23,350
task from lock number as the
default. So we're going to do

9943
09:56:23,380 --> 09:56:28,960
export default task like so. And
now we should be good to run our

9944
09:56:28,960 --> 09:56:33,970
scripts. So we can just do yarn,
art hat, run scripts,

9945
09:56:34,330 --> 09:56:38,440
employee.ts. We can do network
hard hat if we choose. And

9946
09:56:38,470 --> 09:56:42,250
awesome. Now, it's when we get
to the testing, that things get

9947
09:56:42,280 --> 09:56:45,400
a little bit different here. So
let's go ahead and change this

9948
09:56:45,430 --> 09:56:50,410
required to import. Just to make
it happy there. Let's try to run

9949
09:56:50,440 --> 09:56:55,990
yarn, art head test, we get a
whole bunch of errors, and in VS

9950
09:56:55,990 --> 09:56:58,930
code will actually go ahead and
get these errors right from the

9951
09:56:58,930 --> 09:57:02,320
linter. One of the trickiest
things that you run into as a

9952
09:57:02,320 --> 09:57:06,100
developer in this space is
calling functions on contracts

9953
09:57:06,100 --> 09:57:09,520
where those functions don't
exist, or vice versa. We're not

9954
09:57:09,520 --> 09:57:12,340
calling functions on contracts
that do exist. Right now the

9955
09:57:12,340 --> 09:57:17,140
typing for our contracts is just
type contract, which isn't super

9956
09:57:17,140 --> 09:57:20,290
helpful, because type contract
doesn't necessarily have all the

9957
09:57:20,290 --> 09:57:23,440
functions that we want it to
have. We want our contracts to

9958
09:57:23,440 --> 09:57:27,490
be of type contract, but we want
them to be of the type of our

9959
09:57:27,490 --> 09:57:30,550
contract, because if they're the
type of our contract, they can

9960
09:57:30,550 --> 09:57:33,880
have all the functions that we
want them to have. So to give

9961
09:57:33,880 --> 09:57:37,330
our contracts the correct typing
here, we actually can use this

9962
09:57:37,330 --> 09:57:40,870
tool called type chain, which
gives our contracts correct

9963
09:57:40,900 --> 09:57:44,800
typing type chain has a hardened
plugin, which allows us to use

9964
09:57:44,830 --> 09:57:47,890
type chain and TypeScript
natively together, type chain

9965
09:57:47,890 --> 09:57:49,930
slash hard hat was one of these
things that we already

9966
09:57:49,930 --> 09:57:53,440
installed. And to add it to our
hard hat, we got to just go to

9967
09:57:53,440 --> 09:57:59,530
the hard hat config, and add it
in import at type chain slash

9968
09:57:59,680 --> 09:58:03,910
arhat. Now once we import that
in to our config, if we run yarn

9969
09:58:03,910 --> 09:58:08,860
hardhat, we now get a new task
here called type chain, you read

9970
09:58:08,860 --> 09:58:11,650
the description, it says
generate type chain typings for

9971
09:58:11,650 --> 09:58:15,460
compiled contracts, this will
enable all of our contracts to

9972
09:58:15,460 --> 09:58:18,910
have their own typing. So we can
have a simple storage variable

9973
09:58:18,970 --> 09:58:22,810
of type simple storage contract,
which is much better, because

9974
09:58:22,810 --> 09:58:25,600
we're always going to know
exactly what we can do with each

9975
09:58:25,600 --> 09:58:28,360
contract. To create this, we run
yarn,

9976
09:58:28,810 --> 09:58:35,620
arhat type chain. And this is
going to create a new folder

9977
09:58:35,680 --> 09:58:39,130
called type chain slash types.
With types for all of our

9978
09:58:39,130 --> 09:58:42,400
contracts, you can even go into
our simple storage sub Ts, which

9979
09:58:42,400 --> 09:58:44,650
is going to have all the
different functions and

9980
09:58:44,890 --> 09:58:48,550
everything to do with our simple
storage contract automatically

9981
09:58:48,550 --> 09:58:51,610
coded into Typescript and
JavaScript for us, which is

9982
09:58:51,610 --> 09:58:54,400
incredibly helpful. And again,
no, I haven't shown you what

9983
09:58:54,400 --> 09:58:57,520
this is yet. But in our dot Git
ignore, we usually want to add

9984
09:58:57,520 --> 09:59:01,390
type chain and type chain dash
types into our dot Git ignore so

9985
09:59:01,390 --> 09:59:04,630
we don't push them up to GitHub.
Now back in our test, we're

9986
09:59:04,630 --> 09:59:09,220
going to add the exact types of
these different objects here. So

9987
09:59:09,220 --> 09:59:12,130
we're going to import them from
that folder that we just

9988
09:59:12,130 --> 09:59:17,950
created. So we'll do import
simple storage, comma, simple

9989
09:59:17,950 --> 09:59:24,130
storage underscore underscore
factory from dot dot slash

9990
09:59:24,190 --> 09:59:29,350
types, ain slash types, the
simple storage factory is going

9991
09:59:29,350 --> 09:59:32,110
to be simple storage factory and
then civil storage of course, is

9992
09:59:32,110 --> 09:59:36,730
going to be simple storage. So
now when do let simple storage

9993
09:59:36,730 --> 09:59:42,430
factory which is going to be of
type, simple storage, underscore

9994
09:59:42,430 --> 09:59:46,090
underscore factory, and then
simple storage, which is going

9995
09:59:46,090 --> 09:59:51,820
to be of type simple storage
contract. And if we command

9996
09:59:51,820 --> 09:59:55,390
clicked into simple storage,
once again, we can see all the

9997
09:59:55,390 --> 09:59:59,380
contract functions that we know
and love, are here. In addition,

9998
09:59:59,380 --> 10:00:03,970
we have all the functions of the
actual contract itself. Once we

9999
10:00:03,970 --> 10:00:06,580
do that, we're pretty much good
to go we just need to have a

10000
10:00:06,580 --> 10:00:10,540
couple of new things here. Get
contract factory returns a type

10001
10:00:10,570 --> 10:00:13,420
ethers dot contract factory. So
what we just need to do is we

10002
10:00:13,420 --> 10:00:17,410
need to wrap this in a simple
storage factory type. So We'll

10003
10:00:17,410 --> 10:00:21,250
just do a little wrap like this.
And we'll say, as simple

10004
10:00:21,670 --> 10:00:25,960
storage, I'm just going to sort
of factory. And that's good to

10005
10:00:25,960 --> 10:00:28,930
go. Now that we've added all
this, we can run yarn, Hardhead

10006
10:00:28,930 --> 10:00:33,970
test. And boom, our test run is
normal, but with TypeScript and

10007
10:00:33,970 --> 10:00:37,060
with this additional typing that
makes our lives substantially

10008
10:00:37,060 --> 10:00:39,880
substantially better. And that's
going to be all you need to know

10009
10:00:39,880 --> 10:00:43,510
for TypeScript, reusable, all of
the branches have an optional

10010
10:00:43,540 --> 10:00:46,870
TypeScript branch that you can
use to reference to work with

10011
10:00:46,870 --> 10:00:47,410
TypeScript.

10012
10:00:51,350 --> 10:00:53,660
We've learned really just the
basics of all the different

10013
10:00:53,660 --> 10:00:56,960
things we can do with hardhat.
And these next few lessons

10014
10:00:56,960 --> 10:00:59,720
Hardhead fun meme and hard hat
smart contract lottery are

10015
10:00:59,720 --> 10:01:02,480
really going to be the basics
for all the fundamentals of all

10016
10:01:02,480 --> 10:01:05,120
the tools that we're going to
learn in hardhat. Lesson Eight

10017
10:01:05,150 --> 10:01:07,970
is going to be our introduction
to full stack and working with

10018
10:01:07,970 --> 10:01:11,870
front end and building full
stack applications. Getting all

10019
10:01:11,870 --> 10:01:14,540
the way through this course will
give you all the tools to start

10020
10:01:14,540 --> 10:01:17,450
your web three journey. But if
you're looking to just learn

10021
10:01:17,450 --> 10:01:20,780
just the basics, make sure you
absolutely get all the way to

10022
10:01:20,780 --> 10:01:24,110
Lesson Nine. And if you get all
the way through lesson 18, you

10023
10:01:24,110 --> 10:01:26,750
are going to know all of the
cutting edge tools for this

10024
10:01:26,750 --> 10:01:29,690
space. And you're going to have
the knowledge to become easily

10025
10:01:29,870 --> 10:01:32,540
one of the best developers in
the space. So hope you make it

10026
10:01:32,540 --> 10:01:35,120
all the way through to the end.
Now one of the most important

10027
10:01:35,120 --> 10:01:38,420
parts of this section of this
lesson is going to be pushing

10028
10:01:38,420 --> 10:01:42,530
our code up to GitHub, and then
sending a tweet celebrating that

10029
10:01:42,530 --> 10:01:45,860
we pushed our first smart
contract our first web three

10030
10:01:45,860 --> 10:01:49,880
GitHub repository to GitHub. So
before moving on to the next

10031
10:01:49,880 --> 10:01:53,750
lesson, be absolutely sure to
get to the end of this and push

10032
10:01:53,750 --> 10:01:56,960
this code up to GitHub. And then
optionally, if you want to

10033
10:01:57,080 --> 10:02:00,050
celebrate by sending a tweet,
but be absolutely sure to get to

10034
10:02:00,050 --> 10:02:02,870
the GitHub section, because as
I've said, many times the web

10035
10:02:02,870 --> 10:02:05,570
three space is this incredibly
collaborative community and

10036
10:02:05,570 --> 10:02:09,530
working with GitHub or GitLab,
or any other version control

10037
10:02:09,530 --> 10:02:12,710
tool is going to be essential
for your success in the space.

10038
10:02:12,710 --> 10:02:16,610
So be sure to get to that part.
All right. Now, welcome back to

10039
10:02:16,610 --> 10:02:21,470
the hard hat Fund Me section of
our course. This is the section

10040
10:02:21,500 --> 10:02:24,770
where we're actually going to
upload our first code repository

10041
10:02:24,770 --> 10:02:28,190
to GitHub if you've never done
this before, this is going to be

10042
10:02:28,190 --> 10:02:31,310
the section where we're going to
learn even more about hardhat

10043
10:02:31,370 --> 10:02:34,340
using a familiar contract base
we've already worked with, which

10044
10:02:34,370 --> 10:02:37,790
is the fund me contract. And
again, if you're using the

10045
10:02:37,790 --> 10:02:40,850
GitHub repo associated with this
course, you can scroll down to

10046
10:02:40,850 --> 10:02:46,010
the Hardhead Funmi. And all the
code is located in our repo. If

10047
10:02:46,010 --> 10:02:48,680
you'd like to do a quickstart,
you can go ahead and get clone

10048
10:02:48,680 --> 10:02:52,760
it CVU into it, and then run
yarn, and then just run yarn

10049
10:02:52,760 --> 10:02:56,570
hardhat deploy this, I'm going
to briefly show you what that

10050
10:02:56,570 --> 10:03:00,470
looks like. So in your in your
VS code, you can do git clone,

10051
10:03:01,550 --> 10:03:08,690
grab the package, cd into it,
and then type code period. To

10052
10:03:08,690 --> 10:03:12,200
open it up in a new VS code.
Once you're in your folder, you

10053
10:03:12,200 --> 10:03:15,290
can go ahead and run yarn. To
install all the dependencies for

10054
10:03:15,290 --> 10:03:17,780
working with this project, you
plan on working with the test

10055
10:03:17,780 --> 10:03:21,260
net or working with ether scan
or coin market cap, feel free to

10056
10:03:21,260 --> 10:03:25,790
fill out your Dotty and V with a
private key RPC URL, corn market

10057
10:03:25,790 --> 10:03:28,910
cap key and ether scan key. And
then you can just follow along

10058
10:03:28,910 --> 10:03:33,290
with the readme to use this repo
to run yarn, hard hat deploy.

10059
10:03:34,670 --> 10:03:37,310
And it'll show you deploying
some contracts and some mocks,

10060
10:03:37,310 --> 10:03:43,400
etc. So let's get to building
this ourselves though. Now we're

10061
10:03:43,400 --> 10:03:45,920
gonna make a new directory for
this project, it's gonna be the

10062
10:03:45,920 --> 10:03:52,820
same setup we've seen before. MK
dir, hard hat. And me, FCC,

10063
10:03:53,180 --> 10:03:56,690
we're gonna cd into heart at
Funmi, FCC, and then type code

10064
10:03:56,750 --> 10:03:59,810
period. And if code period
doesn't work for you, you can

10065
10:03:59,810 --> 10:04:04,640
absolutely open this up by
hitting File, Open Folder, like

10066
10:04:04,640 --> 10:04:07,910
we showed you before. Now, we're
in a brand new folder here. And

10067
10:04:07,910 --> 10:04:10,940
we're gonna go ahead and add
hard hat here. And we're gonna

10068
10:04:10,940 --> 10:04:19,310
run yarn, add dash dash Dev,
hard hat. Now that we have hard

10069
10:04:19,310 --> 10:04:23,240
hat, in our package, JSON, and
in our node modules, we can go

10070
10:04:23,240 --> 10:04:27,800
ahead and run yarn, start app.
And this will say, What do you

10071
10:04:27,800 --> 10:04:30,530
want to do? I'm going to choose
the advanced sample project

10072
10:04:30,530 --> 10:04:33,560
here, just to show you what's
going on. And we're going to set

10073
10:04:33,560 --> 10:04:36,410
this up in a way that I think
works best. So we'll go ahead

10074
10:04:36,410 --> 10:04:38,510
and do the advanced sample
project. Yes, we're going to

10075
10:04:38,510 --> 10:04:41,420
have that as the root. Yes, we
want to add a Git ignore. And

10076
10:04:41,420 --> 10:04:44,210
there are a lot of sample
project dependencies that it

10077
10:04:44,210 --> 10:04:47,780
wants us to add. We're gonna go
ahead and hit yes. But we're

10078
10:04:47,810 --> 10:04:50,180
going to end up not using all of
these and I'll show you which

10079
10:04:50,180 --> 10:04:53,060
ones we're not going to use and
why. But for now, let's go ahead

10080
10:04:53,060 --> 10:04:53,720
and hit yes.

10081
10:05:02,990 --> 10:05:06,110
All right, awesome. And now we
have an advanced project in

10082
10:05:06,110 --> 10:05:08,810
here. Let me walk you through
the additional things that are

10083
10:05:08,810 --> 10:05:11,720
in here. So we have a
traditional contract node

10084
10:05:11,720 --> 10:05:14,060
modules, which is going to be
the same scripts is going to be

10085
10:05:14,060 --> 10:05:18,410
the same test is going to be the
same. But this comes with a dot

10086
10:05:18,440 --> 10:05:21,980
E and V dot example already
packed in for us. It also comes

10087
10:05:21,980 --> 10:05:27,980
with.es lint files.es lint, RC
dot j s.es. Lint, ignore es Lint

10088
10:05:28,010 --> 10:05:31,340
is known as a JavaScript linter,
which helps you find and

10089
10:05:31,370 --> 10:05:34,460
automatically fix problems in
your code for the JavaScript

10090
10:05:34,460 --> 10:05:37,670
that I work with. I'm not a big
fan of ES lint, so I typically

10091
10:05:37,670 --> 10:05:40,190
don't use it. So I'm going to go
ahead and delete the two of

10092
10:05:40,190 --> 10:05:43,490
these. If you want to keep them
in you absolutely can dot Git

10093
10:05:43,490 --> 10:05:46,100
ignore. We're going to finally
understand what this file does

10094
10:05:46,130 --> 10:05:50,090
in this lesson that NPM ignore
helps Ignore files if you want

10095
10:05:50,090 --> 10:05:53,120
to push your project up to be an
NPM package, which we're not

10096
10:05:53,120 --> 10:05:55,760
going to do. So if you want to
delete this, you can as well

10097
10:05:56,540 --> 10:05:58,880
pretty or ignore it and pretty
DRC. We already know what these

10098
10:05:58,880 --> 10:06:01,340
do small hint. And so hint
ignore, which we're going to

10099
10:06:01,340 --> 10:06:04,580
talk about it in a minute, or
Hardhead config, which just

10100
10:06:04,580 --> 10:06:08,300
comes already with a ropsten
network, a gas reporter and

10101
10:06:08,330 --> 10:06:11,930
ether scan package dot JSON with
all the additional packages, the

10102
10:06:11,930 --> 10:06:14,630
readme is a little bit more
robust. And then of course, our

10103
10:06:14,630 --> 10:06:17,840
yarn dot lock. So this advanced
project looks pretty similar to

10104
10:06:17,840 --> 10:06:22,700
what we're going to be working
with anyways. Now I do want to

10105
10:06:22,700 --> 10:06:25,790
talk about this soul hint,
though. So what is solvent

10106
10:06:25,970 --> 10:06:30,530
solvent is known as a solidity
linter that we can use to lint

10107
10:06:30,560 --> 10:06:33,620
our code linting is the process
of running a program that will

10108
10:06:33,620 --> 10:06:36,800
analyze code for potential
errors. It also does a little

10109
10:06:36,800 --> 10:06:41,000
bit of formatting, oftentimes,
es Lint is a way to lint for

10110
10:06:41,000 --> 10:06:45,110
JavaScript code. So hint is a
way to lint for solidity code,

10111
10:06:45,530 --> 10:06:48,830
we use prettier to format our
code, and we can use soul hint

10112
10:06:48,860 --> 10:06:51,590
to lint, our code, they are
often used a little bit

10113
10:06:51,590 --> 10:06:54,290
interchangeably, even though
that's not exactly correct, as

10114
10:06:54,290 --> 10:06:56,930
they are a little bit different.
We can run this linter on our

10115
10:06:56,930 --> 10:07:01,460
code by running yarn, sole hint,
and then type the name of the

10116
10:07:01,460 --> 10:07:06,020
files that we want to lint. So
we do contracts, slash and then

10117
10:07:06,020 --> 10:07:10,520
you can just do start out so
everything looks okay, nothing

10118
10:07:10,520 --> 10:07:13,040
will happen. Well, let's say we
have a variable that we don't

10119
10:07:13,040 --> 10:07:18,320
explicitly say the visibility of
it is. This isn't the best

10120
10:07:18,320 --> 10:07:22,100
practice because ideally, we
always say exactly what the

10121
10:07:22,100 --> 10:07:25,640
visibility of some variable is.
This obviously gets defaulted.

10122
10:07:25,670 --> 10:07:28,400
But it's usually better to be
more explicit. So now if we run

10123
10:07:28,400 --> 10:07:35,660
yarn, so hint, contracts start
up so it'll give us a warning,

10124
10:07:35,690 --> 10:07:39,380
saying we should explicitly Mark
visibility of state, this linter

10125
10:07:39,410 --> 10:07:42,950
is a good way to check for some
best practices for running our

10126
10:07:42,950 --> 10:07:48,860
code. So we're definitely going
to keep a small hint around. Now

10127
10:07:48,860 --> 10:07:51,230
that we've got a repo here,
let's add a couple of our common

10128
10:07:51,230 --> 10:07:56,030
setup pieces here. So in
prettier.rc, we're going to swap

10129
10:07:56,030 --> 10:08:00,230
this out with what we've been
using so far. Tab of the form us

10130
10:08:00,230 --> 10:08:04,760
tab is false, semi false, single
quote, also false. We're going

10131
10:08:04,760 --> 10:08:08,780
to update our prettier dot
ignore node modules, package dot

10132
10:08:08,780 --> 10:08:12,860
JSON image artifacts, cache
coverage ID v dot star, readme,

10133
10:08:12,860 --> 10:08:16,280
and coverage and anything else
you want to add in here. And

10134
10:08:16,280 --> 10:08:19,010
we're going to scroll up to our
contracts folder. And we're

10135
10:08:19,010 --> 10:08:22,550
going to swap this greeter dot
soul out with our fund me dot

10136
10:08:22,550 --> 10:08:26,210
soul. Now let's go ahead and add
our contracts in here. If you're

10137
10:08:26,210 --> 10:08:29,150
following along with the repo,
you go to the contracts folder,

10138
10:08:29,540 --> 10:08:33,710
there's actually another folder
in here and the contracts look a

10139
10:08:33,710 --> 10:08:36,740
little bit different. So if you
have those contracts, steal from

10140
10:08:36,740 --> 10:08:39,350
remix, let's actually grab them
from remix because we're going

10141
10:08:39,350 --> 10:08:42,350
to make a couple of changes to
them. If you don't have remix up

10142
10:08:42,350 --> 10:08:44,510
anymore, which you probably
shouldn't, because you should be

10143
10:08:44,510 --> 10:08:48,110
taking breaks, you can jump back
over to Lesson four remix Funmi

10144
10:08:48,620 --> 10:08:51,980
jump into the repo here and grab
the contracts from inside here.

10145
10:08:52,370 --> 10:08:55,820
Just go to the fun v dash Free
Code Camp tutorial and grab the

10146
10:08:55,820 --> 10:08:58,790
code from there. So we're gonna
grab just fun me and price

10147
10:08:58,790 --> 10:09:02,090
converter dot soul. So go ahead
and delete that old file, create

10148
10:09:02,090 --> 10:09:07,760
a new one and call it fund me
dot song. Paste it in there. And

10149
10:09:07,760 --> 10:09:13,340
then we're going to create the
price converter. That's all. Now

10150
10:09:13,340 --> 10:09:17,030
we have both our Funmi and our
price converter contracts in

10151
10:09:17,030 --> 10:09:19,820
here. Now one of the first
things that we want to do one of

10152
10:09:19,820 --> 10:09:21,980
the first things that we did
last time was we ran yarn

10153
10:09:21,980 --> 10:09:24,740
compile to make sure that our
code is actually working the way

10154
10:09:24,740 --> 10:09:27,590
we want to. And before we
actually hit Compile, one of the

10155
10:09:27,590 --> 10:09:29,630
things that we're going to need
to do is come to our Hardhead

10156
10:09:29,630 --> 10:09:31,910
dot config, we're going to make
sure we're on the correct

10157
10:09:31,910 --> 10:09:35,270
solidity version. So we're going
to do zero point 8.8 here. And

10158
10:09:35,270 --> 10:09:36,590
let's go ahead and try to
compile.

10159
10:09:39,350 --> 10:09:44,390
So we can run yarn Hardhead
compile. And you'll see we

10160
10:09:44,390 --> 10:09:47,480
actually get an error here.
Library at chain link slash

10161
10:09:47,480 --> 10:09:50,630
contracts imported from
contracts slash fund me dot soul

10162
10:09:50,660 --> 10:09:55,370
is not installed, try installing
it using npm. In remix, we went

10163
10:09:55,370 --> 10:09:58,640
ahead and just imported at
chainlink slash contracts, right

10164
10:09:58,640 --> 10:10:02,600
from our NPM and or GitHub. But
in our local code, we have to

10165
10:10:02,600 --> 10:10:07,070
tell Hardhead specifically,
where to get this from, we want

10166
10:10:07,070 --> 10:10:11,270
to download this specifically
from the NPM package manager at

10167
10:10:11,270 --> 10:10:14,420
chainlink slash contracts, we
can download it simply by

10168
10:10:14,420 --> 10:10:20,690
running yarn, add dash dash dev
at chainlink slash contracts.

10169
10:10:23,000 --> 10:10:25,610
Now that we've downloaded it
into our file, we'll be able to

10170
10:10:25,610 --> 10:10:30,170
see it in Node modules here.
Hardhead is now smart enough to

10171
10:10:30,170 --> 10:10:32,510
know that at chain link slash
contracts is going to point to

10172
10:10:32,510 --> 10:10:36,290
that node module that we have.
So we can now run yarn Hardhead

10173
10:10:36,290 --> 10:10:40,610
compile boom, now we can see
compiled three solidity files

10174
10:10:40,640 --> 10:10:47,000
successfully. So now we have our
contracts in here and our code

10175
10:10:47,000 --> 10:10:50,000
is compiling successfully. We're
probably going Want to deploy

10176
10:10:50,030 --> 10:10:52,910
our code? Now in our last
section, I know we use the

10177
10:10:52,910 --> 10:10:56,360
scripts module. And we made our
own manual deploy script.

10178
10:10:56,390 --> 10:10:58,730
However, something that you'd
notice, the more that you work

10179
10:10:58,730 --> 10:11:01,940
with just raw ethers, or even
just hard hat is that keeping

10180
10:11:01,940 --> 10:11:05,390
track of all our deployments can
get a little bit tricky. If you

10181
10:11:05,390 --> 10:11:08,480
just use a deploy script, it's
not saving our deployments to

10182
10:11:08,480 --> 10:11:11,630
any file. Additionally, having
everything in the deploy script

10183
10:11:11,630 --> 10:11:15,020
for deploying can make the tests
and the deploy scripts, maybe

10184
10:11:15,020 --> 10:11:18,200
not work exactly hand in hand.
And there are a couple of other

10185
10:11:18,200 --> 10:11:20,390
things that might be a little
bit tricky to work on, we're

10186
10:11:20,390 --> 10:11:22,820
actually going to work with a
package that makes everything I

10187
10:11:22,820 --> 10:11:26,450
just mentioned, and a couple
other things way easier. And

10188
10:11:26,450 --> 10:11:29,060
this package that I'm talking
about is going to be the hard

10189
10:11:29,060 --> 10:11:32,570
hat deploy package. There's a
link to this package in the

10190
10:11:32,570 --> 10:11:35,330
GitHub repository associated
with this course. It's a hardhat

10191
10:11:35,330 --> 10:11:38,060
plugin for replicable
deployments and easy testing.

10192
10:11:38,450 --> 10:11:40,760
And if we scroll down to
installation, we can see we

10193
10:11:40,760 --> 10:11:44,570
install it basically the normal
way. They're using npm. And

10194
10:11:44,570 --> 10:11:48,200
we're gonna go ahead and use
yarn. So for us to add it, we'll

10195
10:11:48,200 --> 10:11:53,060
do yarn, add hardhat dash
deploy. And then of course,

10196
10:11:53,060 --> 10:11:59,270
we're gonna do dash dash Dev.
Once done deploying this require

10197
10:11:59,270 --> 10:12:04,880
statement to our hard
hat.config.js. Once again,

10198
10:12:04,880 --> 10:12:07,640
basically the config is our
entry point. This is where we're

10199
10:12:07,640 --> 10:12:11,540
gonna get started. And we can go
ahead and delete our deploy.js

10200
10:12:11,540 --> 10:12:15,170
script. Now if we run yarn
hardhat, you see that we have a

10201
10:12:15,170 --> 10:12:19,640
bunch of new tasks in here, with
one of them being this deploy

10202
10:12:19,700 --> 10:12:23,060
task, this deploy task is going
to be the main task that we use

10203
10:12:23,060 --> 10:12:26,030
to deploy our contracts. Instead
of writing our deploy scripts in

10204
10:12:26,030 --> 10:12:28,430
the Scripts folder, we're
actually going to create a new

10205
10:12:28,430 --> 10:12:31,880
folder, we can create a new
folder by just doing MK dir

10206
10:12:32,090 --> 10:12:36,860
deploy. Or you can always right
click and hit New Folder. This

10207
10:12:36,860 --> 10:12:39,290
deploy folder is going to be
where a lot of hard hat Deploy

10208
10:12:39,290 --> 10:12:42,410
Module looks to deploy code. And
it's going to be where we are

10209
10:12:42,410 --> 10:12:45,140
writing our scripts. To write
our scripts, we usually need to

10210
10:12:45,140 --> 10:12:48,230
add one more thing in here.
Since we're going to be using

10211
10:12:48,260 --> 10:12:51,770
ethers JS in all of our scripts,
we want to add Hardhead deploy

10212
10:12:51,800 --> 10:12:55,370
ethers to our package here. Now,
instead of just doing yarn, add

10213
10:12:55,370 --> 10:12:58,190
dash dev hard at deploy ethers,
we're going to do something a

10214
10:12:58,190 --> 10:13:02,390
little bit weird. We're going to
do yarn add or npm install dash

10215
10:13:02,390 --> 10:13:05,780
dash Dev, and we're going to
install it like this. So let me

10216
10:13:05,780 --> 10:13:08,900
just copy this. And you can just
copy that from the repo. And

10217
10:13:08,900 --> 10:13:11,990
we'll do yarn, add dash dash
Dev, and paste that in here.

10218
10:13:12,380 --> 10:13:16,130
What we're doing is we're taking
at nomic labs, hard hat ethers,

10219
10:13:16,160 --> 10:13:19,700
which we've used before, and
we're overriding it with hard

10220
10:13:19,700 --> 10:13:23,450
hat deploy ethers. Remember how
in our last project, we used

10221
10:13:23,450 --> 10:13:27,260
hard hat ethers. So that hard
hat could override ethers to use

10222
10:13:27,260 --> 10:13:30,350
hard hat deploy. We use hard hat
deploy ethers, so that hard hat

10223
10:13:30,350 --> 10:13:34,370
deploy can override Hardhead,
which overrides ethers, which is

10224
10:13:34,370 --> 10:13:38,210
kind of funny. When you say like
that, this will enable ethers to

10225
10:13:38,210 --> 10:13:41,570
keep track of and remember all
the different deployments that

10226
10:13:41,570 --> 10:13:44,030
we actually make in our
contract. So if we look at our

10227
10:13:44,030 --> 10:13:48,410
package, JSON, and now we can
see our nomic labs dashboard had

10228
10:13:48,410 --> 10:13:52,850
ethers. Now the version of it is
going to be MPM. Hardhead deploy

10229
10:13:52,880 --> 10:13:56,030
ethers. This is our package dot
JSON, basically saying the hard

10230
10:13:56,060 --> 10:13:59,540
hat ethers package is now
overwritten by the hard hat

10231
10:13:59,540 --> 10:14:03,140
deploy ethers package, which is
what we want. Alright, great. So

10232
10:14:03,140 --> 10:14:05,570
now that we have that setup, we
can start writing our deploy

10233
10:14:05,570 --> 10:14:08,630
scripts, the way that Hart had
to play works is all the scripts

10234
10:14:08,660 --> 10:14:12,080
that get added to our deploy
folder will get run when we run

10235
10:14:12,080 --> 10:14:16,070
yarn, hard hat deploy. So a good
practice is usually to number

10236
10:14:16,070 --> 10:14:18,800
them so that they run in the
order that you want them to run

10237
10:14:18,800 --> 10:14:22,130
in. So since we only have one
contract that we want to deploy

10238
10:14:22,160 --> 10:14:28,340
the Funmi contract, we're going
to do 01 Deploy Funmi Jas, and

10239
10:14:28,340 --> 10:14:31,760
in this script, this is going to
be where we define how to deploy

10240
10:14:31,760 --> 10:14:35,150
the fundament contract. Alright,
so we're in our deploy Funmi

10241
10:14:35,150 --> 10:14:39,350
scripts. Now traditionally, what
did we do, we did imports, we

10242
10:14:39,350 --> 10:14:43,460
did the main function. And then
we did calling of main function,

10243
10:14:44,210 --> 10:14:47,120
that Hardhead deploy is a little
bit different, we're still going

10244
10:14:47,120 --> 10:14:49,700
to import our libraries and
packages, but we're not going to

10245
10:14:49,700 --> 10:14:52,460
have main function. And we're
also not going to call the main

10246
10:14:52,460 --> 10:14:56,000
function when we run Hardhead
deploy Harnett deploy is

10247
10:14:56,000 --> 10:14:59,750
actually going to call a
function that we specify. In

10248
10:14:59,780 --> 10:15:02,030
this script here. What we're
going to do is we're gonna

10249
10:15:02,030 --> 10:15:05,510
create a function, we'll call it
deploy funk.

10250
10:15:06,530 --> 10:15:08,990
We're going to export this
deploy function as the default

10251
10:15:08,990 --> 10:15:12,500
function for Hardhead deploy to
look for, so we could say,

10252
10:15:13,040 --> 10:15:20,240
module that exports dot default
equals deploy funk. To test it

10253
10:15:20,240 --> 10:15:25,370
out, we can go ahead and do
console dot log, hi. And then in

10254
10:15:25,370 --> 10:15:31,880
our terminal, run yarn, hard
hat, deploy. Oops, get rid of

10255
10:15:31,880 --> 10:15:37,220
the parentheses here. Sorry. Run
it again. And we can see it went

10256
10:15:37,370 --> 10:15:41,420
and ran our deploy func here.
Now if this syntax is easier for

10257
10:15:41,420 --> 10:15:44,510
you to understand, go ahead and
use this syntax and we're going

10258
10:15:44,510 --> 10:15:47,270
to be passing the heart at
runtime environment as a

10259
10:15:47,270 --> 10:15:51,500
parameter to this function.
However, if we go to the heart

10260
10:15:51,500 --> 10:15:55,610
hat deploy documentation, and we
scroll down to an example

10261
10:15:55,640 --> 10:15:58,700
script, the syntax looks a
little bit different. And let me

10262
10:15:58,700 --> 10:16:01,670
just explain what's going on
here and how we're going to be

10263
10:16:01,670 --> 10:16:04,370
writing ours. So instead of kind
of defining everything like

10264
10:16:04,370 --> 10:16:07,640
this, and defining the function
name, similar to what we were

10265
10:16:07,640 --> 10:16:10,730
doing before, we're actually
going to using a nameless, a

10266
10:16:10,730 --> 10:16:13,580
synchronous function, we're
going to make it an anonymous

10267
10:16:13,580 --> 10:16:17,120
function, similar to what we've
seen before. So instead, we're

10268
10:16:17,120 --> 10:16:21,770
going to say async parameters
like this, I'm going to pass our

10269
10:16:21,770 --> 10:16:24,830
parameters our heart at runtime
environment in here. And it's

10270
10:16:24,830 --> 10:16:28,490
going to be an arrow function.
And then we're going to wrap

10271
10:16:28,490 --> 10:16:32,480
this whole thing in module dot
exports. So we're gonna say,

10272
10:16:33,320 --> 10:16:40,640
module, dot exports, equals this
async function like this. This

10273
10:16:40,670 --> 10:16:45,200
syntax here is nearly identical
to what's up here, we just don't

10274
10:16:45,200 --> 10:16:48,710
have a name for our async
function. So this is how we're

10275
10:16:48,710 --> 10:16:52,040
going to set it up instead. But
if this syntax is a little bit

10276
10:16:52,040 --> 10:16:55,070
confusing for you feel free to
use this above as the two of

10277
10:16:55,070 --> 10:16:58,580
these are going to be the same.
Now the next thing that most of

10278
10:16:58,580 --> 10:17:01,100
the documentation does is it
pulls out the variables and

10279
10:17:01,100 --> 10:17:05,240
functions out of the HRV that
we're going to use. HRV is the

10280
10:17:05,240 --> 10:17:09,290
heart hat runtime environment.
Whenever we run a deploy script,

10281
10:17:09,350 --> 10:17:12,710
heart hat deploy automatically
calls this function and just

10282
10:17:12,710 --> 10:17:16,580
passes the hard hat object into
it similar to in back in hard

10283
10:17:16,580 --> 10:17:21,020
hat simple storage. In our
deploy script. We had ethers run

10284
10:17:21,050 --> 10:17:24,350
in network come from hard hat,
instead of coming from hard hat.

10285
10:17:24,680 --> 10:17:27,770
We're coming from HRV, which is
basically the same thing as hard

10286
10:17:27,770 --> 10:17:30,740
hat. For our script, we're only
going to use two variables from

10287
10:17:30,740 --> 10:17:38,450
a jury when you use const. Get
named accounts. And deployments.

10288
10:17:41,060 --> 10:17:44,450
This syntax might look a little
bit weird for you. But it's just

10289
10:17:44,450 --> 10:17:47,930
a way to pull these exact
variables out of a tree. It's

10290
10:17:47,930 --> 10:17:51,170
kind of the same thing as just
doing a tree dot get named

10291
10:17:51,170 --> 10:17:56,990
accounts and HRA dot
deployments. But pulling them

10292
10:17:56,990 --> 10:17:58,970
out like this means we don't
have to add a tree at the

10293
10:17:58,970 --> 10:18:01,940
beginning anymore. And then
additionally, additionally,

10294
10:18:02,150 --> 10:18:05,480
JavaScript has something called
syntactic sugar. So instead of

10295
10:18:05,480 --> 10:18:09,110
doing this on two lines like
this, we can actually do that

10296
10:18:09,110 --> 10:18:14,180
whole bit on one line. So
instead, we just extrapolate

10297
10:18:14,300 --> 10:18:18,260
those two variables, right in
the function declaration. So

10298
10:18:18,290 --> 10:18:22,250
this line is the exact same
thing as doing this line. This

10299
10:18:22,250 --> 10:18:25,430
is an asynchronous, nameless
function using the arrow

10300
10:18:25,430 --> 10:18:29,150
notation, or working with our
deploy scripts here. And we're

10301
10:18:29,150 --> 10:18:32,750
default, exporting it with
module dot exports. I don't know

10302
10:18:32,750 --> 10:18:35,510
that was a lot. And another is
kind of a lot of syntactic sugar

10303
10:18:35,510 --> 10:18:38,270
here. But if that's really
confusing for you, just feel

10304
10:18:38,270 --> 10:18:41,270
free to use the above. And
whenever we refer to get named

10305
10:18:41,270 --> 10:18:48,560
accounts, you can also just do a
three dot get named accounts, or

10306
10:18:48,590 --> 10:18:53,210
a three dot deployments. So
hopefully, that's clear that

10307
10:18:53,210 --> 10:18:55,760
this top part is gonna be the
same as this bottom part right

10308
10:18:55,760 --> 10:18:58,460
here, whichever one you feel
more comfortable working with.

10309
10:18:59,360 --> 10:19:01,460
But alright, now that we've
gotten all that out of the way,

10310
10:19:01,580 --> 10:19:04,790
let's continue with the script.
So we're using this deployments

10311
10:19:04,820 --> 10:19:08,150
object, reason this deployments
object to get two functions,

10312
10:19:08,870 --> 10:19:11,690
those two functions are going to
be the deploy function, and the

10313
10:19:11,690 --> 10:19:14,540
log function. So we're gonna say
const, deploy log equals

10314
10:19:14,540 --> 10:19:18,350
deployments. So we're going to
pull these two functions out of

10315
10:19:18,350 --> 10:19:22,100
deployments. And then we're also
going to do const Deployer.

10316
10:19:23,150 --> 10:19:28,310
Equals await, get named
accounts. So we are grabbing

10317
10:19:28,310 --> 10:19:31,310
this new deploy function, this
new log function, and we're

10318
10:19:31,310 --> 10:19:34,880
grabbing this deployer account
from this weird get named

10319
10:19:34,880 --> 10:19:38,420
accounts function. What's this
get named accounts function,

10320
10:19:38,660 --> 10:19:42,350
this get named accounts is a way
for us to get named accounts.

10321
10:19:42,710 --> 10:19:45,620
When working with ethers we saw
when working with ethers, we can

10322
10:19:45,620 --> 10:19:49,400
actually get our accounts based
off of the number in the Account

10323
10:19:49,400 --> 10:19:51,710
section of each network. So for
example,

10324
10:19:54,800 --> 10:19:57,800
in this list of private keys,
private keys zero private key

10325
10:19:57,800 --> 10:20:00,770
one private key two, it might
get a little confusing to

10326
10:20:00,770 --> 10:20:04,460
remember which ones which so
instead of working like that, we

10327
10:20:04,460 --> 10:20:07,880
can add a section at the bottom
called named accounts where we

10328
10:20:07,880 --> 10:20:11,900
can name each one of those spots
in the accounts array. So we'll

10329
10:20:11,900 --> 10:20:15,470
do named accounts. And we'll say
one of the accounts that will

10330
10:20:15,470 --> 10:20:18,710
name is going to be named
Deployer. And we're gonna say by

10331
10:20:18,710 --> 10:20:23,240
default, the zero with account
is going to be Deployer. We can

10332
10:20:23,240 --> 10:20:27,560
also specify which number is
going to be the deployer account

10333
10:20:27,560 --> 10:20:31,070
across different chains. For
example, on Rigby we wanted the

10334
10:20:31,070 --> 10:20:33,770
deployer account to be the first
position, we could do something

10335
10:20:33,770 --> 10:20:37,130
like this or on hard hat, we
could do it like this. We can

10336
10:20:37,130 --> 10:20:40,160
create multiple users. Like for
example, if we wanted to do a

10337
10:20:40,160 --> 10:20:44,510
user for some test or something,
and we'll just say the default

10338
10:20:44,540 --> 10:20:48,380
is one or whatever we wanted in
here. So back in our deploy fun

10339
10:20:48,380 --> 10:20:51,170
me We're going to say we're
going to grab that deployer

10340
10:20:51,260 --> 10:20:54,320
account from our named accounts.
And then finally, we're going to

10341
10:20:54,320 --> 10:20:57,530
grab our chain ID for reasons
that will come clear pretty

10342
10:20:57,530 --> 10:21:03,320
soon. So we'll do const, chain
ID equals network dot config dot

10343
10:21:03,320 --> 10:21:09,920
chain ID. Now, how do we
actually deploy this fund me

10344
10:21:09,920 --> 10:21:12,590
contract? Well, let's think
about this for a little bit.

10345
10:21:12,830 --> 10:21:15,260
When working with remix, it was
pretty easy, right? We just

10346
10:21:15,260 --> 10:21:18,830
deployed it to a test net. Ah,
that's kind of the issue there,

10347
10:21:18,830 --> 10:21:21,590
isn't it deploying to a rink,
the test net is a little bit

10348
10:21:21,590 --> 10:21:24,680
slow. We don't always want to
have to deploy to one of these

10349
10:21:24,680 --> 10:21:27,920
slow test nets or even a main
net when tinkering and fiddling

10350
10:21:27,920 --> 10:21:31,010
with our contracts, do we know
that's gonna be really bad, we

10351
10:21:31,010 --> 10:21:34,700
really want to deploy to a test
net as a last stop after we've

10352
10:21:34,700 --> 10:21:37,580
done all our testing locally. Or
we can deploy it to a test that

10353
10:21:37,580 --> 10:21:41,450
to see some very specific code
work, like for example, with the

10354
10:21:41,450 --> 10:21:44,870
chain link documentation. So
ideally, we deploy this to a

10355
10:21:44,870 --> 10:21:48,020
local network first. But can we
just do that? Well, if we look

10356
10:21:48,020 --> 10:21:51,260
in our price converter, dot
Seoul, we have this hard coded

10357
10:21:51,260 --> 10:21:55,220
address in here, this 0x
address, if we go to Doc's dot

10358
10:21:55,220 --> 10:21:59,570
chain that link EVM chains,
contract addresses for Aetherium

10359
10:21:59,570 --> 10:22:03,560
data feeds. That address is the
eth USD, specifically for

10360
10:22:03,560 --> 10:22:07,400
Rinkeby. What if we work on the
Hard Hat Network? Example?

10361
10:22:07,580 --> 10:22:08,630
default network?

10362
10:22:10,010 --> 10:22:13,250
Hard Hat. And then like I said
before, if you don't write this

10363
10:22:13,250 --> 10:22:16,640
in part, it is automatically the
default network. But if we're to

10364
10:22:16,640 --> 10:22:19,430
point to the Hard Hat Network,
harder network is a blank

10365
10:22:19,430 --> 10:22:21,860
blockchain. And it gets
destroyed every time our scripts

10366
10:22:21,860 --> 10:22:24,950
finish, or even if we're working
with a local node, this price

10367
10:22:24,950 --> 10:22:28,220
feed contract won't exist, one
of the code there won't be

10368
10:22:28,220 --> 10:22:31,880
updated with data. So what do we
do? How do we test and interact

10369
10:22:31,880 --> 10:22:34,550
with our code locally? Is there
a way we can do this? Well, one

10370
10:22:34,550 --> 10:22:36,770
of the ways that we can do this
that we'll learn a little bit

10371
10:22:36,770 --> 10:22:39,920
later is actually forking a
blockchain, where you can keep

10372
10:22:39,920 --> 10:22:42,920
stuff hard coded. But usually,
it's still better to figure out

10373
10:22:42,920 --> 10:22:46,370
how to do everything with
something called mocks. There's

10374
10:22:46,370 --> 10:22:49,460
a great Stack Overflow question
that just says, What is mocking

10375
10:22:49,520 --> 10:22:52,550
and mocking is primarily used
for unit testing, which we'll

10376
10:22:52,550 --> 10:22:55,880
talk about in a little bit. And
object under test may have

10377
10:22:55,880 --> 10:22:59,480
dependencies on other complex
objects. To isolate the behavior

10378
10:22:59,480 --> 10:23:03,860
of the object, you want to
replace other objects by mocks

10379
10:23:03,890 --> 10:23:07,490
that simulate the behavior of
the real objects. In short,

10380
10:23:07,490 --> 10:23:10,490
mocking is creating objects that
simulate behavior of real

10381
10:23:10,520 --> 10:23:13,670
objects. Now, this might seem
like a lot of words. But

10382
10:23:14,090 --> 10:23:17,060
basically, what we want to do is
we want to make a fake price

10383
10:23:17,060 --> 10:23:20,330
feed contract that we can use
and we can control when working

10384
10:23:20,360 --> 10:23:23,270
locally. So back here, I'm just
going to leave a note in here

10385
10:23:23,270 --> 10:23:30,350
saying, When going for local
host or Hard Hat Network, we

10386
10:23:30,560 --> 10:23:33,800
want to use a mock. Okay, great,
well, we can use a mock and

10387
10:23:33,800 --> 10:23:36,110
we'll learn how to make one of
those in a little bit. Well,

10388
10:23:36,110 --> 10:23:42,290
what happens when we want to
change chains, for example, back

10389
10:23:42,290 --> 10:23:46,490
in dots dot chain to link EVM
chains, contract addresses,

10390
10:23:46,940 --> 10:23:50,150
there are a ton of different
block chains that have price

10391
10:23:50,150 --> 10:23:53,840
feeds on them. And on each one
of these blockchains, the eth

10392
10:23:53,840 --> 10:23:56,060
USD price feed is going to be a
little bit different. For

10393
10:23:56,060 --> 10:23:59,900
example, we're looking at ETH
USD, the address of eth USD for

10394
10:23:59,900 --> 10:24:03,740
Aetherium main net is different
from the address of eth USD for

10395
10:24:03,740 --> 10:24:05,840
Rigby, which makes sense,
they're totally different

10396
10:24:05,840 --> 10:24:08,150
contracts on different chains,
they have very similar

10397
10:24:08,150 --> 10:24:10,970
functionality. And they do
nearly the exact same thing. But

10398
10:24:11,000 --> 10:24:13,580
they're still different. We're
also going to need a way for us

10399
10:24:13,580 --> 10:24:18,230
to modularize or parameterize,
this address in here, so that no

10400
10:24:18,230 --> 10:24:21,410
matter what chain we deploy to,
we don't have to change any of

10401
10:24:21,410 --> 10:24:23,810
our code, we can always have our
code be exactly the same. And we

10402
10:24:23,810 --> 10:24:26,180
don't have to come in here and
like flip values and flip

10403
10:24:26,180 --> 10:24:29,720
variables and stuff. So let's
keep that all of that in mind as

10404
10:24:29,720 --> 10:24:32,990
we write the rest of this. Now
in order to parameterize. This,

10405
10:24:33,170 --> 10:24:36,500
we actually want to prioritize
and do a little refactoring of

10406
10:24:36,500 --> 10:24:39,440
our fundamental soul.
Refactoring basically means

10407
10:24:39,440 --> 10:24:43,370
going back and, and changing the
way your code works. Right now

10408
10:24:43,400 --> 10:24:46,340
we have this constructor
function, right the constructor

10409
10:24:46,340 --> 10:24:49,190
function is the function that
automatically gets called

10410
10:24:49,220 --> 10:24:52,280
whenever we deploy our contract.
Right now it's not doing a whole

10411
10:24:52,280 --> 10:24:55,040
lot right now it's just updating
the owner variable to be whoever

10412
10:24:55,040 --> 10:24:58,970
sent in the contract. But we can
actually have a do much more

10413
10:24:58,970 --> 10:25:02,030
than that. Since this
constructor is a function just

10414
10:25:02,030 --> 10:25:04,520
like every other function, we
can actually have it take

10415
10:25:04,520 --> 10:25:07,250
parameters, one of the
parameters that we might like

10416
10:25:07,250 --> 10:25:11,270
for it to have is going to be
the address of a price feed. So

10417
10:25:11,270 --> 10:25:13,220
let's go ahead and add this and
figure out how to refactor all

10418
10:25:13,220 --> 10:25:17,900
this code. So we're going to add
constructor address, price feed

10419
10:25:18,380 --> 10:25:21,500
for the constructor in here.
When we deploy our contract. Now

10420
10:25:21,530 --> 10:25:24,890
we're going to pass it the eth
USD price feed address depending

10421
10:25:24,890 --> 10:25:27,500
on what chain we're on. If we're
on rink B, we'll use this

10422
10:25:27,500 --> 10:25:30,470
address if one polygon will use
a different one b&b, different

10423
10:25:30,470 --> 10:25:34,100
one, Gnosis hecho, avalanche,
etc, you get the picture. So

10424
10:25:34,100 --> 10:25:37,730
we're going to marginalize this
like so. Now that our

10425
10:25:37,730 --> 10:25:40,700
constructor takes a parameter
for the price feed, we can

10426
10:25:40,700 --> 10:25:44,420
actually save an aggregator v3
interface object as a global

10427
10:25:44,420 --> 10:25:47,540
variable in our price converter,
we just create a price feed

10428
10:25:47,540 --> 10:25:51,290
variable of type aggregator v3
interface, which again, we're

10429
10:25:51,290 --> 10:25:54,020
importing from the chainlink
repo, which is an interface

10430
10:25:54,020 --> 10:25:57,590
object which gets compiled down
to the ABI. If you match an ABI

10431
10:25:57,590 --> 10:26:00,590
with up with an address, you get
a contract that you can interact

10432
10:26:00,590 --> 10:26:02,690
with. So we're going to do the
same thing here. We're gonna

10433
10:26:02,690 --> 10:26:09,530
say, aggregate Tor, v3
interface, public price feed,

10434
10:26:10,670 --> 10:26:13,940
ration and call this price feed
address so that these don't have

10435
10:26:13,940 --> 10:26:17,690
the same name. And in our
constructor, we're going to say

10436
10:26:17,690 --> 10:26:21,440
price feed equals, and we're
going to do the exact same thing

10437
10:26:21,470 --> 10:26:26,360
we did with our price converter
equals aggregate tore the three

10438
10:26:26,360 --> 10:26:27,440
interface

10439
10:26:28,580 --> 10:26:36,680
of price feed address. Like so
now, we have this price feed

10440
10:26:36,680 --> 10:26:40,520
address that's variable and
modularized, depending on

10441
10:26:40,520 --> 10:26:44,030
whatever chain that we're on.
Now, what we can do is we can

10442
10:26:44,030 --> 10:26:47,720
grab this price feed address,
and we can use it for our price

10443
10:26:47,720 --> 10:26:51,170
converter. So where are we using
our price converter? Well, just

10444
10:26:51,170 --> 10:26:55,550
a quick reminder, we're using
using price converter for you at

10445
10:26:55,550 --> 10:26:59,690
256. We're using this as a
library on top of our unit 256

10446
10:26:59,720 --> 10:27:03,200
type. So we're calling message
dot value dot get conversion

10447
10:27:03,200 --> 10:27:06,200
rate. So we look at our price
converter, we have this function

10448
10:27:06,200 --> 10:27:09,860
get conversion rate, which takes
an FML as its initial parameter,

10449
10:27:09,860 --> 10:27:13,490
which again, since this is a
library, it automatically passes

10450
10:27:13,490 --> 10:27:16,550
the message dot value into this
get conversion rate function.

10451
10:27:17,150 --> 10:27:22,280
But we could also pass in this
price feed, and therefore we

10452
10:27:22,280 --> 10:27:25,640
wouldn't need to hard code it in
the get price anymore. So let's

10453
10:27:25,640 --> 10:27:28,310
go ahead and figure out how to
do that. Well, what we can do is

10454
10:27:28,310 --> 10:27:31,430
we can do message dot value dot
get conversion rate, we'll stick

10455
10:27:31,430 --> 10:27:34,520
price feed in here. And then
we'll have to update our get

10456
10:27:34,520 --> 10:27:38,240
conversion rate to do a comma so
that it takes a second

10457
10:27:38,240 --> 10:27:41,960
parameter, because remember,
again, the initial parameter is

10458
10:27:41,960 --> 10:27:44,540
going to be message dot value.
And the second parameter is

10459
10:27:44,540 --> 10:27:50,210
going to be what we define here.
So we'll do s amount, comma ag

10460
10:27:50,210 --> 10:27:58,610
reg gate Tor v3 interface. And
we'll call this price feed. And

10461
10:27:58,610 --> 10:28:03,680
now, when we call our get price
function, we can pass the price

10462
10:28:03,680 --> 10:28:07,430
feed to the get price function.
And up here we can have get

10463
10:28:07,430 --> 10:28:14,420
price. Take, you guessed it an
aggregate or the three interface

10464
10:28:15,410 --> 10:28:22,220
called price feed. And now we no
longer need to hard code in the

10465
10:28:22,220 --> 10:28:25,430
price feed. And we can just
delete those lines and have it

10466
10:28:25,430 --> 10:28:30,020
compile like this, which is
awesome. So quick refresher,

10467
10:28:30,170 --> 10:28:33,590
we're parameterizing that price
feed address and passing it in

10468
10:28:33,590 --> 10:28:37,250
with a constructor that gets
saved as a global variable to an

10469
10:28:37,250 --> 10:28:41,570
aggregator v3 interface type, or
passing it to a get conversion

10470
10:28:41,570 --> 10:28:45,770
rate function, which passes it
to the get price function, which

10471
10:28:45,770 --> 10:28:48,680
then just calls latest round
data. And we probably could have

10472
10:28:48,680 --> 10:28:50,720
made this even easier, probably
could have just got rid of the

10473
10:28:50,720 --> 10:28:54,080
get price function and stuck
this code in the get conversion

10474
10:28:54,080 --> 10:28:56,630
rate. But we'll leave it there
for now. Now that we've done

10475
10:28:56,660 --> 10:28:59,630
that refactoring, let's make
sure it works. Yarn Hardhead,

10476
10:28:59,630 --> 10:29:03,140
compile, invalid value undefined
for hardhat dot config dot

10477
10:29:03,140 --> 10:29:07,010
networks. Let's go to the let's
go to the config real quick.

10478
10:29:07,100 --> 10:29:09,860
That's because the default
network needs to be outside of

10479
10:29:09,860 --> 10:29:14,300
networks. My mistake. Let's try
that again. I spelled interface

10480
10:29:14,300 --> 10:29:17,360
wrong and the price converter.
And a quick note, if gives you

10481
10:29:17,360 --> 10:29:20,750
an error like this, oftentimes,
you can command click or control

10482
10:29:20,750 --> 10:29:23,930
click and open that file up
right in the editor, which saves

10483
10:29:23,930 --> 10:29:26,240
you some time, we're going to
have defined the line and find

10484
10:29:26,240 --> 10:29:29,540
the file. But yeah, let's spell
that correctly. And let's try

10485
10:29:29,540 --> 10:29:33,620
this again. And awesome. It
looks like it's compiling

10486
10:29:33,620 --> 10:29:36,560
correctly. And we just have some
warnings, it looks like these

10487
10:29:36,560 --> 10:29:39,560
warnings are just about this git
version, which is because we're

10488
10:29:39,560 --> 10:29:42,650
shadowing this, we're creating a
new price variable down here,

10489
10:29:42,920 --> 10:29:45,590
you've no we just created a
global price free variable.

10490
10:29:46,100 --> 10:29:48,200
Let's just go ahead and delete
the get version function

10491
10:29:48,200 --> 10:29:51,140
altogether since we're not even
going to really need it. And we

10492
10:29:51,140 --> 10:29:53,690
only use the Git version to show
you how to actually start

10493
10:29:53,690 --> 10:29:56,480
working with interfaces. And
then we'll compile it one more

10494
10:29:56,480 --> 10:30:01,100
time for good measure. Boom
compiled successfully. Awesome.

10495
10:30:01,130 --> 10:30:04,970
So now we've just refactored our
code. So we can pass a price

10496
10:30:04,970 --> 10:30:08,990
feed address depending on the
network that we're on. Okay,

10497
10:30:08,990 --> 10:30:12,320
great. With all that being said,
let's come back to our deploy

10498
10:30:12,320 --> 10:30:15,110
Funmi script, and let's learn
how to actually deploy the rest

10499
10:30:15,110 --> 10:30:18,350
of it. In order for us to deploy
a contract we remember from our

10500
10:30:18,350 --> 10:30:22,100
last sections that we use the
contract factories, with heart

10501
10:30:22,100 --> 10:30:25,640
hit Deploy, we can just use this
deploy function. And to use the

10502
10:30:25,640 --> 10:30:28,700
deploy function, we'll say const
Funmi, which is going to be the

10503
10:30:28,700 --> 10:30:32,300
name of our contract, equals
await. And we'll call this

10504
10:30:32,300 --> 10:30:36,200
deploy function, the name of the
contract that we're deploying

10505
10:30:36,200 --> 10:30:39,710
right now, and then a list of
overrides that we want to add

10506
10:30:39,710 --> 10:30:42,650
here. So we're gonna say who is
actually deploying this by

10507
10:30:42,650 --> 10:30:45,980
saying from, we're gonna say
it's from the Deployer. We're

10508
10:30:45,980 --> 10:30:49,880
gonna pass any arguments to the
constructor In this args piece

10509
10:30:49,880 --> 10:30:55,250
here, which we just added a
single Argh. So these brackets,

10510
10:30:55,250 --> 10:30:57,530
we're going to make it a list of
arguments, we're going to put

10511
10:30:57,530 --> 10:30:59,660
the price feed address in here,
which we'll show you how to do

10512
10:30:59,660 --> 10:31:03,980
in a second, put price feed
address. And then we're also

10513
10:31:03,980 --> 10:31:06,260
going to do some custom logging
here so that we don't have to do

10514
10:31:06,260 --> 10:31:08,600
all that console dot log stuff
that we've been doing this whole

10515
10:31:08,600 --> 10:31:12,080
time. And we need to put
something in here. We need to

10516
10:31:12,080 --> 10:31:15,290
put an address in here. And you
can use this backslash star to

10517
10:31:15,290 --> 10:31:17,600
put like a common in between
your code.

10518
10:31:18,950 --> 10:31:22,130
We can't just do const address
equals, you know the address and

10519
10:31:22,190 --> 10:31:24,740
stick it in here. Well, I mean,
we could but we're not really

10520
10:31:24,740 --> 10:31:27,620
prioritizing now. Right? We're
kind of back to just hard coding

10521
10:31:27,620 --> 10:31:30,860
it here. So what can we do
instead? Well, what we can do is

10522
10:31:30,860 --> 10:31:35,990
we can actually use the chain ID
to do something like if chain ID

10523
10:31:35,990 --> 10:31:45,500
is x, use address, Y, or if
chain ID is Z use address A. So

10524
10:31:45,500 --> 10:31:48,140
we can do something that looks
like this. And to enable this

10525
10:31:48,140 --> 10:31:51,860
functionality, we actually take
a page out of the Ave GitHub. So

10526
10:31:51,890 --> 10:31:54,830
Ave is another protocol that's
on multiple chains and has to

10527
10:31:54,830 --> 10:31:57,590
deploy their code to multiple
chains and work with multiple

10528
10:31:57,590 --> 10:32:01,220
different addresses. So what
they do is they use a number of

10529
10:32:01,220 --> 10:32:04,070
different useful tricks. But one
of the main ones is using this

10530
10:32:04,070 --> 10:32:07,340
helper hardhat config. Now
they're using TypeScript with

10531
10:32:07,340 --> 10:32:10,280
JavaScript, but it's gonna be
the same thing. With this

10532
10:32:10,280 --> 10:32:14,630
config, they have different
variables, depending on what

10533
10:32:14,630 --> 10:32:17,690
network that they're actually
on. And depending on the network

10534
10:32:17,690 --> 10:32:20,270
that they're on, they use
different variables. So they use

10535
10:32:20,270 --> 10:32:24,020
this network config almost to do
exactly what we're trying to do

10536
10:32:24,020 --> 10:32:27,710
here. So what we want to do is
we're going to create a new file

10537
10:32:28,250 --> 10:32:32,900
at the root directory, so just
click down here, new file. And

10538
10:32:32,900 --> 10:32:39,170
we're going to call it helper,
hard hat config dot j, s. And

10539
10:32:39,170 --> 10:32:41,840
this is where we're going to
define that network config. And

10540
10:32:41,840 --> 10:32:43,940
this is where we're going to
say, hey, if you're on network,

10541
10:32:43,970 --> 10:32:48,050
a, use this address network, be
this use this address, etc. So

10542
10:32:48,080 --> 10:32:52,280
we're going to create an object
called const. Network config.

10543
10:32:53,000 --> 10:32:55,730
equals and we're going to add a
bunch of stuff in here. So our

10544
10:32:55,730 --> 10:32:58,700
main network that we're working
with right now is rinky. dinky

10545
10:32:58,700 --> 10:33:04,250
has a chain ID of four. So we'll
say chain ID four is going to be

10546
10:33:04,310 --> 10:33:12,410
named Rinkeby. And the eth USD
price feed address is going to

10547
10:33:12,410 --> 10:33:16,370
be the price feed address of
rank B of the eth USD price

10548
10:33:16,370 --> 10:33:19,190
feed. So we're going to copied
from the documentation or from

10549
10:33:19,190 --> 10:33:22,820
the GitHub, whatever you want to
do, and paste it in here. Now we

10550
10:33:22,820 --> 10:33:26,000
have a simple methodology of
keeping track of different price

10551
10:33:26,000 --> 10:33:29,270
feeds a different contract
addresses across different

10552
10:33:29,270 --> 10:33:33,140
chains. Let's say for example,
we wanted to deploy to Polygon

10553
10:33:33,170 --> 10:33:36,110
as well. Well, first, what are
we going to need? Well, we're

10554
10:33:36,110 --> 10:33:39,590
going to need the chain ID of
polygon. So a quick little

10555
10:33:39,590 --> 10:33:43,040
Google Search brings us to the
polygon documentation. And we

10556
10:33:43,040 --> 10:33:48,170
see the chain ID is 137. So I'll
do 137. What's a little brackets

10557
10:33:48,170 --> 10:33:54,260
here, we'll say name, polygon.
Then we'll do a comma eth USD,

10558
10:33:54,800 --> 10:33:58,700
price feed. And then we'll add
the price feed of eth USD on

10559
10:33:58,700 --> 10:34:04,130
polygon. So docstoc, chain link,
polygon or Matic and then we'll

10560
10:34:04,130 --> 10:34:09,200
look up eth, USD. And boom, we
see it right here. We've grabbed

10561
10:34:09,200 --> 10:34:12,770
this address, and we paste it
in. Well, what about the

10562
10:34:12,770 --> 10:34:15,620
Hardhead? Network? We'll get to
that in just a second, don't you

10563
10:34:15,620 --> 10:34:18,620
worry. And then at the bottom,
we need to export this network

10564
10:34:18,620 --> 10:34:21,710
config. So our other scripts can
actually work with it. So we'll

10565
10:34:21,710 --> 10:34:28,100
do module dot exports equals
network config. And we're going

10566
10:34:28,100 --> 10:34:31,070
to actually export a couple of
things from this file, which is

10567
10:34:31,070 --> 10:34:34,160
why we're doing it like this
instead of that default way that

10568
10:34:34,160 --> 10:34:37,580
I showed you before. So back in
our script, now, what can we do?

10569
10:34:37,760 --> 10:34:41,390
Well, first, we want to go ahead
and import that network config.

10570
10:34:41,420 --> 10:34:47,810
So we'll say const. Network
config equals require, and then

10571
10:34:47,810 --> 10:34:51,590
we'll import it, we'll go down
and directory to help our

10572
10:34:51,590 --> 10:34:54,920
Hardhead config and save. And I
just want to mention this one

10573
10:34:54,920 --> 10:34:57,410
more time, just so that it
doesn't confuse anybody. This

10574
10:34:57,410 --> 10:35:00,710
syntax here, constant network
config with the little curly

10575
10:35:00,710 --> 10:35:08,990
braces around it is the same is
if I went const. Helper config

10576
10:35:10,100 --> 10:35:13,280
equals this thing, which helper
config is now kind of this whole

10577
10:35:13,280 --> 10:35:21,020
file. And then const network
config equals Hopper config dot

10578
10:35:21,440 --> 10:35:24,890
network config. So again, this
index is just kind of an easy

10579
10:35:24,890 --> 10:35:28,610
way to extrapolate or pull out
just the network config from

10580
10:35:28,610 --> 10:35:31,850
this file. So that's how that
works. And that's why we export

10581
10:35:31,850 --> 10:35:35,600
it at the bottom so that we can
do this, please use the GitHub

10582
10:35:35,600 --> 10:35:39,410
repository to ask questions and
discussions especially about

10583
10:35:39,410 --> 10:35:41,840
some of this JavaScript stuff.
Alright, great. So now that we

10584
10:35:41,840 --> 10:35:44,630
have this network configured
here, we can now do this part of

10585
10:35:44,630 --> 10:35:48,950
where we say if China d z use a
if chain ID is x use y. So Since

10586
10:35:48,950 --> 10:35:52,670
our helper config is nicely in
this kind of dictionary, key

10587
10:35:52,670 --> 10:35:58,490
value pair style, what we can do
is we can say const. eth USD.

10588
10:35:59,060 --> 10:36:08,360
Price feed address equals
network config at the chain ID,

10589
10:36:08,690 --> 10:36:12,770
because if Francina D, or it'll
be this object, French entity

10590
10:36:12,770 --> 10:36:21,470
polygon, it'll be this object at
the eth USD price feed, we're

10591
10:36:21,470 --> 10:36:24,950
going to save this to eth USD
price feed address. And now no

10592
10:36:24,950 --> 10:36:27,980
matter what chain we're on,
whenever we run hard hat deploy,

10593
10:36:28,130 --> 10:36:34,550
if I run yarn, hard hat deploy
dash dash network Rinkeby. This

10594
10:36:34,550 --> 10:36:37,940
chain ID is going to be four.
And so it's going to use this

10595
10:36:37,940 --> 10:36:42,500
price feed address. If I do dash
test network polygon, and I

10596
10:36:42,500 --> 10:36:45,560
remember to add both ring P and
polygon to my networks, like

10597
10:36:45,560 --> 10:36:48,770
here, the channel is going to be
137. It's going to use this

10598
10:36:48,770 --> 10:36:52,310
price feed address. So this is
awesome. This is exactly what we

10599
10:36:52,310 --> 10:36:55,340
want. But is it everything that
we want? Those of you who have

10600
10:36:55,340 --> 10:36:58,040
been questioning while I have
been coding and talking, you

10601
10:36:58,040 --> 10:37:00,590
might be thinking, Okay, well,
you talked about this marking

10602
10:37:00,590 --> 10:37:03,500
thing. You talked about
localhost and hard hat. And how

10603
10:37:03,500 --> 10:37:06,410
do we test this locally? Like
this is how we go to a test net

10604
10:37:06,410 --> 10:37:09,740
and a main net. But what about a
local network? And that is

10605
10:37:09,740 --> 10:37:13,370
exactly what we're going to talk
about now. So we've modularized,

10606
10:37:13,370 --> 10:37:16,760
our code and parameterize our
code so that we're going to use

10607
10:37:16,760 --> 10:37:20,240
the address based off of the
chain that we're on. But what if

10608
10:37:20,240 --> 10:37:24,020
we use a chain that doesn't even
have a price feed address on it?

10609
10:37:24,080 --> 10:37:27,470
What do we do there? This is
where we actually create those

10610
10:37:27,500 --> 10:37:32,120
mock contracts. The idea of mock
contracts here is if the

10611
10:37:32,120 --> 10:37:37,550
contract doesn't exist, we
deploy a minimal version of it

10612
10:37:37,580 --> 10:37:42,530
for our local testing, or our
local testing. And deploying

10613
10:37:42,530 --> 10:37:48,200
mocks is technically a deploy
script. So what we do actually

10614
10:37:48,230 --> 10:37:51,080
is back in our deploy folder is
we're going to create a new

10615
10:37:51,080 --> 10:37:58,340
file, and we're going to call it
00 Dash deploy mocks dot j s, we

10616
10:37:58,340 --> 10:38:01,670
started with 00. Because this is
almost like the pre deploy

10617
10:38:01,670 --> 10:38:05,480
stuff, we only do this,
sometimes we don't always deploy

10618
10:38:05,480 --> 10:38:08,750
mocks, right, we don't need to
deploy mocks to Rinkeby, or

10619
10:38:08,750 --> 10:38:11,810
polygon or or Aetherium main
net, because those already have

10620
10:38:11,810 --> 10:38:15,200
these price feeds, we're
actually going to deploy our own

10621
10:38:15,350 --> 10:38:19,700
mock price feed contracts. And
in our deploy Funmi script,

10622
10:38:19,730 --> 10:38:23,780
we're going to use our own
contracts, instead of already

10623
10:38:23,780 --> 10:38:26,990
established contracts. If we're
on a network that doesn't have

10624
10:38:27,020 --> 10:38:30,770
any price, few contracts, like
hard hat or locos, for example.

10625
10:38:30,860 --> 10:38:34,160
So let's write our deploy mock
script. So the setup of this is

10626
10:38:34,160 --> 10:38:37,430
going to look nearly identical
to our deploy Funmi. And again,

10627
10:38:37,430 --> 10:38:41,270
if you want to set it up like
this, you absolutely can. But

10628
10:38:41,270 --> 10:38:43,880
I'm actually just going to copy
this, this part, paste it in

10629
10:38:43,880 --> 10:38:46,820
here, because that initial part
is going to be exactly the same.

10630
10:38:47,000 --> 10:38:49,340
Oh, and over here, I just
realized that we're calling this

10631
10:38:49,340 --> 10:38:52,160
network thing without being
defined, JavaScript will kind of

10632
10:38:52,160 --> 10:38:54,770
be smart enough to know where
this network thing is coming

10633
10:38:54,770 --> 10:38:57,860
from. But it can be a little bit
confusing. So it's better to be

10634
10:38:57,860 --> 10:39:03,740
really explicit, and say, const.
Network equals require hard hat,

10635
10:39:03,980 --> 10:39:07,130
this network thing is coming
from hard hat. And we're going

10636
10:39:07,130 --> 10:39:10,370
to grab this line. And we're
also going to use this at the

10637
10:39:10,370 --> 10:39:13,460
top of our script here. And then
our top section is going to look

10638
10:39:13,490 --> 10:39:16,160
exactly the same as well, we're
going to grab these three lines,

10639
10:39:16,250 --> 10:39:19,490
and paste them in deploy
deployer chain ID, boom, it's

10640
10:39:19,490 --> 10:39:21,530
all going to be the same here,
because we're setting up to

10641
10:39:21,530 --> 10:39:25,100
deploy some stuff. Now we want
to deploy a new contract. But if

10642
10:39:25,100 --> 10:39:28,460
we look at our contracts folder,
this is all we have right now.

10643
10:39:28,580 --> 10:39:32,450
So we're going to need to add
this mock this fake contract to

10644
10:39:32,450 --> 10:39:35,330
our contracts folder. Now what
we can do is in our contracts

10645
10:39:35,330 --> 10:39:38,810
folder, we want to separate this
file from the rest of our file

10646
10:39:38,810 --> 10:39:41,900
so that we know okay, this isn't
part of our project, but it is

10647
10:39:41,900 --> 10:39:44,990
part of our testing. So we're
going to right click Create New

10648
10:39:44,990 --> 10:39:49,160
Folder. And we can either call
it mocks, or test I like to call

10649
10:39:49,160 --> 10:39:52,220
mine test. And inside of this
folder, we can go ahead and

10650
10:39:52,220 --> 10:39:54,890
right click create a new file,
I'm going to create a new file

10651
10:39:54,920 --> 10:40:01,940
and call it mock, v3 aggregate
tore that soul. And this is

10652
10:40:01,940 --> 10:40:05,360
where we're going to define our
mock price feed aggregator

10653
10:40:05,390 --> 10:40:09,650
ourselves. So how can we create
our own fake price feed

10654
10:40:09,650 --> 10:40:12,620
contract, so we can test
everything locally? Well, one

10655
10:40:12,620 --> 10:40:16,010
thing we could do is we go to
the chain link GitHub repo, and

10656
10:40:16,010 --> 10:40:18,470
go through the contracts and
find one of these price feed

10657
10:40:18,470 --> 10:40:22,640
addresses, source eight, or
maybe we'll go back to source

10658
10:40:22,640 --> 10:40:24,500
we'll maybe we'll check in V
six.

10659
10:40:26,360 --> 10:40:29,510
Looks like we could find some
stuff and look around and we

10660
10:40:29,510 --> 10:40:32,690
probably copy paste all this
code, but it really seems like

10661
10:40:32,690 --> 10:40:35,060
kind of a huge pain in the butt
to have to copy all this code.

10662
10:40:35,210 --> 10:40:38,210
Now we absolutely could we copy
paste the code in here, but

10663
10:40:38,210 --> 10:40:40,460
we're gonna do something a
little bit more clever. So the

10664
10:40:40,460 --> 10:40:44,750
chainlink repo actually comes
with some mocks. If we go to

10665
10:40:44,750 --> 10:40:52,040
contracts, SRC V 0.6 tests They
actually have a mock v3

10666
10:40:52,040 --> 10:40:56,210
aggregator dot soul in here that
we can use as our mock. So we

10667
10:40:56,210 --> 10:40:59,690
can copy paste everything, but
we'd have to revamp a little bit

10668
10:40:59,690 --> 10:41:03,080
of it because it's doing some
dot dot stuff. It's talking to

10669
10:41:03,080 --> 10:41:06,530
other contracts that are locally
in this file structure that are

10670
10:41:06,530 --> 10:41:10,010
not going to be in our file
structure. So instead though,

10671
10:41:10,040 --> 10:41:13,340
what we can do is we can use
this node modules package to our

10672
10:41:13,340 --> 10:41:19,130
advantage, we can just say
pragma, solidity, carrot zero,

10673
10:41:19,670 --> 10:41:22,610
point 6.0, we'll use the same
version that that package is

10674
10:41:22,610 --> 10:41:28,130
doing. And then just do import
at a chain link slash contracts

10675
10:41:28,160 --> 10:41:35,840
slash SRC slash v 0.6. Slash
tests slash mock, B, three egg,

10676
10:41:35,840 --> 10:41:40,340
Reg, gay tore that soul. And
then we'll add, and then of

10677
10:41:40,340 --> 10:41:46,040
course, we'll add spdx, license
identifier, MIT. And boom, this

10678
10:41:46,040 --> 10:41:50,930
is actually all we need. If we
just import the code like this,

10679
10:41:50,960 --> 10:41:54,830
remember, this is exactly the
same as copy pasting this

10680
10:41:54,830 --> 10:41:59,000
contract into our project, of
course, with this path resolve

10681
10:41:59,000 --> 10:42:03,140
to where it actually is in our
node modules. Now, actually, I

10682
10:42:03,140 --> 10:42:07,910
can run yarn hardhat compile,
and it will also compile this

10683
10:42:07,910 --> 10:42:12,350
contract. Except for of course,
we have an issue, hey, compiler

10684
10:42:12,350 --> 10:42:15,530
versions don't match. Right?
What's What's up with that now,

10685
10:42:15,560 --> 10:42:18,020
you're going to get into
situations where you will be

10686
10:42:18,020 --> 10:42:20,780
working with contracts that are
not the same version of solidity

10687
10:42:20,780 --> 10:42:23,840
as you why well because
contracts keep being deployed

10688
10:42:23,870 --> 10:42:26,660
all the time. And there are a
ton of contracts that are in

10689
10:42:26,660 --> 10:42:32,540
version 0.4, solidity,
0.5 0.678, and probably 910, or

10690
10:42:32,540 --> 10:42:35,180
15 billion, or however many
solidity versions will come to

10691
10:42:35,180 --> 10:42:38,930
be. So in our config, in our
hard hat dot config, when you

10692
10:42:38,930 --> 10:42:41,870
scroll to the bottom, we can
scroll to where we're defining

10693
10:42:41,900 --> 10:42:45,500
our solidity version. And we can
actually add multiple solidity

10694
10:42:45,500 --> 10:42:49,520
versions, so that our compiler
can compile multiple versions of

10695
10:42:49,520 --> 10:42:54,110
solidity. To do that, we'll say,
so Lyd, did T. And we'll turn it

10696
10:42:54,110 --> 10:42:57,890
into an object here, we'll make
sure to put this comma here. And

10697
10:42:57,890 --> 10:43:01,850
inside our solidity object,
we'll put compilers and we'll

10698
10:43:01,850 --> 10:43:05,840
have a list of compilers. Our
first one we'll say is version,

10699
10:43:06,260 --> 10:43:09,770
zero, point 8.8. And we'll say
our second one is going to be

10700
10:43:09,770 --> 10:43:15,080
version 0.6, point six, and then
we'll go ahead and save that.

10701
10:43:15,680 --> 10:43:17,900
And it looks like mine wanted to
format it like this, which is

10702
10:43:17,900 --> 10:43:21,830
fine. Now, we can go ahead,
rerun, yarn, Hardhead, compile,

10703
10:43:22,430 --> 10:43:26,360
and boom, compiled five solidity
files successfully. This means

10704
10:43:26,360 --> 10:43:29,840
that our Mark V aggregator
should also have been compiled.

10705
10:43:29,900 --> 10:43:34,340
And if we look in artifacts, at
chain link, do indeed see this

10706
10:43:34,340 --> 10:43:38,870
at chain link slash contract
slash SRC bid, and a v 0.6. In

10707
10:43:38,870 --> 10:43:41,570
tests, we see this mock
aggregator dot soul, which has

10708
10:43:41,570 --> 10:43:45,620
been compiled. Awesome. So now
that we have our mock contract

10709
10:43:45,650 --> 10:43:50,180
compiled, we now have a contract
that we can use to deploy a fake

10710
10:43:50,180 --> 10:43:53,660
price feed to a blockchain. So
how do we actually do this?

10711
10:43:53,780 --> 10:43:56,690
Well, it's going to be the exact
same way that we deployed the

10712
10:43:56,690 --> 10:43:59,420
Funmi contract. But we're going
to add a little if statement in

10713
10:43:59,420 --> 10:44:04,400
here, we don't want to deploy
this mock contract to a test net

10714
10:44:04,400 --> 10:44:08,390
or a network that actually has a
price feed on it, we could just

10715
10:44:08,390 --> 10:44:13,220
do something like if chain ID
does not equal, you know, some

10716
10:44:13,220 --> 10:44:17,270
chain ID, then deploy marks,
right. And then this is kind of

10717
10:44:17,270 --> 10:44:19,640
pseudocode. Obviously, this code
won't actually work. But

10718
10:44:19,640 --> 10:44:22,910
instead, what I like is I
actually like to specify which

10719
10:44:22,910 --> 10:44:25,550
chains are going to be my
development chains, which chains

10720
10:44:25,550 --> 10:44:29,600
are going to be the one that I
can deploy these mocks to, in my

10721
10:44:29,600 --> 10:44:32,960
helper, hard hat config, I'll
define these chains. So I'll say

10722
10:44:32,960 --> 10:44:38,630
const, development chains,
equals, and then I'll just say

10723
10:44:38,630 --> 10:44:45,980
hard hat, and local host. I'll
export these. And back in my

10724
10:44:45,980 --> 10:44:51,350
deploy mocks, I'll import these
with const. Development chains

10725
10:44:51,380 --> 10:44:58,040
equals require dot dot slash
helper Hardhead config. And now

10726
10:44:58,160 --> 10:45:06,170
I'll say if development chains
dot includes chain ID. This

10727
10:45:06,170 --> 10:45:10,040
includes keyword basically is a
function that checks to see if

10728
10:45:10,190 --> 10:45:13,430
some variable is inside an
array, then we're gonna go ahead

10729
10:45:13,430 --> 10:45:17,030
and deploy Max, and which is
what we want to do. So we'll do

10730
10:45:17,090 --> 10:45:19,760
log, which we're getting from
deployments, which is basically

10731
10:45:19,760 --> 10:45:24,980
console dot log. And we'll say
local network detected,

10732
10:45:25,640 --> 10:45:27,620
deploying mocks.

10733
10:45:28,970 --> 10:45:34,940
And we'll do a weight ploy, and
we'll deploy our new mock v3

10734
10:45:34,940 --> 10:45:40,130
aggregator mock v3 aggregator
will do a comma. There a little

10735
10:45:40,130 --> 10:45:43,430
colons here. If we want to get
really specific, we can say

10736
10:45:43,430 --> 10:45:47,630
contract v3 aggregator which
we're kind of already saying

10737
10:45:47,660 --> 10:45:51,680
we'll say from deployer We'll
say logging is going to be true.

10738
10:45:53,030 --> 10:45:56,390
And then we need to pass some
arguments, we need to pass the

10739
10:45:56,390 --> 10:46:00,080
constructor parameters for the
mock v3 aggregator, which are

10740
10:46:00,170 --> 10:46:04,310
what? Well, let's go to docs
chain to link to find out. Or

10741
10:46:04,340 --> 10:46:09,800
you can also just go to Node
modules chainlink, SRC V 06,

10742
10:46:10,010 --> 10:46:13,790
tests, and then all the way down
to mock V three, aggregated out.

10743
10:46:13,790 --> 10:46:17,270
So where you could also find the
constructor in here, whatever

10744
10:46:17,270 --> 10:46:19,640
one you like better, sometimes I
find it easier just to read

10745
10:46:19,640 --> 10:46:24,680
GitHub Ctrl plus F or Command
plus F for constructor. We see

10746
10:46:25,160 --> 10:46:29,570
it takes a decimals and an
initial answer. And if we read

10747
10:46:29,570 --> 10:46:33,050
through the code, we'll learn
that the decimals object is

10748
10:46:33,050 --> 10:46:36,380
going to be equivalent to the
decimals parameter is going to

10749
10:46:36,380 --> 10:46:40,700
be equivalent to this decimals
function and the initial answer.

10750
10:46:40,970 --> 10:46:43,190
And the initial answer is
basically just going to be what

10751
10:46:43,190 --> 10:46:45,680
is the price feed starting at,
we actually get to pick the

10752
10:46:45,680 --> 10:46:48,710
price of the price feed, which
works out really well, because

10753
10:46:48,710 --> 10:46:51,170
that works out great for
testing. I usually like to

10754
10:46:51,170 --> 10:46:53,780
define the decimals and the
initial answers somewhere

10755
10:46:53,780 --> 10:46:57,050
outside of this function so that
I can access it later. One good

10756
10:46:57,050 --> 10:47:00,410
place you can add it is once
again in our helper Hardhead

10757
10:47:00,410 --> 10:47:06,740
config.js. So I might do const
decimals equals eight. And then

10758
10:47:06,740 --> 10:47:15,740
const initial answer. Answer
equals, and we'll do 2000. So

10759
10:47:15,770 --> 10:47:20,930
since we have a decimals, we'll
do 2000 And then 123456788

10760
10:47:20,930 --> 10:47:24,650
decimal places, and then we'll
export these as well. Export

10761
10:47:24,650 --> 10:47:28,760
decimals, and export initial
answer. We could of course, just

10762
10:47:28,760 --> 10:47:32,480
do you know, const decimals
equals eight at the top and then

10763
10:47:32,480 --> 10:47:35,540
initial answer and then use them
down here. But I like to do it

10764
10:47:35,540 --> 10:47:38,660
like that. So Conce. So now we
have to import them in here.

10765
10:47:39,260 --> 10:47:43,640
const development chains. It's
also grabbed decimals. It's also

10766
10:47:43,640 --> 10:47:47,120
grabbed initial answer, we'll
save it. We'll take a look back

10767
10:47:47,120 --> 10:47:49,550
at the constructor looks like
it's decimals first, initial

10768
10:47:49,550 --> 10:47:52,820
answers second. So in our
arguments, we'll do decimals

10769
10:47:52,820 --> 10:47:57,440
first, initial answers second,
and tada. And then we will be

10770
10:47:57,440 --> 10:48:01,940
all done that we'll do a quick
log box deployed. And then I

10771
10:48:01,940 --> 10:48:05,450
also like to do kind of like a
big line at the end of all of my

10772
10:48:05,450 --> 10:48:08,030
deploy scripts just to be like,
hey, that's the end of this

10773
10:48:08,030 --> 10:48:11,180
deploy script. Anything else
after this is going to be a

10774
10:48:11,180 --> 10:48:14,390
different deploy script. All
right, great. Now our deployed

10775
10:48:14,390 --> 10:48:17,600
mocks script is actually done.
But our deploy Funmi script

10776
10:48:17,840 --> 10:48:21,770
isn't quite done. Is there a way
that we could run only our

10777
10:48:21,770 --> 10:48:25,190
deploy mock script? Well, yes,
there is. Great, thanks for

10778
10:48:25,190 --> 10:48:27,890
asking. What we can do at the
bottom of our deploy mock script

10779
10:48:27,920 --> 10:48:35,000
is we can add a module that
exports dot tags, equals, and

10780
10:48:35,000 --> 10:48:40,430
we'll say all and marks. Now
what we can do is if we run

10781
10:48:40,430 --> 10:48:45,770
yarn, hard hat deploy, we can
add this flag dash dash tags.

10782
10:48:46,190 --> 10:48:50,540
And it will only run the deploy
scripts that have a special tag.

10783
10:48:50,930 --> 10:48:55,310
So we'll run our mocks tag,
which means it'll only run our

10784
10:48:55,310 --> 10:48:59,840
deploy mock script. And, and
oops, actually, in our helper

10785
10:48:59,840 --> 10:49:03,440
config development chains is
actually hard hat and localhost.

10786
10:49:03,440 --> 10:49:06,860
And I said, we're going to try
to do with the chain ID, sorry,

10787
10:49:06,890 --> 10:49:09,380
we're going to do this, we're
gonna do development chains dot

10788
10:49:09,380 --> 10:49:11,990
includes network dot name.

10789
10:49:15,350 --> 10:49:19,880
Because our helper config is
using names and not chain IDs,

10790
10:49:19,910 --> 10:49:23,030
so if development chains that
includes that network the names,

10791
10:49:23,060 --> 10:49:25,670
then we're gonna go ahead and
deploy the mocks. So let's go

10792
10:49:25,670 --> 10:49:28,730
ahead and run this yarn here and
hit Deploy dash dash tags,

10793
10:49:28,730 --> 10:49:32,990
mocks. And perfect we do indeed
see our mocks getting deployed

10794
10:49:32,990 --> 10:49:36,620
here. This log true means that
it's going to spit out stuff

10795
10:49:36,620 --> 10:49:39,560
like this. It'll say contract,
it's deploying, it'll say the

10796
10:49:39,560 --> 10:49:42,830
transaction it's doing and it'll
say where it was deployed with

10797
10:49:42,830 --> 10:49:47,000
how much gas and awesome This
means our deployed Mach script

10798
10:49:47,000 --> 10:49:50,570
is working perfectly. So now we
have our deploy mocks script

10799
10:49:50,600 --> 10:49:54,170
working perfectly. So how do we
apply that back to our deploy

10800
10:49:54,200 --> 10:49:57,440
Funmi script? Well, we're gonna
do the exact same thing here.

10801
10:49:57,980 --> 10:50:01,070
Instead of making eth USD price
feed address constant variable,

10802
10:50:01,100 --> 10:50:04,700
we're gonna say let at USD price
you'd variable so that we can

10803
10:50:04,700 --> 10:50:09,800
actually update it. And we'll
say, if development chains dot

10804
10:50:09,800 --> 10:50:15,650
includes network dot name, what
we can do with hard hat deploy

10805
10:50:15,680 --> 10:50:19,010
is we can just get the most
recent deployment using a

10806
10:50:19,010 --> 10:50:23,840
command called literally get. So
we'll say const. eth USD

10807
10:50:23,840 --> 10:50:30,200
aggregator equals await
deployments dot get. And then

10808
10:50:30,200 --> 10:50:34,280
the name of the contract that we
deployed Mach v3 aggregator, and

10809
10:50:34,280 --> 10:50:37,040
if you wanted to just do get
instead of deployments dot get,

10810
10:50:37,220 --> 10:50:42,020
we absolutely could, just by
doing it like this. Those are

10811
10:50:42,020 --> 10:50:45,080
exactly the same. So we'll get
the address like this and then

10812
10:50:45,080 --> 10:50:52,400
we'll say eth USD price feed
address equals that eth USD

10813
10:50:52,400 --> 10:50:56,900
aggregator contract dot address.
And then if we're not on a

10814
10:50:56,900 --> 10:51:00,380
development chain, if we didn't
deploy a mock, we're just going

10815
10:51:00,380 --> 10:51:04,160
to do exactly what we did
before. With using the network

10816
10:51:04,160 --> 10:51:09,740
config. Oh, my goodness. Now,
now that we've done all of these

10817
10:51:09,740 --> 10:51:13,070
steps, let's add a little log
thing at the bottom here with

10818
10:51:13,070 --> 10:51:18,260
just a bunch of hyphens. Now, we
should have a very robust script

10819
10:51:18,440 --> 10:51:22,340
to flip between a local
development chain, a test net

10820
10:51:22,340 --> 10:51:25,820
chain, a main net chain, and
allow us to deploy literally

10821
10:51:25,820 --> 10:51:29,330
everywhere without changing any
of our solidity. And then we

10822
10:51:29,330 --> 10:51:33,770
just take this, this eth USD
price feed address and stick it

10823
10:51:34,460 --> 10:51:38,450
into logs here. And then at the
bottom, we can do module dot

10824
10:51:38,450 --> 10:51:43,490
exports, dot tags equals and
then we'll just do all and then

10825
10:51:43,490 --> 10:51:48,650
we'll call this one Funmi. Oh,
now moment of truth. If we did

10826
10:51:48,650 --> 10:51:52,430
all this, right, we should just
be able to run yarn, hard hat

10827
10:51:52,430 --> 10:51:57,110
deploy. And it should work on
our local chain, our hard hat

10828
10:51:57,110 --> 10:52:00,500
chain. And then it should also
work on any test net that we

10829
10:52:00,500 --> 10:52:03,950
give it. So let's give this a
try. Yarn, Hardhead deploy.

10830
10:52:04,340 --> 10:52:07,460
Let's see if this works.
Awesome. And we got this all to

10831
10:52:07,460 --> 10:52:11,780
deploy locally to our Hard Hat
Network, we can see that we went

10832
10:52:11,780 --> 10:52:14,780
ahead and we deployed mocks, we
did our little underline here.

10833
10:52:15,170 --> 10:52:18,020
And then we deployed Funmi
deployed at this address with

10834
10:52:18,050 --> 10:52:21,560
this much gas. Now, what are the
other awesome things about hard

10835
10:52:21,560 --> 10:52:24,680
hat deploy? When we run our
local blockchain, our own

10836
10:52:24,680 --> 10:52:28,880
blockchain node, hard hat deploy
will automatically run through

10837
10:52:29,060 --> 10:52:33,290
all of our deploy scripts and
add them to our node. So now if

10838
10:52:33,290 --> 10:52:38,420
I run yarn, hard hat node, we're
going to spin up a new

10839
10:52:38,420 --> 10:52:41,690
blockchain node, but it's
already going to have all of our

10840
10:52:41,690 --> 10:52:45,140
deployed contracts on it. So
every time we spin up a local

10841
10:52:45,140 --> 10:52:48,530
node, now it's going to come
automatically packed with the

10842
10:52:48,530 --> 10:52:54,500
contracts that we want on it. So
we are going to show us doing

10843
10:52:54,500 --> 10:52:57,740
this on a test net on Rinkeby.
But before we actually test it

10844
10:52:57,740 --> 10:53:00,530
on Rinkeby, I'm going to add a
little bit of the auto

10845
10:53:00,530 --> 10:53:03,440
verification piece in here as
well, because we did that in the

10846
10:53:03,440 --> 10:53:06,290
last lesson. And we wanted to
show how to do it in hard hat

10847
10:53:06,290 --> 10:53:09,770
deploy as well. So right after
we deploy our Funmi, we can do

10848
10:53:09,770 --> 10:53:13,100
something similar here, we'll
say, if developer chains

10849
10:53:13,100 --> 10:53:17,150
includes network dot name, we'll
say if developer chains doesn't

10850
10:53:17,150 --> 10:53:19,670
include network dot name,
because we don't want to verify

10851
10:53:19,700 --> 10:53:25,010
on a local network. So we'll say
if not development chains dot

10852
10:53:25,010 --> 10:53:28,670
includes network dot name, the
exclamation mark, aka the bang

10853
10:53:29,000 --> 10:53:32,690
means not when we're talking
about booleans. So we're saying,

10854
10:53:32,960 --> 10:53:36,080
if the name of the network isn't
a development chain, we want to

10855
10:53:36,080 --> 10:53:41,450
go ahead and verify and same as
last time. And if process dot e

10856
10:53:41,450 --> 10:53:45,170
NV dot ether scan API key,

10857
10:53:46,490 --> 10:53:50,270
then we're going to go ahead and
verify. Now before we had our

10858
10:53:50,270 --> 10:53:53,450
verify code, right in our deploy
code, we're gonna do something a

10859
10:53:53,450 --> 10:53:56,450
little bit different here.
Instead of having our verify

10860
10:53:56,450 --> 10:53:59,810
code in our deploy scripts here,
we're actually going to create a

10861
10:53:59,810 --> 10:54:04,250
new folder called utils, which
stands for utilities. And this

10862
10:54:04,250 --> 10:54:07,010
is where we're going to add
different scripts that we can

10863
10:54:07,010 --> 10:54:09,200
use across different
deployments. Because let's say

10864
10:54:09,200 --> 10:54:12,320
we have 50 Deploy scripts, we're
not going to make 50 Deploy

10865
10:54:12,320 --> 10:54:15,350
functions, we're just going to
add them to our utils folder,

10866
10:54:15,470 --> 10:54:19,460
and in our utils folder, or
create a new file called verify

10867
10:54:19,580 --> 10:54:23,270
dot j s, we're going to add that
code from our last project in

10868
10:54:23,270 --> 10:54:26,540
here. So if you want, you can go
ahead copy paste from our last

10869
10:54:26,540 --> 10:54:30,200
project over to this one, or you
can pause the video to type it

10870
10:54:30,200 --> 10:54:33,320
out yourself. Since we're using
the run command here, we're

10871
10:54:33,320 --> 10:54:38,810
gonna do const run equals
require RT hat. And then at the

10872
10:54:38,810 --> 10:54:47,750
bottom, we're going to do module
exports. Exports equals verify.

10873
10:54:48,470 --> 10:54:53,180
Now that we have a verify script
in our utils folder, back in our

10874
10:54:53,180 --> 10:54:59,090
deploy Funmi we're going to say
const. Verify equals require dot

10875
10:54:59,090 --> 10:55:04,970
dot slash utils. Slash verify.
And since now in our verified

10876
10:55:05,000 --> 10:55:08,540
Jas, we have a lot of this
trycatch stuff in here, we can

10877
10:55:08,540 --> 10:55:15,140
just do a wait. Verify and a
verify once again takes a

10878
10:55:15,140 --> 10:55:18,320
contract address and a list of
arguments. We'll say await

10879
10:55:18,350 --> 10:55:24,680
verify, fund me dot address and
then the list of arguments. To

10880
10:55:24,680 --> 10:55:27,740
make the list of arguments
easier to put in. You can go

10881
10:55:27,740 --> 10:55:32,540
const args, equals and then
we'll just stick our eth USD

10882
10:55:32,540 --> 10:55:37,640
price feed in here and then
replace this with args and then

10883
10:55:37,640 --> 10:55:42,410
take this args and pop it on
down into the second parameter

10884
10:55:42,410 --> 10:55:48,560
here. All right, great. Now
let's go ahead and deploy this

10885
10:55:48,590 --> 10:55:51,470
to With the Rinkeby test net,
and what do we need to deploy

10886
10:55:51,470 --> 10:55:53,900
this to the Rinkeby test net?
Well, let's jump into our hard

10887
10:55:53,900 --> 10:55:57,140
hat config first. And let's
clean this up, we don't really

10888
10:55:57,140 --> 10:56:00,410
need this accounts task, so I'm
just going to delete it, I don't

10889
10:56:00,410 --> 10:56:03,710
really need this comment. So I'm
going to delete this too. And

10890
10:56:03,710 --> 10:56:06,470
let's jump into the network
section, we're not going to be

10891
10:56:06,470 --> 10:56:09,560
working with ropsten. So we're
gonna go ahead and dump that. We

10892
10:56:09,560 --> 10:56:13,370
are however, going to be working
with rink B, the URL is going to

10893
10:56:13,370 --> 10:56:18,410
be that same Rinkeby RPC URL. So
we're going to define that up

10894
10:56:18,410 --> 10:56:21,950
here, like we did before. And if
you want to copy paste from your

10895
10:56:21,950 --> 10:56:25,280
last project, feel free to do so
you can also follow along with

10896
10:56:25,280 --> 10:56:38,540
me or fastforward me the counts
is going to be the same. I'm

10897
10:56:38,540 --> 10:56:41,360
going to go ahead and just copy
paste the gas reporter with what

10898
10:56:41,360 --> 10:56:44,960
we had from before. So we're
going to add this constant corn

10899
10:56:44,960 --> 10:56:49,340
market cap API key equals
process dot EMV dot corn market

10900
10:56:49,340 --> 10:56:53,600
cap API key. Do the same thing
with the ether scan API key

10901
10:56:53,600 --> 10:57:00,920
Licious add everything in here.
Now. We have our ether scan

10902
10:57:00,920 --> 10:57:04,160
section in here already, we're
gonna have our gas reporter be

10903
10:57:04,160 --> 10:57:06,800
false, because I don't really
feel like using it right now.

10904
10:57:07,070 --> 10:57:09,920
And then finally, we're going to
add one more thing in here.

10905
10:57:10,130 --> 10:57:12,830
Remember how in our last
project, before we actually

10906
10:57:12,830 --> 10:57:16,100
verified we waited some block
confirmations. That way ether

10907
10:57:16,100 --> 10:57:19,130
scan could make sure to catch
up. Well, we can do the exact

10908
10:57:19,130 --> 10:57:22,910
same thing in here in our hard
hat dot config, we can add a

10909
10:57:22,910 --> 10:57:26,300
section for each test net for
how many blocks we want to wait,

10910
10:57:26,570 --> 10:57:33,320
I'm going to add block
confirmations of six. Now back

10911
10:57:33,320 --> 10:57:36,920
on our deploy Funmi. In a new
section, I can add wait

10912
10:57:37,130 --> 10:57:46,340
confirmations of network dot
config. That block on for

10913
10:57:47,180 --> 10:57:53,480
motions, or one is or one means
if no block confirmations is

10914
10:57:53,480 --> 10:57:57,110
given in our Hardhead dot config
will just wait for one block.

10915
10:57:57,290 --> 10:57:59,960
And again, the reason we want to
wait for approximately six block

10916
10:57:59,960 --> 10:58:03,410
confirmations is we want to give
ether scan a chance to index our

10917
10:58:03,410 --> 10:58:07,490
transaction. And I added a chain
ID 42 when it should be for my

10918
10:58:07,490 --> 10:58:11,240
mistake. And of course, we're
going to need our dot env file,

10919
10:58:11,420 --> 10:58:14,660
where we add all of our stuff
from the last session, the RIP

10920
10:58:14,660 --> 10:58:18,650
ERP CRL private key ether scan
API and then coin market cap

10921
10:58:18,650 --> 10:58:23,000
API. All right moment of truth.
Let's try this out. If we run

10922
10:58:23,000 --> 10:58:30,020
yarn Hardhead deploy dash dash
network Rinkeby. It should not

10923
10:58:30,050 --> 10:58:34,040
deploy any marks because we have
this if statement in our mock

10924
10:58:34,040 --> 10:58:39,050
deployment. But it should deploy
our Funmi contract using the

10925
10:58:39,050 --> 10:58:43,250
correct price feed address. And
then it'll go ahead and verify

10926
10:58:43,250 --> 10:58:47,300
it. Since we're waiting for six
block confirmations, we can even

10927
10:58:47,300 --> 10:58:51,500
be super secure by adding dash
dash tags and just running the

10928
10:58:51,500 --> 10:58:55,790
funding tag. But we're just
going to do yarn hearted deploy

10929
10:58:55,820 --> 10:58:59,930
network Rigby. And let's see
what happens. All right, and

10930
10:58:59,930 --> 10:59:03,950
we're deploying funding. And we
can see the transaction that we

10931
10:59:03,950 --> 10:59:08,630
have for fun me, this is that
logging feature, we have log is

10932
10:59:08,630 --> 10:59:12,860
true for deploying Funmi. So it
gives us the transaction once it

10933
10:59:12,860 --> 10:59:16,160
has a transaction, and it will
give us the address once we have

10934
10:59:16,160 --> 10:59:20,120
the address. So we're going to
wait six block confirmations for

10935
10:59:20,120 --> 10:59:23,240
this transaction to finish going
through. Now we see we've

10936
10:59:23,240 --> 10:59:27,230
deployed this contract address
with X amount of gas. And now

10937
10:59:27,260 --> 10:59:30,410
we're running the verification
process. While the verification

10938
10:59:30,410 --> 10:59:35,630
process is running, we can pull
up Rinkeby ether scan, paste our

10939
10:59:35,630 --> 10:59:39,560
address in here and see that we
have indeed created this

10940
10:59:39,560 --> 10:59:42,620
contract. And now it looks like
we've successfully verified the

10941
10:59:42,620 --> 10:59:46,760
contract on ether scan. So if we
hit refresh, we can indeed see

10942
10:59:46,790 --> 10:59:50,030
that the contract has been
verified. Awesome. All right. So

10943
10:59:50,030 --> 10:59:53,570
this is fantastic. Our deploy
script is looking great, we're

10944
10:59:53,570 --> 10:59:57,110
able to deploy to a local chain,
we're able to deploy to a test

10945
10:59:57,110 --> 11:00:00,050
that and if we wanted to, we
could deploy to any network that

10946
11:00:00,050 --> 11:00:03,860
we wanted simply by updating our
hard hat config, and then

10947
11:00:03,890 --> 11:00:07,700
updating our helper config. This
is fantastic.

10948
11:00:07,730 --> 11:00:13,610
Great work so far. Now we're
about to jump in and level up

10949
11:00:13,610 --> 11:00:16,430
our tests. But before we do
that, we're going to clean up

10950
11:00:16,460 --> 11:00:19,130
our Funmi contract a little bit
to make it look a little bit

10951
11:00:19,130 --> 11:00:22,190
more professional. And I'm going
to talk about some of the syntax

10952
11:00:22,190 --> 11:00:25,520
and some of the reasons why some
conventions exist. We're not

10953
11:00:25,520 --> 11:00:28,970
going to do this full force on
all the projects moving forward.

10954
11:00:29,210 --> 11:00:31,820
But they are good to know and
they are good to keep in mind

10955
11:00:31,910 --> 11:00:35,330
when moving forward and working
with our contracts. While we go

10956
11:00:35,330 --> 11:00:37,640
through this we're going to
learn why some of these

10957
11:00:37,640 --> 11:00:40,460
conventions exist including
learning a little bit of low

10958
11:00:40,460 --> 11:00:43,400
level solidity. So don't skip
this part. When we get to later

10959
11:00:43,400 --> 11:00:46,460
sections. We're going to be a
little bit looser and not be as

10960
11:00:46,460 --> 11:00:49,700
strict with the code style
guides but That's basically what

10961
11:00:49,700 --> 11:00:52,400
we're gonna go over now. And for
now, you might see this event

10962
11:00:52,400 --> 11:00:55,250
funded thing here, please just
ignore that for now, in an

10963
11:00:55,250 --> 11:00:58,730
earlier take, I'd introduced the
events much earlier. And now

10964
11:00:58,730 --> 11:01:00,530
we're actually going to learn
about events a little bit later

10965
11:01:00,530 --> 11:01:04,070
in the course. So please ignore
that event funded for now. So

10966
11:01:04,070 --> 11:01:06,380
let's go ahead and tweak a
little bit of our contracts

10967
11:01:06,380 --> 11:01:08,900
here. Now what I'm talking about
tweaking this to make it look

10968
11:01:08,900 --> 11:01:11,240
professional, a little bit more
professional, I'm talking about

10969
11:01:11,240 --> 11:01:14,690
the solidity style guide, there
are some conventions for naming

10970
11:01:14,690 --> 11:01:17,810
and ordering that we can follow
to make our code look a little

10971
11:01:17,810 --> 11:01:20,390
bit better. Now, like I said,
this is going to be a little bit

10972
11:01:20,390 --> 11:01:23,360
more optional, because it can be
a little bit verbose. And it

10973
11:01:23,510 --> 11:01:26,330
doesn't really make that big of
a difference. But it can

10974
11:01:26,330 --> 11:01:29,870
increase readability of your
contracts by a lot and make your

10975
11:01:29,870 --> 11:01:33,350
code look a lot nicer. So if you
want, you can go through this

10976
11:01:33,380 --> 11:01:36,800
style guide to learn more about
what kind of makes solidity look

10977
11:01:36,800 --> 11:01:39,290
nice, and what makes it not look
nice. But well, that's some of

10978
11:01:39,290 --> 11:01:41,360
these style guides in here,
we're not going to follow the

10979
11:01:41,360 --> 11:01:44,090
style guide exactly to a tee.
But we are going to make some

10980
11:01:44,090 --> 11:01:47,060
best efforts to make our code
follow the style guide, we've

10981
11:01:47,060 --> 11:01:50,150
got a link to the style guide in
the GitHub repository for this

10982
11:01:50,150 --> 11:01:53,210
section, we can read some more
about the layout. But the main

10983
11:01:53,210 --> 11:01:55,700
thing we want to look at is this
order of the layout, we want to

10984
11:01:55,700 --> 11:01:59,180
start with our imports with our
pragma statement, our imports,

10985
11:01:59,210 --> 11:02:02,450
interfaces, libraries, and then
contracts. And then inside each

10986
11:02:02,450 --> 11:02:05,480
contract type declarations,
state variables, events,

10987
11:02:05,510 --> 11:02:08,990
modifiers, and functions. So
let's go back here and make sure

10988
11:02:08,990 --> 11:02:12,530
that we're up to speed, we want
our pragma first. Alright,

10989
11:02:12,530 --> 11:02:16,610
awesome, we did exactly that,
then we want our imports. Okay,

10990
11:02:16,640 --> 11:02:19,460
awesome, we have those too.
Something that's not in the

10991
11:02:19,460 --> 11:02:22,820
style guide is going to be error
codes, which we definitely want

10992
11:02:22,820 --> 11:02:27,140
next. So next is going to be
error codes. Now this is where

10993
11:02:27,140 --> 11:02:30,410
we're going to bump into one of
our first updates here. As of

10994
11:02:30,410 --> 11:02:34,400
recent, it's sort of becoming a
best practice to add the name of

10995
11:02:34,400 --> 11:02:37,820
your contract, some underscores,
and then the name of your error.

10996
11:02:38,000 --> 11:02:40,580
Whenever you're running into an
error. This makes it a lot

10997
11:02:40,610 --> 11:02:43,970
easier to understand which
contract is throwing the error.

10998
11:02:44,030 --> 11:02:48,350
So for this, we're going to say
error Funmi, two underscores not

10999
11:02:48,350 --> 11:02:52,190
owner, then we're going to
scroll down to the our revert

11000
11:02:52,490 --> 11:02:56,120
and set it like this. This way,
when if we ever run into this

11001
11:02:56,120 --> 11:02:59,240
error, we know that the error is
coming from the Funmi contract,

11002
11:02:59,480 --> 11:03:01,940
not from the aggregator v3
interface, or the price

11003
11:03:01,940 --> 11:03:05,090
converter or some other
contract. So that's how we want

11004
11:03:05,090 --> 11:03:07,820
to write our error codes here.
If we had any interfaces or

11005
11:03:07,820 --> 11:03:11,720
libraries not imported, we would
add them here. But then finally,

11006
11:03:11,750 --> 11:03:15,050
we add our contracts. In this
file, we only have one contract

11007
11:03:15,050 --> 11:03:18,950
here. It's our Funmi contract.
Awesome. Now the next thing we

11008
11:03:18,950 --> 11:03:21,590
want to learn about as far as
style guides go is this thing

11009
11:03:21,590 --> 11:03:26,810
called natspec. natspec stands
for Etherium natural language

11010
11:03:26,810 --> 11:03:30,500
specification format. And it's
basically a way of documenting

11011
11:03:30,530 --> 11:03:34,490
our code inspired by Doxygen
uses Doxygen style comments and

11012
11:03:34,490 --> 11:03:38,270
tags to help document our code,
you can click the link here in

11013
11:03:38,270 --> 11:03:41,270
the solidity documentation to
learn more about Doxygen. If we

11014
11:03:41,270 --> 11:03:43,880
scroll down in the
documentation, here, we can see

11015
11:03:43,880 --> 11:03:47,330
an example of using natspec.
Whenever we have a contract or a

11016
11:03:47,330 --> 11:03:50,450
function that needs
documentation, we can add some

11017
11:03:50,450 --> 11:03:53,750
syntax that looks like this to
it. So for example, if we wanted

11018
11:03:53,750 --> 11:03:57,470
to add this to our code, we
could add a comment explaining

11019
11:03:57,500 --> 11:04:00,560
this funding contract to start a
piece of natspec, you can do

11020
11:04:00,590 --> 11:04:05,210
three backslashes, or one
backslash, two stars, and then

11021
11:04:05,870 --> 11:04:09,350
another ending star here.
Everything we put inside of this

11022
11:04:09,350 --> 11:04:12,200
comment section basically gets
turned into a comment. For the

11023
11:04:12,200 --> 11:04:15,590
start of our contract, we'll do
the Add sign title to explain

11024
11:04:15,590 --> 11:04:18,050
basically, what this contract
is, it's fun, we contract is

11025
11:04:18,050 --> 11:04:20,270
going to be a contract

11026
11:04:20,390 --> 11:04:27,980
for crowdfunding, we'll add
another star. And we can add the

11027
11:04:27,980 --> 11:04:31,610
author of it, which is going to
be your name, I'm going to put

11028
11:04:31,640 --> 11:04:35,030
Patrick Collins, of course, then
we'll add a notice, which is

11029
11:04:35,030 --> 11:04:39,800
just kind of a note to people we
can say this contract is is to

11030
11:04:39,800 --> 11:04:46,250
demo a sample funding contract.
And we can also add apt Dev,

11031
11:04:46,670 --> 11:04:49,820
which is a note specifically to
developers. And we can say this

11032
11:04:50,120 --> 11:04:54,770
implements price feeds as our
library. The reason that we want

11033
11:04:54,770 --> 11:04:58,850
to add these tags here is
actually because we can use the

11034
11:04:58,850 --> 11:05:02,360
natspec to automatically create
documentation for us if we

11035
11:05:02,360 --> 11:05:06,350
download so we can actually run
solc dash s user doc dash dash

11036
11:05:06,350 --> 11:05:10,220
dev doc, and the name of our
file to automatically generate

11037
11:05:10,220 --> 11:05:13,820
documentation. So this is also
really helpful for automatically

11038
11:05:13,820 --> 11:05:16,370
creating documentation for other
developers who interact with the

11039
11:05:16,370 --> 11:05:20,300
protocol later on. You can use
this natspec For as many or as

11040
11:05:20,300 --> 11:05:23,090
few functions as you'd like.
Most of us probably aren't going

11041
11:05:23,090 --> 11:05:26,120
to be making documentation. So
we really just want to follow

11042
11:05:26,120 --> 11:05:29,300
those guidelines if we think
some function or some section of

11043
11:05:29,300 --> 11:05:32,240
our code is a little bit tricky
for other developers. Now that

11044
11:05:32,240 --> 11:05:34,910
we're inside of contract, we can
follow the order of our

11045
11:05:34,910 --> 11:05:39,110
contract. We're first going to
start with type declarations

11046
11:05:41,870 --> 11:05:43,790
which we don't really have any
except for the fact that we're

11047
11:05:43,790 --> 11:05:48,410
using our price converter for
the UN 256 type. Okay, great.

11048
11:05:48,650 --> 11:05:51,140
You Next, after our type
declarations, we're going to do

11049
11:05:51,170 --> 11:05:54,380
state variables. And in this
state variables section, this is

11050
11:05:54,380 --> 11:05:57,410
where we're actually going to
change the name of some of our

11051
11:05:57,410 --> 11:06:00,170
state variables. So we'll do a
little common here state

11052
11:06:00,170 --> 11:06:04,370
variables. Now in the solidity
style guide, kind of adhere to

11053
11:06:04,400 --> 11:06:08,780
the naming styles, we use upper
and lowercase, we use total caps

11054
11:06:08,810 --> 11:06:12,080
with underscores here. However,
these naming variables are going

11055
11:06:12,080 --> 11:06:14,750
to change in the future in this
section. And if you're following

11056
11:06:14,750 --> 11:06:16,820
along with the GitHub repo
associated with this course,

11057
11:06:17,180 --> 11:06:19,340
these are going to be actually a
little bit different than what

11058
11:06:19,340 --> 11:06:22,400
you see. However, for now, we're
going to leave them as they are,

11059
11:06:22,400 --> 11:06:24,710
because the reason why we're
going to change them isn't going

11060
11:06:24,710 --> 11:06:27,980
to be quite clear yet. Don't
worry. So these names are going

11061
11:06:27,980 --> 11:06:31,310
to change soon, but not yet.
Alright, after state variables

11062
11:06:31,310 --> 11:06:34,940
comes events, and modifiers. We
don't have any events, but we do

11063
11:06:34,940 --> 11:06:39,560
have a modifier. So we'll copy
this. And actually, we'll delete

11064
11:06:39,560 --> 11:06:46,850
this comment here. And we'll
paste our modifier here. Oh, and

11065
11:06:46,850 --> 11:06:50,120
it looks like looks like we're
not auto formatting here. So

11066
11:06:50,450 --> 11:06:52,820
we're going to uncomment
immutable actually, so that it

11067
11:06:52,880 --> 11:06:55,160
automatically auto formats.
Okay, great. We're out of

11068
11:06:55,160 --> 11:06:57,440
formatting now. And Cool.
Alright, so now we have our

11069
11:06:57,440 --> 11:07:01,100
modifiers. Next, we have right
here, and then we have all of

11070
11:07:01,100 --> 11:07:05,030
our functions. Great. We
actually want to group our

11071
11:07:05,030 --> 11:07:08,390
functions in this order that I
just print here. So we want the

11072
11:07:08,390 --> 11:07:11,720
constructor which we have
received and fall back, we do

11073
11:07:11,720 --> 11:07:14,570
have fall back and receive. So
we're going to actually copy

11074
11:07:14,570 --> 11:07:20,690
those and delete this comment.
We're gonna stick those veterans

11075
11:07:20,690 --> 11:07:24,110
Heath here looks like receive
goes first. So we'll put that

11076
11:07:24,110 --> 11:07:28,460
here. Then external functions,
then public, internal, private.

11077
11:07:29,180 --> 11:07:32,480
So we have public public. And
that's it. And then we can

11078
11:07:32,480 --> 11:07:36,680
delete this part down here.
Okay. Cool. And if we want, we

11079
11:07:36,680 --> 11:07:39,920
can do that syntax up here from
the net spec for our functions.

11080
11:07:40,490 --> 11:07:44,060
For example, for fund it, we
could even just copy paste, we

11081
11:07:44,060 --> 11:07:48,710
would remove title, we would
remove author, and we just say

11082
11:07:48,710 --> 11:07:55,640
add, notice, this function,
funds this contract. And we can

11083
11:07:55,640 --> 11:07:58,850
even leave a little dev thing
here to talk about it. Now if we

11084
11:07:58,850 --> 11:08:02,660
have parameters, you can do apt
puram. And say like what the

11085
11:08:02,660 --> 11:08:06,470
parameter is. And then if we
have returns, we can say

11086
11:08:06,470 --> 11:08:10,400
returns, or returns and then
what it returns for the

11087
11:08:10,400 --> 11:08:13,400
documentation. Since this
doesn't have any parameters in

11088
11:08:13,400 --> 11:08:15,980
here, and doesn't return
anything, we can just leave it

11089
11:08:15,980 --> 11:08:18,680
like this. And great, we've just
revamped our contract here to

11090
11:08:18,680 --> 11:08:21,560
make it a little bit more nicely
formatted. Great job. Now, like

11091
11:08:21,560 --> 11:08:24,710
I said, we actually are going to
change the names of our state

11092
11:08:24,710 --> 11:08:26,900
variables, and we're going to
add some functions in here and a

11093
11:08:26,900 --> 11:08:29,300
little bit. So if we're
following with the GitHub repo,

11094
11:08:29,330 --> 11:08:31,940
the state of the contract right
now is going to look a little

11095
11:08:31,940 --> 11:08:34,670
bit different. But it'll make
sense why change this up in a

11096
11:08:34,670 --> 11:08:35,120
little bit.

11097
11:08:37,910 --> 11:08:40,190
Alright, so now that we've
cleaned this up, we've got to

11098
11:08:40,190 --> 11:08:43,730
deploy marks, deploy Funmi.
Let's go ahead and start writing

11099
11:08:43,730 --> 11:08:46,640
some tests. And after we write
these tests, we're actually

11100
11:08:46,640 --> 11:08:50,000
going to run that gas estimator
and using that gas estimator,

11101
11:08:50,210 --> 11:08:52,370
we're gonna go back, and we're
going to update this contract

11102
11:08:52,370 --> 11:08:56,300
one more time to make this even
cheaper to use and work with.

11103
11:08:56,540 --> 11:08:58,850
And remember, that's going to be
one of the advantages of writing

11104
11:08:58,850 --> 11:09:01,700
these tests is how we can
optimize our contracts to be

11105
11:09:01,700 --> 11:09:05,780
even faster, more gas efficient,
etc, we want to make sure that

11106
11:09:05,780 --> 11:09:08,540
we write really good tests, and
this is going to be one of our

11107
11:09:08,540 --> 11:09:13,070
first jumps into these more
professional test setups. So

11108
11:09:13,100 --> 11:09:14,930
we're going to jump into our
test folder, we're going to

11109
11:09:14,930 --> 11:09:19,490
delete this sample test.js. In
our last section, we went over a

11110
11:09:19,490 --> 11:09:22,880
really minimalistic test, which
is great. However, when we get

11111
11:09:22,880 --> 11:09:24,950
bigger and bigger projects,
we're going to want to start

11112
11:09:24,950 --> 11:09:28,190
testing more and more different
things, we're going to get more

11113
11:09:28,190 --> 11:09:31,100
and more into at least two
different types of testing. So

11114
11:09:31,100 --> 11:09:33,800
if we cd into our test folder,
we're going to make one

11115
11:09:33,800 --> 11:09:37,310
directory called staging. And
then we're going to make another

11116
11:09:37,310 --> 11:09:41,090
directory called unit. And now
if we look in our test folder,

11117
11:09:41,150 --> 11:09:44,450
we now have a staging folder,
and a unit test folder. Now

11118
11:09:44,480 --> 11:09:47,330
we're going to talk about two
different types of tests. The

11119
11:09:47,330 --> 11:09:49,820
first one is going to be
something called a unit test.

11120
11:09:49,850 --> 11:09:53,090
Now what is a unit test? Unit
testing is a software testing

11121
11:09:53,090 --> 11:09:56,690
method by which individual units
of source code are tested.

11122
11:09:56,780 --> 11:10:00,320
Basically, what we want to do is
in our contracts, we want to

11123
11:10:00,320 --> 11:10:03,680
test minimal portions of our
code to make sure that they work

11124
11:10:03,710 --> 11:10:07,430
correctly. Then once our small
pieces of the test work, we want

11125
11:10:07,430 --> 11:10:11,360
to do a staging test or maybe an
integration test. This might be

11126
11:10:11,360 --> 11:10:15,020
where we run our code on a test
net or some actual network. You

11127
11:10:15,020 --> 11:10:17,630
can think of a staging test,
it's kind of the last stop

11128
11:10:17,660 --> 11:10:21,380
before you deploy to a main net.
They're not always 100%

11129
11:10:21,380 --> 11:10:24,080
necessary, but they can be
really, really helpful.

11130
11:10:24,110 --> 11:10:28,130
Remember, we do want to be
conscientious of how much we use

11131
11:10:28,160 --> 11:10:32,060
our test nets, but we absolutely
would 100% want to make sure

11132
11:10:32,060 --> 11:10:35,480
that everything works locally
and that we unit test and we run

11133
11:10:35,510 --> 11:10:39,500
all of our code locally. Then we
can use staging tests on an

11134
11:10:39,500 --> 11:10:43,400
actual test net to make sure
that our code will work with

11135
11:10:43,400 --> 11:10:48,740
actual other contracts. Now unit
tests can be done with local

11136
11:10:48,770 --> 11:10:52,070
Hard Hat Network or a forked
Hard Hat Network, we'll talk

11137
11:10:52,070 --> 11:10:55,820
about this for tar Hat Network
very soon, right, now, let's

11138
11:10:55,850 --> 11:10:58,340
build these unit tests, these
unit tests are going to be

11139
11:10:58,340 --> 11:11:02,090
basically what we saw in our
last section. So let's go in and

11140
11:11:02,090 --> 11:11:04,670
let's jump in and write some of
these unit tests. So let's

11141
11:11:04,670 --> 11:11:10,370
create a new test, we'll call it
on me dot test dot j, s. And

11142
11:11:10,370 --> 11:11:13,160
we'll start making our tests in
here. Now, we did test

11143
11:11:13,160 --> 11:11:15,920
previously in our last section,
but our tests here are going to

11144
11:11:15,920 --> 11:11:18,470
look a little bit differently,
we're actually going to use

11145
11:11:18,470 --> 11:11:22,130
hardhat deploy, to automatically
set up our tests as if both of

11146
11:11:22,130 --> 11:11:24,860
these deployed functions had
been run. So let's go ahead and

11147
11:11:24,860 --> 11:11:27,440
get this started. So we're still
going to do that same setup that

11148
11:11:27,440 --> 11:11:32,600
we're gonna do describe, we're
gonna say fund me. And this is

11149
11:11:32,600 --> 11:11:41,540
going to have that async
function like so. And in here,

11150
11:11:41,570 --> 11:11:46,670
we're going to have a before
each, and we're going to have

11151
11:11:46,670 --> 11:11:49,730
some hits and some describes and
everything. Now since we want to

11152
11:11:49,730 --> 11:11:52,280
unit test this, we're gonna go a
little bit heavier on the test

11153
11:11:52,280 --> 11:11:54,470
here, and then with our last
project, but in the future,

11154
11:11:54,470 --> 11:11:57,140
we'll go a little bit lighter
with some of the tests. So let's

11155
11:11:57,140 --> 11:12:02,750
get started. If we run yarn
Hardhead test right now, we're

11156
11:12:02,750 --> 11:12:06,770
gonna get zero passing. Now, if
we run yarn hardhat coverage,

11157
11:12:08,690 --> 11:12:11,180
we're gonna get something that
looks like this, saying, Hey,

11158
11:12:11,510 --> 11:12:15,440
you're missing a lot of stuff.
So let's try to cover some more

11159
11:12:15,440 --> 11:12:18,680
lines with our tests. And one
way we can do that is actually

11160
11:12:18,680 --> 11:12:22,760
we can group our tests based off
of different functions. So let's

11161
11:12:22,760 --> 11:12:26,150
have our first set of tests be
around our constructor. To do

11162
11:12:26,150 --> 11:12:29,300
that inside of our first
describe, we can add another

11163
11:12:29,300 --> 11:12:34,250
describe, have this describe the
just the constructor, this

11164
11:12:34,280 --> 11:12:37,610
larger scope will be for the
entire Funmi contract. And

11165
11:12:37,610 --> 11:12:41,690
everything inside this one will
just be for the constructor. So

11166
11:12:41,690 --> 11:12:45,530
this will also be an async
function. And these tasks will

11167
11:12:45,530 --> 11:12:48,560
be just for the constructor. But
before we even work on this

11168
11:12:48,560 --> 11:12:51,380
describe, we probably want to
deploy our Funmi contract. So

11169
11:12:51,380 --> 11:12:54,440
let's learn how to do that. So
we'll do a before each, which

11170
11:12:54,440 --> 11:13:00,950
will be an async function. And
we're going to deploy our Funmi

11171
11:13:00,950 --> 11:13:06,350
contract using hard hat deploy.
Since we use hard hat deploy,

11172
11:13:06,380 --> 11:13:09,350
our Funmi contract will come
even with our mocks and

11173
11:13:09,350 --> 11:13:11,540
everything. So above the before
each,

11174
11:13:11,570 --> 11:13:18,500
let's do let me HDMI. And then
here, we're going to deploy

11175
11:13:18,500 --> 11:13:21,380
Funmi, where we're going to
deploy our Funmi contract is

11176
11:13:21,380 --> 11:13:24,140
first by pulling in our
deployments object from Harnett

11177
11:13:24,140 --> 11:13:28,880
deploy. So we'll do const
deployments equals require

11178
11:13:29,930 --> 11:13:33,950
hardhat. And this deployments
object has, has a function

11179
11:13:33,950 --> 11:13:38,300
called fixture with fixture does
is it allows us to basically run

11180
11:13:38,300 --> 11:13:41,960
our entire deploy folder with as
many tags as we want. You'll

11181
11:13:41,960 --> 11:13:46,190
notice I added this alt tag in
both of our scripts. This means

11182
11:13:46,190 --> 11:13:49,940
that in this deployment stuff
fixtures, it's gonna be a wait

11183
11:13:49,970 --> 11:13:53,630
deployment of fixtures. If I run
away deployments dot fixture,

11184
11:13:53,720 --> 11:13:56,840
I'll run through our deploy
scripts on our local network and

11185
11:13:56,840 --> 11:14:00,200
deploy all of the contracts that
we can use them in our scripts

11186
11:14:00,230 --> 11:14:03,170
and in our testing, and we can
deploy everything in that deploy

11187
11:14:03,170 --> 11:14:07,040
folder with just this one line.
isn't that helpful. Now, once

11188
11:14:07,040 --> 11:14:09,590
all of our contracts have been
deployed, we can start getting

11189
11:14:09,590 --> 11:14:15,890
them will say fund me equals
await ethers, and we'll pull an

11190
11:14:15,890 --> 11:14:20,450
ether some hard hat as well. dot
and this is where hard hat

11191
11:14:20,450 --> 11:14:25,010
deploy is helpful. Again, hard
to deploy rapt ether is with a

11192
11:14:25,010 --> 11:14:29,180
function called Get contract,
this get contract function is

11193
11:14:29,180 --> 11:14:32,510
going to get the most recent
deployment of whatever contract

11194
11:14:32,510 --> 11:14:36,380
we tell it. So we'll say get
contract of fun to me. So this

11195
11:14:36,380 --> 11:14:40,820
will give us the most recent Lee
deployed Funmi contract in just

11196
11:14:40,850 --> 11:14:45,200
this one line. And now Funmi
will be equal to this line here.

11197
11:14:45,410 --> 11:14:48,350
Now we're going to make a bunch
of transactions on our Funmi. To

11198
11:14:48,350 --> 11:14:52,280
test it. Of course, we can also
tell ethers which account we

11199
11:14:52,280 --> 11:14:57,080
want connected to fund me. So I
can say const deployer equals

11200
11:14:57,620 --> 11:15:03,050
goes away get named accounts,
exactly like we did in our

11201
11:15:03,050 --> 11:15:06,770
deploy scripts. And then we just
need to import it from our tap

11202
11:15:06,920 --> 11:15:10,130
in our deploy scripts we
imported get named accounts

11203
11:15:10,220 --> 11:15:13,970
inside of our input parameters
for our deploy function.

11204
11:15:14,390 --> 11:15:17,240
Remember getting named accounts
and deployments was abstracted

11205
11:15:17,240 --> 11:15:20,390
from if we look up here, from
the hard hat runtime

11206
11:15:20,390 --> 11:15:23,030
environment, and like I said,
the hard hat runtime environment

11207
11:15:23,030 --> 11:15:25,580
is basically the same thing as
hard hat. So we can just go

11208
11:15:25,580 --> 11:15:29,180
ahead and import it like this,
actually like this. Because we

11209
11:15:29,180 --> 11:15:32,210
actually need to abstract just
the deployer from getting named

11210
11:15:32,210 --> 11:15:36,290
accounts. And now what we can do
is we can connect our Deployer

11211
11:15:36,350 --> 11:15:39,830
to our Fund Me account. So
whenever we call a function with

11212
11:15:39,830 --> 11:15:43,340
fund me, it'll automatically be
from that the player account,

11213
11:15:43,670 --> 11:15:46,070
which is great. Another way you
can get different accounts

11214
11:15:46,100 --> 11:15:49,250
directly from your heart had
config. Is you could take const

11215
11:15:49,280 --> 11:15:55,400
accounts equals await ethers dot
get signers, ethers dot get

11216
11:15:55,400 --> 11:15:58,640
signers is going to return
whatever is in this account

11217
11:15:58,640 --> 11:16:01,790
section of your network. If
you're on your default network

11218
11:16:01,790 --> 11:16:04,280
hard hat, it's going to give you
a list of 10 fake accounts that

11219
11:16:04,280 --> 11:16:06,470
we can work with you then of
course, can do something like

11220
11:16:06,470 --> 11:16:12,860
const. Account one equals
accounts. More correctly would

11221
11:16:12,860 --> 11:16:16,100
be account zero equals account
zero and work like that. We'll

11222
11:16:16,100 --> 11:16:17,960
leave that comment that out,
just in case you need a

11223
11:16:17,960 --> 11:16:20,390
reference to it in the future.
Okay, great. So now we have our

11224
11:16:20,390 --> 11:16:23,960
Funmi contract. Let's go ahead
and write some tests for testing

11225
11:16:23,960 --> 11:16:25,940
the constructor. And we're
probably going to want to use

11226
11:16:25,940 --> 11:16:30,320
this deployer object down here.
So we'll do let deployer above.

11227
11:16:30,410 --> 11:16:33,920
And we'll do something a little
finicky here. But we'll say

11228
11:16:33,920 --> 11:16:39,710
deployer equals Wait, get named
accounts, dot Deployer. And

11229
11:16:39,710 --> 11:16:42,170
we'll just wrap this up so that
we can just grab this deployer

11230
11:16:42,170 --> 11:16:45,410
object and assign it to declare
like so. Now in here, we'll

11231
11:16:45,410 --> 11:16:50,420
create our first test, we'll say
it will say it sets the Agra

11232
11:16:50,450 --> 11:16:56,480
Gator addresses correctly. Comma
will have this be an async

11233
11:16:56,480 --> 11:17:03,050
function. And we'll say const
response equals await fund me

11234
11:17:03,200 --> 11:17:07,850
dot, let's get this price feed
here, fund me dot price feed.

11235
11:17:08,240 --> 11:17:10,880
And then we'll want to make sure
this price feed is going to be

11236
11:17:10,880 --> 11:17:14,330
the same as our Mk V three
aggregator since we're going to

11237
11:17:14,330 --> 11:17:18,200
be running these tests locally.
So we should get our mark three

11238
11:17:18,230 --> 11:17:23,960
V three aggregator up top. Let's
do let mock v3 aggregate store.

11239
11:17:25,040 --> 11:17:27,950
And we'll grab this address the
same way mockbee Three

11240
11:17:27,950 --> 11:17:34,010
aggregator equals await ethers
dot get contract mockbee Three

11241
11:17:34,010 --> 11:17:37,460
aggregator comma, we'll connect
this one to the deployer as

11242
11:17:37,460 --> 11:17:43,880
well. So we'll want to say cert
dot equals cert dot equal

11243
11:17:44,660 --> 11:17:50,000
response comma lock v3
aggregator dot address. And of

11244
11:17:50,000 --> 11:17:58,040
course we'll want to say const.
Assert equals require gy. Import

11245
11:17:58,040 --> 11:18:00,170
that from DJI. Okay, cool.

11246
11:18:00,500 --> 11:18:05,630
Now, let's go ahead and try this
out. Yarn hardhat. Test. Oops, I

11247
11:18:05,630 --> 11:18:10,850
spelled response wrong. Let's
try that again. Awesome. So this

11248
11:18:10,850 --> 11:18:14,960
means that we are indeed
assigning the price feed address

11249
11:18:14,990 --> 11:18:18,230
correctly to the Mach v3
aggregator. Okay, great.

11250
11:18:18,440 --> 11:18:21,080
Awesome. I think for now, that's
all we really want to do for our

11251
11:18:21,080 --> 11:18:24,200
constructor. Now these two are
kind of a nice to have, I showed

11252
11:18:24,200 --> 11:18:26,870
them more just to kind of demo
what they look like, we're going

11253
11:18:26,870 --> 11:18:29,420
to skip writing tests for them
for now. And we're actually

11254
11:18:29,420 --> 11:18:31,760
going to go ahead and delete
them directly from the contract.

11255
11:18:32,090 --> 11:18:34,190
If you want to go ahead and
write some tests for them and

11256
11:18:34,190 --> 11:18:36,920
leave them in your examples for
your learnings. You absolutely

11257
11:18:36,920 --> 11:18:39,440
can pause the video and write
some tests for it if you choose

11258
11:18:39,440 --> 11:18:42,470
so, but we're going to skip
them. Next though, we are going

11259
11:18:42,470 --> 11:18:46,250
to move on to fund and running
some tests for fun here. So

11260
11:18:46,250 --> 11:18:49,730
let's go ahead and write
describe fund. This will be an

11261
11:18:49,730 --> 11:18:55,730
async function. And in here,
we're going to do a number of

11262
11:18:55,730 --> 11:18:58,760
tests. So if we're going to go
line by line here, what's the

11263
11:18:58,760 --> 11:19:01,370
first thing that we should look
at? Well, we should look at this

11264
11:19:01,370 --> 11:19:04,790
require line we should write a
test to see if this contract

11265
11:19:04,790 --> 11:19:09,170
actually does fail? If not
enough, eath is sent. So let's

11266
11:19:09,170 --> 11:19:15,680
go ahead and we'll say it fails,
if you don't send enough eath

11267
11:19:17,030 --> 11:19:23,210
have this be an async function?
Now, how do we test to see if

11268
11:19:23,210 --> 11:19:26,810
something fails? Right now we've
done assert equals, but if

11269
11:19:26,810 --> 11:19:30,500
something fails, we might run
into an issue. So for example,

11270
11:19:30,530 --> 11:19:36,290
if I run await fund me dot fund,
but I don't pass any value to

11271
11:19:36,290 --> 11:19:39,410
this transaction. Let's see what
happens. I run yarn Hardhead

11272
11:19:39,410 --> 11:19:44,720
test. Well, our test is actually
going to break VM exception.

11273
11:19:44,930 --> 11:19:48,980
While processing transaction
reverted with reason string, you

11274
11:19:48,980 --> 11:19:51,950
need to spend more eath. So our
tests are going to break which

11275
11:19:51,950 --> 11:19:56,330
is good. We want this to break.
But we want to tell our test

11276
11:19:56,330 --> 11:20:00,710
that this is okay. Right? Want
to tell that this is okay. So

11277
11:20:00,860 --> 11:20:04,220
the way we can do this, and this
is where our waffle testing

11278
11:20:04,220 --> 11:20:07,580
comes into play. With waffle and
with testing, what we can

11279
11:20:07,580 --> 11:20:11,390
actually do is we can use the
expect keyword and expect

11280
11:20:11,510 --> 11:20:15,080
transactions to be reverted and
for transactions to fail. So

11281
11:20:15,080 --> 11:20:18,200
instead of using assert here,
we're actually going to run a

11282
11:20:18,200 --> 11:20:28,310
wait expect fund me dot fun 2.2
dot B, that reverted and we've

11283
11:20:28,310 --> 11:20:31,340
actually even be more specific
here by saying to be reverted

11284
11:20:31,430 --> 11:20:37,310
with and then the exact reverted
error, you need to spend more

11285
11:20:37,340 --> 11:20:42,950
eath. Now if we run our tests,
oops expect is not defined. So

11286
11:20:42,950 --> 11:20:47,570
we need to import that from
Chai. Which chai is being

11287
11:20:47,600 --> 11:20:52,790
overwritten by waffle, we see
that it does indeed Pass, which

11288
11:20:52,790 --> 11:20:57,860
is perfect. So now we have a way
to both assert things and expect

11289
11:20:57,860 --> 11:21:01,310
things to fail. Awesome, even
with the specific failure codes.

11290
11:21:01,580 --> 11:21:04,670
Perfect. Let's write some more
tests here. Well, we probably

11291
11:21:04,670 --> 11:21:09,170
want it to correctly update this
data structure. So we could say,

11292
11:21:09,680 --> 11:21:16,640
it updates the amount funded
data structure, it's going to be

11293
11:21:16,640 --> 11:21:20,630
an async function. In here,
we're going to need to call fund

11294
11:21:20,630 --> 11:21:25,070
v dot fund. However, we're going
to need to actually pass some

11295
11:21:25,070 --> 11:21:29,180
value with this transaction. And
for now, we'll just hard code

11296
11:21:29,180 --> 11:21:34,280
the value that we're going to
send, say const. Send value is

11297
11:21:34,280 --> 11:21:40,070
going to be
112345 678-910-1234 5678, which

11298
11:21:40,070 --> 11:21:43,640
is going to be one eath. Another
way we can write this though, is

11299
11:21:43,640 --> 11:21:46,790
we can use the ethers utility to
make this a little bit easier to

11300
11:21:46,790 --> 11:21:49,610
read. Because all those zeros
are kind of confusing, and it's

11301
11:21:49,610 --> 11:21:52,460
hard to tell at first glance
what this actually is. So we're

11302
11:21:52,460 --> 11:22:00,980
gonna actually use ethers dot
utils dot parse ether, one, this

11303
11:22:01,010 --> 11:22:05,570
parse ethers utility converts
this one into that one with 18

11304
11:22:05,570 --> 11:22:08,870
zeros, which makes life a lot
easier. If you go to the ethers

11305
11:22:08,870 --> 11:22:11,930
documentation, there's also a
parts units function where you

11306
11:22:11,930 --> 11:22:16,250
can actually convert any unit,
either ethers or Gwei. Or really

11307
11:22:16,250 --> 11:22:19,370
whatever you want to do, you
could convert any number to any

11308
11:22:19,370 --> 11:22:22,130
other Aetherium you type. So
this is the set value that we're

11309
11:22:22,130 --> 11:22:25,760
going to use for our fund. And,
and this is definitely going to

11310
11:22:25,760 --> 11:22:30,830
be more than our minimum USD of
50. So after we call this fun

11311
11:22:30,830 --> 11:22:34,790
function, we'll say const
response is going to be equal to

11312
11:22:34,850 --> 11:22:41,720
a weight, fund me dot address to
Mt funded address to Mt funded

11313
11:22:41,990 --> 11:22:45,440
for the deployer dot address.
Because remember, this is a

11314
11:22:45,440 --> 11:22:49,310
mapping of each address and how
much they've actually funded. So

11315
11:22:49,310 --> 11:22:51,980
if we use the deployer address,
it should give us the amount

11316
11:22:52,010 --> 11:22:55,130
that we actually sent. So now we
can run assert dot equal

11317
11:22:57,020 --> 11:23:00,950
response.to string, right,
because this response is going

11318
11:23:00,950 --> 11:23:04,880
to be the big number version of
how much has been funded by that

11319
11:23:04,880 --> 11:23:08,570
account. And that should be the
same as our send value.to

11320
11:23:08,570 --> 11:23:14,090
string. Since send value, our
one should be the exact same as

11321
11:23:14,090 --> 11:23:17,690
the amount that we funded, we
can run just this one test, or

11322
11:23:17,690 --> 11:23:23,090
running yarn, art hat, test,
dash dash grep. And we'll put

11323
11:23:23,090 --> 11:23:28,970
this in quotes allow funded for
this amount funded line. And it

11324
11:23:28,970 --> 11:23:32,630
looks like we ran into an issue
here, because we don't need to

11325
11:23:32,630 --> 11:23:36,860
do deployed at address, we can
just do deploy here. And great,

11326
11:23:36,890 --> 11:23:40,370
it looks like we are indeed
passing. Now if we even run yarn

11327
11:23:40,370 --> 11:23:44,390
Hardhead coverage will now see
we've got at least a little bit

11328
11:23:44,390 --> 11:23:47,570
more coverage here. It's still
not going to be great. But we

11329
11:23:47,570 --> 11:23:50,270
have much better coverage. We
have some statements, some

11330
11:23:50,270 --> 11:23:53,450
branches, and at least some
functions covered. So this is

11331
11:23:53,450 --> 11:23:56,990
awesome. Let's keep going. Are
we all done testing our fun

11332
11:23:56,990 --> 11:24:00,260
function? Well, probably not.
What else can we do with our fun

11333
11:24:00,260 --> 11:24:03,230
function? Well, we're also
adding funders to a funders

11334
11:24:03,230 --> 11:24:09,650
array. So let's go ahead and
test for that. So it adds funder

11335
11:24:09,680 --> 11:24:17,540
to array of funders has been an
async function. And we'll say

11336
11:24:17,570 --> 11:24:23,210
await fund mean that fund value
is going to be send value. We'll

11337
11:24:23,210 --> 11:24:30,650
say const response equals await
fund me dot calling the funders

11338
11:24:30,680 --> 11:24:38,030
array at index zero. So this
will be funder equals await fund

11339
11:24:38,030 --> 11:24:41,930
me dot funders zero. And then
we'll say assert dot equal

11340
11:24:42,680 --> 11:24:46,880
funder should be the same as the
Deployer. So let's go ahead and

11341
11:24:46,880 --> 11:24:49,850
run this test. We'll hit up a
couple times. And we'll change

11342
11:24:49,850 --> 11:24:56,990
the GREP to under to array so
that it looks for this line. And

11343
11:24:56,990 --> 11:25:00,590
perfect. It looks like that one
is also passing. Great. So the

11344
11:25:00,590 --> 11:25:03,890
money's coming through, the
minimum amount is coming through

11345
11:25:03,920 --> 11:25:07,400
and our data structures are
being updated. Awesome. Now we

11346
11:25:07,400 --> 11:25:10,340
could be a little bit more
verbose and do even more testing

11347
11:25:10,340 --> 11:25:12,980
with this fun function. But I
think for the most part, we've

11348
11:25:12,980 --> 11:25:16,280
got the gist, right. So now
let's go ahead and move on to

11349
11:25:16,310 --> 11:25:18,800
the withdrawal function. So
we're going to create a new

11350
11:25:18,800 --> 11:25:24,590
describe or withdraw. This is
going to be an async function.

11351
11:25:26,150 --> 11:25:29,480
And let's see what the
withdrawal function does. Only

11352
11:25:29,480 --> 11:25:32,120
the owner of the contract is
going to be able to get the

11353
11:25:32,120 --> 11:25:36,170
balance, get the money back. And
we're also going to reset all of

11354
11:25:36,170 --> 11:25:39,710
the amounts that each one of
these users is done. So let's go

11355
11:25:39,710 --> 11:25:42,980
ahead and do some withdrawing.
Now in order for us to test

11356
11:25:42,980 --> 11:25:47,630
withdraw, we probably first want
the contract to actually have

11357
11:25:47,630 --> 11:25:51,230
some money and so what we can do
actually is we can add another

11358
11:25:51,230 --> 11:25:55,250
before each in the describe to
automatically fund the contract

11359
11:25:55,460 --> 11:26:01,430
before we run any tests. So we
can say before each async

11360
11:26:01,430 --> 11:26:10,160
function. We can say await, fund
me dot fund. Value, send value.

11361
11:26:10,820 --> 11:26:14,660
Now for all of our tests in this
withdrawal scope, we're first

11362
11:26:14,660 --> 11:26:18,500
going to fund it with eath.
Let's say it can withdraw,

11363
11:26:19,940 --> 11:26:26,300
withdraw eath. From a single
founder, this would be an async

11364
11:26:26,300 --> 11:26:32,720
function. And this is going to
be a little bit longer test. So

11365
11:26:32,750 --> 11:26:39,050
I'm going to set it up to be an
arrange, act and assert test. So

11366
11:26:39,050 --> 11:26:42,290
arrange act assert is just sort
of a way to think about writing

11367
11:26:42,290 --> 11:26:45,500
tests, you want to arrange the
test, then you want to act. And

11368
11:26:45,500 --> 11:26:47,720
then you want to run the
asserts, and you'll see what I

11369
11:26:47,720 --> 11:26:50,630
mean in just a second. So we're
going to arrange this test,

11370
11:26:50,630 --> 11:26:53,360
we're going to set this test up,
we want to actually check that

11371
11:26:53,360 --> 11:26:56,930
we're correctly withdrawing the
ether from a single founder. So

11372
11:26:56,930 --> 11:26:59,360
first, we're going to get the
starting balance of the

11373
11:26:59,360 --> 11:27:01,550
fundraising contract and the
starting balance of the

11374
11:27:01,550 --> 11:27:08,090
Deployer. So we'll say const.
Starting under me, balance,

11375
11:27:09,200 --> 11:27:16,340
equals await, fund me dot
provider, dot get balance, fund

11376
11:27:16,340 --> 11:27:20,720
me dot address. So we're gonna
start with the balance of the

11377
11:27:20,720 --> 11:27:24,470
fund V contract after it's been
funded with some eath. And we're

11378
11:27:24,470 --> 11:27:29,840
also gonna get costs start
starting, deploy your balance

11379
11:27:30,560 --> 11:27:37,790
goes await, fund me dot
provider, dot get balance of

11380
11:27:38,360 --> 11:27:38,930
deployed employer.

11381
11:27:39,770 --> 11:27:42,410
So we're getting the starting
balance of the Funmi, we're

11382
11:27:42,410 --> 11:27:44,930
getting to the starting balance
of the employer so that we can

11383
11:27:44,960 --> 11:27:48,320
test later on how much these
numbers have changed based off

11384
11:27:48,320 --> 11:27:50,750
of what happens when we call the
withdrawal function. Now that

11385
11:27:50,750 --> 11:27:53,690
we've done a little bit of
setup, we can actually run this

11386
11:27:53,690 --> 11:27:56,750
withdrawal function, we can do
the act here. So we're gonna say

11387
11:27:56,750 --> 11:28:02,570
const, trans action response
equals await, fund me dot

11388
11:28:02,570 --> 11:28:10,970
withdraw. And then we can say
const, transaction receipt

11389
11:28:11,630 --> 11:28:19,520
equals await transaction
response. That Wait, one, and

11390
11:28:19,520 --> 11:28:22,400
now we should be able to check
to see that the entire fund

11391
11:28:22,400 --> 11:28:26,360
rebalance has been added to the
deployer balance. So now we can

11392
11:28:26,360 --> 11:28:33,560
say const ending fund me balance
equals a weight on me that

11393
11:28:33,560 --> 11:28:41,150
provider dot get balance of
Unreal dot address. Then we can

11394
11:28:41,150 --> 11:28:49,460
say const ending deployer
balance equals await, fund me

11395
11:28:49,610 --> 11:28:52,220
dot provider dot get balance

11396
11:28:54,080 --> 11:28:59,510
of Deployer. And now we can just
check to see if the numbers work

11397
11:28:59,510 --> 11:28:59,900
out here.

11398
11:29:00,200 --> 11:29:09,770
So we can say assert dot equal
ending fund me balance is going

11399
11:29:09,770 --> 11:29:13,070
to be zero, right, because we
just withdrew all of the money.

11400
11:29:13,070 --> 11:29:16,940
So ending funding balance should
be zero. And we'll say assert

11401
11:29:17,180 --> 11:29:25,880
dot equal starting fund me
balance plus starting deployer

11402
11:29:25,880 --> 11:29:30,140
balance. So the starting funds
the balance plus the starting

11403
11:29:30,170 --> 11:29:34,700
employer balance should equal
the ending employer balance.

11404
11:29:34,730 --> 11:29:37,730
Since we're grabbing whatever
the starting deployer balance

11405
11:29:37,730 --> 11:29:40,400
started with plus the starting
fund to be balanced, because we

11406
11:29:40,400 --> 11:29:43,040
just withdrew all of the
starting fund, we balance that

11407
11:29:43,040 --> 11:29:46,220
should equal the ending deployer
bots. Now a couple of notes

11408
11:29:46,220 --> 11:29:48,830
here, since starting Funmi
balance is calling from the

11409
11:29:48,830 --> 11:29:52,340
blockchain, it's going to be of
type a big number, we want to

11410
11:29:52,340 --> 11:29:56,090
use big number dot add actually,
instead of the plus sign here,

11411
11:29:56,120 --> 11:29:58,400
just because it'll it'll make
working with our big numbers a

11412
11:29:58,400 --> 11:30:02,030
little bit easier. So instead of
starting Funmi balance, plus

11413
11:30:02,060 --> 11:30:06,770
we're gonna be starting from the
balance dot add. Like that. And

11414
11:30:06,770 --> 11:30:09,080
that should be good. One other
thing about this, though, is

11415
11:30:09,080 --> 11:30:13,940
that when we called withdraw our
Deployer did what our Deployer

11416
11:30:13,970 --> 11:30:20,510
spent a little bit of gas. So
this actually isn't accurate. We

11417
11:30:20,510 --> 11:30:24,110
actually also need to calculate
in the gas cost, so we wouldn't

11418
11:30:24,110 --> 11:30:29,930
need to do dot add gas cost.
We'd also have to do.to string

11419
11:30:29,930 --> 11:30:34,340
because big numbers are objects
and so identities a little bit

11420
11:30:34,340 --> 11:30:37,460
weird. So to test to see if
they're equal, we'll just make

11421
11:30:37,460 --> 11:30:44,120
them both strings. Now we don't
have gas costs. So let's figure

11422
11:30:44,120 --> 11:30:48,170
out how to get the gas cost from
this transaction. So we can add

11423
11:30:48,170 --> 11:30:51,260
it to Are any deployer bounce,
so we can run this assertion

11424
11:30:51,260 --> 11:30:54,230
here. So what we can do is we
can actually find the gas costs

11425
11:30:54,260 --> 11:30:57,290
from our transaction receipt.
And I'm going to show you a

11426
11:30:57,290 --> 11:31:01,190
couple of phenomenal tricks you
can use with VS code. And if

11427
11:31:01,190 --> 11:31:04,220
using a different editor, then
don't worry too much about this.

11428
11:31:04,250 --> 11:31:07,220
What we can do in VS code
actually is create something

11429
11:31:07,220 --> 11:31:10,970
called breakpoints. unverified
breakpoint file is modified to

11430
11:31:11,000 --> 11:31:14,510
please restart the bug session,
or let's put it right here, put

11431
11:31:14,510 --> 11:31:17,600
it right in this line after
transaction receipt is created.

11432
11:31:17,720 --> 11:31:21,650
But before ending Funmi belts,
what this breakpoint does is it

11433
11:31:21,650 --> 11:31:25,850
stops the script at this line,
and allows us to drop into

11434
11:31:25,850 --> 11:31:30,320
something called a debug console
and see all the variables that

11435
11:31:30,320 --> 11:31:33,590
are happening. At this time, we
want to look at the transaction

11436
11:31:33,590 --> 11:31:37,820
receipt and see if the total gas
cost is in there. This is also

11437
11:31:37,820 --> 11:31:40,700
incredibly helpful for dropping
into tests and dropping into

11438
11:31:40,700 --> 11:31:44,030
scripts and seeing exactly
what's going on that's wrong. So

11439
11:31:44,030 --> 11:31:47,090
what we can do is we can move
down to this run into bug

11440
11:31:47,210 --> 11:31:50,090
section. And if it's not there,
you can hit additional views.

11441
11:31:50,330 --> 11:31:54,440
And we can click this JavaScript
Debug Terminal, which will

11442
11:31:54,440 --> 11:31:58,550
create a new terminal in our
terminal section. Now, what

11443
11:31:58,550 --> 11:32:03,440
happens here is if we run yarn,
hard hat test, it'll run our

11444
11:32:03,440 --> 11:32:06,380
testing and everything. But when
it hits this breakpoint, it'll

11445
11:32:06,380 --> 11:32:09,140
stop. Currently, there is no gas
cost. So we're just going to

11446
11:32:09,140 --> 11:32:11,570
delete this for now. So that we
compile and we work in

11447
11:32:11,570 --> 11:32:17,000
everything. But if we run yarn
Hardhead test, see, it's gonna

11448
11:32:17,000 --> 11:32:21,500
say debugger has been attached
to start running our tests. And

11449
11:32:21,500 --> 11:32:25,460
it's going to stop on this line
here. And if we look in this

11450
11:32:25,460 --> 11:32:29,270
variable section on the left
hand side, we can actually see a

11451
11:32:29,270 --> 11:32:34,340
ton of the variables that are in
here. And we can read a little

11452
11:32:34,340 --> 11:32:37,910
bit more about what's going on.
And if we go over to our debug

11453
11:32:37,910 --> 11:32:44,270
console, we can type in things
like transaction receipt, and we

11454
11:32:44,270 --> 11:32:47,510
can see a ton of information
about that transaction receipt

11455
11:32:47,510 --> 11:32:50,420
object, what we're looking for
is we're looking to see this

11456
11:32:50,420 --> 11:32:53,480
transaction receipt, which we
could look in the debug console

11457
11:32:53,510 --> 11:32:56,870
or over here, if there's
anything to do with gas in here.

11458
11:32:57,110 --> 11:33:01,460
And it looks like there is
there's a gas used big number.

11459
11:33:01,700 --> 11:33:05,630
And there's also an effective
gas price. So the amount of gas

11460
11:33:05,630 --> 11:33:09,620
used times the gas price is
going to give us all the money

11461
11:33:09,620 --> 11:33:13,100
that we paid for gas here. So
now that we've figured out

11462
11:33:13,100 --> 11:33:17,030
there's a gas used and effective
gas price variables in this

11463
11:33:17,030 --> 11:33:20,240
transaction receipt, which we
could have also found in the

11464
11:33:20,240 --> 11:33:23,510
documentation here. However,
sometimes it's even quicker just

11465
11:33:23,510 --> 11:33:27,320
to find it out yourself what we
can do, we can exit the debugger

11466
11:33:27,530 --> 11:33:32,570
by clicking this little thing
here. Go back to terminal will

11467
11:33:32,570 --> 11:33:35,450
trash can the JavaScript
debugger, we'll remove the

11468
11:33:35,450 --> 11:33:42,860
breakpoint. And we'll grab those
two variables we can pull them

11469
11:33:42,890 --> 11:33:46,880
right out of that transaction
receipt object by typing const.

11470
11:33:48,230 --> 11:33:55,460
Yes, used comma effective gas
price equals transaction

11471
11:33:55,460 --> 11:33:59,930
receipt. So again, with this
curly bracket syntax, we can use

11472
11:33:59,930 --> 11:34:03,560
this to pull out objects out of
another object. And now that we

11473
11:34:03,560 --> 11:34:08,090
have these two objects, we can
create a const gas cost or total

11474
11:34:08,090 --> 11:34:13,310
gas cost is going to be equal to
the gas used times the effective

11475
11:34:13,520 --> 11:34:17,930
gas price. Which again, since
these are both big numbers, we

11476
11:34:17,930 --> 11:34:23,540
can use a big number function
called dot mol to multiply them

11477
11:34:23,540 --> 11:34:27,770
together. Now that we have this
total gas cost, we can come down

11478
11:34:27,860 --> 11:34:32,210
and we can say the ending
deployer balance plus that gas

11479
11:34:32,210 --> 11:34:36,830
cost to string. Now the two of
these should be equivalent. I

11480
11:34:36,830 --> 11:34:39,140
know there's a lot of math that
we're doing in this section and

11481
11:34:39,140 --> 11:34:42,830
a lot of new things. So I want
to just quickly rego over what

11482
11:34:42,830 --> 11:34:46,670
we just learned. So first off,
the font of the contract comes

11483
11:34:46,670 --> 11:34:49,550
with a provider, we could have
also done ethers dot provider

11484
11:34:49,580 --> 11:34:52,940
dot get balance, but we're using
fun v dot provider because we're

11485
11:34:52,940 --> 11:34:55,370
using the provider of the Funmi
contract. It doesn't really

11486
11:34:55,370 --> 11:34:58,790
matter what we use here. We just
wanted to use this get balanced

11487
11:34:58,790 --> 11:35:02,510
function of the provider object
which gets us the balance of any

11488
11:35:02,510 --> 11:35:06,140
contract. We do the same thing
with starting deplore balance.

11489
11:35:06,140 --> 11:35:08,810
The reason that we needed the
starting balances is because we

11490
11:35:08,810 --> 11:35:11,330
wanted to compare it to the
ending balances to see if all

11491
11:35:11,330 --> 11:35:13,760
the money went to the right
places, we then call the

11492
11:35:13,760 --> 11:35:17,630
withdrawal function. And from
the transaction receipt, we

11493
11:35:17,630 --> 11:35:22,250
grabbed the gas used and the gas
price. If you want to debug your

11494
11:35:22,250 --> 11:35:26,510
JavaScript code, you can add a
breakpoint like so go to run

11495
11:35:26,510 --> 11:35:30,800
into bug, open your debug
JavaScript terminal, which is

11496
11:35:30,800 --> 11:35:34,970
different from your regular bash
terminals. And when you run

11497
11:35:35,000 --> 11:35:38,210
JavaScript commands in here,
they will stop where your

11498
11:35:38,210 --> 11:35:40,550
breakpoints are. Then you can
read the different variables and

11499
11:35:40,550 --> 11:35:43,460
see where different things are.
Using that knowledge. We pulled

11500
11:35:43,460 --> 11:35:46,430
out the gas use and effective
gas price from the transaction

11501
11:35:46,430 --> 11:35:49,400
receipt and used it to get the
total gas cost of this

11502
11:35:49,400 --> 11:35:52,220
transaction, we then got the
ending fund, we balanced the

11503
11:35:52,220 --> 11:35:55,970
ending deployer balance, and
used all those variables to make

11504
11:35:55,970 --> 11:35:59,840
sure all the money went to the
right places. And we, we can

11505
11:35:59,840 --> 11:36:04,220
check this by running yarn
Hardhead test dash dash grep

11506
11:36:05,450 --> 11:36:09,200
withdraw eath in quotes, since
there's a space here, and we can

11507
11:36:09,200 --> 11:36:14,030
see that our test does indeed
pass. Great job. If we didn't

11508
11:36:14,570 --> 11:36:19,910
add the gas cost here, and we
just did.to string, we would see

11509
11:36:19,910 --> 11:36:25,040
something like this, we would
see that the numbers are ever so

11510
11:36:25,040 --> 11:36:28,010
slightly off, because we're not
anticipating we're not

11511
11:36:28,010 --> 11:36:31,220
calculating the gas here. So we
always want to make sure we're

11512
11:36:31,220 --> 11:36:36,740
using the gas if we're doing
calculations like this. Now

11513
11:36:36,740 --> 11:36:39,350
another incredibly powerful
debugging tool that we're not

11514
11:36:39,350 --> 11:36:41,720
really going to go over here.
But it's important to know about

11515
11:36:41,720 --> 11:36:43,850
because it can be really helpful
is that you can actually use

11516
11:36:43,850 --> 11:36:48,050
console dot log in your solidity
with hard hat. If you're inside

11517
11:36:48,050 --> 11:36:51,350
of a heart hat project, you just
import hard hat slash console

11518
11:36:51,350 --> 11:36:56,090
dot soul. And then right in your
solidity, you can do console dot

11519
11:36:56,090 --> 11:36:59,480
log, and then type pretty much
whatever you want. When you

11520
11:36:59,480 --> 11:37:02,840
execute these functions, similar
to how we do a console dot log

11521
11:37:02,840 --> 11:37:05,750
in JavaScript, those will
actually console dot log out to

11522
11:37:05,750 --> 11:37:09,260
your terminal. Here's an example
of if you run yarn, hard hat

11523
11:37:09,260 --> 11:37:12,650
test and you have those console
dot logs, you'll see stuff like

11524
11:37:12,650 --> 11:37:16,370
this get printed out. So in
addition to the Visual Studio

11525
11:37:16,370 --> 11:37:19,760
Code debugger, importing hard
hat slash console dot Sol, and

11526
11:37:19,760 --> 11:37:23,000
using console dot logs in your
solidity can also be an

11527
11:37:23,000 --> 11:37:25,610
effective debugging strategy.
Feel free to give this video a

11528
11:37:25,610 --> 11:37:29,210
pause, implement this in some of
our contracts and try it out in

11529
11:37:29,210 --> 11:37:35,210
our tests. So we tested that
withdrawing eath when there's a

11530
11:37:35,210 --> 11:37:38,930
single funder works perfectly,
let's test withdrawing eath if

11531
11:37:38,930 --> 11:37:44,450
there are multiple funders, so
we'll do it, let's say allows us

11532
11:37:44,450 --> 11:37:51,680
to withdraw with multiple
funders. Why would this be an

11533
11:37:51,680 --> 11:37:59,150
async function. And let's do
this await Funmi not fun, but

11534
11:37:59,150 --> 11:38:02,390
with a number of different
accounts. So we can create a

11535
11:38:02,390 --> 11:38:04,970
whole bunch of different
accounts of course, by saying

11536
11:38:04,970 --> 11:38:12,560
const accounts equals await
ethers dot get signers. And we

11537
11:38:12,560 --> 11:38:15,140
can loop through these accounts
and have each one of these

11538
11:38:15,140 --> 11:38:18,710
accounts call the fund function.
And we're going to do this with

11539
11:38:18,740 --> 11:38:25,490
a for loop. So we're going to
say for let i equals we'll start

11540
11:38:25,490 --> 11:38:28,670
with the first index of the
accounts because the zero with

11541
11:38:28,700 --> 11:38:31,310
index is going to be the
Deployer. So we'll say let i

11542
11:38:31,310 --> 11:38:36,140
equals one is going to be less
than let's say six. And we'll do

11543
11:38:36,170 --> 11:38:43,310
i plus plus. And in here, we'll
say const. And me contract Funmi

11544
11:38:43,310 --> 11:38:51,050
connected contract equals await.
And me dot connect two accounts,

11545
11:38:51,440 --> 11:38:55,610
I, so we need to call this
connect function because right

11546
11:38:55,610 --> 11:38:59,930
now if we scroll up back to the
top, our Funmi contract is

11547
11:38:59,930 --> 11:39:03,800
connected to our Deployer
account. And anytime we call a

11548
11:39:03,800 --> 11:39:08,090
transaction with Funmi, the
deployer is the account that is

11549
11:39:08,120 --> 11:39:11,300
calling that transaction, we
need to create new objects to

11550
11:39:11,300 --> 11:39:13,940
connect to all of these
different accounts. So we're

11551
11:39:13,940 --> 11:39:16,910
gonna say fund me connected
contract, which is now connected

11552
11:39:16,910 --> 11:39:20,780
to one of these different
accounts dot fund. And this is

11553
11:39:20,780 --> 11:39:25,310
where we'll do value, send
value. Or excuse me, we'll do

11554
11:39:25,310 --> 11:39:29,720
await. Great. So this is going
to be our our range section. And

11555
11:39:29,720 --> 11:39:33,020
then same as we did above, we
need to grab those starting

11556
11:39:33,020 --> 11:39:36,680
balances. So we can just copy
that, those two lines and paste

11557
11:39:36,680 --> 11:39:39,650
that down here. Now we're going
to move into act, I'm going to

11558
11:39:39,650 --> 11:39:43,730
call that withdrawal function
again. So let's say const,

11559
11:39:43,910 --> 11:39:50,000
transaction action response
equals await and MI dot

11560
11:39:50,810 --> 11:39:54,350
withdraw. And we're going to do
the exact same thing as we did

11561
11:39:54,350 --> 11:39:58,730
above, getting the transaction
receipt and the gas costs so we

11562
11:39:58,730 --> 11:40:01,790
can get everything correct. Once
we've done the act, we move on

11563
11:40:01,790 --> 11:40:05,420
into assert. And we're going to
do some very similar things to

11564
11:40:05,420 --> 11:40:08,570
what we did above, like this,
for example, this whole first

11565
11:40:08,570 --> 11:40:12,830
part is going to be exactly the
same. We also want to make sure

11566
11:40:12,920 --> 11:40:18,950
the funders are reset properly.
So we'll make sure that this

11567
11:40:18,950 --> 11:40:22,670
funders array is reset properly.
So to do that, we can actually

11568
11:40:22,670 --> 11:40:25,160
just check to see that if
looking at the zero with

11569
11:40:25,160 --> 11:40:30,260
position throws an error so we
can run a wait expect fund me

11570
11:40:30,260 --> 11:40:36,170
dot get on me dot funder on me
dot funders of zero. This should

11571
11:40:36,170 --> 11:40:41,780
revert so we'll say await expect
Funmi dot funders dot two dot b

11572
11:40:41,780 --> 11:40:47,060
dot reverted and then we want to
loop through all these accounts

11573
11:40:47,090 --> 11:40:50,840
and make sure that it makes sure
or that in our mapping here, all

11574
11:40:50,870 --> 11:40:58,760
their amounts are zero. So we'll
say, for I equals one is less

11575
11:40:58,760 --> 11:40:59,720
than six,

11576
11:41:01,520 --> 11:41:11,450
i plus plus, we'll say assert
dot equal. Wait, fund me dot

11577
11:41:12,530 --> 11:41:21,980
address to amount funded, of the
accounts of I got address should

11578
11:41:21,980 --> 11:41:26,630
be zero. So we're making sure
that all of these mappings are

11579
11:41:26,630 --> 11:41:29,960
correctly updated to zero. So
let's go and test this. So we're

11580
11:41:29,960 --> 11:41:32,420
withdrawing with multiple
founders, we're going to go back

11581
11:41:32,420 --> 11:41:36,530
to our terminal, we're going to
hit up, we're going to change

11582
11:41:36,530 --> 11:41:42,020
this GREP or this one. We'll see
if this passes. And it does

11583
11:41:42,020 --> 11:41:45,530
indeed, so this means that our
withdraw function works really

11584
11:41:45,530 --> 11:41:49,250
well even when there's multiple
funders and we can be happy and

11585
11:41:49,250 --> 11:41:52,130
go to sleep knowing that. Now
the other thing we absolutely

11586
11:41:52,130 --> 11:41:55,880
want 100% want to test is that
our only owner modifier is

11587
11:41:55,880 --> 11:41:59,540
working, we want only the owner
to be able to withdraw the funds

11588
11:41:59,540 --> 11:42:04,580
from here. So we'll create a new
session, we'll say it only

11589
11:42:04,580 --> 11:42:10,220
allows the owner to withdraw
only allows you to withdraw.

11590
11:42:10,820 --> 11:42:15,740
This will be an async function.
And in here, we'll say const.

11591
11:42:17,420 --> 11:42:20,780
Accounts equals ethers dot get
signers again. And we'll say

11592
11:42:20,780 --> 11:42:27,680
const attacker equals accounts
of one. So we'll say the first

11593
11:42:27,680 --> 11:42:30,860
account will be some random
attacker will connect this

11594
11:42:30,860 --> 11:42:34,970
attacker to a new contract,
we'll say const attacker

11595
11:42:35,180 --> 11:42:44,360
connected contract equals await
on DB dot Connect. Attacker dot

11596
11:42:44,360 --> 11:42:49,190
address, excuse me a dot connect
attacker. Since we're not just

11597
11:42:49,190 --> 11:42:52,160
connecting the address, we're
connecting the account which

11598
11:42:52,220 --> 11:42:56,990
attacker is an account object.
And then we'll do a wait expect

11599
11:42:59,630 --> 11:43:10,670
attacker connected contract dot
withdraw dot two dot b dot

11600
11:43:11,210 --> 11:43:15,470
reverted, they should not be
able to withdraw. So let's go

11601
11:43:15,470 --> 11:43:19,010
ahead, we can even just copy
this whole thing if we want to

11602
11:43:19,190 --> 11:43:24,410
hit up, we'll delete this
section here. We'll paste that

11603
11:43:24,410 --> 11:43:29,510
in. And boom. This means that
when some other account tries to

11604
11:43:29,510 --> 11:43:32,360
call withdraw, automatically
gets reverted, which is what we

11605
11:43:32,360 --> 11:43:36,110
want. Now we can be more
explicit to make sure that the

11606
11:43:36,110 --> 11:43:39,410
correct error code is being
thrown, not just that it's

11607
11:43:39,440 --> 11:43:43,280
reverted. Right, it can be very
reverted because they sent ether

11608
11:43:43,280 --> 11:43:45,230
did it they did something weird,
we want to make sure it's

11609
11:43:45,230 --> 11:43:48,650
reverted with our specific error
code. So right now we have this

11610
11:43:48,680 --> 11:43:52,730
not owner error code. But it's
actually a best practice to put

11611
11:43:52,730 --> 11:43:57,620
the contract name to underscores
and then your custom error. This

11612
11:43:57,620 --> 11:44:00,110
makes it a lot easier in the
future when you have a ton of

11613
11:44:00,110 --> 11:44:02,960
different contracts, and you're
not sure where an error is

11614
11:44:02,960 --> 11:44:05,510
coming from. So we're going to
just update this really quickly

11615
11:44:05,510 --> 11:44:09,530
to be fund me underscore
underscore, not owner, now we

11616
11:44:09,530 --> 11:44:12,860
can do is now that we have this
custom error, we can say

11617
11:44:12,950 --> 11:44:17,690
withdraw that to be reverted
with, then we can add our custom

11618
11:44:17,690 --> 11:44:22,400
error in here. Now, if we rerun
our test, with only allows the

11619
11:44:22,400 --> 11:44:26,270
owner to withdraw, oops, we need
to do a wait here. My mistake,

11620
11:44:26,300 --> 11:44:29,870
wait a Thursday, get signers.
And now let's try this again.

11621
11:44:30,560 --> 11:44:32,900
And we are indeed passing
Perfect.

11622
11:44:35,690 --> 11:44:38,990
Okay, great. We have some basic
unit tests here. And we're going

11623
11:44:38,990 --> 11:44:41,780
to write some staging tests
pretty soon. But before we

11624
11:44:41,780 --> 11:44:46,490
actually do that, let's go ahead
and add the gas estimator. And

11625
11:44:46,490 --> 11:44:49,280
we'll see how much gas these
contracts in these functions are

11626
11:44:49,280 --> 11:44:52,160
taking. It looks like the
Hardhead gas reporter is already

11627
11:44:52,160 --> 11:44:57,620
here. So let's scroll down.
We'll do gas reporter true. And

11628
11:44:57,770 --> 11:45:01,250
we won't do coin market cap
here. And we'll just look purely

11629
11:45:01,250 --> 11:45:03,920
at the GUI. So you can just
comment it out like that. Now

11630
11:45:03,920 --> 11:45:09,710
rerun all of our tests. So we'll
say yarn, our test. And in doing

11631
11:45:09,710 --> 11:45:13,310
so we're gonna get that that gas
output in that gas report dash

11632
11:45:13,310 --> 11:45:17,210
text here. So looks like all of
our tests are passing, which is

11633
11:45:17,210 --> 11:45:21,830
perfect. Now we can look into
our gas report and see what's

11634
11:45:21,830 --> 11:45:25,220
going on here. i Well, it looks
like the fundraising function is

11635
11:45:25,220 --> 11:45:28,970
taking a decent chunk of gas,
the withdrawal function, take it

11636
11:45:28,970 --> 11:45:32,330
some guests to we'd see the min,
the max and the average. Of

11637
11:45:32,330 --> 11:45:35,300
course, we can see how much each
one of these contracts cost to

11638
11:45:35,300 --> 11:45:38,210
actually output. We don't really
care about the MOQ aggregator of

11639
11:45:38,210 --> 11:45:39,860
course, because we're never
actually going to use that.

11640
11:45:40,220 --> 11:45:42,800
Let's say we look at the average
gas for these and we go hmm,

11641
11:45:42,980 --> 11:45:45,980
this looks like it's actually a
lot more than what we originally

11642
11:45:45,980 --> 11:45:48,770
expected. Is there a way for us
to make this a little bit cheap.

11643
11:45:48,770 --> 11:45:51,740
If we go back to our funding
contract, we look at our

11644
11:45:51,740 --> 11:45:55,760
withdrawal function. And we
noticed something, oh, there is

11645
11:45:55,760 --> 11:45:58,940
actually a way to make this a
lot cheaper. And it has to do

11646
11:45:58,970 --> 11:46:02,600
with something called storage
variables, or these global

11647
11:46:02,600 --> 11:46:05,060
variables that we've been
working with this whole time.

11648
11:46:05,240 --> 11:46:07,790
Let me let me paint you a little
picture here, we're gonna look

11649
11:46:07,790 --> 11:46:10,610
at one of the first gas
optimization techniques you can

11650
11:46:10,610 --> 11:46:14,600
take to drop these down. And it
has to do with an R Funmi.

11651
11:46:14,600 --> 11:46:19,130
Contract these state variables
and how they're actually stored

11652
11:46:19,130 --> 11:46:22,070
and how this contract actually
keeps track of all this stuff,

11653
11:46:22,370 --> 11:46:25,280
this section is going to be a
little bit more advanced. So

11654
11:46:25,280 --> 11:46:27,560
we'll have a note here saying
that this is an advanced

11655
11:46:27,560 --> 11:46:30,410
section, if you want to skip
over it, you can, because now

11656
11:46:30,410 --> 11:46:32,630
we're getting into gas
optimizations here, this

11657
11:46:32,630 --> 11:46:35,180
information still is really good
to know. So if you want to skip

11658
11:46:35,180 --> 11:46:38,120
it for now, and then come back
later, you absolutely can. But

11659
11:46:38,120 --> 11:46:43,250
let's talk about what happens
when we actually save or store

11660
11:46:43,370 --> 11:46:47,870
these global variables. Okay,
these storage variables. Now,

11661
11:46:47,870 --> 11:46:50,180
everything I'm about to go
through is in the documentation.

11662
11:46:50,210 --> 11:46:52,550
And there is a link to this, of
course, in the GitHub repo

11663
11:46:52,580 --> 11:46:55,190
associated with this course,
whenever we have one of these

11664
11:46:55,190 --> 11:46:58,520
global variables, or these
variables that stay permanently,

11665
11:46:58,700 --> 11:47:01,550
they're stuck in something
called storage, you can think of

11666
11:47:01,550 --> 11:47:06,080
storage as a big giant array, or
a giant list of all the

11667
11:47:06,080 --> 11:47:08,930
variables that we actually
create. So when we say we have

11668
11:47:08,930 --> 11:47:11,510
some contract called Son of
storage, and we have a variable

11669
11:47:11,510 --> 11:47:14,420
called favorite number, we're
basically saying we want this

11670
11:47:14,420 --> 11:47:17,570
favorite number variable to
persist, right, we saw in a lot

11671
11:47:17,570 --> 11:47:20,210
of our examples, we had a
favorite number variable that we

11672
11:47:20,210 --> 11:47:23,000
can always call to see what this
contracts favorite number was,

11673
11:47:23,000 --> 11:47:27,020
well, the way it persists, is it
gets stored in this place called

11674
11:47:27,050 --> 11:47:30,560
storage. A storage box is this
giant list associated with this

11675
11:47:30,560 --> 11:47:33,800
contract where every single
variable and every single value

11676
11:47:33,800 --> 11:47:38,720
in the storage section is
slotted into a 32 byte long slot

11677
11:47:38,750 --> 11:47:43,430
in this storage array. So for
example, the number 25 in its

11678
11:47:43,430 --> 11:47:48,080
bytes implementation is 000 with
a ton of zeros 19. This is the

11679
11:47:48,080 --> 11:47:51,950
hex version of the yuan 256.
This is why we do so much hex

11680
11:47:51,950 --> 11:47:56,120
translation, the bytes
implementation of a yuan 256.

11681
11:47:56,270 --> 11:47:59,450
And each store saw increments
just like an array starting from

11682
11:47:59,480 --> 11:48:04,460
zero. So for example, our next
global variable or next storage

11683
11:48:04,460 --> 11:48:08,720
variable just gets slotted at
the next slot that's available.

11684
11:48:09,140 --> 11:48:12,800
So bullions, for example, get
transformed from their bull

11685
11:48:12,800 --> 11:48:16,220
version two, their hex and we
modified our some bool variable

11686
11:48:16,220 --> 11:48:22,010
to be true and X edition of the
true Boolean 0x 001. Every time

11687
11:48:22,010 --> 11:48:25,640
you save an additional global
variable, or more correctly, one

11688
11:48:25,640 --> 11:48:29,480
of these storage variables, it
takes up an additional storage

11689
11:48:29,510 --> 11:48:32,450
slot. And what about variables
that are dynamic in length, or

11690
11:48:32,450 --> 11:48:35,300
that can change length? What
about something that's dynamic?

11691
11:48:35,360 --> 11:48:39,080
Well, for dynamic values, like a
dynamic array, or a mapping

11692
11:48:39,230 --> 11:48:42,560
elements inside the array or
inside the mapping are actually

11693
11:48:42,560 --> 11:48:45,560
stored using some type of
hashing function. And you can

11694
11:48:45,560 --> 11:48:48,800
see those specific functions in
the documentation, the object

11695
11:48:48,800 --> 11:48:52,010
itself does take up a storage
slot, but it's not going to be

11696
11:48:52,010 --> 11:48:55,760
the entire array. For example,
my array variable here at

11697
11:48:55,760 --> 11:49:00,230
storage, slot two doesn't have
the entire array in storage slot

11698
11:49:00,230 --> 11:49:04,100
two, what has actually is just
the array length, the length of

11699
11:49:04,100 --> 11:49:07,730
the array is stored at storage
slot two. But for example, if we

11700
11:49:07,730 --> 11:49:12,500
do my array dot push 222, we do
some hashing function, which

11701
11:49:12,500 --> 11:49:15,140
again, you can see in the
documentation what that is, and

11702
11:49:15,140 --> 11:49:20,300
we'll store the number 222. At
that location in storage, the

11703
11:49:20,300 --> 11:49:26,390
hex of 222 is 0x 0000 D, so it
gets stored in this crazy spot.

11704
11:49:26,390 --> 11:49:29,780
And this is good, this is
intentional, because 32 Bytes

11705
11:49:29,900 --> 11:49:32,960
may not be nearly big enough to
store my array if our array gets

11706
11:49:32,960 --> 11:49:35,360
massive. And it wouldn't make
sense for to put the elements

11707
11:49:35,360 --> 11:49:38,900
inside the array at subsequent
numbers because again, the size

11708
11:49:38,900 --> 11:49:40,880
of the array can change and
you're never going to be sure

11709
11:49:40,910 --> 11:49:44,810
how many subsequence that you
need. So for my array, it does

11710
11:49:44,810 --> 11:49:47,630
have a storage slot for the
length for mappings. It does

11711
11:49:47,630 --> 11:49:50,810
have a storage spot as well
similar to array, but it's just

11712
11:49:50,810 --> 11:49:54,050
blank. But it's blank
intentionally so that solidity

11713
11:49:54,050 --> 11:49:57,830
knows, okay, there is a mapping
here, and it needs a storage

11714
11:49:57,830 --> 11:50:00,110
slot for attaching functional
work correctly. Now

11715
11:50:00,110 --> 11:50:03,110
interestingly, constant
variables and immutable

11716
11:50:03,110 --> 11:50:07,340
variables do not take up spots
in storage. The reason for this

11717
11:50:07,370 --> 11:50:10,820
is because constant variables
are actually part of the

11718
11:50:10,820 --> 11:50:14,120
contracts byte code itself,
which sounds a little bit weird.

11719
11:50:14,390 --> 11:50:17,870
But you can imagine what
solidity does is anytime it sees

11720
11:50:17,900 --> 11:50:21,320
constant variables name is it
just automatically swaps it out

11721
11:50:21,320 --> 11:50:24,320
with whatever number it actually
is. So you can kind of think of

11722
11:50:24,380 --> 11:50:28,940
not in storage is just a pointer
to 123 and it doesn't take up a

11723
11:50:28,940 --> 11:50:32,510
storage slot. Well when we have
variables inside of a function,

11724
11:50:32,690 --> 11:50:36,110
those variables only exist for
the duration of the function.

11725
11:50:36,290 --> 11:50:39,260
They don't stay inside the
contract. They don't persist

11726
11:50:39,260 --> 11:50:42,350
they're not permanent. So
variables inside these functions

11727
11:50:42,350 --> 11:50:46,400
like new var and other var do
not get added to storage. They

11728
11:50:46,400 --> 11:50:49,490
get added in their own memory
data structure. Which gets

11729
11:50:49,490 --> 11:50:52,850
deleted after the function has
finished running. Now you might

11730
11:50:52,850 --> 11:50:55,850
be asking, Okay, well, why do we
need this memory keyword,

11731
11:50:55,880 --> 11:50:59,210
especially when it comes to
strings, we saw before that we

11732
11:50:59,210 --> 11:51:02,360
had to say String memory. The
reason we need it for strings is

11733
11:51:02,360 --> 11:51:05,990
because strings are technically
this dynamically sized array.

11734
11:51:06,260 --> 11:51:08,960
And we need to tell solidity,
hey, we're going to do this on

11735
11:51:08,960 --> 11:51:11,180
the storage location, or we're
going to do it into the memory

11736
11:51:11,180 --> 11:51:14,690
location where we can just wipe
it. arrays and mappings can take

11737
11:51:14,690 --> 11:51:18,290
up a lot more space. So slowly,
just wants to make sure Okay,

11738
11:51:18,290 --> 11:51:21,080
where are we working with this
is it storage is a memory, you

11739
11:51:21,080 --> 11:51:24,110
have to tell me, I need to know
if I need to allocate space for

11740
11:51:24,110 --> 11:51:27,230
it in our storage data
structure. And again, everything

11741
11:51:27,230 --> 11:51:29,900
here you can read in the
solidity documentation. Now, in

11742
11:51:29,900 --> 11:51:33,200
the GitHub repo associated with
this course, if you go to

11743
11:51:33,200 --> 11:51:37,010
contracts, we've actually got an
example contract section called

11744
11:51:37,040 --> 11:51:39,920
Fun with storage, where you can
play with and look at a lot of

11745
11:51:39,920 --> 11:51:44,810
this stuff. And we even wrote a
little script called deploy

11746
11:51:44,810 --> 11:51:48,140
storage fun, where it'll print
out the storage location of some

11747
11:51:48,140 --> 11:51:50,750
of the different variables, feel
free to give it a run, if you

11748
11:51:50,750 --> 11:51:53,420
want to try a challenge anybody
to write some functions that

11749
11:51:53,420 --> 11:51:56,510
find the storage slots of the
elements of the arrays, and the

11750
11:51:56,510 --> 11:52:00,200
mappings, and then find the data
inside of those as well. We use

11751
11:52:00,200 --> 11:52:03,380
a function here called Get
storage app, which allows us to

11752
11:52:03,380 --> 11:52:06,890
get the storage at any one of
these slots. And this is to

11753
11:52:06,890 --> 11:52:10,910
reinforce that even if you have
a function as private or

11754
11:52:10,910 --> 11:52:14,930
internal. Anybody can still read
it. Anybody can read anything

11755
11:52:14,930 --> 11:52:18,260
off the blockchain. And you can
test it exactly what this if you

11756
11:52:18,260 --> 11:52:20,930
go ahead and get clone that or
copy paste the code yourself.

11757
11:52:21,260 --> 11:52:26,570
You can then run yarn part at
deploy dash test tags, storage.

11758
11:52:27,440 --> 11:52:30,260
And you'll run the deploy script
for that storage.

11759
11:52:30,260 --> 11:52:33,920
And you'll see printing out the
location of storage in each

11760
11:52:33,920 --> 11:52:40,430
storage slot with a fun contract
that we made as an example. And

11761
11:52:40,430 --> 11:52:42,620
you might of course be asking,
Okay, Patrick, why are you

11762
11:52:42,620 --> 11:52:45,290
telling me all this? We're just
trying to get this gas price

11763
11:52:45,290 --> 11:52:48,080
down? Why are you telling me all
about this storage thing? Well,

11764
11:52:48,080 --> 11:52:51,170
the reason I'm telling you all
about the storage thing. Anytime

11765
11:52:51,170 --> 11:52:55,520
you read or you write to and
from storage, you spend a ton of

11766
11:52:55,520 --> 11:52:58,880
gas. Remember I said when we
compile our code, we compile it

11767
11:52:58,880 --> 11:53:01,670
down to some crazy weird
bytecode. Well, let me show you

11768
11:53:01,670 --> 11:53:05,180
on remix what this looks like.
We go to compliation details, we

11769
11:53:05,180 --> 11:53:09,140
can go to bytecode. And we see
this weird hex object zero,

11770
11:53:09,140 --> 11:53:12,440
blah, blah, blah. But we also
see these things called op

11771
11:53:12,440 --> 11:53:16,730
codes. Now, this bytecode here
represents these op codes. Each

11772
11:53:16,730 --> 11:53:20,330
one of these op codes represents
a small piece of everything in

11773
11:53:20,330 --> 11:53:23,390
this bytecode. And in fact, in
our heart hat, we can go to

11774
11:53:23,450 --> 11:53:28,490
artifacts, build info, and we
can see, we can see these op

11775
11:53:28,490 --> 11:53:32,180
codes in the build info, we can
do a command F or Control F for

11776
11:53:32,600 --> 11:53:37,820
opcodes. We can see op codes for
different contracts. These op

11777
11:53:37,820 --> 11:53:40,100
codes represent what the machine
code is doing. And they

11778
11:53:40,100 --> 11:53:44,180
represent how much computational
work it takes to actually run

11779
11:53:44,180 --> 11:53:47,210
our code and do stuff with our
code. The way that gas is

11780
11:53:47,210 --> 11:53:50,720
actually calculated is by these
opcodes. There are a couple of

11781
11:53:50,720 --> 11:53:53,150
lists here. But here's one that
I'm going to use this EVM

11782
11:53:53,150 --> 11:53:56,000
opcodes. And again, there's a
link to this in the GitHub repo

11783
11:53:56,000 --> 11:53:59,300
associated with this lesson.
Well, if we scroll down, we can

11784
11:53:59,300 --> 11:54:03,200
see exactly how much it costs
for each one of these op codes.

11785
11:54:03,560 --> 11:54:08,660
So for example, anytime we add,
it costs three gas, anytime we

11786
11:54:08,660 --> 11:54:13,790
multiply, that's five gas,
subtracting three gas, we have

11787
11:54:13,820 --> 11:54:17,810
all of these op codes that cost
different amounts of gas in in

11788
11:54:17,810 --> 11:54:21,320
our functions, here's kind of a
sample contract. If we're doing

11789
11:54:21,350 --> 11:54:25,940
adding, anytime we add it's
going to cost three gas. Anytime

11790
11:54:25,940 --> 11:54:29,000
we save to memory, it's going to
cost gas from some other

11791
11:54:29,000 --> 11:54:33,110
opcodes. These op codes combined
show us how much gas we actually

11792
11:54:33,110 --> 11:54:36,800
use. Now, let's look at a lot of
these op codes and how much they

11793
11:54:36,800 --> 11:54:43,550
cost three 510, three, three,
balance is 700. So getting the

11794
11:54:43,550 --> 11:54:47,630
balance is is a ton of gas.
Let's keep going. Getting the

11795
11:54:47,630 --> 11:54:50,600
sides of an Accounts code is a
lot of gas copying and accounts

11796
11:54:50,600 --> 11:54:56,810
code into memory. But oh my
goodness, what is this save word

11797
11:54:56,810 --> 11:55:03,410
to storage costs a ton of gas
that is 20,000 gas and s load

11798
11:55:03,440 --> 11:55:08,330
load word from storage cost 800
gas. These are two of the most

11799
11:55:08,330 --> 11:55:12,620
important opcodes s load and s
store which stands for storage

11800
11:55:12,620 --> 11:55:17,720
load and storage store. Anytime
one of these op codes fires,

11801
11:55:17,930 --> 11:55:21,980
we're spending 800 or 20,000.
You know, there's a big asterisk

11802
11:55:21,980 --> 11:55:25,160
there because that can change a
lot. But we're spending a ton of

11803
11:55:25,160 --> 11:55:29,030
gas anytime we work with storage
as developers. Anytime we work

11804
11:55:29,030 --> 11:55:33,200
with some stuff in storage, we
want to go boy, this is about to

11805
11:55:33,200 --> 11:55:37,610
cost me a lot of gas and the
best convention or making sure

11806
11:55:37,610 --> 11:55:40,850
we know that we're working with
a stored variable and we're

11807
11:55:40,850 --> 11:55:46,070
about to spend a lot of gas is
to append an S underscore right

11808
11:55:46,070 --> 11:55:49,580
before them which stands for
storage right So we're saying

11809
11:55:49,610 --> 11:55:52,400
address to amount funded is
going to be a storage variable

11810
11:55:52,520 --> 11:55:56,570
wonders is going to be a storage
variable. Owner is not going to

11811
11:55:56,570 --> 11:55:59,750
be a storage variable. It's
immutable. The best practice for

11812
11:55:59,780 --> 11:56:02,330
immutable variables is
prefixing. It with an I

11813
11:56:02,330 --> 11:56:06,290
underscore constant values are
also not in storage. So for

11814
11:56:06,290 --> 11:56:09,230
constant values, we want to keep
them capslock, like that

11815
11:56:09,320 --> 11:56:12,950
aggregator v3 interface public
price feed. Yep, you know what

11816
11:56:12,980 --> 11:56:15,620
that is going to be a storage
variable. So we want to append

11817
11:56:15,620 --> 11:56:18,200
an S underscore with it. So
we're going to do a little bit

11818
11:56:18,200 --> 11:56:21,680
more refactor, we've appended
these appropriately to update

11819
11:56:21,680 --> 11:56:25,100
everything. So instead of owner,
it's going to be I underscore

11820
11:56:25,100 --> 11:56:28,010
owner, and as a developer will
read this, and we'll go ah, this

11821
11:56:28,010 --> 11:56:31,310
is going to be much cheaper than
a regular variable. Okay, that's

11822
11:56:31,310 --> 11:56:34,160
great. I'm going to work with
this. This I underscore owner

11823
11:56:34,190 --> 11:56:37,700
for my modifier. Awesome. Is
owner anywhere else in here?

11824
11:56:38,480 --> 11:56:42,260
Okay, right in the constructor.
I own underscore owner is

11825
11:56:42,260 --> 11:56:45,950
message dot sender. Price feed
is a storage variable. We should

11826
11:56:45,950 --> 11:56:49,100
as developers, we should see the
s underscore when reading this

11827
11:56:49,130 --> 11:56:53,420
and go, Okay, we're spending a
lot of gas to store this.

11828
11:56:53,480 --> 11:56:57,140
Perfect. Okay, great. Let's keep
going. Great. We've updated all

11829
11:56:57,140 --> 11:57:01,040
the owners. Okay, well, what
about address to amount funded?

11830
11:57:01,850 --> 11:57:06,590
In VS code? If you do Command F,
or Ctrl, F, and you hit this

11831
11:57:06,590 --> 11:57:10,070
little down arrow, you can
actually find and replace all of

11832
11:57:10,070 --> 11:57:14,750
these address to amount funded
with s underscore address to Mt

11833
11:57:14,750 --> 11:57:18,710
funded. Hit it like that. And
since I updated one, I got a

11834
11:57:18,740 --> 11:57:22,160
backspace that one no. So now
these are all updated. Let's do

11835
11:57:22,160 --> 11:57:26,120
the same thing with s funders.
Let's update everywhere. It has

11836
11:57:26,120 --> 11:57:29,810
funders just to be s funders.
And we probably doubled up here.

11837
11:57:29,810 --> 11:57:30,020
Yep.

11838
11:57:30,020 --> 11:57:33,260
Let's undo that. We already
updated all the AI owners. So

11839
11:57:33,260 --> 11:57:36,350
now it's updated all the price
feeds. So let's look for price

11840
11:57:36,350 --> 11:57:39,740
feed, we'll update it with ES
price feed. And then we probably

11841
11:57:39,740 --> 11:57:42,740
doubled up right here. So we'll
undo that. Okay, great. Now that

11842
11:57:42,740 --> 11:57:45,890
we've updated everything in
here, we can scroll down and we

11843
11:57:45,890 --> 11:57:49,670
can oops, sorry, doubled up
there too. Sorry. We can we can

11844
11:57:49,670 --> 11:57:53,900
green through our code and go
okay, where are we reading and

11845
11:57:53,900 --> 11:57:57,230
writing to storage way more
often than we probably need to.

11846
11:57:57,560 --> 11:58:00,950
And that's when we get to this
withdrawal function, which seems

11847
11:58:00,980 --> 11:58:05,240
rather suspect to reading and
writing to storage a lot. So

11848
11:58:05,240 --> 11:58:08,030
let's take a look at what we're
doing here. Okay, so first of

11849
11:58:08,030 --> 11:58:13,040
all, I can see that we're doing
a for loop here. And every time

11850
11:58:13,040 --> 11:58:16,400
we do a for loop, we're just
constantly looping through all

11851
11:58:16,400 --> 11:58:20,330
of this code. Every single time
we're doing a little compare

11852
11:58:20,330 --> 11:58:24,530
option here we're saying, okay,
is our funder index less than s

11853
11:58:24,530 --> 11:58:28,940
funders dot length? S funders
dot length, this means the

11854
11:58:28,940 --> 11:58:32,000
longer our funders array is, the
more times we're going to be

11855
11:58:32,000 --> 11:58:36,110
reading from storage, that's
incredibly expensive. We're also

11856
11:58:36,110 --> 11:58:40,340
recalling this, oh my goodness,
we're reading from storage a lot

11857
11:58:40,340 --> 11:58:43,160
and saving it to this memory
variable, and then updating our

11858
11:58:43,160 --> 11:58:46,580
storage variable with it. Wow.
So we're reading from storage a

11859
11:58:46,580 --> 11:58:50,300
ton here, and we're reading from
storage a ton here, okay, then

11860
11:58:50,300 --> 11:58:52,640
we have to reset our funders
array, there's really no way

11861
11:58:52,640 --> 11:58:55,610
around it. And that's pretty
much it for our reading and

11862
11:58:55,610 --> 11:58:58,130
writing to storage, we could
probably create a withdrawal

11863
11:58:58,130 --> 11:59:01,640
function, that's a lot cheaper.
So let's go ahead and create a

11864
11:59:01,640 --> 11:59:05,480
function called cheaper
withdraw, function, cheaper

11865
11:59:05,480 --> 11:59:10,730
withdraw. That's going to take
what we've just learned and make

11866
11:59:10,730 --> 11:59:13,970
a cheaper withdraw, that's much
more gas efficient. So we'll

11867
11:59:13,970 --> 11:59:18,350
keep this public payable. and
have it be only owner, we're not

11868
11:59:18,350 --> 11:59:23,180
going to change anything there.
But what can we do for at least

11869
11:59:23,210 --> 11:59:26,630
this part here, we don't want to
keep reading from storage here.

11870
11:59:26,870 --> 11:59:29,150
And we don't want to always have
to keep reading from storage

11871
11:59:29,180 --> 11:59:32,240
here. We're like doubling up the
amount of storage we're reading

11872
11:59:32,240 --> 11:59:35,960
from. So instead, what we can
do, we can read this entire

11873
11:59:35,960 --> 11:59:41,720
array into memory one time, and
then read from memory instead of

11874
11:59:41,720 --> 11:59:43,940
constantly reading from storage.
And that's going to make our

11875
11:59:43,940 --> 11:59:49,430
lives a lot cheaper. So we can
create an address array. Memory

11876
11:59:49,460 --> 11:59:54,230
funders equals s underscore,
funders. And now it's going to

11877
11:59:54,230 --> 11:59:58,670
start making sense why for
arrays and strings in our

11878
11:59:58,670 --> 12:00:02,000
functions, it makes us say, hey,
is this memory is a storage?

11879
12:00:02,000 --> 12:00:04,700
What is this? And we're telling
it, we want it to be memory

11880
12:00:04,700 --> 12:00:07,340
because memory is going to be a
lot cheaper. So now that we're

11881
12:00:07,340 --> 12:00:12,110
saving it into our funders, oh,
and a quick note mappings can't

11882
12:00:12,140 --> 12:00:16,490
be in memory. Sorry. They're
just too weird and too wacky. So

11883
12:00:16,730 --> 12:00:19,250
flooding just doesn't let you do
that right now. But now that

11884
12:00:19,250 --> 12:00:24,350
we've saved our storage variable
into a memory variable, we can

11885
12:00:24,350 --> 12:00:28,100
read and write from this memory
variable, much, much cheaper,

11886
12:00:28,130 --> 12:00:31,400
and then update storage when
we're all done. So what we're

11887
12:00:31,400 --> 12:00:35,240
going to do now is we're gonna
say for you into V six, fund or

11888
12:00:35,240 --> 12:00:38,750
index equals zero, and we're
going to basically rewrite

11889
12:00:38,750 --> 12:00:43,220
everything but just using this
memory array. instead. We're

11890
12:00:43,220 --> 12:00:48,740
gonna say funder index is less
than funders dot length and

11891
12:00:48,770 --> 12:00:53,540
instead of s funders dot length,
and then we're gonna say funder

11892
12:00:53,570 --> 12:00:57,650
index plus plus. And then in
here we're gonna do nearly

11893
12:00:57,650 --> 12:01:00,800
exactly the same thing, except
we're gonna say address funder

11894
12:01:01,430 --> 12:01:08,060
equals funders, using our memory
array and not s funders have

11895
12:01:08,060 --> 12:01:13,310
funder index. And then we're
gonna say s address to amount

11896
12:01:13,340 --> 12:01:20,150
funded. funder equals zero. So
we're resetting our funders

11897
12:01:20,150 --> 12:01:24,080
mapping here, we're using our
memory variables instead, then

11898
12:01:24,080 --> 12:01:28,010
we're going to do the same thing
s underscore funders equals new

11899
12:01:28,370 --> 12:01:33,590
address array of zero. And then
we're gonna do the same thing

11900
12:01:33,590 --> 12:01:40,730
bool success, comma equals S
owner, dot call value,

11901
12:01:41,930 --> 12:01:47,000
address this balance, and we're
going to send it nothing and

11902
12:01:47,000 --> 12:01:53,780
then require success. Like that
actually, sorry, Iona on a sonar

11903
12:01:53,840 --> 12:01:56,810
now that we have this function
that we think is cheaper, let's

11904
12:01:56,810 --> 12:02:01,430
go back to our test. And let's
run this same multi test here,

11905
12:02:01,850 --> 12:02:05,060
but with our cheaper function.
So I know this can be a little

11906
12:02:05,060 --> 12:02:08,540
bit tricky to copy, paste, but
let's copy this entire massive

11907
12:02:08,540 --> 12:02:13,010
test. Let's come down here,
paste it, and we'll change the

11908
12:02:13,010 --> 12:02:19,400
name saying cheaper withdraw,
testing dot that done. And in

11909
12:02:19,400 --> 12:02:23,000
here in in this giant it here,
all we're going to change is

11910
12:02:23,000 --> 12:02:27,110
we're going to change withdraw
to cheaper withdraw, and the

11911
12:02:27,110 --> 12:02:30,200
rest of the test is going to be
exactly the same. So with that,

11912
12:02:30,200 --> 12:02:33,080
let's see if if we were
successful in making our

11913
12:02:33,080 --> 12:02:36,260
withdraw function cheaper with
cheaper withdraw, we're gonna

11914
12:02:36,260 --> 12:02:40,940
pull apart our terminal now. And
we do yarn, art hat test, which

11915
12:02:40,940 --> 12:02:43,310
is going to run our gas
estimator because it's enabled

11916
12:02:43,310 --> 12:02:45,950
right now. And of course, all of
our functions have been broken

11917
12:02:45,950 --> 12:02:49,790
because we renamed everything.
So we'll do a quick final

11918
12:02:49,790 --> 12:02:57,560
replace of funders, to change
funders to ask funders. And then

11919
12:02:57,590 --> 12:03:02,960
we're gonna change price feed to
ask price feed. And then do we

11920
12:03:02,960 --> 12:03:06,920
have owner anywhere? We don't
have owner or anywhere. We need

11921
12:03:06,920 --> 12:03:10,280
to change this one. Address to
amount funded. Let's come in

11922
12:03:10,280 --> 12:03:15,560
here. Address to amount funded.
S adderstone. well funded. What

11923
12:03:15,560 --> 12:03:18,530
else do we need to change price?
We price feed funders. Okay, I

11924
12:03:18,530 --> 12:03:20,930
think we changed everything.
Alright, so let's try our test

11925
12:03:20,930 --> 12:03:24,950
now. Yarn Hardhead test. All
right, great. Everything's

11926
12:03:24,950 --> 12:03:30,050
passing. And we ran our cheaper
withdraw testing. So now, if we

11927
12:03:30,050 --> 12:03:34,760
go to our gas output here, our
gas report, zoom out just a

11928
12:03:34,760 --> 12:03:38,450
hair, we can see the difference
between cheaper withdraw and

11929
12:03:38,450 --> 12:03:42,140
withdraw, we see something
really interesting. Here we see

11930
12:03:42,170 --> 12:03:46,790
our cheaper withdraw on average
was actually more expensive than

11931
12:03:46,790 --> 12:03:49,940
our regular withdraw. And the
reason for this is because

11932
12:03:49,940 --> 12:03:53,150
actually, if we go to our tests
are cheaper withdrawal, we only

11933
12:03:53,150 --> 12:03:57,170
tested on the multi withdraw. So
we had to reset many, many more

11934
12:03:57,170 --> 12:04:01,850
accounts. But this was also
technically its maximum as well.

11935
12:04:01,940 --> 12:04:04,670
And if we compare the maximum of
the cheaper withdrawal, the

11936
12:04:04,670 --> 12:04:07,520
maximum of the withdraw, it
looks like the cheaper

11937
12:04:07,520 --> 12:04:11,000
withdrawal was indeed cheaper.
And if we go to our hard hat dot

11938
12:04:11,000 --> 12:04:15,140
config, and we add our API key
back in, what we could even do

11939
12:04:15,260 --> 12:04:18,860
is in our test, we could copy
withdraw eath from a single

11940
12:04:18,860 --> 12:04:23,660
funder, copy that, paste it in
and just change withdraw to

11941
12:04:23,660 --> 12:04:27,290
cheaper withdrawal, rerun it
with the key and now do yarn

11942
12:04:27,290 --> 12:04:30,500
Hardhead test, we can see
exactly how many dollars we

11943
12:04:30,500 --> 12:04:36,770
would save if we ran this on the
Matic blockchain. Now let's go

11944
12:04:36,770 --> 12:04:41,120
back, we'll reopen up our gas
report. And we can see, in the

11945
12:04:41,120 --> 12:04:43,640
minimum cheaper withdrawal was
actually a little bit more

11946
12:04:43,640 --> 12:04:46,640
expensive. This actually does
make sense because if we look at

11947
12:04:46,640 --> 12:04:49,340
funding, if we only have to
withdraw when there was one

11948
12:04:49,340 --> 12:04:53,240
funder, well this loop only runs
one time. And our cheaper

11949
12:04:53,240 --> 12:04:56,960
withdraw will do the exact same
but it will have this this extra

11950
12:04:56,960 --> 12:05:00,470
thing here of loading them all
in, we see that the savings The

11951
12:05:00,470 --> 12:05:04,430
more people our funders in our
contracts. So automatic, we can

11952
12:05:04,430 --> 12:05:08,330
see we pretty much didn't save
anything. But if I change this

11953
12:05:08,330 --> 12:05:14,780
one more time to eath run the
test again. Now we can see

11954
12:05:14,870 --> 12:05:17,990
people withdraw saved a few
cents. This is how we can start

11955
12:05:18,020 --> 12:05:21,050
optimizing our contracts will be
cheaper and cheaper. And this

11956
12:05:21,050 --> 12:05:23,720
two cents was just in the
average. It's not even comparing

11957
12:05:23,750 --> 12:05:27,380
the max to the max, which was a
lot more gas than their

11958
12:05:27,380 --> 12:05:35,060
averages. We have just learned
an absolute ton here. Now, this

11959
12:05:35,060 --> 12:05:36,950
next part is going to make some
of you mad because we're going

11960
12:05:36,950 --> 12:05:39,620
to refactor our code one more
time if you don't want to

11961
12:05:39,620 --> 12:05:42,200
refactor it and you want to
leave all your tests as s

11962
12:05:42,200 --> 12:05:45,770
underscores you absolutely can
but to other users using our

11963
12:05:45,770 --> 12:05:48,920
application. Dealing with this s
underscore is a little Little

11964
12:05:48,920 --> 12:05:51,620
bit gross and actually can make
our code a little bit more

11965
12:05:51,620 --> 12:05:55,610
confusing for those who use it.
And additionally, right now all

11966
12:05:55,610 --> 12:05:58,250
of our state variables are
public. And actually internal

11967
12:05:58,250 --> 12:06:01,670
variables and private variables
are also cheaper gas wise. And

11968
12:06:01,670 --> 12:06:03,650
we don't need to make every
single one of our variables

11969
12:06:03,650 --> 12:06:07,070
public, because anybody can read
them off the chain anyways. So

11970
12:06:07,070 --> 12:06:09,710
one more refactoring that we're
going to do is we're actually

11971
12:06:09,710 --> 12:06:13,370
going to set the visibility of
these to private or internal,

11972
12:06:13,640 --> 12:06:16,250
based off of whether or not they
need to be private or internal,

11973
12:06:16,280 --> 12:06:20,480
and then we'll create getters at
the bottom of our function here.

11974
12:06:20,660 --> 12:06:23,540
So minimum USD, we can keep this
public because we want other

11975
12:06:23,540 --> 12:06:26,840
people to know what the minimum
USD of our contract is, without

11976
12:06:26,840 --> 12:06:29,060
having to go right through
storage, the owner of our

11977
12:06:29,060 --> 12:06:31,820
contract isn't important for
others to know or other

11978
12:06:31,820 --> 12:06:34,310
contracts to know. So we can go
ahead and make this private, and

11979
12:06:34,310 --> 12:06:36,260
then at the bottom at a function

11980
12:06:37,490 --> 12:06:48,470
get owner. That's a public view
that returns I owner, turns

11981
12:06:49,640 --> 12:06:55,520
address as funders, as funders
can be private as well. So at

11982
12:06:55,520 --> 12:07:00,230
the bottom, we're gonna say
function, get funder, and we're

11983
12:07:00,230 --> 12:07:11,930
going to pass a un 236 index,
public U, turns, address, return

11984
12:07:12,470 --> 12:07:17,210
as funders of index, the address
to Mt funded can also be

11985
12:07:17,210 --> 12:07:21,920
private. So the bottom, we're
going to create function, get

11986
12:07:22,220 --> 12:07:28,340
address to amount funded. And
this is going to take an address

11987
12:07:29,210 --> 12:07:36,260
under the public view returns,
you went to 56. And we're going

11988
12:07:36,260 --> 12:07:41,960
to return amount funded of the
funder did this one we did this

11989
12:07:41,960 --> 12:07:46,310
one, we did this one. And then
price feed, function get price

11990
12:07:46,310 --> 12:07:50,840
feed. This is going to be public
view as well, that returns

11991
12:07:51,440 --> 12:07:55,070
aggregate tour of the three
interface that's going to return

11992
12:07:55,100 --> 12:07:58,400
so I'm just gonna price feed.
Oh, okay. The reason why we did

11993
12:07:58,400 --> 12:08:02,030
that is because we want to have
this s underscore so that we as

11994
12:08:02,030 --> 12:08:05,600
developers can know, okay, this
is a storage variable, I want to

11995
12:08:05,600 --> 12:08:08,780
be very careful about how I
interact with this. But we don't

11996
12:08:08,780 --> 12:08:11,300
want people who interact with
our code to have to deal with

11997
12:08:11,300 --> 12:08:14,180
this s stuff. And we want to
give them an API that makes

11998
12:08:14,180 --> 12:08:17,090
sense, and that it's easy and
readable. So we add these getter

11999
12:08:17,090 --> 12:08:20,240
functions at the bottom to do
that. And also changing the

12000
12:08:20,240 --> 12:08:24,110
visibility can save us some gas
in the long run as well, because

12001
12:08:24,140 --> 12:08:26,270
we're gonna be calling from
private variables or internal

12002
12:08:26,270 --> 12:08:29,300
variables, which are cheaper gas
wise, of course, we do need to

12003
12:08:29,300 --> 12:08:31,970
upgrade our test one more time.
And like I said, if you want to

12004
12:08:31,970 --> 12:08:34,250
just leave them with the S
underscores, that's absolutely

12005
12:08:34,250 --> 12:08:40,160
fine. So s underscore price feed
is now going to be replaced with

12006
12:08:40,340 --> 12:08:44,420
get price feed, s underscore
amount to fund it is going to be

12007
12:08:44,450 --> 12:08:49,340
now replaced with get address to
amount funded. For now going to

12008
12:08:49,340 --> 12:08:56,330
change SW, underscore funders,
to get funder. We're going to

12009
12:08:56,330 --> 12:08:59,360
change Iona, there's nowhere
else in their mind, we don't

12010
12:08:59,360 --> 12:09:01,760
need to change them. And I think
that was everything. Let's just

12011
12:09:01,760 --> 12:09:05,240
look for s underscore, we don't
see it, I underscore, we don't

12012
12:09:05,240 --> 12:09:08,180
see that either. Let's just run
our tests one more time to make

12013
12:09:08,180 --> 12:09:13,100
sure we refactor that correctly.
And it looks like we did

12014
12:09:13,280 --> 12:09:17,240
awesome. Okay, we have just
learned a ton. we've refactored

12015
12:09:17,240 --> 12:09:20,930
our code a ton. And everything
is starting to look really,

12016
12:09:20,960 --> 12:09:24,650
really good here. One more gas
optimization we could make. And

12017
12:09:24,650 --> 12:09:28,520
an optimization for errors as
well is we could update all of

12018
12:09:28,520 --> 12:09:33,470
our requires to instead be to
instead be reverts. Because

12019
12:09:33,470 --> 12:09:37,130
without requires, we're actually
storing this massive string,

12020
12:09:37,130 --> 12:09:42,200
this massive array of text on
chain, these error codes are

12021
12:09:42,200 --> 12:09:44,720
much cheaper. But that's
optional. If you want to do

12022
12:09:44,720 --> 12:09:47,150
that. The whole reason we were
doing this is we were going

12023
12:09:47,150 --> 12:09:50,240
through the style guide in
updating things here. So we have

12024
12:09:50,240 --> 12:09:53,210
public internal private, and the
bottom is going to be our view

12025
12:09:53,210 --> 12:09:56,480
slash pure functions, which they
are they're just all these

12026
12:09:56,480 --> 12:09:57,800
getters that we just added.

12027
12:10:00,860 --> 12:10:03,770
So now our style in here looks
good. We've learned a lot about

12028
12:10:03,770 --> 12:10:06,620
gas, we've learned a lot about
storage. This is fantastic.

12029
12:10:06,620 --> 12:10:09,500
Let's do a quick refresher on
everything we just learned

12030
12:10:09,500 --> 12:10:13,100
because we went through a lot
right there. And like I said,

12031
12:10:13,100 --> 12:10:16,610
this is one of the harder parts
of this course. Any variable

12032
12:10:16,610 --> 12:10:20,000
that is changeable that we want
to persist across contract

12033
12:10:20,000 --> 12:10:24,140
executions and transactions. We
save to a giant array called

12034
12:10:24,170 --> 12:10:27,440
storage this array is
sequentially indexed starting at

12035
12:10:27,440 --> 12:10:31,220
zero. So the first variable the
first value that we have in our

12036
12:10:31,220 --> 12:10:35,330
contract gets stored to the zero
with index. The next one gets

12037
12:10:35,330 --> 12:10:39,110
stored to one and so on and so
forth. Dynamic arrays and

12038
12:10:39,110 --> 12:10:43,100
mappings and other dynamically
sized objects use specific

12039
12:10:43,100 --> 12:10:46,010
hashing function that you can
find in the documentation to

12040
12:10:46,010 --> 12:10:50,210
determine where the elements of
those dynamic Data Structures go

12041
12:10:50,390 --> 12:10:53,360
memory variables, constant
variables and immutable

12042
12:10:53,360 --> 12:10:57,140
variables don't go in storage.
And one of the main reasons

12043
12:10:57,140 --> 12:11:01,190
talking about storage is so
important is because the op

12044
12:11:01,190 --> 12:11:05,120
codes for loading from storage
and for reading from storage and

12045
12:11:05,120 --> 12:11:09,020
writing to storage are
incredibly gas expensive. So in

12046
12:11:09,050 --> 12:11:12,560
everywhere we can we want to
reduce the amount that we read

12047
12:11:12,560 --> 12:11:16,310
and load from storage. And it's
one of the easiest ways to save

12048
12:11:16,310 --> 12:11:20,060
gas and try to optimize our code
to be gas efficient. Like I

12049
12:11:20,060 --> 12:11:22,580
said, some of this gas stuff can
be a little tricky and a little

12050
12:11:22,580 --> 12:11:25,580
bit confusing. So if you don't
get this right away, it's okay.

12051
12:11:25,610 --> 12:11:28,610
It is totally fine. If you're a
little bit confused, and you're

12052
12:11:28,610 --> 12:11:31,670
like, What is he talking about?
Like I said, this is some of the

12053
12:11:31,670 --> 12:11:34,490
more advanced stuff it'll come,
the more you work with solidity,

12054
12:11:34,490 --> 12:11:36,890
and the more you work with
everything here. So don't let it

12055
12:11:36,890 --> 12:11:39,620
stress you out. Don't let it
stop you from continuing. You're

12056
12:11:39,620 --> 12:11:45,740
doing fantastic being here. So
far. We've written some really

12057
12:11:45,740 --> 12:11:50,240
good unit tests. Let's now write
some staging tests. And these

12058
12:11:50,240 --> 12:11:54,440
are the tests that we can use on
an actual test net. This is a

12059
12:11:54,440 --> 12:11:57,320
test that we're basically going
to run after we've deployed some

12060
12:11:57,320 --> 12:12:01,220
code just to see if everything
is working approximately the way

12061
12:12:01,220 --> 12:12:03,740
we want it to. So let's go ahead
and we'll create a new file

12062
12:12:03,740 --> 12:12:10,280
here. We'll call it fund me. Dot
staging dot test, dot j s. And

12063
12:12:10,280 --> 12:12:12,410
it's going to look really
similar to what we were just

12064
12:12:12,410 --> 12:12:15,020
doing with our unit tests. And
we're going to assume this is on

12065
12:12:15,020 --> 12:12:18,260
a test net. So these are tests
that we're going to run, right

12066
12:12:18,260 --> 12:12:21,710
before we deploy this to a main
net, this is the last step in

12067
12:12:21,710 --> 12:12:24,410
your development journey, we
want to just make sure that

12068
12:12:24,590 --> 12:12:27,140
everything is working
approximately correctly on an

12069
12:12:27,140 --> 12:12:29,870
actual test net. So what we're
gonna do is we're gonna do the

12070
12:12:29,870 --> 12:12:34,280
same thing describe, fund me,
and I'm gonna go a little quick

12071
12:12:34,310 --> 12:12:37,040
through these tests here,
because we've basically written

12072
12:12:37,040 --> 12:12:39,560
this type of test before, so
we're gonna say before each,

12073
12:12:39,890 --> 12:12:44,510
it's gonna be an async.
function. We're gonna do the

12074
12:12:44,510 --> 12:12:47,540
same thing as our unit tests. So
we're gonna have a Funmi

12075
12:12:48,740 --> 12:12:51,980
variable, we're gonna have our
let Deployer, we're gonna have

12076
12:12:51,980 --> 12:12:59,930
our constant send value equals
ethers.utils.rs ether of one,

12077
12:13:00,410 --> 12:13:04,640
and in here, we're going to do
const. Get named accounts.

12078
12:13:05,990 --> 12:13:11,990
Equals require hardhats, we're
going to say deployer equals

12079
12:13:12,200 --> 12:13:17,750
weight, get named accounts,
we're going to wrap this up, dot

12080
12:13:17,750 --> 12:13:23,000
Deployer. We're gonna say fun me
equals await ethers dot get

12081
12:13:23,000 --> 12:13:23,870
contract.

12082
12:13:25,580 --> 12:13:29,180
And me, comma, we're going to
connect it to our Deployer,

12083
12:13:29,450 --> 12:13:32,090
we're not going to deploy this,
we're not going to do any

12084
12:13:32,090 --> 12:13:35,000
fixtures like we did in our unit
tests, because in our staging

12085
12:13:35,000 --> 12:13:38,600
tests, we're assuming that it's
already deployed here. And we

12086
12:13:38,630 --> 12:13:43,100
also don't need a mock because
on a staging, we're assuming

12087
12:13:43,130 --> 12:13:46,250
that we're on a test net, now we
can actually wrap this whole

12088
12:13:46,250 --> 12:13:49,970
thing to make sure that we're on
a test net by using our helper

12089
12:13:49,970 --> 12:13:53,150
config. And looking for our
development chains, we can say

12090
12:13:53,150 --> 12:13:57,410
we only want to run our describe
bit if we're on a development

12091
12:13:57,410 --> 12:14:04,100
chain. So first, we'll say
const. Development chains equals

12092
12:14:04,100 --> 12:14:10,160
require, we'll pull that that
helper config in. And we'll say,

12093
12:14:10,220 --> 12:14:15,230
development chains dot includes
network dot name. And we'll

12094
12:14:15,230 --> 12:14:18,650
basically will say if developer
chains that includes network dot

12095
12:14:18,650 --> 12:14:22,340
name, we're going to skip and we
can actually skip using this,

12096
12:14:22,610 --> 12:14:25,370
we're going to use something
called a ternary operator is

12097
12:14:25,370 --> 12:14:28,190
basically like a one liner if
statement. And you can think of

12098
12:14:28,190 --> 12:14:31,130
this as a special type of F.
I've got a link to this and the

12099
12:14:31,130 --> 12:14:33,680
GitHub repo associated with this
course. And here's some

12100
12:14:33,680 --> 12:14:37,400
JavaScript documentation,
showing it in action. You say,

12101
12:14:37,400 --> 12:14:43,250
Okay, return is member. And if
it's true, have it be $2.

12102
12:14:43,430 --> 12:14:47,090
Otherwise have a B $10. And
that's pretty much it. So

12103
12:14:47,180 --> 12:14:50,990
another way of thinking about is
like, you say, let variable

12104
12:14:51,020 --> 12:14:57,530
equals true, then we could say,
let some var equals variable

12105
12:14:57,650 --> 12:15:03,860
question. Yes? Or no? Some var
will end up being Yes. Because

12106
12:15:03,860 --> 12:15:07,460
variable is true. If variable
was false than some var would be

12107
12:15:07,460 --> 12:15:12,650
no. So it's literally saying, If
variable, if variable, then some

12108
12:15:12,650 --> 12:15:19,010
var equals yes. Else. Some var
equals no, these lines are

12109
12:15:19,010 --> 12:15:21,770
literally the exact same thing.
This one is just a little bit

12110
12:15:21,770 --> 12:15:24,500
more succinct. That's really it.
So that's what this operator

12111
12:15:24,500 --> 12:15:26,720
does. We're gonna say
development chains that includes

12112
12:15:26,750 --> 12:15:30,710
network dot name. So if our
network is a development chain,

12113
12:15:30,710 --> 12:15:33,650
which we're going to import
network as well from hard hat

12114
12:15:33,650 --> 12:15:37,550
and ethers as well. Then we're
going to do describe that

12115
12:15:37,550 --> 12:15:41,150
skipped and this tells our test
to just skip this whole

12116
12:15:41,150 --> 12:15:43,520
describe, and then we're going
to put this little colon here

12117
12:15:43,520 --> 12:15:48,260
thing and save and boom. So now
we're only going to run this if

12118
12:15:48,290 --> 12:15:50,990
we're not On a development
chain, and we want to take this

12119
12:15:50,990 --> 12:15:54,650
exact same syntax, we'll go to
our unit testing here, and we'll

12120
12:15:54,650 --> 12:15:58,100
do the exact same thing, we'll
paste it will have this be the

12121
12:15:58,100 --> 12:16:01,640
opposite by putting a little
knot here, sticking that colon

12122
12:16:01,640 --> 12:16:05,600
in. So now, our unit tests only
run on development chains in our

12123
12:16:05,600 --> 12:16:09,320
staging tests, only run on test
nets. Perfect. That's what we

12124
12:16:09,320 --> 12:16:15,020
want, allows people to fund and
own and withdraw. And this will

12125
12:16:15,020 --> 12:16:18,260
be an async function, of course,
and we probably can make this

12126
12:16:18,260 --> 12:16:23,360
pretty robust, but we'll just
say await, fund me dot fund is

12127
12:16:23,360 --> 12:16:28,490
going to be send a value. And
then we'll say a weight on me

12128
12:16:28,910 --> 12:16:36,110
dot withdraw. CERT equals
require try. Now we'll do kind

12129
12:16:36,110 --> 12:16:40,400
of a lame final one, we'll say
const ending balance equals a

12130
12:16:40,400 --> 12:16:47,510
weight on me dot provider dot
get balance, fund me dot

12131
12:16:47,510 --> 12:16:52,790
address. And then we'll say
assert dot equals ending

12132
12:16:52,820 --> 12:16:58,310
balance.to string, comma zero as
a string, we're only going to

12133
12:16:58,310 --> 12:17:00,950
run this on a test net, I'm just
going to give you this one more

12134
12:17:00,950 --> 12:17:04,400
run to show you it in action.
Feel free to skip this part

12135
12:17:04,400 --> 12:17:06,560
again, because we are going to
be working with a test net, I'm

12136
12:17:06,560 --> 12:17:11,270
going to run yarn, hard hat
deploy dash test network

12137
12:17:11,900 --> 12:17:17,330
Rinkeby. And it's going to run
through our deploy. And after

12138
12:17:17,330 --> 12:17:20,750
it's all deployed, we're going
to run our staging tests to make

12139
12:17:20,750 --> 12:17:24,560
sure that everything works even
with a price feed on a real test

12140
12:17:24,560 --> 12:17:28,370
net, and I need to do const
development chains equals

12141
12:17:28,370 --> 12:17:34,490
require dot dot slash dot dot
slash helper heart config. Now

12142
12:17:34,490 --> 12:17:40,790
for run yarn, hard hat test,
we'll see just our unit tests

12143
12:17:40,790 --> 12:17:44,540
get run. But if we run yarn hard
to test dash dash network

12144
12:17:44,720 --> 12:17:47,960
Rinkeby, we're not going to run
nine tests, we're only going to

12145
12:17:47,960 --> 12:17:51,830
run our singular staging test.
And of course, this is going to

12146
12:17:51,830 --> 12:17:54,440
be a lot slower, because we're
on a

12147
12:17:54,500 --> 12:18:02,210
test net. Net will we write
written all these tests, we can

12148
12:18:02,210 --> 12:18:05,090
write a couple of scripts. And
then we're going to finish this

12149
12:18:05,090 --> 12:18:08,780
out by pushing this up to GitHub
making this our first smart

12150
12:18:08,780 --> 12:18:11,840
contract GitHub repository, when
it comes to the blockchain, when

12151
12:18:11,840 --> 12:18:14,870
it comes to smart contracts,
interacting with community

12152
12:18:14,900 --> 12:18:18,410
interacting with open source
being a part of GitHub, or git

12153
12:18:18,410 --> 12:18:21,320
labs or whatever Git hosting
service you're using is

12154
12:18:21,320 --> 12:18:24,080
essential to being successful
here. So let's write our

12155
12:18:24,080 --> 12:18:27,500
scripts. And then we'll upload
this to GitHub to start building

12156
12:18:27,530 --> 12:18:30,230
our portfolio. So first, we're
going to create a script to

12157
12:18:30,230 --> 12:18:34,130
interact with our code called
fund dot j s. And this is going

12158
12:18:34,130 --> 12:18:37,550
to be really similar to our
tests. And this way, in the

12159
12:18:37,550 --> 12:18:39,710
future. If we want to just fund
one of our contracts very

12160
12:18:39,710 --> 12:18:42,980
quickly, we can just run this
and we can do it, we're gonna do

12161
12:18:42,980 --> 12:18:45,470
the same thing that we've been
doing, we're gonna do an async

12162
12:18:45,470 --> 12:18:49,100
function main. And down below,
I'm just going to copy paste

12163
12:18:49,100 --> 12:18:51,800
this because we're going to be
copy pasting in a lot. We're

12164
12:18:51,800 --> 12:18:55,310
going to paste this little
syntax here. So let's write a

12165
12:18:55,310 --> 12:18:59,360
script that allows us to fund
our contracts. So first, we're

12166
12:18:59,360 --> 12:19:04,370
going to need const get named
accounts just like in our tests,

12167
12:19:04,730 --> 12:19:15,200
equals require arhat we're gonna
say const Deployer. Equals await

12168
12:19:15,710 --> 12:19:20,570
yet named accounts, just like
that. And then we're gonna say

12169
12:19:20,570 --> 12:19:27,080
const fund me equals await
ethers dot get contract. From

12170
12:19:27,080 --> 12:19:31,820
funding comm a Deployer.
Literally, almost exactly the

12171
12:19:31,820 --> 12:19:36,710
same as our tests, then we'll do
a little console dot log funding

12172
12:19:36,710 --> 12:19:43,190
contract that that and we'll do
const transaction response

12173
12:19:43,910 --> 12:19:49,190
equals await funding dot fund.
And for the value, we'll do

12174
12:19:49,190 --> 12:19:56,240
something like ethers dot utils,
that parse ether of 0.1 or

12175
12:19:56,240 --> 12:19:58,910
something, whatever you want to
do here, we of course, need to

12176
12:19:58,910 --> 12:20:01,790
import ethers, which it looks
like we already have. We'll do

12177
12:20:01,790 --> 12:20:06,950
await transaction response dot
wait for one transaction. And

12178
12:20:06,950 --> 12:20:12,080
then we'll do console dot log
funded, we can run this little

12179
12:20:12,080 --> 12:20:17,990
script by running yarn, RT head
node will run a local node with

12180
12:20:17,990 --> 12:20:21,560
all of our contracts deployed.
We'll see if our script looks

12181
12:20:21,560 --> 12:20:27,830
okay by running yarn, hard hat
run scripts fund dot j s dash

12182
12:20:27,830 --> 12:20:31,940
dash network localhost. And it
looks like it's funding Great.

12183
12:20:32,210 --> 12:20:37,010
Let's now write a withdraw
script withdraw that J S. And we

12184
12:20:37,010 --> 12:20:41,000
can even leave our localhost
Node running because we're going

12185
12:20:41,000 --> 12:20:43,850
to withdraw the funds that we've
just funded it with. So we're

12186
12:20:43,850 --> 12:20:47,300
going to do the exact same setup
here. We can even copy this main

12187
12:20:47,300 --> 12:20:54,140
bit to our withdraw Ah, the top
will do async function main will

12188
12:20:54,140 --> 12:21:00,230
say const deployer equals await,
get named accounts, which wow, I

12189
12:21:00,230 --> 12:21:03,980
hit enter and my VS code auto
imported it, that's pretty nice.

12190
12:21:03,980 --> 12:21:06,080
Maybe yours will too, maybe
won't if it won't, you just

12191
12:21:06,080 --> 12:21:08,240
gotta write it out or copy paste
from the other one. And then

12192
12:21:08,240 --> 12:21:13,610
we'll do cars Funmi equals await
ethers dot get contract on me,

12193
12:21:13,910 --> 12:21:17,480
course. And this is going to be
the exact same. Now we're going

12194
12:21:17,480 --> 12:21:23,390
to do console dot log funding
data dot, we'll say const

12195
12:21:23,690 --> 12:21:29,930
transaction response equals
await on v dot withdraw, await

12196
12:21:30,620 --> 12:21:35,720
transaction response dot wait
one, then console dot log. Got

12197
12:21:35,750 --> 12:21:42,050
it? Back. And we can test this
out by running yarn, hard hit

12198
12:21:42,050 --> 12:21:46,970
run scripts, withdraw dash dash
network localhost, we'll see if

12199
12:21:46,970 --> 12:21:51,530
this works. And cool and our
script is working. Fantastic

12200
12:21:51,530 --> 12:21:54,200
crushed out two scripts
incredibly quickly. And now we

12201
12:21:54,200 --> 12:21:57,560
have a way to easily interact
with our code with our contracts

12202
12:21:57,590 --> 12:22:03,440
if we want to via a script.
There's actually one more thing

12203
12:22:03,440 --> 12:22:05,900
I want to show you before we
actually work and we push all

12204
12:22:05,900 --> 12:22:09,800
this wonderful code up to GitHub
in our package dot JSON. I've

12205
12:22:09,800 --> 12:22:12,350
shown you a little bit of this
before, but we can add this

12206
12:22:12,380 --> 12:22:17,180
scripts section to make our
lives a lot easier and condense

12207
12:22:17,210 --> 12:22:22,130
all these long tests into a yarn
script for us. So usually, what

12208
12:22:22,130 --> 12:22:25,460
you'll see in common package dot
JSON is you'll see a list of

12209
12:22:25,460 --> 12:22:29,000
these in here for people to look
and just automatically run, one

12210
12:22:29,000 --> 12:22:32,720
of the most common ones is going
to be test. And to run test,

12211
12:22:32,930 --> 12:22:37,430
we're going to do yarn, hard hat
test. So now instead of running

12212
12:22:37,430 --> 12:22:40,400
yarn, Hardhead test, someone can
just come to your package once

12213
12:22:40,400 --> 12:22:44,120
this is saved and just run yarn
test. And this will grab this

12214
12:22:44,120 --> 12:22:47,060
test from your script section
and it will run yarn heart at

12215
12:22:47,060 --> 12:22:49,700
test and Bada bing, bada boom,

12216
12:22:49,730 --> 12:22:52,010
okay, cool. What else do we
probably probably want to do in

12217
12:22:52,010 --> 12:22:55,880
here? Well, we probably want to
have a test staging section

12218
12:22:55,940 --> 12:23:02,930
that'll run yarn Hardhead test
dash dash, network Rinkeby. I'm

12219
12:23:02,930 --> 12:23:05,000
not going to run that. But
that's probably something we

12220
12:23:05,000 --> 12:23:07,370
want to have in here, we're
probably going to want some

12221
12:23:07,370 --> 12:23:11,570
linting. So we showed you
briefly that linting thing. So

12222
12:23:11,600 --> 12:23:16,280
we'll have a yarn lint, which
will just run yarn, sole hint.

12223
12:23:16,520 --> 12:23:20,900
And then we'll just have it so
hence the contracts folder. And

12224
12:23:20,900 --> 12:23:24,530
anything that starts out soul.
So now if I run yarn, lint,

12225
12:23:24,800 --> 12:23:29,120
it'll run soul hint, and all of
our code here and it'll give us

12226
12:23:29,120 --> 12:23:32,270
some warnings here, which we can
pretty much all ignore. And

12227
12:23:32,270 --> 12:23:36,290
Solon actually has an auto fix
and auto fix that we can add, by

12228
12:23:36,290 --> 12:23:42,740
doing yarn lint fix, we'll say
yarn. So hint, contracts slash

12229
12:23:42,740 --> 12:23:48,230
start out. So we'll do dash dash
fix. So now we run yarn, lint

12230
12:23:48,230 --> 12:23:52,310
fix, it'll auto fix, which
there's nothing to auto fix. So

12231
12:23:52,670 --> 12:23:55,490
nothing happens. But it's good
to have anyways. And then we can

12232
12:23:55,490 --> 12:23:59,240
do our formatter, we're just
going to format our code format,

12233
12:23:59,600 --> 12:24:03,710
that which will do yarn,
prettier, dash dash write to,

12234
12:24:03,710 --> 12:24:06,800
and we'll just do a period to do
everything. And then we can just

12235
12:24:06,800 --> 12:24:11,240
do yarn format. And it's gonna
fix all of our, it's going to

12236
12:24:11,240 --> 12:24:15,080
fix everything for us, which is
great. And then we finally can

12237
12:24:15,080 --> 12:24:20,630
have coverage. By running yarn
hardhat coverage, now we can

12238
12:24:20,630 --> 12:24:24,350
just run yarn coverage, will
give us this wonderful little

12239
12:24:24,350 --> 12:24:28,250
coverage report. Awesome. So our
packages looking fantastic.

12240
12:24:28,280 --> 12:24:31,130
Maybe we'll even come into
package json. We'll give this a

12241
12:24:31,130 --> 12:24:38,090
name. We'll call this hard hat.
And me give it an author, which

12242
12:24:38,090 --> 12:24:41,000
is going to be your name. So I'm
just gonna say Patrick Collins,

12243
12:24:41,660 --> 12:24:48,740
and we'll give it a version in
here. of 1.0 Point Oh, oops. And

12244
12:24:48,740 --> 12:24:53,840
let's do icons instead of
spaces. Oh, and one more thing.

12245
12:24:53,870 --> 12:24:57,740
We're not using ES lint. So all
this es lint stuff, we can dump

12246
12:24:57,830 --> 12:25:00,710
and we could delete the yarn dot
lock and reinstall. But yeah,

12247
12:25:00,740 --> 12:25:03,590
whatever. We don't have a
readme, but that's okay. If you

12248
12:25:03,590 --> 12:25:06,740
want to go back, like I said, go
check out that best readme

12249
12:25:06,740 --> 12:25:10,310
template and go update your
READMEs to make them look as

12250
12:25:10,310 --> 12:25:12,740
awesome as this, you can do that
as well. But other than that,

12251
12:25:12,770 --> 12:25:19,070
we've got an awesome code repo
here. What do we want to do with

12252
12:25:19,070 --> 12:25:21,770
it? Well, we've been playing
around with GitHub so much,

12253
12:25:21,770 --> 12:25:24,800
we've been looking at all these
good hubs. It's time for us to

12254
12:25:24,800 --> 12:25:29,720
join GitHub with our own with
our first repository. Let's go

12255
12:25:29,720 --> 12:25:33,320
ahead and let's make this happen
in the lesson seven full

12256
12:25:33,320 --> 12:25:36,110
blockchain solidity course, yes,
there is a link to this GitHub

12257
12:25:36,110 --> 12:25:39,080
Quickstart that we're going to
follow to set up our first

12258
12:25:39,080 --> 12:25:42,440
repository. This is going to be
the moment where you are

12259
12:25:42,440 --> 12:25:45,290
starting to build your portfolio
building and GitHub is

12260
12:25:45,290 --> 12:25:48,200
borderline crucial for your
development journey. It's going

12261
12:25:48,200 --> 12:25:50,420
to be your portal folio, it's
going to be where you say, Hey,

12262
12:25:50,690 --> 12:25:53,150
look at all the cool products
that I'm engaging with, that I'm

12263
12:25:53,150 --> 12:25:55,910
working with, that I'm
participating in. If you've

12264
12:25:55,910 --> 12:25:58,670
already made GitHub before, I
highly recommend you still push

12265
12:25:58,670 --> 12:26:01,700
this up to GitHub as proof that
you've done it. And then you can

12266
12:26:01,700 --> 12:26:04,760
also tweet it at me saying, hey,
look how far I've gotten. Look

12267
12:26:04,760 --> 12:26:07,790
where I've done, look at how
fantastic I'm learning smart

12268
12:26:07,790 --> 12:26:10,160
contracts, and be incredibly
excited about now, this

12269
12:26:10,160 --> 12:26:13,130
quickstart will walk you through
creating a repository, creating

12270
12:26:13,130 --> 12:26:16,100
a branch and teaching all this
stuff, we're going to follow the

12271
12:26:16,100 --> 12:26:18,680
instructions from the GitHub
documentation about adding

12272
12:26:18,680 --> 12:26:21,770
locally hosted code to GitHub,
we already have a project, and

12273
12:26:21,770 --> 12:26:25,430
we're just pushing it up. Since
the Windows users are using WsL,

12274
12:26:25,520 --> 12:26:28,370
you can just follow the Mac or
Linux instructions here, the

12275
12:26:28,370 --> 12:26:31,550
first thing that we're going to
do is in your GitHub profile, or

12276
12:26:31,550 --> 12:26:34,760
your GitHub login, we're gonna
hit this little plus thing, and

12277
12:26:34,760 --> 12:26:37,880
hit new repository, you can call
this whatever you want, let's

12278
12:26:37,880 --> 12:26:43,940
call it hard hat, fund me b code
camp, you can put a description

12279
12:26:43,940 --> 12:26:49,910
if you want, learning from
recode camp, and Patrick, about

12280
12:26:49,910 --> 12:26:51,320
smart contracts.

12281
12:26:52,670 --> 12:26:55,070
We'll make it public because we
want other people to see you

12282
12:26:55,070 --> 12:26:57,740
being fantastic and learning
smart contracts. We'll leave

12283
12:26:57,740 --> 12:27:01,820
this blank, and we'll hit Create
repository. Now, this is our

12284
12:27:01,850 --> 12:27:04,970
public code repository. This is
our first one, if you've done

12285
12:27:04,970 --> 12:27:08,000
these already, this will be your
first smart contract one. It

12286
12:27:08,030 --> 12:27:11,810
even has some instructions in
here, too, that teaches us how

12287
12:27:11,810 --> 12:27:14,900
to create a new repository from
the command line, you can follow

12288
12:27:14,900 --> 12:27:18,470
this if you want, or you can
follow like so the first thing

12289
12:27:18,470 --> 12:27:23,000
we're going to do is we're going
to initialize a git branch. And

12290
12:27:23,120 --> 12:27:26,300
from way back when you should
already have Git installed.

12291
12:27:26,390 --> 12:27:29,150
Remember, you can check by
running git dash dash version

12292
12:27:29,150 --> 12:27:32,270
like this. Git is a little
different from GitHub, Git is

12293
12:27:32,270 --> 12:27:35,780
known as version control. And it
allows us to make changes to our

12294
12:27:35,780 --> 12:27:39,200
code, but keep a history of all
the code changes that we've

12295
12:27:39,200 --> 12:27:43,040
made. GitHub is a place where we
can push all of these changes

12296
12:27:43,040 --> 12:27:45,560
and keep track of all of our
code. So the first thing that

12297
12:27:45,560 --> 12:27:48,290
we're going to do is we're going
to create a new branch. And I'm

12298
12:27:48,290 --> 12:27:51,500
not going to explain Git and
working with Git too, too

12299
12:27:51,500 --> 12:27:54,620
deeply. But if you want to learn
about Git Free Code Camp, of

12300
12:27:54,620 --> 12:27:58,130
course, has a video on Git and
GitHub for beginners. So we're

12301
12:27:58,130 --> 12:28:02,000
going to create this new branch
with git init dash b main, now

12302
12:28:02,000 --> 12:28:05,090
your Visual Studio code might
automatically start formatting

12303
12:28:05,090 --> 12:28:07,910
some stuff. And if it does,
that's great. And if it doesn't,

12304
12:28:07,970 --> 12:28:10,670
don't worry about it. But what
you'll see here on the left is

12305
12:28:10,670 --> 12:28:14,930
you'll see some stuff is green,
and some stuff is gray, open

12306
12:28:14,930 --> 12:28:17,960
back up that dot Git ignore,
you'll see that all the gray

12307
12:28:17,960 --> 12:28:21,050
stuff is the stuff that we have
in this dot Git ignore this is

12308
12:28:21,050 --> 12:28:23,840
intentional, this is what we
want. This is just some some

12309
12:28:23,840 --> 12:28:26,270
highlighting saying, hey, this
green stuff is what you're

12310
12:28:26,270 --> 12:28:29,360
working with on GitHub. And this
gray stuff is what you're not

12311
12:28:29,360 --> 12:28:31,970
working with and GitHub. And
that's what we want. You don't

12312
12:28:31,970 --> 12:28:35,420
need to push artifacts, or cash
or coverage or node modules,

12313
12:28:35,420 --> 12:28:39,530
people can install and compile
on their own machines, we

12314
12:28:39,560 --> 12:28:43,070
definitely don't want to push up
our Dotty and V if we're using a

12315
12:28:43,070 --> 12:28:46,070
Dotty and V. And we don't really
need to push up coverage dot

12316
12:28:46,070 --> 12:28:50,420
JSON, either the rest of this we
do. So now what's next, after we

12317
12:28:50,450 --> 12:28:54,380
initialize our main branch, you
now should be able to run git

12318
12:28:54,380 --> 12:28:59,450
status in your terminal and see
this huge red output of all

12319
12:28:59,450 --> 12:29:03,140
these things that are untracked,
and we don't have any commits

12320
12:29:03,140 --> 12:29:07,370
for, what we can do now is we
can stage all of our code with

12321
12:29:07,370 --> 12:29:11,570
git add period, and then commit
it with Git commit, we're going

12322
12:29:11,570 --> 12:29:14,420
to run these one at a time
instead of together. Before I

12323
12:29:14,420 --> 12:29:17,570
run git add, I'm going to add
deployments to this list too,

12324
12:29:17,570 --> 12:29:19,760
because GitHub doesn't really
need to know about all the

12325
12:29:19,760 --> 12:29:22,340
different deployments I make,
especially when I make a ton of

12326
12:29:22,340 --> 12:29:24,800
deployments to my local hosts,
they don't need to know. So

12327
12:29:24,800 --> 12:29:28,880
we're going to add that to, then
we're going to run git add dot.

12328
12:29:29,090 --> 12:29:34,400
And if we do a git status, now,
we can see all of our code has

12329
12:29:34,400 --> 12:29:38,420
been staged for being committed
for being a part of this history

12330
12:29:38,720 --> 12:29:41,810
of our code. And then take a
quick look at all these files

12331
12:29:41,810 --> 12:29:46,220
and make sure your dot E and V
file is not and never in here.

12332
12:29:46,340 --> 12:29:49,370
So now we're going to run git
commit dash m and then this

12333
12:29:49,370 --> 12:29:55,580
message for our commit, okay, so
we'll run git commit dash m, we

12334
12:29:55,580 --> 12:29:59,180
can say, initial commit, or
whatever you want in this

12335
12:29:59,180 --> 12:30:02,000
message here, first commit,
initial commit, who cares, and

12336
12:30:02,000 --> 12:30:04,490
it's gonna say, create mode,
blah, blah, blah, for all of

12337
12:30:04,490 --> 12:30:08,120
these files. And if we do git
status, now, it's blank on

12338
12:30:08,120 --> 12:30:11,120
branch main, nothing to commit.
And then you might get something

12339
12:30:11,120 --> 12:30:13,730
like this. If you've never
worked with Git before your name

12340
12:30:13,730 --> 12:30:16,490
and email were added
automatically. We're a little

12341
12:30:16,490 --> 12:30:20,060
bit confused here. We'll talk
about this in just a second. So

12342
12:30:20,060 --> 12:30:23,630
next, what we can do is we're
actually going to copy the URL

12343
12:30:23,660 --> 12:30:27,110
of our GitHub repo. So you can
grab that just by copying here

12344
12:30:27,140 --> 12:30:30,620
or right at the top, that URL
right there. And what we're

12345
12:30:30,620 --> 12:30:33,710
going to do is we're going to
add this as a remote repo. To do

12346
12:30:33,710 --> 12:30:39,380
that. We'll do git remote add,
and we'll give this remote repo

12347
12:30:39,410 --> 12:30:44,330
a name. For us. We'll say origin
and then we'll paste that URL

12348
12:30:44,330 --> 12:30:48,770
there. We're now saying the the
origin remote repo is good.

12349
12:30:48,770 --> 12:30:54,020
Gonna be at this URL, we run git
remote dash v, we can see that

12350
12:30:54,230 --> 12:30:58,850
the origin repo for fetching is
at this branch. And the origin

12351
12:30:58,850 --> 12:31:02,600
repo for pushing is also at this
branch. So when we want to get

12352
12:31:02,600 --> 12:31:06,650
new code, a fetch code will
fetch it from here. And if we

12353
12:31:06,650 --> 12:31:09,950
want to push code up, we want to
give code to the GitHub. We'll

12354
12:31:09,980 --> 12:31:13,490
also get it from here. So now
we've set the new remote with

12355
12:31:13,490 --> 12:31:17,990
that remote URL. Now we're going
to actually push the changes to

12356
12:31:17,990 --> 12:31:22,730
github.com. And the way we do
that is with Git push, and we

12357
12:31:22,730 --> 12:31:25,250
pick which remote we want to
push to, and we're going to push

12358
12:31:25,250 --> 12:31:29,060
the origin. And then which
branch we want to push to which

12359
12:31:29,060 --> 12:31:32,090
we're going to push to Maine,
it'll probably prompt you for

12360
12:31:32,090 --> 12:31:34,520
your username and your password,
and maybe your email and

12361
12:31:34,520 --> 12:31:36,530
everything. Now, if
authentication doesn't work for

12362
12:31:36,530 --> 12:31:39,410
you, for some reason, you can
come over to Settings. Or if you

12363
12:31:39,410 --> 12:31:44,090
scroll down to developer
settings, Personal Access Tokens

12364
12:31:44,090 --> 12:31:46,760
and create generate new token,
some token,

12365
12:31:48,020 --> 12:31:51,980
give yourself repo access, write
access, and hit Generate token.

12366
12:31:52,610 --> 12:31:55,580
And try to use this token as
your password. Instead, be sure

12367
12:31:55,580 --> 12:31:58,970
to use the GitHub documentation
and the GitHub discussion

12368
12:31:59,000 --> 12:32:01,760
associated with this course, if
you get lost or if something

12369
12:32:01,760 --> 12:32:05,540
doesn't work, as shown here. But
once it's done, once you add all

12370
12:32:05,540 --> 12:32:08,270
that information in correctly,
you come back to your get up and

12371
12:32:08,270 --> 12:32:11,930
you will have your first GitHub
repo with all the code and

12372
12:32:11,930 --> 12:32:15,650
everything in it like this. And
once you complete this step,

12373
12:32:15,650 --> 12:32:18,770
once you do this, you should
absolutely celebrate. If you

12374
12:32:18,770 --> 12:32:21,770
like, you can shoot a tweet web
three community in the

12375
12:32:21,770 --> 12:32:24,260
blockchain community is
absolutely this collaborative

12376
12:32:24,260 --> 12:32:26,660
space. So Twitter crypto is
where a lot of these people

12377
12:32:26,660 --> 12:32:30,500
congregate to share ideas. So
definitely be sure to celebrate

12378
12:32:30,500 --> 12:32:33,200
and share this and be really,
really excited. And shoot a

12379
12:32:33,200 --> 12:32:35,990
tweet out like this. Give your
friends a high five, share it on

12380
12:32:35,990 --> 12:32:38,810
Twitter, share it on Discord
shared on Reddit, be excited for

12381
12:32:38,810 --> 12:32:41,510
how far you've gotten, we've got
a lot more to go. But by

12382
12:32:41,510 --> 12:32:44,690
completing this part, you have
done fantastically, and I'm so

12383
12:32:44,690 --> 12:32:47,660
excited for you to start the
next section. Now, we're not

12384
12:32:47,660 --> 12:32:50,150
going to go over the TypeScript
addition to this because there's

12385
12:32:50,150 --> 12:32:53,210
nothing really new here.
However, again, if you want to

12386
12:32:53,210 --> 12:32:56,060
see TypeScript, feel free to
jump into the GitHub repository

12387
12:32:56,090 --> 12:32:57,380
associated with this course.

12388
12:33:00,250 --> 12:33:03,610
Alright, awesome. You've just
completed Lesson Seven, the

12389
12:33:03,610 --> 12:33:07,210
heart had fun me. And now it's
time to move on to lesson eight,

12390
12:33:07,210 --> 12:33:11,080
which is going to be our HTML
slash JavaScript to fund me, you

12391
12:33:11,080 --> 12:33:13,360
can find all the code for what
we're about to go through, of

12392
12:33:13,360 --> 12:33:16,810
course, on my GitHub repo. And
for this section, we're now

12393
12:33:16,810 --> 12:33:20,050
going to start to see some of
the differences between Node js

12394
12:33:20,050 --> 12:33:23,080
between that back end
JavaScript, and JavaScript in

12395
12:33:23,080 --> 12:33:25,540
the browser or front end
JavaScript. And if you come to

12396
12:33:25,540 --> 12:33:28,900
the GitHub repo associated with
this lesson, our main version

12397
12:33:28,900 --> 12:33:32,710
we'll be using what's considered
better front end JavaScript. But

12398
12:33:32,710 --> 12:33:36,010
we'll also have a no JS
addition, as well, if some of

12399
12:33:36,010 --> 12:33:38,650
the front end JavaScript is
really confusing, and you'll see

12400
12:33:38,650 --> 12:33:41,680
what I mean with some of those
differences very soon. Now,

12401
12:33:41,680 --> 12:33:43,600
people can programmatically
interact with our smart

12402
12:33:43,600 --> 12:33:47,170
contracts at any time. However,
most of our users are not

12403
12:33:47,170 --> 12:33:49,900
compete developers. So we need
to create a website, we need to

12404
12:33:49,900 --> 12:33:52,690
create a user interface for them
to interact with our smart

12405
12:33:52,690 --> 12:33:55,090
contracts and interact with our
protocols. And that's what this

12406
12:33:55,090 --> 12:33:57,550
section is going to teach us,
it's going to be an introduction

12407
12:33:57,790 --> 12:34:00,490
to building these fullstack.
building these front ends on top

12408
12:34:00,490 --> 12:34:03,100
of our smart contracts. Now, I
wanted to show you what this is

12409
12:34:03,100 --> 12:34:06,130
actually going to look like when
we finish it. Because here,

12410
12:34:06,130 --> 12:34:09,130
we're actually going to make our
first front end our first

12411
12:34:09,130 --> 12:34:12,820
website using the blockchain
using web three. And it's going

12412
12:34:12,820 --> 12:34:16,000
to be an incredibly minimalistic
website. As you can see right

12413
12:34:16,000 --> 12:34:18,400
here, we're not going to have
any styling, we're just going to

12414
12:34:18,400 --> 12:34:21,580
show you how to get the
functionality. And additionally,

12415
12:34:21,610 --> 12:34:23,920
we're going to do a couple of
things that aren't really

12416
12:34:23,920 --> 12:34:27,100
recommended and are definitely
not best practices. The reason

12417
12:34:27,100 --> 12:34:29,350
we're going to do it like this
is the same reason that in math

12418
12:34:29,350 --> 12:34:31,390
class, before you learn the
tricks for derivatives, you

12419
12:34:31,390 --> 12:34:34,270
learn what a derivative actually
is. We're teaching it like this

12420
12:34:34,270 --> 12:34:37,090
first, so that you can
understand what's going on on

12421
12:34:37,090 --> 12:34:39,790
the websites when you interact
with them. And when you work

12422
12:34:39,790 --> 12:34:42,730
with them. We saw already with
Foston, touching the link where

12423
12:34:42,730 --> 12:34:45,310
we can connect our wallets and
we can work with the faucets.

12424
12:34:45,490 --> 12:34:48,250
All decentralized applications
have this website and have this

12425
12:34:48,280 --> 12:34:50,980
setup where you connect your
wallet and then you interact by

12426
12:34:50,980 --> 12:34:53,560
clicking buttons, which make
these function calls to the

12427
12:34:53,560 --> 12:34:56,470
blockchain. And here's going to
be our minimalistic website that

12428
12:34:56,470 --> 12:34:59,410
does exactly that. So this
section is just going to teach

12429
12:34:59,410 --> 12:35:01,750
you what's going on under the
hood. So you can really

12430
12:35:01,780 --> 12:35:04,930
understand how to build these
applications at a professional

12431
12:35:04,930 --> 12:35:07,900
level. So for this section, if
you don't want to code along

12432
12:35:07,900 --> 12:35:10,780
with me, you definitely don't
have to however, coding along

12433
12:35:10,780 --> 12:35:13,600
with me will definitely ingrain
everything in your memory here.

12434
12:35:13,630 --> 12:35:17,320
So here's what an application is
going to look like. We have our

12435
12:35:17,320 --> 12:35:20,680
website here, which is connected
to our hard hat, our local

12436
12:35:20,680 --> 12:35:24,460
blockchain, but it's gonna run
exactly the same as if it was on

12437
12:35:24,460 --> 12:35:27,580
a real test net, the first thing
you'll notice is in our meta

12438
12:35:27,580 --> 12:35:31,330
mask, we are not connected. And
we'll go ahead and hit Connect,

12439
12:35:31,360 --> 12:35:34,420
and meta masks will pop up
asking us if we want to connect,

12440
12:35:34,540 --> 12:35:38,260
we'll go ahead and connect to
it. And now we'll be able to

12441
12:35:38,260 --> 12:35:40,750
interact with our heart at
Funmi. You'll notice two buttons

12442
12:35:40,750 --> 12:35:43,030
here are functions that we're
familiar with, we have our

12443
12:35:43,030 --> 12:35:45,310
withdrawal function, which is
going to be our withdrawal

12444
12:35:45,310 --> 12:35:48,340
function that we just created.
And then of course, we also have

12445
12:35:48,370 --> 12:35:52,330
our fund function here where we
push or we send Aetherium or

12446
12:35:52,540 --> 12:35:56,140
Matic or whatever, native
blockchain token to our smart

12447
12:35:56,140 --> 12:35:58,630
contract. So we can do it
through this user interface. So

12448
12:35:58,630 --> 12:36:01,180
once we're connected, if we want
to see the balance, we can

12449
12:36:01,180 --> 12:36:04,660
actually right click, hit
Inspect, come over to our

12450
12:36:04,660 --> 12:36:08,500
console. And we'll print out to
the JavaScript console, the

12451
12:36:08,500 --> 12:36:12,040
current balance of our smart
contract. So nobody has funded

12452
12:36:12,040 --> 12:36:15,130
this yet, we can come down, we
can choose an amount we want to

12453
12:36:15,130 --> 12:36:19,210
fund. So for example, maybe 0.1,
eath, we'll go ahead, we'll hit

12454
12:36:19,210 --> 12:36:22,300
fund, meta masks will pop up,
we'll get a little council

12455
12:36:22,300 --> 12:36:25,720
saying funding with 0.1. And
it'll give us all the

12456
12:36:25,720 --> 12:36:30,190
transaction details that we need
to send 0.1 eath, to our smart

12457
12:36:30,190 --> 12:36:33,580
contract, we can go ahead and
hit Confirm. And after it's been

12458
12:36:33,580 --> 12:36:36,910
confirmed after it's been mined
on our local blockchain, we had

12459
12:36:36,910 --> 12:36:41,260
get balance, we now see that
it's 0.1. We could call fund

12460
12:36:41,260 --> 12:36:44,050
again, we could have multiple
funders, we could switch between

12461
12:36:44,050 --> 12:36:46,690
different accounts and fund with
different amounts. And we can

12462
12:36:46,690 --> 12:36:49,480
see that funding amount
increase, then we can call the

12463
12:36:49,480 --> 12:36:52,510
withdrawal function. As long as
we're the owner, we can confirm

12464
12:36:52,540 --> 12:36:54,490
and we can pull out all the
money out of our funding

12465
12:36:54,490 --> 12:36:57,370
contract. And we'll get balance.
Now we'll see the balance is

12466
12:36:57,370 --> 12:37:00,370
reset to zero. So this is what
we're going to be building. Are

12467
12:37:00,370 --> 12:37:01,930
you ready? I sure am.

12468
12:37:01,960 --> 12:37:04,810
Let's get into it. This is the
introduction to building

12469
12:37:04,810 --> 12:37:07,810
websites with web three. All the
information here is available in

12470
12:37:07,810 --> 12:37:10,840
our GitHub repo, so feel free to
follow along there. Alright, so

12471
12:37:10,840 --> 12:37:14,440
if you're in your heart head
Funmi dash Free Code Camp repo,

12472
12:37:14,470 --> 12:37:17,080
we're still going to want to
have this open as well. But

12473
12:37:17,080 --> 12:37:20,290
we're also going to want to
create a new Visual Studio code

12474
12:37:20,320 --> 12:37:24,490
for working with our new repo.
So let's go ahead and CD down a

12475
12:37:24,490 --> 12:37:31,630
directory. We'll type MK dir,
we'll call this HTML, Fund Me

12476
12:37:32,050 --> 12:37:36,460
Free Code Camp. We'll cd into
that. And we'll open this up by

12477
12:37:36,460 --> 12:37:40,870
typing code period. You can also
do File Open Folder, but we just

12478
12:37:40,870 --> 12:37:45,460
want to open this up in a new
Visual Studio Code. New VS code

12479
12:37:45,460 --> 12:37:49,450
will pop up but before we flip
over to that, we do want to CD

12480
12:37:49,450 --> 12:37:54,550
down CD back into hard hat fun
we Free Code Camp because we are

12481
12:37:54,550 --> 12:37:57,130
still going to use everything in
here. We're still going to

12482
12:37:57,130 --> 12:38:01,120
deploy In a smart contract using
this folder and using this repo,

12483
12:38:01,180 --> 12:38:04,120
when you're building daps, or
websites that are connected to

12484
12:38:04,120 --> 12:38:08,140
the blockchain, you'll usually
have two repositories or repos.

12485
12:38:08,470 --> 12:38:10,990
One is going to be for the smart
contracts, like what we see

12486
12:38:10,990 --> 12:38:13,690
here. This is our repo that has
all the code for our smart

12487
12:38:13,690 --> 12:38:16,480
contracts. And then you'll also
have one for the front end slash

12488
12:38:16,480 --> 12:38:18,880
website. And it's going to be
the combination of these two

12489
12:38:18,880 --> 12:38:22,120
repos, which makes up the full
stack. So when people are

12490
12:38:22,120 --> 12:38:25,360
talking about full stack,
they're talking about the smart

12491
12:38:25,360 --> 12:38:31,150
contracts, which is going to be
our back end, plus, plus our

12492
12:38:31,150 --> 12:38:36,010
HTML slash JavaScript slash
website stuff, which is going to

12493
12:38:36,010 --> 12:38:39,910
be our front end. So smart
contracts are the back end, HTML

12494
12:38:39,910 --> 12:38:42,610
slash JavaScript slash website
stuff is going to be our front

12495
12:38:42,610 --> 12:38:45,640
end. So we have our back end
already. And now we're going to

12496
12:38:45,640 --> 12:38:48,040
build our front end, we want to
keep this up because we're going

12497
12:38:48,040 --> 12:38:51,940
to need it to test and interact
with our front end. Awesome. So

12498
12:38:52,150 --> 12:38:56,650
we have this new folder now,
HTML Funmi, Free Code Camp. Now

12499
12:38:56,650 --> 12:38:59,860
this course is not a how to
learn front end course, we are

12500
12:38:59,860 --> 12:39:02,980
going to teach you a number of
front end concepts. But if you

12501
12:39:02,980 --> 12:39:06,670
want to learn a full traditional
front end course, once again,

12502
12:39:06,670 --> 12:39:08,920
you can check out Free Code
Camp, they've got a ton of

12503
12:39:08,920 --> 12:39:11,710
fantastic tutorials, I'm
teaching you front end, if you

12504
12:39:11,710 --> 12:39:13,720
go ahead and follow along with
me, though, you'll definitely

12505
12:39:13,720 --> 12:39:17,200
get a basic understanding of
front end as well as front ends

12506
12:39:17,200 --> 12:39:19,690
and how it relates to our smart
contracts. Additionally, you

12507
12:39:19,690 --> 12:39:22,450
don't have to do the front end
parts or the full stack parts.

12508
12:39:22,480 --> 12:39:25,900
If you only want to take this
course, to learn back end and to

12509
12:39:25,900 --> 12:39:28,990
learn JavaScript, and to learn
solidity and learn how to do

12510
12:39:28,990 --> 12:39:31,150
these smart contracts
programmatically, then you can

12511
12:39:31,180 --> 12:39:34,210
absolutely skip these front end
parts. However, if you want to

12512
12:39:34,210 --> 12:39:36,640
learn to build exciting
websites, and you want to have

12513
12:39:36,670 --> 12:39:39,160
other people other than
developers interact with your

12514
12:39:39,160 --> 12:39:41,800
protocols, you definitely want
to watch this part. Now before

12515
12:39:41,800 --> 12:39:44,590
we actually jump in here and
start writing our code. We need

12516
12:39:44,590 --> 12:39:48,880
to understand what exactly is
going on when work with one of

12517
12:39:48,880 --> 12:39:51,910
these websites that use the
blockchain. So I actually made a

12518
12:39:51,910 --> 12:39:55,030
video about this recently. So
let's watch a segment from that

12519
12:39:55,030 --> 12:39:57,430
really quick, just so that we
can get up to speed with with

12520
12:39:57,430 --> 12:40:00,520
exactly what's going on behind
the scenes of these websites

12521
12:40:00,730 --> 12:40:06,040
that interact with the
blockchain. All right. So here

12522
12:40:06,040 --> 12:40:10,000
we are, with a website or a
front end on top of some smart

12523
12:40:10,000 --> 12:40:12,430
contracts that we've deployed,
doesn't really matter what it is

12524
12:40:12,430 --> 12:40:16,240
right now. This is typically the
interface that you'll see boiled

12525
12:40:16,240 --> 12:40:20,350
down to a really, really
minimalistic level. Typically,

12526
12:40:20,350 --> 12:40:22,270
you'll see something like
connect function, right, and

12527
12:40:22,270 --> 12:40:25,180
Metamask, or some other wallet
connector thing will pop up,

12528
12:40:25,390 --> 12:40:28,420
we'll hit Next we'll connect
here might even say something

12529
12:40:28,420 --> 12:40:30,970
like connected. And we can also
execute functions, we can

12530
12:40:31,000 --> 12:40:33,580
interact with our smart
contracts, we can confirm, etc.

12531
12:40:33,610 --> 12:40:35,950
Right? This is something you
might see something like Avi

12532
12:40:35,950 --> 12:40:39,010
right, I'll hit Connect on the
application, it'll say, hey, how

12533
12:40:39,010 --> 12:40:41,890
would you like to connect? I'll
choose Metamask. I'm going to

12534
12:40:41,950 --> 12:40:45,040
change my Metamask to main net,
but you get the picture, right?

12535
12:40:45,040 --> 12:40:48,760
This is a simple example of what
that would look like. So what is

12536
12:40:48,820 --> 12:40:52,630
actually going on in the browser
when we connect what is actually

12537
12:40:52,630 --> 12:40:55,450
going on? And what do we
actually need to do, we're going

12538
12:40:55,450 --> 12:40:59,500
to right click, hit Inspect. And
on the right side, we're gonna

12539
12:40:59,500 --> 12:41:04,810
see our debugger here. Now if we
go over to sources, on the top

12540
12:41:04,810 --> 12:41:09,790
of our browser, you'll see a few
things. If you look down over

12541
12:41:09,790 --> 12:41:14,050
here, right, we'll see this URL,
right, which right now is going

12542
12:41:14,050 --> 12:41:18,010
to be my localhost. And we'll
also see meta mask and Phantom

12543
12:41:18,010 --> 12:41:20,710
and a whole bunch of other
stuff. These other things that

12544
12:41:20,710 --> 12:41:24,130
we see here are going to be
what's injected from our browser

12545
12:41:24,130 --> 12:41:27,130
extensions. The reason we see
this meta mask thing here is

12546
12:41:27,130 --> 12:41:30,250
because I've meta mask
installed, right? The reason I

12547
12:41:30,250 --> 12:41:33,160
see Phantom here is because I
have the Phantom app installed.

12548
12:41:33,910 --> 12:41:37,630
Meta masks, of course, being an
EVM, wallet and Phantom being a

12549
12:41:37,630 --> 12:41:40,990
Solana based wallet. Now what
happens when we have these

12550
12:41:41,260 --> 12:41:45,010
extensions installed is they
automatically get injected into

12551
12:41:45,040 --> 12:41:49,240
a window object in JavaScript,
and in fact, we scroll down

12552
12:41:51,520 --> 12:41:54,880
to here in the console, again,
you can find console, you can

12553
12:41:54,880 --> 12:41:59,020
click here and click anything up
there. And we type in window.

12554
12:41:59,950 --> 12:42:02,890
We'll see we have this big
window object with all this

12555
12:42:02,890 --> 12:42:06,880
stuff, right? This window object
represents this our window

12556
12:42:06,970 --> 12:42:09,760
basically right? Now if we
scroll all the way to the bottom

12557
12:42:11,350 --> 12:42:16,180
and we do window dot Aetherium.
We also see an object here. Now

12558
12:42:16,180 --> 12:42:20,800
this window dot Aetherium object
only exists if you have a meta

12559
12:42:20,800 --> 12:42:25,210
mask or meta mask like browser
or if you want to look at some

12560
12:42:25,210 --> 12:42:29,320
other web three wallet you do
window dot Solana. So Alana

12561
12:42:30,010 --> 12:42:33,340
right and we see this window dot
Solana. Now let's look at a

12562
12:42:33,340 --> 12:42:36,610
browser that doesn't have
Metamask or phantom installed.

12563
12:42:36,640 --> 12:42:38,830
What do you think is going to
happen in the window now let's

12564
12:42:38,830 --> 12:42:41,140
go ahead and right click hit
Inspect. We'll go to the

12565
12:42:41,140 --> 12:42:45,130
console. Now let's see what's
going on in here. If we go to

12566
12:42:45,130 --> 12:42:48,880
sources, we first off we don't
see that Metamask or that Solana

12567
12:42:48,880 --> 12:42:52,990
source here. And if we go to
console, we still see window if

12568
12:42:52,990 --> 12:42:55,870
I let me zoom in a little bit.
We still see window here. But if

12569
12:42:55,870 --> 12:42:59,920
I do window dot Aetherium If we
get nothing, or if I do window

12570
12:42:59,920 --> 12:43:04,450
dot Solana, we also get nothing.
So in order for our browsers to

12571
12:43:04,450 --> 12:43:08,110
know that there's a Metamask, or
that there's a phantom, those

12572
12:43:08,110 --> 12:43:11,500
extensions automatically add
these to our window objects, and

12573
12:43:11,500 --> 12:43:14,740
that's something that we can
check for in our JavaScript. The

12574
12:43:14,740 --> 12:43:17,500
reason these wallets are so
important is built into them

12575
12:43:17,530 --> 12:43:21,310
underneath the hood, they have a
blockchain node connected to

12576
12:43:21,310 --> 12:43:24,340
them. And in order to interact
with the blockchain, we always

12577
12:43:24,340 --> 12:43:28,570
need a note. And you might have
seen URLs from alchemy, or in

12578
12:43:28,570 --> 12:43:31,600
FIRA because you need them to
interact with the blockchain,

12579
12:43:32,050 --> 12:43:35,410
Alchemy, and infura are examples
of third party blockchains that

12580
12:43:35,650 --> 12:43:38,530
you can interact with and
basically rent, right. But you

12581
12:43:38,530 --> 12:43:42,340
need them to create a provider,
or a node to send your

12582
12:43:42,340 --> 12:43:45,790
transactions to. So you could do
it in JavaScript, like something

12583
12:43:45,790 --> 12:43:48,370
like this is the alchemy
documentation where you take

12584
12:43:48,370 --> 12:43:52,600
that alchemy URL, you stick it
into some object and use that to

12585
12:43:52,600 --> 12:43:56,410
send your transaction. This is a
way that you could do it in the

12586
12:43:56,410 --> 12:43:59,440
back end. But on the front end,
what you normally want to use is

12587
12:43:59,440 --> 12:44:03,040
you just want to use the user's
Metamask, or their Solana or

12588
12:44:03,040 --> 12:44:06,970
their wallet as the main wallet.
Now, there are a ton of other

12589
12:44:06,970 --> 12:44:09,610
different types of wallets to
connect, like ledger, mu,

12590
12:44:09,610 --> 12:44:13,210
Coinbase, wallet, connect, etc.
And there are different ways to

12591
12:44:13,210 --> 12:44:17,380
set those up. But they all do
the same thing where they expose

12592
12:44:17,410 --> 12:44:21,460
some URL, they expose some node
under the hood, they give us

12593
12:44:21,460 --> 12:44:25,960
that URL. They give us that
provider. The way metamath Does

12594
12:44:25,960 --> 12:44:30,580
it is with window dot Aetherium.
Boom, this is now our URL. This

12595
12:44:30,580 --> 12:44:34,480
is now our connection. In fact,
if you go up to your Metamask,

12596
12:44:35,380 --> 12:44:41,740
hit the little three dots,
expand view. hit Add Network,

12597
12:44:42,160 --> 12:44:45,820
and then just hit the X so we
can get to networks. You can see

12598
12:44:45,850 --> 12:44:49,960
all of these blockchains that I
have in here all have an RPC

12599
12:44:49,960 --> 12:44:54,580
URL, this the HTTP RPC URL
connection of the blockchain No,

12600
12:44:54,580 --> 12:44:56,980
that's running. I happen to have
one running locally right now.

12601
12:44:59,260 --> 12:45:03,070
All of these also have a node
RPC URL and you can actually see

12602
12:45:03,070 --> 12:45:06,280
them right in your meta mask
right. This is connected to in

12603
12:45:06,280 --> 12:45:10,240
Fira, these are all connected to
in Fira. It's all the exact same

12604
12:45:10,240 --> 12:45:13,270
thing. Meta mask just has a
really nice way of taking that

12605
12:45:13,270 --> 12:45:16,960
URL, sticking it in the browser
for us in this window dot

12606
12:45:16,960 --> 12:45:21,310
Aetherium or window dot Solana
you know or whatever. So this is

12607
12:45:21,310 --> 12:45:23,920
the main thing that we need to
know we need. We always need a

12608
12:45:23,920 --> 12:45:27,460
connection with the blockchain.
And these browser wallets are an

12609
12:45:27,490 --> 12:45:31,360
easy way to do that. Make sense?
Great. Let's take this knowledge

12610
12:45:31,360 --> 12:45:32,230
now. And let's

12611
12:45:32,260 --> 12:45:38,920
apply it. So in here, let's make
a quick readme.md. Just so we

12612
12:45:38,920 --> 12:45:40,990
can talk about what we're going
to be making here. So in this

12613
12:45:40,990 --> 12:45:44,620
section, we're gonna be using
raw HTML slash JavaScript in

12614
12:45:44,620 --> 12:45:47,470
conjunction with our smart
contracts to build this website.

12615
12:45:47,590 --> 12:45:52,000
Later on. We will use next Jas
slash react, which is a more

12616
12:45:52,000 --> 12:45:55,390
modern stack to build our
websites here. But learning

12617
12:45:55,420 --> 12:45:57,220
understanding how to do
everything with HTML and

12618
12:45:57,220 --> 12:46:01,270
JavaScript first, is going to
make our lives a lot easier come

12619
12:46:01,270 --> 12:46:05,440
later on down the road. But as
we know, all websites use HTML

12620
12:46:05,560 --> 12:46:08,620
as kind of their scaffolding for
what they look like. So let's go

12621
12:46:08,620 --> 12:46:12,610
ahead and create our HTML for
our website, we'll call it index

12622
12:46:12,640 --> 12:46:17,680
dot HTML. And this is going to
be the basic scaffolding or the

12623
12:46:17,680 --> 12:46:21,130
basic bones of what our website
is going to look like. Now, in

12624
12:46:21,130 --> 12:46:24,940
VS code, if you go ahead and
just type exclamation mark index

12625
12:46:24,940 --> 12:46:28,240
dot HTML, and you click the
first thing that pops up, it'll

12626
12:46:28,270 --> 12:46:32,350
automatically populate your code
your file here with some basic

12627
12:46:32,380 --> 12:46:36,760
HTML setup. If it doesn't do
this for you, feel free to copy

12628
12:46:36,760 --> 12:46:40,360
paste the basic setup from the
GitHub repository associated

12629
12:46:40,360 --> 12:46:43,840
with this course, we have our
doctype. HTML, we have some HTML

12630
12:46:43,840 --> 12:46:46,600
tags telling us that everything
in between here is going to be

12631
12:46:46,660 --> 12:46:49,600
an HTML, which is great.
However, for simplicity, we

12632
12:46:49,600 --> 12:46:51,550
don't need most of this. So
we're going to make this a

12633
12:46:51,550 --> 12:46:54,160
little bit easier. We're going
to delete this line, this line

12634
12:46:54,160 --> 12:46:56,950
and this line. And we're just
going to change the title to

12635
12:46:57,220 --> 12:47:01,090
fund me app. And then inside of
our body, we can do something

12636
12:47:01,090 --> 12:47:05,410
like or Hello. And now we have
the bare bones to create a

12637
12:47:05,410 --> 12:47:09,160
website just with this. Now to
show this on a website, we can

12638
12:47:09,160 --> 12:47:12,040
do one of two things. If you are
using Visual Studio code, I'm

12639
12:47:12,040 --> 12:47:16,240
going to recommend you install
the extension live server. And

12640
12:47:16,240 --> 12:47:18,610
it looks like this. And I'll
have the extension ID for this

12641
12:47:18,610 --> 12:47:21,310
extension in the GitHub
repository associated with this

12642
12:47:21,310 --> 12:47:23,920
course, this is going to allow
us to easily spin up an HTML

12643
12:47:23,920 --> 12:47:27,070
website. So we'll go ahead and
install this. And if you're not

12644
12:47:27,070 --> 12:47:29,890
using Visual Studio Code, I'll
show you a different way in just

12645
12:47:29,890 --> 12:47:33,340
a second. Once this is
installed, you should have this

12646
12:47:33,340 --> 12:47:36,880
little go live button at the
bottom. And if you don't, you

12647
12:47:36,880 --> 12:47:39,460
can always open up your command
palette, which again, you can

12648
12:47:39,460 --> 12:47:43,240
open up by hitting View command
palette, and you can type in

12649
12:47:43,270 --> 12:47:46,810
live server and just say open
with live server but we're going

12650
12:47:46,810 --> 12:47:49,240
to just click this go live
button. And it's going to say

12651
12:47:49,240 --> 12:47:53,680
starting and it's actually going
to open up your browser with our

12652
12:47:53,710 --> 12:47:57,460
index dot HTML. We can actually
see our website is being called

12653
12:47:57,490 --> 12:48:02,500
Save on 120 7.0 point 0.1. This
is known as the loopback, or

12654
12:48:02,530 --> 12:48:06,430
local host endpoint, we're on
port 5501. If you're not

12655
12:48:06,430 --> 12:48:09,010
familiar with the ports, don't
worry about that for now, we

12656
12:48:09,010 --> 12:48:12,310
have our index dot HTML here.
And if we change this to

12657
12:48:12,340 --> 12:48:16,630
something like what's good, we
hit save. If it doesn't

12658
12:48:16,630 --> 12:48:19,060
automatically refresh, we'd come
over here and refresh. And we'd

12659
12:48:19,060 --> 12:48:21,640
see that being reflected here.
If you've never created a

12660
12:48:21,640 --> 12:48:23,980
website before, you've
essentially just done it,

12661
12:48:24,040 --> 12:48:28,150
congratulations, you might get
this.vs code folder. a.vs code

12662
12:48:28,180 --> 12:48:32,680
folder allows you to make
settings specifically for the

12663
12:48:32,680 --> 12:48:35,530
repo that you're working with,
for your code editor for VS

12664
12:48:35,530 --> 12:48:38,740
code, but we're going to mostly
ignore it for now. Now, if

12665
12:48:38,740 --> 12:48:41,680
you're not using Visual Studio
Code, what you can do is you can

12666
12:48:41,680 --> 12:48:45,610
just run this in the browser. So
one thing you could do is you

12667
12:48:45,610 --> 12:48:48,340
could right click it, and I'm
using a Mac. So I'm going to hit

12668
12:48:48,340 --> 12:48:52,270
Reveal in Finder, aka reveal
where it's located. And you can

12669
12:48:52,270 --> 12:48:54,970
just double click it, and boom,
now it's running right in your

12670
12:48:54,970 --> 12:48:57,790
browser. Instead of pointing to
your localhost, it's going to be

12671
12:48:57,790 --> 12:49:01,660
pointing directly to your local
file path. Now one final version

12672
12:49:01,660 --> 12:49:03,970
that we could do that I'm going
to highly recommend you don't

12673
12:49:03,970 --> 12:49:06,850
do. But it's another option,
we're actually going to download

12674
12:49:06,850 --> 12:49:10,180
a package for you using no Jas,
which allows us to serve up

12675
12:49:10,210 --> 12:49:12,910
HTTP. And we're gonna install it
the exact same way we've

12676
12:49:12,910 --> 12:49:17,620
installed our other packages, we
can do yarn, add dash dash dev

12677
12:49:17,680 --> 12:49:22,870
HTTP hyphen server. And you may
still want to add it anyways.

12678
12:49:22,900 --> 12:49:26,470
But now, we'll get some node
modules for this HTTP server

12679
12:49:26,470 --> 12:49:30,010
package, we'll get a package
json, and of course, a yarn dot

12680
12:49:30,010 --> 12:49:34,180
lock as well. And what we can do
is we can stop this down here,

12681
12:49:34,210 --> 12:49:36,940
stop that live server. And if we
go back to our website, refresh,

12682
12:49:37,240 --> 12:49:42,400
it'll now be blank. And we can
run yarn HTTP server. And this

12683
12:49:42,400 --> 12:49:45,670
will do the exact same thing.
And we get, and if we come over,

12684
12:49:45,730 --> 12:49:49,060
and we refresh, we'll see what's
good. Now this one is a little

12685
12:49:49,060 --> 12:49:52,900
bit more finicky. And after you
make a change, like, Hey, what's

12686
12:49:52,900 --> 12:49:56,200
good, you might have to close
it, and then reopen it and then

12687
12:49:56,200 --> 12:50:00,100
refresh. So I do recommend that
if you're on Visual Studio code,

12688
12:50:00,280 --> 12:50:02,590
you definitely just use this
little go live button, because

12689
12:50:02,590 --> 12:50:04,390
it'll reflect your changes a lot
nicer.

12690
12:50:04,420 --> 12:50:07,000
So let's go ahead and hit the Go
Live button. Hey, what's good

12691
12:50:07,000 --> 12:50:10,000
pops up. Okay, cool. Our HTML is
working perfectly.

12692
12:50:12,790 --> 12:50:15,730
So the title, of course, is
going to be the Funmi app, which

12693
12:50:15,730 --> 12:50:19,180
we see up here in the title
section. So let's update this

12694
12:50:19,210 --> 12:50:22,270
HTML, so that it has those
buttons, and it can actually

12695
12:50:22,270 --> 12:50:25,210
connect and work with our
blockchain and work with any

12696
12:50:25,210 --> 12:50:27,910
blockchain. Something else that
you can do in HTML is you can

12697
12:50:27,910 --> 12:50:31,660
actually write JavaScript inside
your HTML. And the way we can do

12698
12:50:31,660 --> 12:50:35,440
that is by doing this script
tag, and then we'll do a closing

12699
12:50:35,440 --> 12:50:39,490
script tag. And anything inside
here inside of our script tags

12700
12:50:39,490 --> 12:50:42,910
is going to be JavaScript. So I
could do something like console

12701
12:50:42,970 --> 12:50:46,390
dot log, hi, with a bunch of
exclamation marks, I'm going to

12702
12:50:46,390 --> 12:50:49,600
save it. We'll go back to our
front end, we're going to right

12703
12:50:49,600 --> 12:50:53,320
click, we'll hit Inspect, we'll
go to the console. And we can

12704
12:50:53,320 --> 12:50:56,380
see that Hi prints it out, we
refresh, we can see the hi

12705
12:50:56,380 --> 12:51:00,730
consistently printed out hi from
script tag, we'll save it, we'll

12706
12:51:00,730 --> 12:51:04,000
move back, we see hi from script
tag printed out. I know it's a

12707
12:51:04,000 --> 12:51:08,680
little bit small. So let me zoom
in. Alright, great. So we can

12708
12:51:08,740 --> 12:51:12,220
type our JavaScript in here,
it's inside the script tag is

12709
12:51:12,220 --> 12:51:14,740
where we're going to write our
JavaScript to write the

12710
12:51:14,740 --> 12:51:17,830
functions that our front end is
going to interact with. Now, as

12711
12:51:17,830 --> 12:51:21,670
we saw before, in this little
console, we can check for window

12712
12:51:21,700 --> 12:51:26,230
dot Etherium, to see if Metamask
or is installed. And again, a

12713
12:51:26,230 --> 12:51:28,300
lot of what we're working with
is actually right in the

12714
12:51:28,300 --> 12:51:31,840
Metamask documentation. If you
go to their basic section, they

12715
12:51:31,840 --> 12:51:34,450
talk a little bit about the
provider, which is this window

12716
12:51:34,450 --> 12:51:37,750
dot Aetherium, you can read how
to actually interact directly

12717
12:51:37,750 --> 12:51:41,020
with meta mask in the meta mask
documentation as well. Now using

12718
12:51:41,020 --> 12:51:43,360
window dot Aetherium is just one
of the ways we're actually going

12719
12:51:43,360 --> 12:51:46,000
to connect to the blockchain,
there's actually multiple ways

12720
12:51:46,000 --> 12:51:48,010
because there's multiple
different kinds of wallets out

12721
12:51:48,010 --> 12:51:50,680
there. But for now, we're just
going to pretend that window dot

12722
12:51:50,680 --> 12:51:54,070
Aetherium and meta mask is the
only extension out there. So

12723
12:51:54,070 --> 12:51:56,710
what we want to do is we want to
check to see if this wind of

12724
12:51:56,710 --> 12:51:59,530
that Aetherium exists. This is
the first thing that we should

12725
12:51:59,530 --> 12:52:02,320
be doing. Because if this
doesn't exist, this means that

12726
12:52:02,350 --> 12:52:04,180
they can't connect to the
blockchain, one of the first

12727
12:52:04,180 --> 12:52:06,430
things that we're going to want
to do is we're going to want to

12728
12:52:06,430 --> 12:52:10,750
check to see if that exists. So
we can do something like if we

12729
12:52:10,750 --> 12:52:16,690
can say type of window that
Aetherium does not equal,

12730
12:52:17,110 --> 12:52:23,800
undefined. Then we'll do console
dot log, I see a meta mask. So

12731
12:52:23,800 --> 12:52:27,970
now if we save, we come back to
our front end, we do see I see a

12732
12:52:27,970 --> 12:52:31,450
Metamask. I've got a Google
Chrome up without Metamask that

12733
12:52:31,450 --> 12:52:35,680
if we look in the console, and
we hit refresh it the same URL

12734
12:52:35,680 --> 12:52:39,130
where our live server is
running. We don't see that I see

12735
12:52:39,130 --> 12:52:42,550
a meta mask because it doesn't
see a meta mask. We can do else.

12736
12:52:43,450 --> 12:52:49,090
console dot log, no Metamask
refresh, we still see ICD a meta

12737
12:52:49,090 --> 12:52:51,670
mask where we have a meta mask.
You don't have to open up a

12738
12:52:51,670 --> 12:52:54,940
browser without one but we see
no meta mask for Chrome because

12739
12:52:54,940 --> 12:52:57,730
it doesn't see a meta mask. Now
what we could do is We can

12740
12:52:57,760 --> 12:53:02,080
automatically try to connect to
meta mask if we see that there

12741
12:53:02,080 --> 12:53:04,960
is a meta mask, right? Remember
how before, when we hit that

12742
12:53:04,960 --> 12:53:07,150
connect button meta mask popped
up and said, Are you sure you

12743
12:53:07,150 --> 12:53:10,420
want to connect? So what we can
do is, and you can, again, you

12744
12:53:10,420 --> 12:53:13,870
can find this in the meta mask
docs, we can run this eath

12745
12:53:13,870 --> 12:53:17,200
request accounts method, which
is basically going to be how we

12746
12:53:17,200 --> 12:53:22,240
connect our Metamask. Now, this
is specified by a new EIP and an

12747
12:53:22,240 --> 12:53:25,000
older documentations. And in
older tutorials, you might see

12748
12:53:25,030 --> 12:53:27,940
Aetherium dot enable, which
essentially does the exact same

12749
12:53:27,940 --> 12:53:31,840
thing. So what we could do here
is we could say, a cerium, or

12750
12:53:31,840 --> 12:53:36,730
excuse me, window dot Aetherium
dot request. And we could put

12751
12:53:36,940 --> 12:53:43,360
method F request accounts. And
we'll save that. Now if we go

12752
12:53:43,360 --> 12:53:47,200
back to our browser, we'll
actually see, you'll actually

12753
12:53:47,200 --> 12:53:50,800
see Metamask, go ahead and pop
up and say, let's connect so we

12754
12:53:50,800 --> 12:53:54,820
can choose an account. And we'll
hit Connect, will automatically

12755
12:53:54,820 --> 12:53:58,270
connect our meta mask to our
website. And now if we look at

12756
12:53:58,270 --> 12:54:01,030
our meta mask, we can see this
little connected thing. It's

12757
12:54:01,030 --> 12:54:04,510
saying that our account one is
now connected to our website.

12758
12:54:04,780 --> 12:54:08,860
This means that the website can
now make API calls to our meta

12759
12:54:08,860 --> 12:54:12,280
mask, we still have to be the
ones to approve them. But it can

12760
12:54:12,280 --> 12:54:15,640
go ahead and connect and try to
run transactions, which is

12761
12:54:15,670 --> 12:54:18,310
awesome, which is what we want.
If you want to disconnect, we

12762
12:54:18,310 --> 12:54:20,890
can go ahead and click that
little button and hit disconnect

12763
12:54:20,890 --> 12:54:23,530
this account. Well that we have
our code currently is anytime we

12764
12:54:23,530 --> 12:54:25,930
hit refresh, this is going to
pop up which is going to be

12765
12:54:26,140 --> 12:54:29,440
really annoying. So what we're
going to do instead is we're

12766
12:54:29,440 --> 12:54:33,070
going to wrap this up into an
asynchronous function, the exact

12767
12:54:33,070 --> 12:54:35,530
same as we've been doing, we'll
do we'll create an async

12768
12:54:36,190 --> 12:54:40,330
function called Connect. And
we'll wrap it up these curly

12769
12:54:40,330 --> 12:54:43,570
braces here. And then we'll just
format this a little bit to make

12770
12:54:43,570 --> 12:54:47,350
it look nicer. And now if we
save, we go back to our website,

12771
12:54:47,410 --> 12:54:50,260
and we refresh. And we go ahead
and disconnect.

12772
12:54:51,550 --> 12:54:54,670
If we refresh Metamask won't
keep asking us Hey, do you want

12773
12:54:54,670 --> 12:54:56,110
to connect Hey, do you want to
connect here do you want to

12774
12:54:56,110 --> 12:54:58,960
connect, because we need to call
this connect function where we

12775
12:54:58,960 --> 12:55:01,960
can do that is we can add a
little button here. So right

12776
12:55:01,990 --> 12:55:06,160
underneath our script tag, we're
going to add a button tag. So

12777
12:55:06,160 --> 12:55:08,950
this is the opening button tag.
And then here's the closing

12778
12:55:08,950 --> 12:55:11,800
button tag. And inside the
opening button tag declaration,

12779
12:55:12,040 --> 12:55:16,690
we'll give it an ID, which will
be Connect button. And we'll say

12780
12:55:16,690 --> 12:55:23,440
on click equals the Connect
connects function. And we'll

12781
12:55:23,440 --> 12:55:25,930
call this button connect in
between these little button

12782
12:55:25,930 --> 12:55:29,560
tags, we'll call it connect will
say when we click it will call

12783
12:55:29,560 --> 12:55:32,950
the Connect function. So if we
save, and we go back to our

12784
12:55:32,950 --> 12:55:35,320
front end, we can now see we
have a little Connect button.

12785
12:55:35,620 --> 12:55:39,010
And now if we press Connect,
Metamask is going to pop up,

12786
12:55:39,190 --> 12:55:43,930
we'll hit next and connect like
that. And boom, now we are

12787
12:55:43,930 --> 12:55:47,950
connected. And we can even do a
little await here so that we

12788
12:55:47,980 --> 12:55:50,980
wait for this to finish before
moving on. And then after we

12789
12:55:50,980 --> 12:55:56,500
connect, we can say console dot
log connected. So let's actually

12790
12:55:56,500 --> 12:55:59,650
go ahead and test this out,
we'll go back to Metamask. we'll

12791
12:55:59,680 --> 12:56:03,730
disconnect here, try to never be
on Main net if we don't have to

12792
12:56:03,730 --> 12:56:07,510
be. And let's go ahead run
connect, we'll hit Next connect.

12793
12:56:07,720 --> 12:56:10,270
And now we see a little console
dot log come out saying

12794
12:56:10,300 --> 12:56:13,660
connected. Okay, great. We can
also update our website

12795
12:56:13,660 --> 12:56:16,870
accordingly. So that we can let
users know that we're connected.

12796
12:56:17,110 --> 12:56:20,950
So we can grab the connect
button element ID and say that

12797
12:56:20,950 --> 12:56:24,220
we're connected once we're
connected. So after we await to

12798
12:56:24,220 --> 12:56:30,370
be connected, we can go ahead
and do document dot get element

12799
12:56:30,940 --> 12:56:38,380
by ID Connect button. And then
we'll say dot inner HTML equals

12800
12:56:39,220 --> 12:56:42,730
connected like that. And then
instead of saying no minimize

12801
12:56:42,730 --> 12:56:45,700
down here, we'll do just the
opposite. So we'll copy this

12802
12:56:45,700 --> 12:56:51,280
line. And instead of connected,
we'll say please install meta

12803
12:56:51,280 --> 12:56:55,630
mask. And we'll save we'll go
back to our front end, we'll hit

12804
12:56:55,630 --> 12:56:58,780
connect. And now if we're
already connected, it'll just

12805
12:56:58,780 --> 12:57:01,150
automatically go to connected.
If we're not connected, it'll

12806
12:57:01,150 --> 12:57:03,550
pop up, we'll get connected. And
now we have this button that

12807
12:57:03,550 --> 12:57:06,700
says connected, which is great.
So now we already know that

12808
12:57:06,700 --> 12:57:12,790
we're connected. So we've
connected our Metamask to our

12809
12:57:12,790 --> 12:57:15,370
front end. Now we want to
actually go ahead and do some

12810
12:57:15,370 --> 12:57:18,010
functions here. And this is
where we want to create some

12811
12:57:18,010 --> 12:57:21,310
more functions and some more
buttons that are going to use

12812
12:57:21,370 --> 12:57:24,670
ethers that package that we
become so familiar with. Now, as

12813
12:57:24,670 --> 12:57:27,790
we code, our script section is
going to get bigger and bigger

12814
12:57:27,790 --> 12:57:31,240
and bigger. So oftentimes, we
actually want to put our code in

12815
12:57:31,270 --> 12:57:34,270
a JavaScript file itself. So
we're gonna go ahead, come over

12816
12:57:34,270 --> 12:57:37,270
here, we're going to create a
new file, and we'll call it

12817
12:57:37,330 --> 12:57:42,370
index dot j s. And instead of
putting our JavaScript in these

12818
12:57:42,400 --> 12:57:46,360
script tags, we're going to put
it in this index and then import

12819
12:57:46,390 --> 12:57:49,180
this index file into our HTML.
And the way that we're going to

12820
12:57:49,180 --> 12:57:51,580
do that is we're actually just
going to grab this function.

12821
12:57:52,360 --> 12:57:55,600
We're going to copy it, delete
everything for now. We're going

12822
12:57:55,600 --> 12:57:59,860
to paste it into our end ext dot
j s, and then in our index dot

12823
12:57:59,860 --> 12:58:05,890
HTML, we're just going to tell
our script tag to use index.js.

12824
12:58:06,550 --> 12:58:10,240
So we're just going to say the
source is going to be equal to

12825
12:58:10,270 --> 12:58:16,600
dot slash index dot j s. And
then we're going to say, the

12826
12:58:16,600 --> 12:58:21,550
type of this is going to be text
slash JavaScript. Now if we save

12827
12:58:21,550 --> 12:58:25,150
that, and we save our index dot
HTML, we come back to our front

12828
12:58:25,150 --> 12:58:28,720
end, we do a little refresh. And
we make sure that we go ahead

12829
12:58:29,320 --> 12:58:34,210
and disconnect. And we do
another refresh, we can see that

12830
12:58:34,240 --> 12:58:38,740
even with our index.js in a
different file, because we're

12831
12:58:38,740 --> 12:58:42,490
doing src equals index.js, and
we're importing it into our

12832
12:58:42,490 --> 12:58:46,120
HTML, when we hit Connect, it
still calls our Connect

12833
12:58:46,120 --> 12:58:49,900
function. That's how we can kind
of separate our JavaScript into

12834
12:58:49,900 --> 12:58:52,720
its own js file that we're a
little bit more familiar with.

12835
12:58:52,780 --> 12:58:55,000
Now, if you look in the GitHub
repo associated with this

12836
12:58:55,000 --> 12:58:58,570
course, and you look in the
index dot j s, you'll see our

12837
12:58:58,570 --> 12:59:01,360
Connect function, we've added
some quality of life stuff,

12838
12:59:01,720 --> 12:59:05,230
we've added some try catches
just to make handling errors a

12839
12:59:05,230 --> 12:59:08,020
little bit better, you can go
ahead and add those try catches

12840
12:59:08,020 --> 12:59:10,630
in yourself if you'd like. But
I'm not going to demo them in

12841
12:59:10,630 --> 12:59:11,110
this video

12842
12:59:11,110 --> 12:59:36,520
here. Now we want to create our
fun function. And then later on,

12843
12:59:36,520 --> 12:59:39,460
we're going to create our
withdrawal function. And this is

12844
12:59:39,460 --> 12:59:44,140
where front end JavaScript code.
And no Gs are a little bit

12845
12:59:44,140 --> 12:59:48,070
different. In no JS, we've been
using this require keyword to

12846
12:59:48,100 --> 12:59:52,570
import dependencies in front end
JavaScript, you can't use

12847
12:59:52,570 --> 12:59:56,230
require, and it won't exactly
work. Now later on, we're going

12848
12:59:56,230 --> 12:59:59,500
to use the Import keyword, which
is really the better way to do

12849
12:59:59,500 --> 13:00:02,680
this. And this is where our
first differences going to be

12850
13:00:02,830 --> 13:00:06,340
using the Import keyword for
front end is much better than

12851
13:00:06,340 --> 13:00:09,160
the require keyword, especially
since the require keyword

12852
13:00:09,160 --> 13:00:12,430
doesn't actually work. And for
those you who might struggle

12853
13:00:12,430 --> 13:00:15,340
with this disconnect in this
change. Once again, in the

12854
13:00:15,340 --> 13:00:18,760
GitHub repo associated with
this, we do have a Node js

12855
13:00:18,760 --> 13:00:22,510
edition of this, where you can
use the require keyword, you

12856
13:00:22,510 --> 13:00:24,700
just have to go through the
readme and download some

12857
13:00:24,700 --> 13:00:28,000
packages and run some scripts
that basically transform your

12858
13:00:28,000 --> 13:00:32,380
code that uses require into code
that works with imports. But

12859
13:00:32,380 --> 13:00:35,260
we're going to teach you the way
to work with your front end code

12860
13:00:35,260 --> 13:00:38,740
here using imports. Now you'll
see when we get to next Jas that

12861
13:00:38,740 --> 13:00:43,510
we will still download code from
node modules and using a yarn

12862
13:00:43,540 --> 13:00:47,650
lock and a package json etc. So
summary in future seconds, we

12863
13:00:47,650 --> 13:00:51,400
are still going to do yarn add.
But outside of a framework when

12864
13:00:51,400 --> 13:00:55,090
we're using this raw JavaScript,
this raw HTML setup, like what

12865
13:00:55,090 --> 13:00:57,520
we're working with here, we're
not going to be doing yarn, add

12866
13:00:57,520 --> 13:01:00,430
node modules will add node
modules for framework like next

12867
13:01:00,430 --> 13:01:03,220
react. But for raw JavaScript,
we'll be using a different

12868
13:01:03,220 --> 13:01:05,710
syntax, which I'll show you
soon. So let's go ahead and

12869
13:01:05,710 --> 13:01:08,470
start building our fund function
here. To make our fun functions,

12870
13:01:08,470 --> 13:01:11,590
what would we normally do? Well,
we'd create an async function

12871
13:01:11,860 --> 13:01:14,950
called fund. And in this
function, we probably would want

12872
13:01:14,950 --> 13:01:18,610
to take some ether mount as a
parameter, because we're going

12873
13:01:18,610 --> 13:01:21,670
to want to fund it with some
amount of Aetherium. When we

12874
13:01:21,670 --> 13:01:26,740
call this function, we might
want to run console dot log will

12875
13:01:26,740 --> 13:01:31,720
do a little string interpolation
here. Funding with eth amount,

12876
13:01:32,470 --> 13:01:36,460
dot dot dot, these semicolons
are going to drive me absolutely

12877
13:01:36,460 --> 13:01:40,630
insane. So I'm going to add a
our dot prettier dot our rc file

12878
13:01:40,750 --> 13:01:43,630
into this, and I'm going to go
ahead and add prettier in here.

12879
13:01:43,660 --> 13:01:46,630
Otherwise, I'm going to lose my
mind. So we're gonna do yarn add

12880
13:01:46,630 --> 13:01:50,620
dash dash Dev, prettier, just so
we can format our JavaScript

12881
13:01:50,620 --> 13:01:53,740
with prettier come back to
index.js. I'm gonna hit command

12882
13:01:53,740 --> 13:01:55,930
S, and it looks like it does
indeed, auto format with

12883
13:01:55,930 --> 13:02:00,100
prettier now yay, no matter
semicolons, we can call this fun

12884
13:02:00,100 --> 13:02:04,060
function the same way we call
connect. So in in our index dot

12885
13:02:04,060 --> 13:02:08,980
HTML, maybe we'll create a new
button. Button. We'll give it an

12886
13:02:08,980 --> 13:02:17,470
ID of fund will say on click
equals fund. And we'll say fund.

12887
13:02:18,100 --> 13:02:20,800
And this will be our button
here, we save it, we're looking

12888
13:02:20,800 --> 13:02:24,340
at our front end. Now the fund
button that if we call, we say

12889
13:02:24,340 --> 13:02:27,430
funding with undefined because
we're not passing it an amount

12890
13:02:27,430 --> 13:02:31,150
here. So back in our index
console dot log funding with and

12891
13:02:31,150 --> 13:02:33,550
we'll just want to make sure
that we can actually call that

12892
13:02:33,550 --> 13:02:37,540
Funmi function. So we'll copy
this line again and we'll say

12893
13:02:37,660 --> 13:02:40,630
type of window dot Aetherium
does not equal undefined. We'll

12894
13:02:40,630 --> 13:02:43,930
go ahead and try to fund here to
send a transaction. What are the

12895
13:02:43,930 --> 13:02:47,560
things that we absolutely 100%
Always need? Well, we need a

12896
13:02:47,560 --> 13:02:51,610
provider slash connection to the
blockchain. And we need a signer

12897
13:02:51,910 --> 13:02:57,340
slash wallet, slash someone with
some gas to actually send it and

12898
13:02:57,340 --> 13:03:01,390
then And we're probably going to
need the contract that we are

12899
13:03:01,390 --> 13:03:04,180
interacting with. And to get
that contract, we're going to

12900
13:03:04,180 --> 13:03:08,800
need ABI and address. And with
these all together, we can send

12901
13:03:08,800 --> 13:03:11,530
any transaction. So to get our
provider, we're going to

12902
13:03:11,530 --> 13:03:14,860
actually go ahead and work with
ethers again. Now, we're going

12903
13:03:14,860 --> 13:03:17,680
to do it a little bit
differently, though, before, the

12904
13:03:17,680 --> 13:03:23,380
way we worked with ethers is we
said const ethers equals require

12905
13:03:23,980 --> 13:03:27,160
ethers, right. And this is how
we pulled ethers. And now like I

12906
13:03:27,160 --> 13:03:30,190
just said to you, though,
require doesn't work in the

12907
13:03:30,190 --> 13:03:33,610
front end. And we actually don't
want to install ethers with a

12908
13:03:33,610 --> 13:03:37,510
node modules package. So what we
can actually do instead is let's

12909
13:03:37,510 --> 13:03:41,860
go to the ethers documentation.
If you go to the Getting Started

12910
13:03:41,860 --> 13:03:46,030
section, scroll down, they have
a section about importing using

12911
13:03:46,030 --> 13:03:50,950
Node js, which uses require or
imports. And then they also have

12912
13:03:51,070 --> 13:03:55,270
some documentation for working
with the web browser. So instead

12913
13:03:55,270 --> 13:03:59,110
of us doing a node module, what
we'll do is we'll copy the

12914
13:03:59,140 --> 13:04:02,500
ethers library to our own
directories and serve it

12915
13:04:02,500 --> 13:04:06,250
ourselves. So what we do is we
can come in here, we can copy

12916
13:04:06,250 --> 13:04:10,300
this massive file, which is
ethers, but in front end

12917
13:04:10,330 --> 13:04:14,410
addition, and come back to our
file. And we'll make a new file

12918
13:04:14,410 --> 13:04:14,860
in here.

12919
13:04:16,540 --> 13:04:24,940
Called ethers. We'll do 5.6
point esm.min.js. And we'll

12920
13:04:24,940 --> 13:04:28,150
paste that massive thing in
here. Now, since I have prettier

12921
13:04:28,150 --> 13:04:31,180
when I save it, it's going to
auto format. And it's just this

12922
13:04:31,210 --> 13:04:37,030
huge file, which has everything
ethers, but front end defied if

12923
13:04:37,030 --> 13:04:41,680
you will. Now what we can do is
we can import this into our

12924
13:04:41,680 --> 13:04:46,210
index.js. So instead of using
require in here, we'll say

12925
13:04:46,210 --> 13:04:51,400
import ethers from and then
we'll just refer to that file

12926
13:04:51,400 --> 13:05:00,760
that we just got ethers dash 5.6
point esm.min.js. Now, we only

12927
13:05:00,760 --> 13:05:04,960
need to do this weird copy
pasting of the file import thing

12928
13:05:05,050 --> 13:05:09,430
in this HTML JavaScript lesson.
In future lessons with Node js,

12929
13:05:09,460 --> 13:05:12,580
we are going to do yarn, add
ethers, kinda like we've

12930
13:05:12,580 --> 13:05:15,790
normally seen. The frameworks
like React and next Jas that

12931
13:05:15,790 --> 13:05:19,900
we're going to use are going to
automatically convert those yarn

12932
13:05:19,930 --> 13:05:23,650
added packages to their front
end to five versions. But for

12933
13:05:23,650 --> 13:05:25,990
this section, this is how we're
going to actually import the

12934
13:05:25,990 --> 13:05:29,830
ethers package. Now the other
thing we'll have to do is on our

12935
13:05:29,830 --> 13:05:34,180
front end, we'll have to change
this from type text slash

12936
13:05:34,180 --> 13:05:39,340
JavaScript to type module
changes. The type module allows

12937
13:05:39,340 --> 13:05:42,040
us to import modules into our
code, which we're going to be

12938
13:05:42,040 --> 13:05:45,310
importing this, and we're going
to import another module as

12939
13:05:45,310 --> 13:05:49,900
well. Awesome. And now though,
if we go back to our front end,

12940
13:05:50,410 --> 13:05:53,830
do a little refresh with the
connect button, we get Connect

12941
13:05:53,830 --> 13:05:57,430
is not defined at HTML
button.on. Click, so instead of

12942
13:05:57,430 --> 13:06:00,580
calling our Connect button from
the front end here, we're going

12943
13:06:00,580 --> 13:06:05,980
to remove these on clicks from
our index dot HTML, and go into

12944
13:06:05,980 --> 13:06:10,660
our index.js and add those
connect buttons in here. So

12945
13:06:10,660 --> 13:06:17,980
we'll say const. Connect button
equals document, dot get element

12946
13:06:18,880 --> 13:06:27,280
by ID, Connect button. And then
we'll say const. One button

12947
13:06:27,880 --> 13:06:35,350
equals Doc, you meant dot get
element by ID. One button, the

12948
13:06:35,350 --> 13:06:37,810
idea of the connect button is
Connect button. The idea the fun

12949
13:06:37,810 --> 13:06:43,750
button is fun button. And then
we'll say connect button.on

12950
13:06:43,750 --> 13:06:53,380
Click equals connect. And one
button.on Click equals fond. We

12951
13:06:53,380 --> 13:06:56,530
go back to our front end, do a
little refresh. We'll hit

12952
13:06:56,530 --> 13:06:59,620
connect now. And it's actually
working, we'll go to our

12953
13:06:59,620 --> 13:07:05,050
Metamask will disconnect,
refresh, hit Connect, and boom,

12954
13:07:05,050 --> 13:07:08,320
it's popping up again. This is
just due to that type being

12955
13:07:08,350 --> 13:07:12,460
module, if it was text slash
JavaScript, that on click button

12956
13:07:12,460 --> 13:07:15,070
adding in here, but since we're
doing module, we're going to add

12957
13:07:15,070 --> 13:07:17,890
those on clicks right in our
JavaScript. But now that we've

12958
13:07:17,890 --> 13:07:20,920
got ethers in here, what we can
do is we can even do like a

12959
13:07:20,920 --> 13:07:25,540
little console dot log, just
paste ethers in here, or

12960
13:07:25,540 --> 13:07:28,330
actually better yet. We'll add
it right above the Connect

12961
13:07:28,330 --> 13:07:31,660
button. Go back to our front
end, we'll do a refresh and we

12962
13:07:31,660 --> 13:07:35,650
see the entire ethers object
right in our front end which is

12963
13:07:35,650 --> 13:07:38,950
perfect, which is exactly what
we want here. And since we've

12964
13:07:38,950 --> 13:07:43,000
got these two variables here, we
might as well update this to

12965
13:07:43,000 --> 13:07:47,260
just say connect button dot
innerHTML equals connected and

12966
13:07:47,260 --> 13:07:50,740
here as well. Connects button
dot innerHTML equals please

12967
13:07:50,740 --> 13:07:53,110
install meta mask because now
connect button is going to be

12968
13:07:53,110 --> 13:07:56,620
the same as running this
document dot get element by ID

12969
13:07:56,620 --> 13:07:56,800
right

12970
13:07:56,800 --> 13:08:03,040
here. and great. Let's go back
to continuing our font function.

12971
13:08:03,280 --> 13:08:09,820
So we'll say const provider
equals new ethers dot providers

12972
13:08:09,880 --> 13:08:14,500
dot web three provider, window
dot Aetherium. Web three

12973
13:08:14,500 --> 13:08:18,670
provider is an object in ethers
that allows us to basically wrap

12974
13:08:18,670 --> 13:08:22,000
around stuff like Metamask is
web three provider is really

12975
13:08:22,000 --> 13:08:25,900
similar to that JSON RPC
provider, which we use before,

12976
13:08:25,930 --> 13:08:30,070
which is where we put in exactly
that endpoint, our alchemy

12977
13:08:30,070 --> 13:08:33,220
endpoint, or when we're working
with Metamask. Here, whatever

12978
13:08:33,220 --> 13:08:36,520
endpoint that we have in our
network section is web three

12979
13:08:36,520 --> 13:08:40,300
provider takes that HTTP
endpoint and automatically

12980
13:08:40,300 --> 13:08:44,200
sticks it in ethers for us. So
this line of code basically

12981
13:08:44,200 --> 13:08:47,920
looks at our Metamask and goes,
Ah, okay, I found the HTTP

12982
13:08:47,920 --> 13:08:50,890
endpoint inside there, Metamask.
That's going to be what we're

12983
13:08:50,890 --> 13:08:53,560
going to use as our provider
here. Since our provider is

12984
13:08:53,560 --> 13:08:57,160
connected to our Metamask. Here,
we can get a signer or we can

12985
13:08:57,160 --> 13:09:04,750
get a wallet just by running
const signer equals provider,

12986
13:09:05,140 --> 13:09:09,670
dot get signer, this is going to
return whichever wallet is

12987
13:09:09,670 --> 13:09:13,150
connected from the provider,
which again, our provider is our

12988
13:09:13,150 --> 13:09:17,770
Metamask. So if we're connected
with with account one, it's

12989
13:09:17,770 --> 13:09:20,530
going to return account one as
the signer connected with

12990
13:09:20,530 --> 13:09:28,240
account two, it'll return
account two, etc. Now, I'm going

12991
13:09:28,240 --> 13:09:31,810
to add console dot log signer
here, and then flip to the front

12992
13:09:31,810 --> 13:09:34,360
end now and show you what
happens when we hit the fund

12993
13:09:34,360 --> 13:09:38,440
button. You can see in here we
have our JSON RPC signer, the

12994
13:09:38,440 --> 13:09:42,010
signer is going to be the
account that we've connected to

12995
13:09:42,040 --> 13:09:45,850
our front end. Now we have our
provider, we have our signer.

12996
13:09:45,880 --> 13:09:49,210
Now, we're going to need our
contract by getting the API and

12997
13:09:49,210 --> 13:09:53,350
the address. So we're gonna need
to say const. Contract equals

12998
13:09:53,680 --> 13:09:57,520
what? How are we going to get
our contract? Well, this is

12999
13:09:57,520 --> 13:10:01,840
where we're going to need to
know the ABI and the address of

13000
13:10:01,840 --> 13:10:04,930
a working with typically, what
you'll see a lot of projects do

13001
13:10:04,960 --> 13:10:07,690
since once a contract is
deployed, the addresses are

13002
13:10:07,690 --> 13:10:10,330
going to change is they're going
to have some type of constants

13003
13:10:10,330 --> 13:10:15,400
file. So they'll create a new
file called constants, dot j s.

13004
13:10:17,500 --> 13:10:20,680
And in here, they'll add the
addresses and any API's and

13005
13:10:20,680 --> 13:10:25,240
anything like that for us to use
in our fund piece here. Now, as

13006
13:10:25,240 --> 13:10:27,670
we're developing, and as we're
building, this, the backend and

13007
13:10:27,670 --> 13:10:30,250
the front end team are gonna
have to interact a little bit,

13008
13:10:30,280 --> 13:10:32,860
or if it's just you doing the
full stack, you're gonna have to

13009
13:10:32,860 --> 13:10:36,070
interact with their back end. So
this is why it's so important to

13010
13:10:36,070 --> 13:10:40,900
have both your front end and
your back end code nearby. So if

13011
13:10:40,900 --> 13:10:45,280
we go back to our Hardhead, fund
me project that we just made, we

13012
13:10:45,280 --> 13:10:49,630
can find the ABI in here. Once
again, if we go to artifacts, go

13013
13:10:49,630 --> 13:10:54,370
to contracts, we can go to fund
me dot soul, fund me dot JSON,

13014
13:10:54,790 --> 13:10:58,660
we can find the ABI right here,
it's going to be this massive

13015
13:10:58,660 --> 13:11:01,480
thing right here. So you can go
ahead, you can even copy this

13016
13:11:01,480 --> 13:11:05,140
whole thing in this little non
squiggly bracket and this little

13017
13:11:05,140 --> 13:11:09,040
bracket here, we can copy that.
And then we can come back to our

13018
13:11:09,040 --> 13:11:12,580
constant.js. And we can just
save it as variable, we'll say

13019
13:11:12,670 --> 13:11:23,200
Export const, Avi, e equals and
paste that in there. And then

13020
13:11:23,200 --> 13:11:26,920
back in our index dot j s, we
can import it with import

13021
13:11:28,509 --> 13:11:38,529
API from constants. Oops. Okay,
great. So we have the API. Well,

13022
13:11:38,559 --> 13:11:41,439
what about the address, since
we're going to be running this

13023
13:11:41,439 --> 13:11:44,289
locally, we want to get the
contract address of this locally

13024
13:11:44,319 --> 13:11:48,039
run contract, we can do that a
couple of ways. One way is you

13025
13:11:48,039 --> 13:11:50,799
can just have two windows open
one with your front end code,

13026
13:11:50,829 --> 13:11:53,559
one with your back end code, and
the one with your back end code,

13027
13:11:53,559 --> 13:11:57,579
you can run yarn, hard hat node,
which will spin up our

13028
13:11:57,579 --> 13:12:01,839
blockchain node for us, and give
us the address in here. Or what

13029
13:12:01,839 --> 13:12:04,239
we can do. And this will
probably be a little bit easier

13030
13:12:04,329 --> 13:12:07,449
is in your window with your
front end code and create a new

13031
13:12:07,449 --> 13:12:10,569
terminal. And now we'll have two
terminals running. And then this

13032
13:12:10,599 --> 13:12:15,849
second one, we're going to CD
down CD dot dot, and then CD,

13033
13:12:16,329 --> 13:12:20,649
hard hat on Me Free Code Camp.
And in here, we're going to run

13034
13:12:20,649 --> 13:12:25,929
yarn, art head node. And this is
going to spin up our local

13035
13:12:25,929 --> 13:12:30,159
blockchain in this second
terminal in here, where we have

13036
13:12:30,459 --> 13:12:34,029
deploying fund me deploy that
address, blah, blah, blah, right

13037
13:12:34,029 --> 13:12:37,869
here. And just a reminder, if I
hit this x, it just hides the

13038
13:12:37,869 --> 13:12:41,619
terminal. I can always pull it
back up with terminal new

13039
13:12:41,619 --> 13:12:45,639
terminal, and I can always hide
it, but this is still running

13040
13:12:45,669 --> 13:12:48,399
inside of my terminal. So I'm
going to hide it. And what I can

13041
13:12:48,399 --> 13:12:51,699
do is I can come back over to
our constants folder, and at the

13042
13:12:51,699 --> 13:12:59,439
top, we can do export const
contract address. equals, we'll

13043
13:12:59,439 --> 13:13:04,059
pull the terminal back up. And
we'll go grab, where it says,

13044
13:13:04,929 --> 13:13:08,709
pulling fund me deployed at
right here. We'll copy that

13045
13:13:08,709 --> 13:13:12,999
address, put some quotes, and
we'll paste it in. And now we're

13046
13:13:12,999 --> 13:13:16,959
also exporting the contract
address, then in our index.js

13047
13:13:17,019 --> 13:13:22,749
will import the contract address
with comma, contract address.

13048
13:13:23,469 --> 13:13:28,149
And now we have both the ABI and
the contract address. So what we

13049
13:13:28,149 --> 13:13:33,249
can do, we can say const
contract equals new ethers dot

13050
13:13:33,249 --> 13:13:38,439
contract of, we'll pass the
contract address, pass the API,

13051
13:13:38,679 --> 13:13:41,649
and we'll pass it the signer.
Now we have an ethers contract

13052
13:13:41,649 --> 13:13:44,829
object that's connected to our
signer, and we have the contract

13053
13:13:44,829 --> 13:13:47,769
address, and we have the
contract abi, now that we have a

13054
13:13:47,769 --> 13:13:50,829
contract object, we can go ahead
and start making transactions

13055
13:13:51,009 --> 13:13:54,219
the exact same way we've made
transactions before we can just

13056
13:13:54,219 --> 13:14:02,739
run const transaction response
equals a weight contract dot

13057
13:14:02,799 --> 13:14:08,829
fund. And then we'll pass a
value of ethers dot utils dot

13058
13:14:09,039 --> 13:14:14,619
parse, ether ether mount. So
this is going to be how we're

13059
13:14:14,619 --> 13:14:18,219
going to go ahead and create our
transaction. And if you take

13060
13:14:18,219 --> 13:14:21,159
this right now, and we go to our
front, we give it a little

13061
13:14:21,159 --> 13:14:24,699
refresh, make sure we're
connected and we hit fund, we're

13062
13:14:24,699 --> 13:14:29,529
gonna get this error value must
be a string. That's because at

13063
13:14:29,529 --> 13:14:33,219
the mount right now is being
passed in as nothing. Now

13064
13:14:33,219 --> 13:14:36,669
normally, we'll pass parameters
directly to our functions. But

13065
13:14:36,789 --> 13:14:39,309
what we're going to do is for
now is we're just going to hard

13066
13:14:39,309 --> 13:14:43,629
code this. So we'll say const.
At the mount equals, we'll do

13067
13:14:43,629 --> 13:14:47,379
like 77, or something we had
fun. Now, what do you think's

13068
13:14:47,379 --> 13:14:51,669
gonna happen? Well, we get this
other air, insufficient funds

13069
13:14:51,699 --> 13:14:55,089
for intrinsic transaction cost,
or you might get some other

13070
13:14:55,089 --> 13:14:57,459
error, but you're gonna get a
weird error here. And that's

13071
13:14:57,459 --> 13:15:01,689
because we're not actually
connected to our local hard head

13072
13:15:01,689 --> 13:15:04,899
node right now. Well, if we look
at our Metamask, we're currently

13073
13:15:04,929 --> 13:15:08,409
not connected to the right
blockchain, we're connected to

13074
13:15:08,409 --> 13:15:12,729
rink B, or main net or whatever,
we need to get connected to our

13075
13:15:12,729 --> 13:15:16,209
local host. If you look in your
networks, you'll actually have a

13076
13:15:16,209 --> 13:15:19,869
local host object here already.
But let's just be super

13077
13:15:19,869 --> 13:15:23,079
specific. And we'll add a new
network here, we're going to add

13078
13:15:23,079 --> 13:15:27,099
something called our hard hat,
local host. And we'll hit Add

13079
13:15:27,099 --> 13:15:30,549
Network and we'll add Hardhead.
Local host in here, the RPC URL,

13080
13:15:30,789 --> 13:15:35,379
we can find from our node area,
which we scroll to where our

13081
13:15:35,379 --> 13:15:39,579
node is running, we can copy
this URL and paste it into new

13082
13:15:39,579 --> 13:15:44,859
RPC URL, chain ID is going to be
31337 currency symbol is going

13083
13:15:44,859 --> 13:15:48,789
to be go or ether. Even though
this pop up says it might have a

13084
13:15:48,789 --> 13:15:51,159
different currency symbol go,
we're just going to put eath in

13085
13:15:51,159 --> 13:15:54,429
here. And there is no block
explorer, right? Because this is

13086
13:15:54,429 --> 13:15:57,249
a local blockchain, we're not
going to have a block Explorer.

13087
13:15:57,309 --> 13:15:58,809
So we'll go ahead and hit Save.

13088
13:15:58,900 --> 13:16:01,870
And now we have an account here,
which is great. We're connected

13089
13:16:01,870 --> 13:16:04,990
to our local blockchain. And if
we switch our meta mask, we can

13090
13:16:04,990 --> 13:16:08,590
see we're on the local hard hat.
And we are connected. Awesome.

13091
13:16:08,770 --> 13:16:13,390
Let's refresh. Let's run fund
one more time. And we'll see a

13092
13:16:13,390 --> 13:16:17,740
transaction does indeed pop up.
This is great. But our account

13093
13:16:17,740 --> 13:16:21,190
here doesn't have any money we
have, we're broke, we don't have

13094
13:16:21,190 --> 13:16:24,880
any local Hardhead Aetherium. So
we're actually going to need to

13095
13:16:24,940 --> 13:16:29,230
import one of our accounts from
hard hat into our meta mask,

13096
13:16:29,530 --> 13:16:33,640
which we can do so and you can
actually do this for any account

13097
13:16:33,640 --> 13:16:36,940
with a private key so hard that
gives us these accounts. And

13098
13:16:36,940 --> 13:16:40,030
we're going to import the
private key of Count zero into

13099
13:16:40,060 --> 13:16:42,910
our meta mask. So we're going to
copy the private key, we're

13100
13:16:42,910 --> 13:16:45,790
going to come back to our front
end, click on our meta mask,

13101
13:16:46,090 --> 13:16:48,850
we're gonna hit this big button,
we're gonna hit import account.

13102
13:16:49,270 --> 13:16:52,450
It's like type private key, and
we're gonna paste our private

13103
13:16:52,450 --> 13:16:57,340
key here. A quick note, if you
choose json file, remember how

13104
13:16:57,340 --> 13:17:01,510
back in that ether section, we
encrypted our key into a JSON

13105
13:17:01,510 --> 13:17:05,830
file with a password, you can
actually import accounts with

13106
13:17:05,830 --> 13:17:08,770
that JSON file with the
password. So if you encrypt a

13107
13:17:08,770 --> 13:17:11,650
key and you want to add it to
meta mask, you can go ahead and

13108
13:17:11,650 --> 13:17:13,750
add it in just like this. But
for now, we're going to use

13109
13:17:13,750 --> 13:17:16,180
private key, we'll paste the
private key in and we'll hit

13110
13:17:16,180 --> 13:17:21,100
import. And we can see we now
have an account, a new account

13111
13:17:21,130 --> 13:17:26,380
and account three, with a ton of
eath from our local blockchain.

13112
13:17:26,650 --> 13:17:29,890
So we'll refresh one more time,
we'll go ahead and connect,

13113
13:17:29,920 --> 13:17:33,370
we'll make sure that our account
three is connected. And if it's

13114
13:17:33,370 --> 13:17:36,700
not, we'll go ahead and hit this
Connect button. So that now our

13115
13:17:36,700 --> 13:17:39,760
account three is what's
connected here. And we'll go

13116
13:17:39,760 --> 13:17:43,720
ahead and hit fund. And we now
see that we can fund this

13117
13:17:43,720 --> 13:17:48,340
contract, we can go ahead and
hit Confirm. And if we look and

13118
13:17:48,340 --> 13:17:50,230
nothing's going to happen on our
front end, because we didn't

13119
13:17:50,230 --> 13:17:52,450
tell our front end to do
anything once we confirm, but if

13120
13:17:52,450 --> 13:17:55,960
we go to our blockchain, we can
see our fun function was called

13121
13:17:55,990 --> 13:17:58,750
we've just made our first
transaction on a blockchain from

13122
13:17:58,750 --> 13:18:02,680
our own front end, this is
awesome, great work. But it's

13123
13:18:02,710 --> 13:18:05,440
probably a little confusing to
the user. If nothing happens

13124
13:18:05,440 --> 13:18:07,720
here, they're going to hit the
fun function. And it's going to

13125
13:18:07,720 --> 13:18:12,190
be like, Oh, okay, cool. What,
what happens? Now, we probably

13126
13:18:12,190 --> 13:18:14,740
want to make it a little bit
more obvious that something just

13127
13:18:14,740 --> 13:18:17,200
happened. And one more thing I
want to show you, you don't have

13128
13:18:17,200 --> 13:18:20,590
to follow along here, if I hit
fund, and then I hit reject,

13129
13:18:20,860 --> 13:18:23,470
it's gonna freak out on us and
be like, hey, like, you hit

13130
13:18:23,470 --> 13:18:25,720
reject, I don't know what to do
now. So we're going to make our

13131
13:18:25,720 --> 13:18:28,600
code a little bit more robust by
adding a try catch. So we'll

13132
13:18:28,600 --> 13:18:36,160
tell JavaScript to try running
this transaction. And then if it

13133
13:18:36,160 --> 13:18:41,980
catches an error, just to
console dot log, that error. So

13134
13:18:41,980 --> 13:18:46,330
now, if I hit fund, and I hit
reject, it's gonna, it'll still

13135
13:18:46,330 --> 13:18:49,060
be a little bit mad, but at
least we're catching it and it's

13136
13:18:49,060 --> 13:18:52,240
not going to break and destroy
everything. Okay, cool. We've

13137
13:18:52,240 --> 13:18:55,840
got a transaction response here.
And when we hit fund, our front

13138
13:18:55,840 --> 13:19:03,130
end goes great. You've funded me
I'm I'm super confused. Oh, one

13139
13:19:03,130 --> 13:19:05,800
other point, something that
you'll probably run into

13140
13:19:05,830 --> 13:19:09,820
multiple times. As we're doing
this. If you get an error that

13141
13:19:09,820 --> 13:19:13,360
looks like this eath. JS query
while formatting outputs from

13142
13:19:13,360 --> 13:19:17,200
RPC, nonce to high expected not
to be too but got form, you will

13143
13:19:17,200 --> 13:19:20,560
definitely see this a whole lot.
Here's what you do to fix this.

13144
13:19:20,680 --> 13:19:23,890
The reason this happens is
because you've closed your

13145
13:19:23,890 --> 13:19:27,490
hardhat node and then restarted
it, and your heart had node

13146
13:19:27,490 --> 13:19:30,610
goes, Okay, well, I'm starting
fresh, I'm starting from zero.

13147
13:19:30,880 --> 13:19:34,240
But Metamask isn't smart enough
to know that, what we want to do

13148
13:19:34,300 --> 13:19:36,850
is we want to come to our
Metamask, we'll hit this big

13149
13:19:36,850 --> 13:19:40,540
button, we'll go down to
settings, we'll go to Advanced,

13150
13:19:40,870 --> 13:19:44,050
and we'll go to reset account.
And yes, we're going to reset

13151
13:19:44,050 --> 13:19:48,100
it. This isn't something ideally
that you'd like to do with an

13152
13:19:48,100 --> 13:19:51,820
actual account with actual money
on a local network, this is

13153
13:19:51,820 --> 13:19:54,940
fine. Now if you reset the
account, and you reset the node,

13154
13:19:55,090 --> 13:19:58,030
we can go ahead and hit Confirm.
And it doesn't give us that

13155
13:19:58,030 --> 13:20:01,180
error anymore. So that's kind of
the tip there, you want to reset

13156
13:20:01,180 --> 13:20:04,120
the nuts so that our Metamask
and our blockchain are in sync

13157
13:20:04,120 --> 13:20:05,410
with that nonce number.

13158
13:20:08,290 --> 13:20:10,810
So we have this transaction
response. And we probably want

13159
13:20:10,810 --> 13:20:14,680
our front end to give the user
some indication, hey, the

13160
13:20:14,680 --> 13:20:17,590
transaction went through. So
what we want to do is we want to

13161
13:20:17,590 --> 13:20:20,590
listen to the blockchain for
this to finish. So we can either

13162
13:20:20,650 --> 13:20:26,860
listen for the TX to be mined.
Or we can listen for an event.

13163
13:20:27,130 --> 13:20:29,950
We haven't learned about events
yet. But we will. So for now,

13164
13:20:29,950 --> 13:20:32,230
since we haven't learned about
events yet, we're just going to

13165
13:20:32,230 --> 13:20:34,960
listen for the TX to be mined.
Or to listen for the transaction

13166
13:20:34,960 --> 13:20:37,240
to be mined, we're actually
going to create a new function

13167
13:20:37,510 --> 13:20:44,950
called function, listen, or
transaction mine in this is

13168
13:20:44,950 --> 13:20:49,360
going to take as input a
transaction response, and a

13169
13:20:49,360 --> 13:20:53,410
provider. Now you'll notice this
isn't an async function. For

13170
13:20:53,410 --> 13:20:56,050
this section. This is
intentional, we don't want this

13171
13:20:56,050 --> 13:20:57,970
to be an async function. And
you'll see why in a second.

13172
13:20:58,390 --> 13:21:00,970
We're going to be using
JavaScript promise JavaScript

13173
13:21:01,000 --> 13:21:04,270
async functionality to its
massive advantage. And this is

13174
13:21:04,270 --> 13:21:07,060
why JavaScript actually works so
well on the front end is because

13175
13:21:07,420 --> 13:21:09,790
of how it's asynchronous. So
we're going to create this

13176
13:21:09,790 --> 13:21:12,400
function listen for transaction
to be mined, we're going to

13177
13:21:12,400 --> 13:21:16,180
await in our fund function. And
we're going to have this return

13178
13:21:16,240 --> 13:21:19,270
a promise. Let's go ahead, and
let's learn how to build this.

13179
13:21:19,270 --> 13:21:22,750
So we're gonna say console dot
log, string interpolation, we'll

13180
13:21:22,750 --> 13:21:27,730
say mining. And then in here,
we'll say transaction, response

13181
13:21:27,730 --> 13:21:32,140
dot hash. All of our transaction
response objects have a hash,

13182
13:21:32,140 --> 13:21:36,100
which just represent that hash.
And we'll do a couple of data

13183
13:21:36,100 --> 13:21:39,280
dot, we'll put in our console
here, we're waiting for the

13184
13:21:39,280 --> 13:21:42,250
transaction to be mined, then
what we're going to do is we're

13185
13:21:42,250 --> 13:21:47,740
going to return a new promise.
And the reason we're going to

13186
13:21:47,740 --> 13:21:52,060
return a promise is because we
need to create a listener for

13187
13:21:52,060 --> 13:21:55,750
the blockchain. We want to
listen for this event to happen.

13188
13:21:55,780 --> 13:22:01,150
But we want to tell JavaScript,
hey, wait for this thing to

13189
13:22:01,150 --> 13:22:04,930
finish looking, wait for this
thing to finish looking. Now

13190
13:22:04,930 --> 13:22:07,270
here's where this gets a little
bit tricky. In our fund

13191
13:22:07,270 --> 13:22:10,960
function. After we create the
transaction, we basically want

13192
13:22:10,960 --> 13:22:17,260
to tell JavaScript Hey, wait for
this TX to finish. So our code

13193
13:22:17,290 --> 13:22:22,420
is going to look as simple as
await listen for transaction

13194
13:22:22,420 --> 13:22:28,330
mine. And we're going to pass it
the trans action response

13195
13:22:29,529 --> 13:22:32,469
and our provider. So we're
saying hey, listen for this

13196
13:22:32,469 --> 13:22:35,289
transaction finish. And we're
using this await keyword,

13197
13:22:35,469 --> 13:22:38,589
because again, the await keyword
says okay, we're gonna stop

13198
13:22:38,619 --> 13:22:40,599
right here. We're gonna stop
until this function is

13199
13:22:40,599 --> 13:22:43,899
completely done. Now in this
listen for transaction in mind,

13200
13:22:43,929 --> 13:22:46,539
we have to define how we're
actually going to listen for

13201
13:22:46,539 --> 13:22:50,289
this. So we're going to say
listen for this transaction to

13202
13:22:50,289 --> 13:22:54,399
finish. Ethers actually comes
with a way for us to listen for

13203
13:22:54,399 --> 13:22:57,279
transactions and listen for
events, which again, we haven't

13204
13:22:57,279 --> 13:23:00,159
learned About, but don't worry
about that yet. So we can go to

13205
13:23:00,159 --> 13:23:04,509
the ethers docs. And we can look
up once. Contract dot once.

13206
13:23:04,569 --> 13:23:08,019
There's a whole bunch of
listeners that we can use to

13207
13:23:08,049 --> 13:23:11,019
listen for events and listen for
different things to happen, we

13208
13:23:11,019 --> 13:23:13,749
can do this thing called
provider dot once where we

13209
13:23:13,749 --> 13:23:18,489
listen for some event. And once
that event fires, we call some

13210
13:23:18,519 --> 13:23:21,129
other function that we've
defined. Now, we haven't talked

13211
13:23:21,129 --> 13:23:24,099
about events yet. And again,
don't worry about this quite

13212
13:23:24,099 --> 13:23:27,099
yet. One of the events that we
can wait for is we can just wait

13213
13:23:27,099 --> 13:23:30,639
for the transaction receipt to
finish, right, because once we

13214
13:23:30,639 --> 13:23:33,999
get a transaction receipt, that
means that the transaction has

13215
13:23:33,999 --> 13:23:36,309
actually finished going through.
So we're going to use this

13216
13:23:36,309 --> 13:23:41,109
provider dot once syntax to wait
for the transaction receipt,

13217
13:23:41,259 --> 13:23:43,959
which is going to be our event,
which isn't really an event, but

13218
13:23:43,959 --> 13:23:45,849
don't worry about that yet. And
then we're going to call some

13219
13:23:45,849 --> 13:23:48,069
listener function that we
defined, you can also do

13220
13:23:48,069 --> 13:23:52,569
provider.on, which will trigger
anytime your event fires

13221
13:23:52,599 --> 13:23:56,199
provider once just triggers one
time, we only care about this

13222
13:23:56,199 --> 13:23:59,379
transaction going through one
time. So we're passing our

13223
13:23:59,379 --> 13:24:04,239
provider object. So we're gonna
say provider dot once our event

13224
13:24:04,269 --> 13:24:09,669
which is just going to be
transaction response, hash,

13225
13:24:09,999 --> 13:24:13,269
provided on transaction response
dot hash. So once we get this

13226
13:24:13,269 --> 13:24:16,119
hash, which will pretty much get
right away, we're going to call

13227
13:24:16,119 --> 13:24:20,349
our listener function. Now we
can create a function listener

13228
13:24:20,529 --> 13:24:23,739
like this, and then just pass
listener in here. But we're

13229
13:24:23,739 --> 13:24:25,869
going to do an anonymous
function here, because that's

13230
13:24:25,959 --> 13:24:28,239
typically what we see as the
syntax for these loops. And so

13231
13:24:28,239 --> 13:24:30,909
far, we're doing provider dot
once to do this anonymous

13232
13:24:30,909 --> 13:24:34,539
function, we're going to do just
two little parentheses here. And

13233
13:24:34,539 --> 13:24:39,069
this arrow notation. So this by
itself represents an anonymous

13234
13:24:39,069 --> 13:24:41,919
function. So we're saying, hey,
there's some function, it

13235
13:24:41,919 --> 13:24:45,039
doesn't take any parameters, and
it doesn't have any code, this

13236
13:24:45,039 --> 13:24:48,039
arrow function, this whole thing
is saying this is an anonymous

13237
13:24:48,039 --> 13:24:51,099
function. So we're saying
provided at once transaction

13238
13:24:51,099 --> 13:24:53,259
hash happens, here's the
function that you want to

13239
13:24:53,259 --> 13:24:56,709
execute. It doesn't do anything
right now. But let's have a do

13240
13:24:56,709 --> 13:24:58,959
something. So once this
transaction dot response

13241
13:24:58,989 --> 13:25:05,739
finishes, we're going to take a
trans transaction received as an

13242
13:25:05,739 --> 13:25:09,399
input parameter, or our our
callback function, or our

13243
13:25:09,399 --> 13:25:12,189
listener function. And all we're
going to do is we're gonna say

13244
13:25:12,189 --> 13:25:19,209
console dot log, completed with
a little string interpolation,

13245
13:25:19,449 --> 13:25:23,649
transaction receipt, that
confirmations, confirmations,

13246
13:25:24,069 --> 13:25:26,319
and then completed with
transaction receipt,

13247
13:25:26,349 --> 13:25:30,699
confirmations, confirmations. So
once this provider dot once sees

13248
13:25:30,699 --> 13:25:34,479
that there's a transaction hash,
it's going to give as an input

13249
13:25:34,479 --> 13:25:37,749
rammer to our listener function,
the transaction receipt, kind of

13250
13:25:37,749 --> 13:25:40,389
that same syntax that we've been
seeing this whole time, once a

13251
13:25:40,389 --> 13:25:43,179
transaction response finishes,
we get the transaction receipt,

13252
13:25:43,479 --> 13:25:45,729
and we can do stuff with it. And
we see how many block

13253
13:25:45,729 --> 13:25:48,909
confirmations it has. For us,
this pretty much should always

13254
13:25:48,909 --> 13:25:52,749
be one. Now if we save this, go
back to our front end, and we

13255
13:25:52,749 --> 13:25:56,319
hit fund, it's going to work,
we're going to give the user

13256
13:25:56,319 --> 13:25:59,409
some indication that it worked,
which is great. But it's not

13257
13:25:59,499 --> 13:26:02,229
really going to work the way
that we want it to work. We have

13258
13:26:02,229 --> 13:26:05,709
this console dot log done right
after we do the await, listen

13259
13:26:05,709 --> 13:26:09,789
for transaction mine, and we
come back and we hit fund, we

13260
13:26:09,789 --> 13:26:13,839
hit confirm, it actually doesn't
go in the order that we want it

13261
13:26:13,839 --> 13:26:18,489
to go, it goes mining this thing
that it says Done. And then it

13262
13:26:18,489 --> 13:26:21,879
says completed with one trip
confirmation what what's going

13263
13:26:21,879 --> 13:26:26,349
on here, we should write
completed before we write done,

13264
13:26:26,409 --> 13:26:28,929
because that's the order that we
have this in. But it looks like

13265
13:26:28,929 --> 13:26:32,199
it's words, it's going out of
order. What what's going on

13266
13:26:32,199 --> 13:26:35,709
here, what's going to happen is
when we call listen for

13267
13:26:35,709 --> 13:26:40,569
transaction mine, or listen for
transaction, mine function is

13268
13:26:40,569 --> 13:26:44,499
going to kick off, but it's
going to kick off provided on

13269
13:26:44,499 --> 13:26:49,059
once as its own process. So
await listen for transaction,

13270
13:26:49,059 --> 13:26:53,349
mine will kick off the listener,
but it doesn't wait for this

13271
13:26:53,349 --> 13:26:57,279
listener to find the transaction
response. So this function will

13272
13:26:57,279 --> 13:27:04,269
actually finish before provider
dot once finishes. So after it

13273
13:27:04,269 --> 13:27:08,079
kicks off the listener, it'll
run to the next line of our

13274
13:27:08,079 --> 13:27:12,369
code, which is console dot log
and done. Our front end we'll go

13275
13:27:12,369 --> 13:27:15,969
oh, oh, you kicked off a
listener earlier. Let me go back

13276
13:27:15,969 --> 13:27:20,049
down and let me recheck to see
if it's finished. And if it has

13277
13:27:20,049 --> 13:27:23,229
finished, I'll go do what it
told me to do. And this is where

13278
13:27:23,229 --> 13:27:25,029
what's known as the event loop
kicks in.

13279
13:27:25,389 --> 13:27:28,479
We don't actually wait for this
provider that wants to finish,

13280
13:27:28,809 --> 13:27:32,259
we add this provided at once
onto this queue called the event

13281
13:27:32,259 --> 13:27:36,399
loop. And our front end is going
to periodically check back to it

13282
13:27:36,399 --> 13:27:40,689
to see if it's finished. So we
want to adjust our code. So we

13283
13:27:40,689 --> 13:27:43,539
wait for the listener to finish
listening, which is where we're

13284
13:27:43,539 --> 13:27:47,079
going to get into promises here.
So what we want to do is we want

13285
13:27:47,079 --> 13:27:50,649
to adjust this function to now
return a promise. And we're

13286
13:27:50,649 --> 13:27:53,139
going to use this syntax a
couple of times in the future.

13287
13:27:53,169 --> 13:27:55,959
So what we're going to do is
we're going to say hey, we want

13288
13:27:55,959 --> 13:27:59,379
to wait for the listener To
finish listening, we're going to

13289
13:27:59,379 --> 13:28:02,739
wrap this whole thing into a
promise. And we're going to say

13290
13:28:02,739 --> 13:28:08,469
return, new promise. And a
promise takes a function itself

13291
13:28:08,499 --> 13:28:12,759
as an input parameter. So again,
we'll use kind of this anonymous

13292
13:28:12,759 --> 13:28:15,489
function notation. And it will
take two input parameters

13293
13:28:15,489 --> 13:28:21,189
resolve and reject. So resolve
says, hey, if this promise works

13294
13:28:21,189 --> 13:28:24,489
correctly, call this resolve
function. And for us, this

13295
13:28:24,489 --> 13:28:28,629
promise is going to be done when
the listener finishes listening.

13296
13:28:28,839 --> 13:28:31,899
And then we would reject if
there was some type of timeout,

13297
13:28:31,929 --> 13:28:34,599
we're not going to write the
reject function. But in the

13298
13:28:34,599 --> 13:28:37,479
future, if you were to do this
for production, you'd add some

13299
13:28:37,479 --> 13:28:40,299
timeout as the reject parameter.
Basically, you're saying, hey,

13300
13:28:40,449 --> 13:28:42,249
once the listener finishes
listening, we're going to

13301
13:28:42,249 --> 13:28:45,219
resolve and if it takes too
long, we're gonna say ask for

13302
13:28:45,219 --> 13:28:47,799
you, you took too long, and
instead of closing it off, here,

13303
13:28:47,949 --> 13:28:52,359
we're going to close it off
around this provider thing. So

13304
13:28:52,359 --> 13:28:55,599
we're gonna say return new
promise, resolve, reject. And

13305
13:28:55,629 --> 13:29:00,729
only once this transaction gets
fired, are we going to resolve

13306
13:29:00,759 --> 13:29:05,199
this promise, like so. So what
is happening here, so we're

13307
13:29:05,199 --> 13:29:10,269
going to put the resolve inside
of this provider at once. So

13308
13:29:10,269 --> 13:29:15,849
we're saying, once this
transaction hash is found, then

13309
13:29:15,849 --> 13:29:18,069
we're going to call this
function, we're gonna say

13310
13:29:18,069 --> 13:29:21,219
console dot log, and then we're
going to resolve so this promise

13311
13:29:21,249 --> 13:29:25,389
only returns once a resolve or
reject is called. And we're

13312
13:29:25,389 --> 13:29:30,759
telling it only resolve only
finish this function once.

13313
13:29:31,239 --> 13:29:34,329
Transaction response dot hash is
found, because it's going to be

13314
13:29:34,359 --> 13:29:38,349
inside of these little squiggly
parentheses for provider dot

13315
13:29:38,349 --> 13:29:43,569
once, the promise right now only
resolves after it's fired. It's

13316
13:29:43,569 --> 13:29:47,619
event here. If this was really
confusing, just copy paste this

13317
13:29:47,679 --> 13:29:50,859
and move on, we're getting a
little bit deeper into front end

13318
13:29:50,859 --> 13:29:54,339
stuff here. So hopefully, this
was clear, if not definitely

13319
13:29:54,339 --> 13:29:56,559
jump in to the GitHub
discussions to start asking

13320
13:29:56,559 --> 13:30:00,639
about this stuff. But now that
we've updated this, we can come

13321
13:30:00,639 --> 13:30:03,489
back to our front end, we can
hit the fund button. And

13322
13:30:03,489 --> 13:30:06,099
hopefully this time, everything
will go in order. We'll hit

13323
13:30:06,099 --> 13:30:10,749
confirm, we see mining
completed, and then we see done.

13324
13:30:10,959 --> 13:30:14,349
And the reason for this is
because again, our await keyword

13325
13:30:14,409 --> 13:30:17,469
is now waiting, it says oh,
you're returning a promise, I

13326
13:30:17,469 --> 13:30:21,489
need to await I need to wait for
it to resolve or reject. And we

13327
13:30:21,519 --> 13:30:25,029
only resolve the promise once
our provider finds this

13328
13:30:25,029 --> 13:30:27,969
transaction hash and this
transaction receipt, this is

13329
13:30:27,969 --> 13:30:31,269
this listen for transaction
mine. In future sections, all of

13330
13:30:31,269 --> 13:30:33,819
this is going to be abstracted
away for us. So life is going to

13331
13:30:33,819 --> 13:30:36,069
be much easier, but it is
important to understand what's

13332
13:30:36,069 --> 13:30:39,609
actually going on here. Awesome.
So now we're giving the front

13333
13:30:39,609 --> 13:30:47,079
end some indication of what's
going on. Our fun function is

13334
13:30:47,079 --> 13:30:52,359
done well, no, not really. Why
not? Well, because right now

13335
13:30:52,359 --> 13:30:55,659
we're hard coding the eath
amount to 0.1. And on the front

13336
13:30:55,659 --> 13:30:57,939
end, we probably don't want to
hard code it, we probably want

13337
13:30:57,939 --> 13:31:02,049
to allow users to fund as much
or as little as they want. So we

13338
13:31:02,049 --> 13:31:05,349
actually need to change this
from just a button to a input

13339
13:31:05,349 --> 13:31:09,639
form. So to do this, we're gonna
go back over into our HTML. So

13340
13:31:09,639 --> 13:31:13,149
we'll go back to index dot HTML.
And we're going to change this

13341
13:31:13,179 --> 13:31:15,939
fun section here, we're going to
add some form information. So

13342
13:31:15,939 --> 13:31:18,249
we're going to keep this button
as it is, or we're going to add

13343
13:31:18,249 --> 13:31:22,809
like a little text box to input
as much eath as they want. So

13344
13:31:22,839 --> 13:31:26,739
I'm going to create a label,
we're gonna say it's for, it's

13345
13:31:26,739 --> 13:31:29,889
going to be fund and this label
we're gonna say, is eath amount,

13346
13:31:30,549 --> 13:31:32,589
and then we're gonna close
label, this is basically just

13347
13:31:32,589 --> 13:31:34,959
going to create a label. And if
we go back to our front end, we

13348
13:31:34,959 --> 13:31:37,899
now just have this Etham out
label that isn't labeling

13349
13:31:37,929 --> 13:31:40,809
anything. Now we're going to
create an input, and we're going

13350
13:31:40,809 --> 13:31:45,249
to give it an ID of eath amount.
And we're going to give it a

13351
13:31:45,249 --> 13:31:46,059
placeholder

13352
13:31:47,140 --> 13:31:53,470
of 0.1. And then we're gonna
close the input. So now if we

13353
13:31:53,470 --> 13:31:56,920
flip to our front end, we have
eath amount, labeling this

13354
13:31:56,920 --> 13:31:59,710
little text box with a
placeholder of 0.1. And we can

13355
13:31:59,710 --> 13:32:02,110
add stuff in here, you know,
blah, blah, whatever. And one

13356
13:32:02,110 --> 13:32:05,170
more thing, if you have some
tags, but you don't put anything

13357
13:32:05,170 --> 13:32:07,720
in between them, you can
actually shorten it by just

13358
13:32:07,960 --> 13:32:11,950
putting the little closing thing
at the back of it like this. So

13359
13:32:11,950 --> 13:32:13,600
if you don't have anything
between your tags, you can just

13360
13:32:13,600 --> 13:32:17,140
close them like this, these two
are equivalent, boom, boom,

13361
13:32:17,170 --> 13:32:20,230
boom, boom, those are the same
thing. Great. When we called

13362
13:32:20,230 --> 13:32:22,900
fund right now we're calling
fund and we're not passing any

13363
13:32:22,900 --> 13:32:27,130
parameters. Let's update our
fund to no longer be hardcoding

13364
13:32:27,160 --> 13:32:30,100
eath amount in here, and we'll
have and we'll have our fund

13365
13:32:30,130 --> 13:32:36,070
function populated by whatever
we put in this eath amount input

13366
13:32:36,070 --> 13:32:39,250
box in our fund function,
instead of saying const eath

13367
13:32:39,250 --> 13:32:45,400
amount equals 0.1. We'll grab it
from this eath amount ID and

13368
13:32:45,700 --> 13:32:53,830
we'll say document dot get
element by ID eath amount, dot

13369
13:32:53,830 --> 13:32:59,020
value. So we're going to grab
whatever value In this input box

13370
13:32:59,020 --> 13:33:02,800
here, now, in our index.js, we
have console dot log funding

13371
13:33:02,800 --> 13:33:07,540
with eath amount, if in our
front end, we do 1.7. And we hit

13372
13:33:07,540 --> 13:33:11,230
fund, we now see in our console
dot log, it says funding with

13373
13:33:11,230 --> 13:33:16,900
1.7. And we'll get 1.7. And our
little fun section confirm, it

13374
13:33:16,900 --> 13:33:20,620
will mine it, it'll complete it,
and then say, done. Awesome. So

13375
13:33:20,620 --> 13:33:24,280
now we've added a little text
box here. So people can fund as

13376
13:33:24,280 --> 13:33:27,670
much or as little as they want.
Perfect, this whole thing can

13377
13:33:27,670 --> 13:33:31,480
kind of be considered a form.
There's also a form tag, but

13378
13:33:31,480 --> 13:33:36,850
we're going to just use this for
now. All right, great. We're

13379
13:33:36,850 --> 13:33:39,580
doing a lot of funding right,
and we keep funding our contract

13380
13:33:39,580 --> 13:33:42,370
with more and more Ethan, we
keep adding more and more stuff,

13381
13:33:42,400 --> 13:33:45,220
we probably want a button to
keep track of how much is

13382
13:33:45,220 --> 13:33:48,310
actually in here. So let's just
add a really simple balance

13383
13:33:48,310 --> 13:33:51,190
button. And let me actually just
move this down to the bottom

13384
13:33:51,190 --> 13:33:56,140
here, much better. So we'll say
button, id equals balance

13385
13:33:56,140 --> 13:34:03,010
button. We'll call it get
balance. Now we have a get

13386
13:34:03,010 --> 13:34:05,500
balanced button. And it's not
going to do anything because we

13387
13:34:05,500 --> 13:34:07,780
don't have a get balanced
function. So let's go back to

13388
13:34:07,780 --> 13:34:11,500
our index.js. And we'll create a
get bounced function async

13389
13:34:13,300 --> 13:34:17,110
function get bounce. And we'll
just do what we've been doing so

13390
13:34:17,110 --> 13:34:23,140
far. If type of window dot
Aetherium does not equal,

13391
13:34:23,680 --> 13:34:27,670
undefined, then we're going to
do const provider equals new

13392
13:34:27,910 --> 13:34:34,540
ethers, ethers, dot providers
dot web three provider of

13393
13:34:34,540 --> 13:34:40,840
window, that Aetherium then will
do const balance equals awaits

13394
13:34:40,840 --> 13:34:46,810
provider dot get balance,
contract address, which again,

13395
13:34:46,840 --> 13:34:49,990
we're importing way up at the
top, and then we'll just do

13396
13:34:50,020 --> 13:34:59,680
console dot log ethers dot utils
dot format, ether, bounce this

13397
13:34:59,680 --> 13:35:02,620
format ether function ethers
utils, which you can find in the

13398
13:35:02,620 --> 13:35:06,910
documentation to make reading
ethers, formatted numbers much

13399
13:35:06,910 --> 13:35:09,970
easier to read. Then same as
what we've been doing before,

13400
13:35:10,540 --> 13:35:13,390
we're going to go up, we're
going to copy this fun button

13401
13:35:13,390 --> 13:35:19,540
line, paste it will say balance
button equals document dot get

13402
13:35:19,540 --> 13:35:26,860
element by ID, balance button.
And then we'll say balance

13403
13:35:26,860 --> 13:35:31,780
button on click equals get
balance, we're gonna come back

13404
13:35:31,780 --> 13:35:34,030
to our front end, we'll do a
quick refresh, we'll do get

13405
13:35:34,030 --> 13:35:37,420
balance. And now we can see the
balance in the console, we can

13406
13:35:37,420 --> 13:35:42,550
fund with more like 1.8, we'll
hit fund metamath pops up, we'll

13407
13:35:42,550 --> 13:35:46,030
go ahead and confirm mining
completed done, we hit get

13408
13:35:46,030 --> 13:35:53,080
balanced, and now we're at 3.8.
Fantastic. Alright, let's keep

13409
13:35:53,080 --> 13:35:55,690
it going. What do we need to do
next, we're gonna go ahead and

13410
13:35:55,690 --> 13:35:58,750
eat our withdrawal function
here. So let's create that this

13411
13:35:58,750 --> 13:36:01,600
is gonna look really similar to
everything we've done so far. So

13412
13:36:01,600 --> 13:36:04,630
on our index dot HTML, let's
create a new button that we can

13413
13:36:04,630 --> 13:36:09,190
do by copying this whole line,
paste it underneath, call this

13414
13:36:09,190 --> 13:36:13,930
withdraw button, we'll call
withdraw. And we'll call this

13415
13:36:13,960 --> 13:36:18,880
withdraw. And then in our index,
do the same thing, we'll copy

13416
13:36:18,880 --> 13:36:25,390
this, paste it below. So with
drop button was document get

13417
13:36:25,390 --> 13:36:31,180
element by ID, withdraw button,
withdraw button.on Click equals

13418
13:36:31,240 --> 13:36:34,780
withdraw. So let's make a
withdrawal function down at the

13419
13:36:34,780 --> 13:36:39,400
bottom. We'll go ahead, say
async. Function withdraw,

13420
13:36:40,930 --> 13:36:43,990
will do the exact same that
we've done above. And I can even

13421
13:36:43,990 --> 13:36:48,430
just copy everything from the
get balance and just remove the

13422
13:36:48,430 --> 13:36:51,730
balance section. If type of
window dot Aetherium does not

13423
13:36:51,730 --> 13:36:56,320
equal to undefined, then we'll
grab the provider here. And same

13424
13:36:56,320 --> 13:37:00,430
as the fund contract, we'll grab
the signer and the contract. So

13425
13:37:00,430 --> 13:37:03,910
let's just grab those two lines.
Paste them down here called

13426
13:37:03,910 --> 13:37:07,180
signer equals provider dot get
signer. Contract equals new

13427
13:37:07,180 --> 13:37:09,970
contract, blah, blah, blah.
Okay, cool. Now we're gonna do

13428
13:37:09,970 --> 13:37:13,360
the exact same here as we did
with the fun function. So we're

13429
13:37:13,360 --> 13:37:15,820
gonna do a little try, catch,
and then we'll even add the

13430
13:37:15,820 --> 13:37:21,970
catch here, catch error, console
dot log error. And inside of our

13431
13:37:21,970 --> 13:37:29,080
try, we'll do const transaction
response equals await, contracts

13432
13:37:29,110 --> 13:37:33,310
dot withdraw. We don't need to
put any parameters in here. Oh,

13433
13:37:33,310 --> 13:37:39,070
then actually, let's do a little
console dot log, withdrawing,

13434
13:37:39,220 --> 13:37:41,470
and then we'll get this
transaction response. And then

13435
13:37:41,470 --> 13:37:43,930
we'll listen for this
transaction to get mined as

13436
13:37:43,930 --> 13:37:52,480
well. By running a Wait, listen
for transaction mine transaction

13437
13:37:52,480 --> 13:37:59,320
response comma, provider And
that's it, since we can reuse

13438
13:37:59,320 --> 13:38:02,530
the functionality from our
listen for transaction mine. So

13439
13:38:02,530 --> 13:38:05,350
now we'll refresh, we'll make
sure we're connected, check the

13440
13:38:05,350 --> 13:38:09,850
current balance, which is 3.8.
Now we'll go ahead and withdraw.

13441
13:38:11,050 --> 13:38:14,620
We see our little withdrawing
console dot log, we'll hit

13442
13:38:14,620 --> 13:38:19,330
Confirm. And it looks like we've
completed it, if we look in our

13443
13:38:19,330 --> 13:38:23,800
Metamask, our bounced will have
been increased by the amount

13444
13:38:23,800 --> 13:38:27,760
that was added here. And now if
we hit balance, we do indeed see

13445
13:38:27,820 --> 13:38:30,460
zero, we can even double check
that this is actually working,

13446
13:38:30,580 --> 13:38:34,600
we can see our balance is 9.99.
Let's go ahead and even fund

13447
13:38:34,600 --> 13:38:39,520
this with 99 eath. Good confirm,
looks like it's completed. Our

13448
13:38:39,520 --> 13:38:44,320
meta mask now shows 99.00. And
if we go ahead and withdraw,

13449
13:38:44,860 --> 13:38:48,130
confirm, that withdrawal has
gone through, we can see our

13450
13:38:48,130 --> 13:38:55,030
balance is back up to 9999. And
now let's just go back and

13451
13:38:55,030 --> 13:39:00,070
change. Hey, what's good. We'll
refresh our front end. And now

13452
13:39:00,070 --> 13:39:03,910
we can see you've done it, we've
created a minimalistic website

13453
13:39:04,090 --> 13:39:07,480
that allows us to connect to the
blockchain and call functions

13454
13:39:07,510 --> 13:39:10,750
from a front end. And from a
website, this is absolutely

13455
13:39:10,780 --> 13:39:13,660
massive, you should be
incredibly proud and incredibly

13456
13:39:13,660 --> 13:39:16,780
excited with yourself. Now, this
is definitely a minimalistic

13457
13:39:16,780 --> 13:39:19,510
version. And we're going to work
with more powerful and more

13458
13:39:19,510 --> 13:39:22,330
modern front end frameworks. But
this will give you an idea of

13459
13:39:22,330 --> 13:39:25,780
exactly what's going on behind
the scenes when we're working

13460
13:39:25,780 --> 13:39:28,840
with those more advanced front
ends, and we'll style them up.

13461
13:39:28,840 --> 13:39:31,780
So they look a little bit better
than this. But with that being

13462
13:39:31,780 --> 13:39:34,570
said, you've just learned the
basics of how these front ends

13463
13:39:34,570 --> 13:39:37,210
work. And now that you know how
to push things up to get, I

13464
13:39:37,210 --> 13:39:40,150
highly recommend you start
pushing all of these projects up

13465
13:39:40,150 --> 13:39:43,150
to your GitHub, they will be a
record that you've actually done

13466
13:39:43,150 --> 13:39:45,610
the work and you've built these
smart contracts. And if you're

13467
13:39:45,610 --> 13:39:47,800
looking to get an internship
down the line, if you're looking

13468
13:39:47,800 --> 13:39:51,190
to help other GitHub projects,
this will be a record of hey, I

13469
13:39:51,190 --> 13:39:54,280
can do this, what I can build
look at what I know how to do so

13470
13:39:54,280 --> 13:39:57,160
congratulations on your first
full stack or your first front

13471
13:39:57,160 --> 13:40:00,250
end application. Before we move
on, let's do a quick refresher

13472
13:40:00,250 --> 13:40:03,250
of everything we've learned
here. So number one, typically,

13473
13:40:03,280 --> 13:40:07,210
you want the repository or your
code base. For your back end for

13474
13:40:07,210 --> 13:40:09,940
your smart contracts to be a
different repository than your

13475
13:40:09,940 --> 13:40:12,370
front end, your front end code
is going to be a combination of

13476
13:40:12,370 --> 13:40:15,460
HTML and JavaScript. When we
have a wallet like meta mask,

13477
13:40:15,490 --> 13:40:18,610
we're injecting these browser
based wallets into the window

13478
13:40:18,610 --> 13:40:21,940
object of our browsers like
window dot Aetherium. Each

13479
13:40:21,940 --> 13:40:24,580
browser will have a different
extension here, reason we do

13480
13:40:24,580 --> 13:40:28,240
this, we want to connect to the
RPC URL that's built into our

13481
13:40:28,240 --> 13:40:31,300
meta masks. And in this way,
we're making the same API calls

13482
13:40:31,330 --> 13:40:34,870
to an RPC URL as we do in hard
hat as we do in remix as we do

13483
13:40:34,870 --> 13:40:38,800
in ethers, etc, we created our
first promise based function

13484
13:40:38,860 --> 13:40:42,400
where we had a listener kickoff,
and we wrapped it in a promise

13485
13:40:42,400 --> 13:40:46,480
to say, hey, we want to wait for
our listener to finish since

13486
13:40:46,480 --> 13:40:49,600
this is a promise based
function, we set a weight listen

13487
13:40:49,600 --> 13:40:52,120
for transaction mind and we
waited for this transaction to

13488
13:40:52,120 --> 13:40:55,270
finish so that on our front end,
once our transaction finished

13489
13:40:55,270 --> 13:40:57,910
going through, we can tell the
user it's finished going through

13490
13:40:57,910 --> 13:41:00,430
and we can continue doing other
stuff. Give yourself that round

13491
13:41:00,430 --> 13:41:02,920
of applause and let's move on to
the next section.

13492
13:41:04,340 --> 13:41:08,090
All right, welcome to the next
section. We are now on Lesson

13493
13:41:08,120 --> 13:41:11,990
Nine, our hardhat smart contract
lottery, which again, all the

13494
13:41:11,990 --> 13:41:15,290
code for this section is going
to be available in the GitHub

13495
13:41:15,290 --> 13:41:17,750
repo associated with this
course. Alright, so let me show

13496
13:41:17,750 --> 13:41:20,000
you what we're about to build.
I'm going to show you the front

13497
13:41:20,000 --> 13:41:22,400
end login, you don't have to do
the front end, if you don't

13498
13:41:22,400 --> 13:41:25,550
want. But the front end does
give us a nice way to visualize

13499
13:41:25,550 --> 13:41:27,620
the lottery that we're building.
Here, we're building an

13500
13:41:27,620 --> 13:41:30,890
application that allows users
completely decentralized to

13501
13:41:30,890 --> 13:41:35,660
allow us to engage in a fair, a
verifiably random lottery. This

13502
13:41:35,660 --> 13:41:39,080
is the application that would
actually fix the McDonald's

13503
13:41:39,080 --> 13:41:42,530
issue that we talked about much
earlier. So first, we got this

13504
13:41:42,560 --> 13:41:45,830
Kinect Wallet button that we're
going to click to connect to

13505
13:41:45,830 --> 13:41:48,020
meta mask. And here, we're
actually going to show you how

13506
13:41:48,020 --> 13:41:51,260
to connect to more than just
Metamask wallet connect to trust

13507
13:41:51,260 --> 13:41:53,570
wallet, math, wallet, any of
these wallets, and we'll show

13508
13:41:53,570 --> 13:41:56,690
you how to customize even more.
So we're going to connect to

13509
13:41:56,690 --> 13:42:00,350
Metamask. Here, we'll choose our
account that we imported in from

13510
13:42:00,350 --> 13:42:03,050
Hardhead, we choose Next we're
gonna choose Connect. And

13511
13:42:03,050 --> 13:42:06,440
remember, for our front end bit,
we're gonna go to Settings

13512
13:42:06,500 --> 13:42:09,890
Advanced reset account, if we're
working with a brand new hard

13513
13:42:09,890 --> 13:42:12,650
hat blockchain. Now, the front
end doesn't look super nice, but

13514
13:42:12,650 --> 13:42:15,980
we have an enter raffle button.
And we have a little bit of UI

13515
13:42:15,980 --> 13:42:18,920
talking about the current number
of players and then the most

13516
13:42:18,920 --> 13:42:22,400
previous winner of a raffle. So
we can go ahead and enter the

13517
13:42:22,400 --> 13:42:27,590
raffle and allow anybody to pay
0.1 eath. To enter our smart

13518
13:42:27,590 --> 13:42:30,590
contract, we get a little
transaction saying transaction

13519
13:42:30,590 --> 13:42:33,800
complete, and we get the current
number of players is one, we can

13520
13:42:33,800 --> 13:42:37,310
continue to enter the raffle and
anybody can enter this raffle.

13521
13:42:37,340 --> 13:42:40,130
And this, the smart contract
will keep track of all the

13522
13:42:40,130 --> 13:42:43,220
players in here, we're going to
run this on a timer, the lottery

13523
13:42:43,220 --> 13:42:46,580
is going to automatically
trigger somebody to win. And to

13524
13:42:46,580 --> 13:42:49,700
do this, to get a pure
verifiable random number, we're

13525
13:42:49,700 --> 13:42:53,450
going to be using chain link VRF
to get a pure verifiably random

13526
13:42:53,450 --> 13:42:57,770
number. And then we're gonna use
chain link keepers to trigger

13527
13:42:57,830 --> 13:43:01,880
the automation to automatically
have one of these winners get

13528
13:43:01,880 --> 13:43:04,730
picked every time one of those
time intervals is up. Once the

13529
13:43:04,730 --> 13:43:07,700
keepers kick it off, they will
pick a winner, our decentralized

13530
13:43:07,700 --> 13:43:10,580
lottery will say the most
previous winner is so and so.

13531
13:43:10,820 --> 13:43:13,820
And they will get all the money
from this lottery making a

13532
13:43:13,820 --> 13:43:17,090
perfectly fair decentralized
lottery, we're going to call our

13533
13:43:17,090 --> 13:43:20,150
contract, raffle dot soul but
you can call it lottery dot soul

13534
13:43:20,150 --> 13:43:22,400
or really whatever you want. And
we're going to make it look

13535
13:43:22,400 --> 13:43:25,850
really, really nice. So now
we're back in our Visual Studio

13536
13:43:25,850 --> 13:43:28,940
code. This is going to be the
project. If you learn this, you

13537
13:43:28,940 --> 13:43:31,880
have the skills to learn all the
rest of the smart contract

13538
13:43:31,880 --> 13:43:34,640
concepts, and you are going to
be able to do great things in

13539
13:43:34,640 --> 13:43:37,610
the space. This is going to be
your flagship project, this is

13540
13:43:37,610 --> 13:43:40,070
going to be the one that you can
be the most excited and the most

13541
13:43:40,070 --> 13:43:46,220
proud about for this tutorial.
So let's go ahead and let's

13542
13:43:46,220 --> 13:43:50,810
create a new folder. So we're
gonna do MK dir, hardhat, smart

13543
13:43:50,810 --> 13:43:55,130
contract lottery, FCC or smart
contract, raffle, whatever you

13544
13:43:55,130 --> 13:43:58,160
want to call it, then we're
going to cd into our hard hat,

13545
13:43:58,400 --> 13:44:01,160
smart contract lottery Free Code
Camp. And we're going to type

13546
13:44:01,160 --> 13:44:04,670
code period, or we're going to
open this up in a new folder,

13547
13:44:04,700 --> 13:44:07,430
however we choose to do. So now
that we're in our new folder,

13548
13:44:07,460 --> 13:44:11,210
we're going to create our new
hard hat project. So we're going

13549
13:44:11,210 --> 13:44:19,730
to do yarn, add dash dash dev
hard hat. And we'll get our node

13550
13:44:19,730 --> 13:44:23,150
modules are package dot JSON and
our yarn dot lock. Now we'll do

13551
13:44:23,150 --> 13:44:26,630
yarn hardhat. To get started
with a new project, and we're

13552
13:44:26,630 --> 13:44:30,200
just going to select create an
empty hard hat dot config dot j

13553
13:44:30,200 --> 13:44:32,900
s because we know what a basic
project looks like. And we're

13554
13:44:32,900 --> 13:44:35,150
gonna give this project the
customizations that we want to

13555
13:44:35,150 --> 13:44:37,940
see, we're going to create an
empty hard hat dot config. And

13556
13:44:37,940 --> 13:44:42,140
now in here we have a blank
hardhead.config.js with almost

13557
13:44:42,140 --> 13:44:44,420
nothing in here. So we're
starting completely from

13558
13:44:44,420 --> 13:44:47,420
scratch. Now we're going to add
all of our dependencies in here.

13559
13:44:47,450 --> 13:44:50,870
And oftentimes, you'll add these
sequentially as you build but

13560
13:44:50,870 --> 13:44:54,110
we're just going to add them all
in one line, and there are a lot

13561
13:44:54,110 --> 13:44:57,350
of them. So we've left a copy,
paste the whole section of the

13562
13:44:57,350 --> 13:45:00,320
full blockchain solidity course,
J S, for you to just copy,

13563
13:45:00,320 --> 13:45:03,530
paste, so you can install
everything in one go. So grab

13564
13:45:03,530 --> 13:45:05,420
that line, and it's going to
have everything that we've been

13565
13:45:05,420 --> 13:45:09,080
talking about. And we'll just
hit enter, and we'll install all

13566
13:45:09,080 --> 13:45:09,560
of these.

13567
13:45:10,820 --> 13:45:13,850
And as you create more and more
projects, you'll get the feel of

13568
13:45:13,850 --> 13:45:16,430
what you like for your
dependencies and what tools that

13569
13:45:16,580 --> 13:45:20,060
you like to use. Remember, at
the end of the day, the tool

13570
13:45:20,060 --> 13:45:23,240
that's best for you and best for
the job is the tool that you

13571
13:45:23,240 --> 13:45:26,540
like the most. There never
really is a one tool fits all,

13572
13:45:26,570 --> 13:45:30,770
there's almost always going to
be trade offs. Alright, now that

13573
13:45:30,770 --> 13:45:32,990
we have all those dependencies
installed, if we look at our

13574
13:45:32,990 --> 13:45:36,020
package, JSON will have this
massive dev dependencies, we'll

13575
13:45:36,020 --> 13:45:38,750
have everything in Node modules
will have everything in yarn dot

13576
13:45:38,750 --> 13:45:41,810
lock. And of course, as we know,
in order for any of these to

13577
13:45:41,810 --> 13:45:45,140
actually work, we need to add
them into our Hardhead config.

13578
13:45:45,380 --> 13:45:48,530
Now, there's a lot of stuff to
add in here as well. So like

13579
13:45:48,530 --> 13:45:51,650
once again, if you want to come
to the heart at smart contract,

13580
13:45:51,650 --> 13:45:55,700
lottery, FCC, and go to the
Hardhead config, you can just

13581
13:45:55,700 --> 13:45:59,180
copy paste everything and place
it into your project so that you

13582
13:45:59,180 --> 13:46:02,450
don't have to always type
everything out yourself. Meclabs

13583
13:46:02,450 --> 13:46:05,120
Hardhead waffle anomic labs
started ether scan harder to

13584
13:46:05,120 --> 13:46:08,090
deploy slitted coverage, or had
gas reporter heart had contract

13585
13:46:08,090 --> 13:46:10,790
sizer, which we haven't talked
about yet. But we will Don't

13586
13:46:10,790 --> 13:46:14,420
worry. And then require dot env
dot config. And as you all know,

13587
13:46:14,450 --> 13:46:17,030
all these little semicolons are
popping up and those are going

13588
13:46:17,030 --> 13:46:20,840
to drive me absolutely crazy. So
once again, we can create a dot

13589
13:46:20,870 --> 13:46:25,220
prettier, RC. And if you want to
copy this as well, from one of

13590
13:46:25,220 --> 13:46:29,300
your previous projects are free
to do so. One thing that I added

13591
13:46:29,300 --> 13:46:33,320
in here was a print width of
100. This just changes how long

13592
13:46:33,350 --> 13:46:36,320
a line can be before it goes on
to a new line. That's the only

13593
13:46:36,320 --> 13:46:39,560
difference here. Now if we go to
our config and hit save, they go

13594
13:46:39,560 --> 13:46:43,370
away, thank goodness. Now if we
look at our solidity version,

13595
13:46:43,430 --> 13:46:47,000
we're currently using zero point
7.3. Let's go ahead and update

13596
13:46:47,000 --> 13:46:50,780
that to 8.8 or 8.7, or whatever
you want to use. Now that we

13597
13:46:50,780 --> 13:46:53,990
have all the basic setup, we can
begin coding our smart

13598
13:46:53,990 --> 13:47:00,140
contracts. So we first need to
create a new folder called

13599
13:47:00,170 --> 13:47:03,290
contracts where we're going to
store all of our contracts. And

13600
13:47:03,290 --> 13:47:07,430
let's go ahead and create a new
file called lottery dot soul or

13601
13:47:07,430 --> 13:47:09,950
raffle dot soul or whatever you
want to call it. I'm going to

13602
13:47:09,950 --> 13:47:13,550
call mine raffle dot soul. And
you might see this indexing

13603
13:47:13,550 --> 13:47:16,430
thing happened from time to
time. It's our hard hat,

13604
13:47:16,430 --> 13:47:20,630
solidity extension, indexing all
of our node modules. So it knows

13605
13:47:20,630 --> 13:47:22,460
how to highlight things and
knows how to work with

13606
13:47:22,490 --> 13:47:25,310
everything in our solidity
files. So that's what happens

13607
13:47:25,310 --> 13:47:28,400
when that pops up. Now before we
jump in and create it, let's

13608
13:47:28,430 --> 13:47:31,310
figure out what we're going to
do. So we're going to create our

13609
13:47:31,310 --> 13:47:34,370
raffle contract. And what do we
want people able to do? Well, we

13610
13:47:34,370 --> 13:47:37,400
probably want people be able to
enter the lottery, you know,

13611
13:47:37,430 --> 13:47:40,970
paying some amount, we're
probably going to want to be

13612
13:47:40,970 --> 13:47:44,630
able to pick a random winner.
But we want this to be

13613
13:47:44,660 --> 13:47:47,930
verifiably random, we want this
to be untampered with a bowl.

13614
13:47:47,960 --> 13:47:53,480
And we also want winner to be
selected every X minutes or

13615
13:47:53,480 --> 13:47:57,260
years or months, aka we want
this to be completely automated.

13616
13:47:57,290 --> 13:48:00,470
So we want to deploy the smart
contract and almost have no

13617
13:48:00,470 --> 13:48:03,020
maintenance almost have nobody
ever have to touch it again. And

13618
13:48:03,020 --> 13:48:05,810
it'll just automatically run
forever. This is the power of

13619
13:48:05,810 --> 13:48:08,390
smart contracts. As we know,
since we're picking a random

13620
13:48:08,390 --> 13:48:12,530
number, and we have some event
driven execution, we know that

13621
13:48:12,530 --> 13:48:15,680
we're going to need to use a
chain link Oracle, since we're

13622
13:48:15,680 --> 13:48:17,840
going to need to get the
randomness from outside the

13623
13:48:17,840 --> 13:48:21,290
blockchain. And we're going to
need to have that automated

13624
13:48:21,320 --> 13:48:25,160
execution. Because a smart
contract can execute itself, we

13625
13:48:25,160 --> 13:48:28,250
need somebody to automatically
trigger these. So to trigger

13626
13:48:28,280 --> 13:48:31,070
selecting a winner, we're gonna
have to use the chain link

13627
13:48:31,100 --> 13:48:34,400
keepers. And that's pretty much
going to be our entire code.

13628
13:48:34,490 --> 13:48:37,160
Now, I usually like to do this
before I start any project. And

13629
13:48:37,160 --> 13:48:39,440
the reason that I do a little
bit of brainstorming is because

13630
13:48:39,440 --> 13:48:42,710
we don't want to just jump in
and really do anything, we want

13631
13:48:42,710 --> 13:48:45,590
to have a good idea of what
we're trying to build so that we

13632
13:48:45,590 --> 13:48:48,140
can write tests for it, so that
we can know if we're going in

13633
13:48:48,140 --> 13:48:50,870
the right direction, etc. Now
that we have a good idea of

13634
13:48:50,870 --> 13:48:55,280
where we're going, let's build
it. So per usual, let's do spdx

13635
13:48:55,310 --> 13:49:01,430
license identifier. And my team
will do pragma solidity little

13636
13:49:01,430 --> 13:49:05,360
caret here, zero point 8.7, even
zoom out, just a hair will trash

13637
13:49:05,360 --> 13:49:09,530
that and we'll say contract,
raffle, we can even make sure

13638
13:49:09,560 --> 13:49:12,440
that we're not going crazy by
doing a little yarn Hardhead

13639
13:49:12,440 --> 13:49:15,440
compile and compiled
successfully, we want it to be

13640
13:49:15,440 --> 13:49:18,650
able to enter the lottery want
us to be able to enter it. So

13641
13:49:18,800 --> 13:49:22,460
maybe we'll create a function
called enter raffle. What else

13642
13:49:22,460 --> 13:49:25,400
do we want to do, we want to be
able to pick a random winner. So

13643
13:49:25,400 --> 13:49:30,800
maybe we'll create a function
called pick a random winner, and

13644
13:49:30,800 --> 13:49:33,500
boom. So let's comment out pick
random winner for now. And let's

13645
13:49:33,500 --> 13:49:36,440
just work on this enter raffle
thing. In the past, we've

13646
13:49:36,440 --> 13:49:39,470
created projects like Funmi,
where people can send ether to

13647
13:49:39,470 --> 13:49:42,440
our contracts or send whatever
native blockchain token to our

13648
13:49:42,440 --> 13:49:45,830
smart contracts using the
message dot value based off of

13649
13:49:45,860 --> 13:49:48,260
some USD value. For this one,
we're just going to have the

13650
13:49:48,260 --> 13:49:50,990
entrance fee instead be USD
based, it's just going to be

13651
13:49:51,020 --> 13:49:53,900
that native asset. So for our
enter raffle, we don't have to

13652
13:49:53,900 --> 13:49:57,410
set a USD price, we can just set
a minimum eath price. So up at

13653
13:49:57,410 --> 13:50:01,490
the top, let's pick our minimum
price. So we'll do a un 256

13654
13:50:01,910 --> 13:50:05,330
entrance fee. And now some of
our learnings from our last

13655
13:50:05,330 --> 13:50:09,260
section should come in here, we
now know that this entrance fee

13656
13:50:09,320 --> 13:50:12,230
is going to be a what, it's
going to be a storage variable.

13657
13:50:12,260 --> 13:50:15,800
So let's prepend it with s
underscore let's make a private

13658
13:50:15,800 --> 13:50:18,920
variable because we always want
to set our visibility. But let's

13659
13:50:18,920 --> 13:50:21,530
have the entrance fee be
configurable. Well, let's create

13660
13:50:21,530 --> 13:50:24,170
a constructor now. And we'll
have this entrance fee be

13661
13:50:24,170 --> 13:50:27,380
settable in our constructor, so
our constructor will take a UNT

13662
13:50:27,410 --> 13:50:32,810
two to the sixth entrance fee, s
underscore entrance fee equals

13663
13:50:33,350 --> 13:50:36,680
entrance fee. Well, if we're
gonna only set this one time, we

13664
13:50:36,680 --> 13:50:38,780
might as well make this a
constant or an immutable

13665
13:50:38,780 --> 13:50:41,690
variable. So let's make this an
immutable variable so that we

13666
13:50:41,690 --> 13:50:46,610
save some gas we'll change this
from S to I and now we're saying

13667
13:50:46,640 --> 13:50:50,060
you interviewed six private
immutable I entrance fee equals

13668
13:50:50,060 --> 13:50:53,090
entrance fee. Now we probably
are going to want other users to

13669
13:50:53,090 --> 13:50:56,240
see the entrance fee. So down
below, we can create function

13670
13:50:56,270 --> 13:50:59,930
get entrance fee, and this will
be a public view function which

13671
13:50:59,930 --> 13:51:03,560
will returns a UN to the set
Next, and we'll just say return

13672
13:51:04,010 --> 13:51:07,280
entrance fee. Now we have a
function that users can call to

13673
13:51:07,280 --> 13:51:10,610
get the entrance fee. But we, as
developers can use this AI

13674
13:51:10,610 --> 13:51:13,730
entrance fee to know this is an
immutable variable. This is

13675
13:51:13,730 --> 13:51:17,210
pretty cheap gas wise for us to
read from in our enter raffle,

13676
13:51:17,240 --> 13:51:20,180
we've done a ton of these
before, all we need to do is we

13677
13:51:20,180 --> 13:51:24,560
just need to require the message
dot value is greater than that I

13678
13:51:24,560 --> 13:51:27,770
underscore entrance fee, what
we've learned before about those

13679
13:51:27,800 --> 13:51:32,570
error codes, so we could use
require message dot value, or we

13680
13:51:32,570 --> 13:51:35,360
could do one of these customers,
which is going to be a lot more

13681
13:51:35,360 --> 13:51:38,150
gas efficient, because instead
of storing this string, we're

13682
13:51:38,150 --> 13:51:41,030
just going to store an error
code in our smart contract. So

13683
13:51:41,030 --> 13:51:44,900
let's do that. Instead, we'll
say if the message dot value is

13684
13:51:44,930 --> 13:51:47,180
less than our eye entrance fee,

13685
13:51:48,620 --> 13:51:52,010
then we're just going to revert
the whole transaction with some

13686
13:51:52,010 --> 13:51:56,540
error code. And we'll use a best
practice naming raffle

13687
13:51:56,720 --> 13:52:02,930
underscore underscore not enough
eath entered. And we'll grab

13688
13:52:02,930 --> 13:52:06,110
this arrow code. And we'll have
if the user doesn't send enough

13689
13:52:06,110 --> 13:52:10,130
value will revert with not
enough eath entered now that we

13690
13:52:10,130 --> 13:52:13,490
know they're calling into raffle
with enough value, we're

13691
13:52:13,490 --> 13:52:16,250
probably going to want to keep
track of all the users who

13692
13:52:16,250 --> 13:52:19,640
actually enter our raffle. That
way, when we pick a winner, we

13693
13:52:19,640 --> 13:52:22,880
know who's in the running. So
let's create an array of players

13694
13:52:22,910 --> 13:52:26,300
at the top error here. And then
just to make this look even

13695
13:52:26,300 --> 13:52:29,300
nicer, we'll do a little comment
here. And we'll say state

13696
13:52:29,360 --> 13:52:32,780
variables. And we'll combine
both our storage and are not

13697
13:52:32,780 --> 13:52:35,510
storage variables just in this
state variable section. So we'll

13698
13:52:35,510 --> 13:52:41,030
do address array players. Now
players, of course, is going to

13699
13:52:41,030 --> 13:52:43,520
have to be in storage, because
we're going to modify this a

13700
13:52:43,520 --> 13:52:45,980
lot, we're going to be adding
and subtracting players all the

13701
13:52:45,980 --> 13:52:49,580
time. So we're going to do s
players will make this private

13702
13:52:49,580 --> 13:52:53,210
as well. And we're going to make
this address payable players

13703
13:52:53,240 --> 13:52:55,340
because one of these players
wins, we're going to need to

13704
13:52:55,340 --> 13:52:59,060
have to pay them. So we'll make
this address payable private as

13705
13:52:59,060 --> 13:53:01,460
players. And since we're going
to make this private, and it's

13706
13:53:01,460 --> 13:53:04,730
probably good that we know who's
in the players array, we'll even

13707
13:53:04,730 --> 13:53:09,800
do function it player. This will
be a public view that returns an

13708
13:53:09,800 --> 13:53:14,870
address of one of these players.
And we'll just return s players

13709
13:53:15,230 --> 13:53:19,880
of index will have this
function, take a un 256 index as

13710
13:53:19,880 --> 13:53:22,370
an input parameter, we know that
players is going to be a storage

13711
13:53:22,370 --> 13:53:25,640
variable. And we're going to add
it to our enter raffle Oh, and

13712
13:53:25,640 --> 13:53:29,210
we definitely want our Inter
raffle to be public and to be

13713
13:53:29,210 --> 13:53:33,290
payable. Since we're having
people send message dot value,

13714
13:53:33,350 --> 13:53:36,260
and we want anyone to be able to
enter our raffle. So it'll be

13715
13:53:36,260 --> 13:53:39,140
public, it'll be payable, it'll
be perfect. Now that we have our

13716
13:53:39,170 --> 13:53:43,910
array, and someone's entered the
raffle, we'll do s players dot

13717
13:53:43,970 --> 13:53:49,160
push message dot sender. Now,
this doesn't actually work

13718
13:53:49,220 --> 13:53:52,580
because message dot sender isn't
a payable address. So we'll need

13719
13:53:52,580 --> 13:53:56,600
to typecast it as a payable
address just by wrapping it in

13720
13:53:56,600 --> 13:53:59,510
payable. So now we have a way to
keep track of all the players

13721
13:53:59,540 --> 13:54:00,200
that are entering

13722
13:54:00,230 --> 13:54:05,300
a raffle. Now one of the
concepts that we haven't gone

13723
13:54:05,300 --> 13:54:08,510
over yet is actually going to be
events. And events are really

13724
13:54:08,510 --> 13:54:11,840
important to our smart
contracts. Whenever we update a

13725
13:54:11,840 --> 13:54:15,920
dynamic object, like an array or
a mapping, we always want to

13726
13:54:15,950 --> 13:54:18,890
omit an event when we get to
less than 10. And then

13727
13:54:18,920 --> 13:54:22,850
especially less than 15 with the
next Jas and if T marketplace,

13728
13:54:22,880 --> 13:54:25,940
these events will make a ton of
sense, especially for front end

13729
13:54:25,940 --> 13:54:29,780
developers. So right now events
might be a little bit of a weird

13730
13:54:29,780 --> 13:54:32,330
thing for you as we explain it.
But as we continue on, they'll

13731
13:54:32,330 --> 13:54:34,700
start to make more and more
sense. So we're going to start

13732
13:54:34,700 --> 13:54:37,460
adding events to our smart
contracts. Whenever we update

13733
13:54:37,460 --> 13:54:40,310
one of these dynamically sized
data structures. And to learn

13734
13:54:40,310 --> 13:54:42,800
more about events and how to use
them. We're gonna watch another

13735
13:54:42,800 --> 13:54:45,620
video that explains all about
events. You can actually follow

13736
13:54:45,620 --> 13:54:48,500
along with this video as a side
project. But let's learn all

13737
13:54:48,500 --> 13:54:50,930
about events. Now, if you've
worked with solidity, you've

13738
13:54:50,930 --> 13:54:54,230
probably seen these things
called events before or maybe

13739
13:54:54,230 --> 13:54:56,450
you haven't seen something like
events. But you've always

13740
13:54:56,450 --> 13:54:59,390
wondered how chain link or the
graph or some of these other off

13741
13:54:59,390 --> 13:55:02,120
chain protocols work under the
hood. And in this video, we're

13742
13:55:02,120 --> 13:55:05,240
gonna learn about logging and
events in solidity, viewing

13743
13:55:05,240 --> 13:55:08,360
those events on ether scan, and
then working with them in hard

13744
13:55:08,360 --> 13:55:12,080
hat. Now it's the Ethereum
virtual machine, or EVM. That

13745
13:55:12,080 --> 13:55:15,470
makes a lot of these block
chains tick, like Aetherium. And

13746
13:55:15,470 --> 13:55:19,100
the EVM has this functionality
called a logging functionality.

13747
13:55:19,280 --> 13:55:22,550
When things happen on a
blockchain, the EVM writes these

13748
13:55:22,550 --> 13:55:26,150
things to a specific data
structure called its log, we can

13749
13:55:26,150 --> 13:55:28,940
actually read these logs from
our blockchain nodes that we

13750
13:55:28,940 --> 13:55:32,090
run. In fact, if you run a node
or you connect to a node, you

13751
13:55:32,090 --> 13:55:37,130
can make a F get logs call to
get the logs. Now inside these

13752
13:55:37,130 --> 13:55:40,970
logs is an important piece of
logging called events. And this

13753
13:55:40,970 --> 13:55:42,950
is the main piece that we're
gonna be talking about today.

13754
13:55:43,040 --> 13:55:46,940
events allow you to print
information to this logging

13755
13:55:46,940 --> 13:55:49,910
structure in a way that's more
gas efficient than actually

13756
13:55:49,910 --> 13:55:53,150
saving it to something like a
storage variable. These events

13757
13:55:53,150 --> 13:55:56,690
and logs live in this special
data structure that isn't

13758
13:55:56,720 --> 13:56:00,050
accessible to smart contracts.
That's why it's cheaper because

13759
13:56:00,050 --> 13:56:02,600
smart contracts can access them
so that If the trade off here,

13760
13:56:02,630 --> 13:56:05,270
we can still print some
information that's important to

13761
13:56:05,270 --> 13:56:09,140
us without having to save it in
a storage variable, which is

13762
13:56:09,140 --> 13:56:12,620
going to take up much more gas.
Each one of these events is tied

13763
13:56:12,620 --> 13:56:16,550
to the smart contract or account
address that emitted this event

13764
13:56:16,580 --> 13:56:19,880
in these transactions. listening
for these events is incredibly

13765
13:56:19,880 --> 13:56:22,790
helpful. Let's say for example,
you want to do something every

13766
13:56:22,790 --> 13:56:26,450
time somebody calls a transfer
function. Instead of always

13767
13:56:26,450 --> 13:56:29,540
reading all the variables and
looking for something to flip

13768
13:56:29,540 --> 13:56:34,220
and switch, all you have to do
is say, listen for event. So a

13769
13:56:34,220 --> 13:56:37,010
transaction happened, an event
is emitted. And we can listen

13770
13:56:37,010 --> 13:56:40,460
for these events. This is how a
lot of off chain infrastructure

13771
13:56:40,490 --> 13:56:44,210
works. When you're on a website,
and that website reloads when a

13772
13:56:44,210 --> 13:56:47,510
transaction completes, it
actually was listening for that

13773
13:56:47,510 --> 13:56:51,200
transaction to finish listening
for that event to be emitted, so

13774
13:56:51,200 --> 13:56:53,870
that it could reload or it could
do something else. It's

13775
13:56:53,870 --> 13:56:57,020
incredibly important for front
ends. It's also incredibly

13776
13:56:57,020 --> 13:57:00,770
important for things like chain
link, and the graph in the chain

13777
13:57:00,770 --> 13:57:03,620
link network. A chain link node
is actually listening for

13778
13:57:03,650 --> 13:57:07,850
request data events for to get a
random number, make an API call,

13779
13:57:07,850 --> 13:57:11,780
or etc. Sometimes there are way
too many events. And you need to

13780
13:57:11,930 --> 13:57:15,170
index them in a way that makes
sense that you can query all

13781
13:57:15,170 --> 13:57:18,620
these events that happen at a
later date. The graph listens

13782
13:57:18,620 --> 13:57:21,620
for these events and stores them
in the graph so that they're

13783
13:57:21,650 --> 13:57:25,280
easy to query later on. So
events are incredibly powerful.

13784
13:57:25,280 --> 13:57:27,590
And they have a wide range of
uses. They're also good for

13785
13:57:27,590 --> 13:57:30,290
testing and some other stuff,
but you get the picture. They're

13786
13:57:30,290 --> 13:57:33,110
really sick. Now that we know
what events are, let's look at

13787
13:57:33,110 --> 13:57:36,500
what they look like how we can
use them and how we might use

13788
13:57:36,500 --> 13:57:39,590
them in our smart contract
development suite. Now here's

13789
13:57:39,590 --> 13:57:42,680
what an event is going to look
like. We have an event here

13790
13:57:42,680 --> 13:57:46,490
called stored number. So we have
basically a new type of event

13791
13:57:46,520 --> 13:57:49,880
called stored number. We're
saying, hey, solidity, hey,

13792
13:57:49,880 --> 13:57:53,300
smart contract, we have this new
event thing, we're going to be

13793
13:57:53,330 --> 13:57:57,290
omitting things of typed stored
number in the future. When we

13794
13:57:57,320 --> 13:58:00,110
emit this event, it's going to
have these four parameters, it's

13795
13:58:00,110 --> 13:58:03,770
going to have a unique 256. For
called old number. Are you

13796
13:58:03,770 --> 13:58:06,260
interested? Is it called new
number are you intimidated six

13797
13:58:06,260 --> 13:58:09,440
called add a number and an
address called center. Now for

13798
13:58:09,440 --> 13:58:10,580
the astute people here, you

13799
13:58:10,580 --> 13:58:13,790
might have noticed that there
was another keyword in here, the

13800
13:58:13,820 --> 13:58:17,360
index to keyword and this is a
really important keyword. When

13801
13:58:17,360 --> 13:58:19,580
we omit one of these events,
there are two kinds of

13802
13:58:19,580 --> 13:58:23,240
parameters, there are the index
parameters and the non indexed

13803
13:58:23,240 --> 13:58:27,380
parameters, you can have up to
three index parameters. And

13804
13:58:27,380 --> 13:58:30,830
they're also known as topics. So
if you see a topic, you know

13805
13:58:30,830 --> 13:58:33,590
that that's going to be an
indexed parameter. Index

13806
13:58:33,590 --> 13:58:37,100
parameters are parameters that
are much easier to search for,

13807
13:58:37,160 --> 13:58:40,550
and much easier to query than
the non index parameters. In

13808
13:58:40,550 --> 13:58:43,910
fact, we recommend F get logs
function, it even has a

13809
13:58:43,910 --> 13:58:46,940
parameter allows us to search
for specific topics. So it's

13810
13:58:46,940 --> 13:58:50,540
much more searchable than the
non indexed ones. The non

13811
13:58:50,540 --> 13:58:53,450
indexed ones are harder to
search because they get ABI

13812
13:58:53,450 --> 13:58:56,090
encoded, and you have to know
the API in order to decode them.

13813
13:58:56,120 --> 13:58:58,400
Now, this is told our smart
contract that there is a new

13814
13:58:58,400 --> 13:59:02,630
type of stored number, a new
kind of event here, we need to

13815
13:59:02,630 --> 13:59:06,230
actually emit that event in
order to store that data into

13816
13:59:06,230 --> 13:59:10,640
the logging data structure of
the EVM. To do that, we need to

13817
13:59:10,640 --> 13:59:13,580
do something that looks like
this. This is what it looks like

13818
13:59:13,580 --> 13:59:16,730
when we emit an event, it looks
very similar to calling a

13819
13:59:16,730 --> 13:59:21,230
function. So you call a mitt and
then the name of the event. And

13820
13:59:21,230 --> 13:59:24,140
then you add all the parameters
in there that you like. Here's

13821
13:59:24,140 --> 13:59:27,560
the full example of a smart
contract that has an event and

13822
13:59:27,560 --> 13:59:30,290
is going to be the example that
we walked through in hard hat.

13823
13:59:30,320 --> 13:59:33,530
Now in this smart contract,
whenever anybody calls the store

13824
13:59:33,530 --> 13:59:37,400
function, we're going to omit
this event. Here's an example of

13825
13:59:37,400 --> 13:59:41,180
a transaction where we call the
store function with a value of

13826
13:59:41,330 --> 13:59:45,950
one, let's look into the logs to
see what this event actually is

13827
13:59:45,950 --> 13:59:49,010
going to look like an event is
going to be broken down like so

13828
13:59:49,040 --> 13:59:52,490
the address of the contract or
account, the event is emitted

13829
13:59:52,490 --> 13:59:56,750
from the topics or the index
parameters of the event data.

13830
13:59:56,900 --> 14:00:00,680
This is the ABI encoded non
index parameters of the event.

13831
14:00:01,250 --> 14:00:04,070
What does this mean? This means
that we took those parameters

13832
14:00:04,070 --> 14:00:08,810
that were non indexed, we match
them together with their API or

13833
14:00:08,810 --> 14:00:11,480
application binary interface,
pumped them through an encoding

13834
14:00:11,480 --> 14:00:14,240
algorithm, and boom, this is
what we got. If you have the

13835
14:00:14,240 --> 14:00:17,360
API, they're very easy to
decode. If you don't have the

13836
14:00:17,360 --> 14:00:22,310
ABI they are very hard to decode
these non indexed parameters

13837
14:00:22,340 --> 14:00:26,180
cost less gas to pump into the
logs. Now in this particular

13838
14:00:26,180 --> 14:00:29,690
contract, since we have verified
the code, we verified the

13839
14:00:29,690 --> 14:00:33,020
contract ether scan knows what
the ABI is, and we can view this

13840
14:00:33,020 --> 14:00:37,940
in Deke or decoded mode. Hex
mode is obviously the non

13841
14:00:37,940 --> 14:00:41,690
decoded mode, or in its raw, hex
or hexadecimal or encoded mode.

13842
14:00:41,810 --> 14:00:44,780
You can read more about the
layout of these events in the

13843
14:00:44,780 --> 14:00:50,180
solidity docs. Now, so that's
the basic introduction of

13844
14:00:50,180 --> 14:00:52,580
events. And for those of you who
want to watch the rest of that

13845
14:00:52,580 --> 14:00:55,460
video, and who wants to actually
practice using events yourself,

13846
14:00:55,520 --> 14:00:58,070
there's a link to these videos
and the code repository

13847
14:00:58,100 --> 14:01:00,500
associated with that video, if
you want to play with it, and if

13848
14:01:00,500 --> 14:01:02,750
you want to learn more, so feel
free Ready to refer back to the

13849
14:01:02,750 --> 14:01:05,570
full blockchain solidity course,
Jas, if you want to go deeper

13850
14:01:05,570 --> 14:01:07,790
into events now that we're back,
and we've learned a little bit

13851
14:01:07,790 --> 14:01:10,730
more about events, let's add
some events to this contract.

13852
14:01:10,850 --> 14:01:13,610
Remember, these events get
emitted to a data storage

13853
14:01:13,640 --> 14:01:16,640
outside of this smart contract.
Let's create an event called

13854
14:01:16,670 --> 14:01:21,140
raffle enter a good syntax for
naming events, name events, with

13855
14:01:21,140 --> 14:01:25,490
the function name reversed. So
for enter raffle, we're gonna

13856
14:01:25,490 --> 14:01:28,880
say raffle entered. So up at the
top below our state variables,

13857
14:01:28,880 --> 14:01:32,390
but above our constructor, we'll
create a new section called

13858
14:01:32,420 --> 14:01:36,890
events. And we'll create our
first event. So we'll do event,

13859
14:01:37,520 --> 14:01:40,790
raffle, Enter. And we'll just
have this raffle enter take one

13860
14:01:40,820 --> 14:01:45,440
index parameter, it'll be an
address indexed player. So in

13861
14:01:45,440 --> 14:01:49,910
our Inter raffle, we're going to
say omit raffle enter. And we're

13862
14:01:49,910 --> 14:01:52,880
just going to pass it message
dot sender. I'm going to remove

13863
14:01:52,880 --> 14:01:55,430
these comments for now. But feel
free to leave them in as you

13864
14:01:55,430 --> 14:01:59,210
code along. Now in this part of
my raffle coding or my lottery

13865
14:01:59,210 --> 14:02:02,480
coding process, I probably would
start already writing some tests

13866
14:02:02,480 --> 14:02:05,330
and already writing some deploy
scripts. The reason that we do

13867
14:02:05,330 --> 14:02:08,300
this is it's good to test our
functionality as we progress.

13868
14:02:08,360 --> 14:02:11,030
And oftentimes, when I'm writing
smart contracts, I'm constantly

13869
14:02:11,030 --> 14:02:14,000
flipping back and forth between
my deploy scripts, my contracts

13870
14:02:14,030 --> 14:02:17,060
and my tests to make sure
everything is doing exactly what

13871
14:02:17,060 --> 14:02:19,700
I want it to do for the purpose
of this course. And just to make

13872
14:02:19,700 --> 14:02:22,340
it easy for you to learn and
follow along, we're not going to

13873
14:02:22,340 --> 14:02:24,800
do that. And we're just going to
keep writing our smart contract

13874
14:02:24,830 --> 14:02:28,040
almost to complete and then move
to our deploy scripts and tests.

13875
14:02:30,710 --> 14:02:33,620
So in its minimalistic sense, we
essentially have a way for

13876
14:02:33,620 --> 14:02:37,070
people to enter our raffle. Now
we need a way to pick the random

13877
14:02:37,100 --> 14:02:40,040
winner. And this is where we're
going to need chain link VRF and

13878
14:02:40,040 --> 14:02:43,310
chain link keepers. So let's
again, watch some sub lessons

13879
14:02:43,340 --> 14:02:46,550
about learning about chain link
VRF. And learning about chain

13880
14:02:46,550 --> 14:02:49,340
link keepers. We've made some
videos about these before. So

13881
14:02:49,340 --> 14:02:51,440
we're just going to play these
videos. So you can learn about

13882
14:02:51,440 --> 14:02:54,320
how taling VRF version two
works, and also how chain link

13883
14:02:54,350 --> 14:02:56,870
keepers works, then we're going
to come back and we're going to

13884
14:02:56,870 --> 14:02:59,090
add them into our contracts
here. If you're already

13885
14:02:59,090 --> 14:03:01,340
familiar, and you already played
with them, feel free to skip

13886
14:03:01,340 --> 14:03:03,710
those sections. And we'll just
get to building them here.

13887
14:03:04,160 --> 14:03:06,680
Hi, my name is Steven fluid. And
today we're going to be taking a

13888
14:03:06,680 --> 14:03:10,160
look at chain links VRF. version
two, version two has a few

13889
14:03:10,160 --> 14:03:12,890
different mental models that we
should be aware of. And I want

13890
14:03:12,890 --> 14:03:15,440
to show you what it feels like
to be using it. The big

13891
14:03:15,440 --> 14:03:18,620
important thing to know about
Vera version two is that instead

13892
14:03:18,620 --> 14:03:21,200
of the Vera one model where
you'd be funding your contract

13893
14:03:21,200 --> 14:03:24,380
with Link, instead, you're going
to be funding a subscription,

13894
14:03:24,620 --> 14:03:27,170
which is basically an account
that allows you to fund and

13895
14:03:27,170 --> 14:03:31,550
maintain balance for multiple
consumer contracts. Let's dive

13896
14:03:31,550 --> 14:03:34,760
into the docs and see what using
Vera fie two looks and feels

13897
14:03:34,760 --> 14:03:37,730
like. In order to show this off
a little bit. I'm going to dive

13898
14:03:37,730 --> 14:03:40,700
right into the get a random
number guide in the chain link

13899
14:03:40,700 --> 14:03:43,160
documentation. And so it's going
to go through a few the

13900
14:03:43,160 --> 14:03:44,870
requirements of some of the
technology we're going to use

13901
14:03:44,870 --> 14:03:47,630
today. And the first thing it's
going to ask us to do is to make

13902
14:03:47,630 --> 14:03:50,120
sure that we are on the Rinkeby
test net. So let's go ahead and

13903
14:03:50,120 --> 14:03:53,720
jump over to Rinkeby. Make sure
my meta mask is unlocked here.

13904
14:03:54,200 --> 14:03:57,890
And now that I'm on Rinkeby,
great, I should be able to use

13905
14:03:58,220 --> 14:04:02,420
the VIP version to test net. Now
we're going to jump over to

13906
14:04:02,420 --> 14:04:05,630
subscription manager. And the
subscription manager is where

13907
14:04:05,630 --> 14:04:07,580
we're going to manage our
subscription account. Basically,

13908
14:04:07,640 --> 14:04:10,370
this is the place that you put
the funds in order to be able to

13909
14:04:10,370 --> 14:04:13,130
use it across a bunch of
different chains. So we're going

13910
14:04:13,130 --> 14:04:16,010
to go ahead and connect our
wallet here in order to use the

13911
14:04:16,010 --> 14:04:20,090
subscription app. And then we're
going to go ahead and create a

13912
14:04:20,150 --> 14:04:22,760
new subscription. So we'll just
use my address as the

13913
14:04:22,760 --> 14:04:27,200
subscription address here. I'll
approve the creation. And as

13914
14:04:27,200 --> 14:04:29,420
soon as that transaction is
confirmed, our subscription

13915
14:04:29,420 --> 14:04:33,230
should be created. Alright, now
we have a subscription.

13916
14:04:33,230 --> 14:04:35,300
Basically, this is the account
where we're going to fund it.

13917
14:04:35,510 --> 14:04:38,990
And then we can use that account
for all of our random Miss

13918
14:04:38,990 --> 14:04:42,140
requests. So I'm gonna go ahead
and just put in 10 link here,

13919
14:04:42,140 --> 14:04:46,880
you can put in however much you
want. The price and link of

13920
14:04:46,880 --> 14:04:49,520
every random number you request,
it's going to be based on the

13921
14:04:49,550 --> 14:04:54,320
current gas rates on a given
chain, as well as the gasoline

13922
14:04:54,320 --> 14:04:57,320
that you've chosen. On our funds
have been added, let's go ahead

13923
14:04:57,320 --> 14:05:00,290
and add a consumer contract. So
it's asking us for consumer

13924
14:05:00,290 --> 14:05:02,780
address, we don't actually have
a consumer address yet. So let's

13925
14:05:02,780 --> 14:05:06,380
go ahead and jump over to the
documentation and create a

13926
14:05:06,380 --> 14:05:09,560
contract that is going to
request a number. So if you

13927
14:05:09,560 --> 14:05:12,320
scroll down, you're going to see
this Vera fee to consumer that

13928
14:05:12,320 --> 14:05:14,960
soul contract that we can open
it in remix, let's just jump

13929
14:05:14,990 --> 14:05:18,290
right there. We're gonna notice
a few different things in this

13930
14:05:18,290 --> 14:05:20,870
contract at the top, we've got
some input. So now you've got

13931
14:05:20,870 --> 14:05:23,720
VRF, consumer base version two,
we've got an interface for the

13932
14:05:23,720 --> 14:05:27,320
VRF coordinator, and then also a
reference to the link token

13933
14:05:27,320 --> 14:05:30,530
interface. So all of those are
specified for you on the Rinkeby

13934
14:05:30,530 --> 14:05:33,620
network here in the example
code. And then you can refer to

13935
14:05:33,620 --> 14:05:35,570
the documentation for whatever
chain you're going to be

13936
14:05:35,570 --> 14:05:39,620
deploying to. And then you're
going to see a few new options

13937
14:05:39,620 --> 14:05:43,190
here. So the key hash option is
the way that you specify that

13938
14:05:43,190 --> 14:05:46,370
gasoline that was described in
the documentation. So depending

13939
14:05:46,370 --> 14:05:49,640
on the key hash you choose for
the given chain you're on the

13940
14:05:49,640 --> 14:05:53,480
gas limit will be set
differently for your random

13941
14:05:53,480 --> 14:05:56,510
number requests. So for example,
on a theory main net, we have a

13942
14:05:56,510 --> 14:06:00,680
200 way key hash 500 Wiki hash
and 1000 graykey hash. You can

13943
14:06:00,680 --> 14:06:03,410
also see in our contract Hear
that we have a callback estimate

13944
14:06:03,410 --> 14:06:06,290
that you're in charge of. So
depending on how much gas you're

13945
14:06:06,290 --> 14:06:09,530
willing to spend in the fulfill
random number, you should set

13946
14:06:09,530 --> 14:06:13,640
this value appropriately. Next
up is request confirmations. So

13947
14:06:13,640 --> 14:06:15,950
this was something in verify
would be one that you could not

13948
14:06:15,950 --> 14:06:18,050
control. But here now, depending
on the chain you're on,

13949
14:06:18,050 --> 14:06:20,600
depending on the request and the
type nature of the request you

13950
14:06:20,600 --> 14:06:24,200
want to make, you can actually
change this number. And then one

13951
14:06:24,200 --> 14:06:26,600
of the most important and useful
features that gives you a lot

13952
14:06:26,600 --> 14:06:30,350
more flexibility and control of
your VRF is you can actually

13953
14:06:30,350 --> 14:06:34,010
specify the number of random
numbers you want. And so you

13954
14:06:34,010 --> 14:06:36,800
specify the number words, and
then that will specify how many

13955
14:06:36,800 --> 14:06:42,560
random you went to 56 as you get
back from the network. All right

13956
14:06:42,560 --> 14:06:45,800
here in the constructor, we're
gonna see a address for the

13957
14:06:45,800 --> 14:06:48,380
coordinator and address for the
link token. And then you'll see

13958
14:06:48,380 --> 14:06:50,810
that the subscription ID is
going to be created as we deploy

13959
14:06:50,810 --> 14:06:54,260
the contract. And so I'm gonna
go ahead and get that. So if you

13960
14:06:54,260 --> 14:06:56,330
remember when we created the
subscription after we found it,

13961
14:06:56,330 --> 14:06:59,060
and we see this subscription ID,
and now when I deploy this, I'm

13962
14:06:59,060 --> 14:07:01,520
going to use that subscription
ID. And we've got two methods

13963
14:07:01,520 --> 14:07:05,000
that should look very familiar,
we've got fulfill randomness

13964
14:07:05,000 --> 14:07:07,940
method that takes in randomness
is going to be fulfilled by the

13965
14:07:07,940 --> 14:07:10,970
Bureau of Oracle, as well as you
got request random words, which

13966
14:07:10,970 --> 14:07:13,130
is how we're actually going to
initiate the request to the

13967
14:07:13,130 --> 14:07:15,830
Oracle. So I think we're
actually are already ready to go

13968
14:07:15,830 --> 14:07:18,620
ahead and deploy this. So let's
jump to the deploy screen here

13969
14:07:19,010 --> 14:07:21,800
and select the right contract,
which in our case, is your FB to

13970
14:07:21,800 --> 14:07:24,800
consumer. And I'm going to make
sure that I am on injected web

13971
14:07:24,800 --> 14:07:26,900
three so that we can actually
deploy to the Rinkeby network.

13972
14:07:27,770 --> 14:07:29,990
And I'm going to paste in the
subscription ID here. And I'm

13973
14:07:29,990 --> 14:07:33,140
going to deploy, let's go ahead
and pay for that transaction.

13974
14:07:35,870 --> 14:07:38,660
And as soon as that is confirmed
by the network will show up

13975
14:07:38,660 --> 14:07:41,690
here, and we'll be able to copy
this address, and then add that

13976
14:07:41,690 --> 14:07:45,860
as a consumer and authorize this
contract to use my subscription

13977
14:07:45,860 --> 14:07:51,830
account. So let's go ahead and
authorize this with them another

13978
14:07:51,830 --> 14:07:52,790
Metamask transaction.

13979
14:07:56,390 --> 14:07:58,130
Alright, we can have your
subscription, we can see how

13980
14:07:58,130 --> 14:08:00,830
much link we funded it with. And
we can see our consumer

13981
14:08:00,830 --> 14:08:04,190
contract. So now by doing this,
we've authorized our consumer

13982
14:08:04,190 --> 14:08:08,360
contract to make requests for
randomness. So let's go ahead

13983
14:08:08,360 --> 14:08:10,820
and make a request for
randomness here. So we're gonna

13984
14:08:10,820 --> 14:08:14,000
go back to our contract that we
deployed here. And we're just

13985
14:08:14,000 --> 14:08:16,460
gonna use the remix interface
here to keep things simple. And

13986
14:08:16,460 --> 14:08:19,460
I'm going to request some
randomness. So obviously, this

13987
14:08:19,460 --> 14:08:23,090
is going to use all of the
configuration that I specified

13988
14:08:23,090 --> 14:08:25,250
in my contract, just kind of
hard coded here. So we're gonna

13989
14:08:25,250 --> 14:08:27,890
get to words of random is here.
So we're gonna hit request

13990
14:08:27,890 --> 14:08:32,450
randomness, confirm the Rigby
transaction. And then as soon as

13991
14:08:32,450 --> 14:08:35,000
that transaction comes back, we
should notice that we actually

13992
14:08:35,000 --> 14:08:38,360
have a request. And then what
we'll be doing is we'll be

13993
14:08:38,360 --> 14:08:41,930
waiting for the Oracle to call
fulfill random words on our

13994
14:08:41,930 --> 14:08:44,390
contract. And then we'll be
storing all of those random

13995
14:08:44,390 --> 14:08:48,710
words in this s random words,
storage variable. Let's go ahead

13996
14:08:48,710 --> 14:08:50,750
and check to see if our random
numbers come back from the

13997
14:08:50,750 --> 14:08:53,630
Oracle. So I'll go in here into
random words. And let's request

13998
14:08:53,630 --> 14:08:56,330
the zeroeth item of the array
looks like we've got a random

13999
14:08:56,330 --> 14:08:58,970
number there. And because we
requested two random numbers, we

14000
14:08:58,970 --> 14:09:03,800
should also have an item in
index one. All right, we we've

14001
14:09:03,800 --> 14:09:06,470
got our randomness there. And if
we go back to the subscription

14002
14:09:06,470 --> 14:09:09,620
manager app, you're going to see
that there's actually an event

14003
14:09:09,620 --> 14:09:11,960
history item here, we'll see
that we spent about point three,

14004
14:09:11,960 --> 14:09:16,370
three link to get those two
random numbers, we've just taken

14005
14:09:16,370 --> 14:09:19,250
a journey to see what it looks
like and feels like to use Veera

14006
14:09:19,250 --> 14:09:20,030
version two,

14007
14:09:20,180 --> 14:09:22,730
now that we've learned a little
bit more about chainlink VRF, I

14008
14:09:22,760 --> 14:09:25,520
hope that you took some time to
go to doxa chain link and play

14009
14:09:25,520 --> 14:09:28,070
around with it a little bit so
that you understand what's

14010
14:09:28,070 --> 14:09:31,520
really going on, we're going to
use this sample contract in here

14011
14:09:31,580 --> 14:09:34,340
to create our function that's
going to pick our random winner.

14012
14:09:34,400 --> 14:09:36,740
This is an on chain contract
that coordinates with a

14013
14:09:36,740 --> 14:09:40,340
verifiably random chain link
node to give us a random number,

14014
14:09:40,370 --> 14:09:42,590
you could look at the code
directly on chain, or you can

14015
14:09:42,590 --> 14:09:46,130
come right to the chain link
GitHub and look at all the code

14016
14:09:46,130 --> 14:09:49,040
for how this is actually
happening provably and randomly.

14017
14:09:49,100 --> 14:09:51,440
And we'll have a link to this in
the GitHub repo associated with

14018
14:09:51,440 --> 14:09:56,540
this course. So we're going to
create our function here called

14019
14:09:56,660 --> 14:09:59,150
pick a random winner, this
function is going to be called

14020
14:09:59,150 --> 14:10:01,670
by the chain link keepers
network so that this can

14021
14:10:01,700 --> 14:10:04,490
automatically run without us
having to interact with it. And

14022
14:10:04,490 --> 14:10:07,340
actually, while we're updating
this, I want to add some some

14023
14:10:07,340 --> 14:10:11,660
stars here saying view slash
pure functions. Now our pick

14024
14:10:11,660 --> 14:10:13,670
random winner function, we're
actually not going to make

14025
14:10:13,670 --> 14:10:16,940
public we're going to make
external, external functions are

14026
14:10:16,940 --> 14:10:19,670
a little bit cheaper than public
functions. Because solidity

14027
14:10:19,670 --> 14:10:22,250
knows that our own contract can
call this, we're actually going

14028
14:10:22,250 --> 14:10:25,130
to change the name of this
function, as well, very soon,

14029
14:10:25,130 --> 14:10:27,500
but we'll get to that in a
little bit. So in order for us

14030
14:10:27,500 --> 14:10:30,500
to pick a random winner, we
actually have to do two things,

14031
14:10:30,560 --> 14:10:34,190
we first have to request the
random number. And then once we

14032
14:10:34,190 --> 14:10:38,330
get it, do something with it. So
chainlink VRF is a two

14033
14:10:38,330 --> 14:10:42,470
transaction process. And this is
actually intentional. Having

14034
14:10:42,470 --> 14:10:45,590
random numbers in two
transactions is actually also

14035
14:10:45,620 --> 14:10:48,380
much better than having it in
one. If it's just one

14036
14:10:48,380 --> 14:10:51,140
transaction, then people could
just brute force tries

14037
14:10:51,140 --> 14:10:53,900
simulating calling this
transaction and we'll learn how

14038
14:10:53,900 --> 14:10:56,810
to simulate calls soon simulate
calling these transactions to

14039
14:10:56,810 --> 14:10:59,030
see what they can manipulate to
make sure that they are the

14040
14:10:59,030 --> 14:11:01,700
winner. We want to make sure
that this is absolutely fair.

14041
14:11:01,730 --> 14:11:05,240
Nobody can manipulate our smart
contract into having them be the

14042
14:11:05,240 --> 14:11:07,880
winner of the lottery, this
function is actually going to

14043
14:11:07,880 --> 14:11:10,850
request it. And then in a second
func the random number is going

14044
14:11:10,850 --> 14:11:13,640
to be returned. And in the
transaction that we actually get

14045
14:11:13,640 --> 14:11:16,760
the random number from the chain
link network, that's when we're

14046
14:11:16,760 --> 14:11:19,460
going to actually send the money
to the winner. And if we go to

14047
14:11:19,460 --> 14:11:21,830
the chain link documentation,
the function that the chain link

14048
14:11:21,830 --> 14:11:24,710
node calls is this function
called fulfill random words,

14049
14:11:24,770 --> 14:11:27,080
this is going to be the
requesting one, which we could

14050
14:11:27,080 --> 14:11:30,200
even change this to request
random winner to make it more

14051
14:11:30,200 --> 14:11:35,330
clear, and then we'll make a
function fulfill random words.

14052
14:11:36,080 --> 14:11:38,900
And this is going to be an
internal override, which we'll

14053
14:11:38,900 --> 14:11:42,380
explain in a little bit, now
fulfill fulfill random words

14054
14:11:42,380 --> 14:11:45,620
basically means we're fulfilling
random numbers. The word comes

14055
14:11:45,620 --> 14:11:47,780
from a computer science
terminology, but you can

14056
14:11:47,780 --> 14:11:50,570
basically just think of this as
fulfill random numbers, because

14057
14:11:50,570 --> 14:11:53,150
we can get multiple random
numbers. Now in order to make

14058
14:11:53,150 --> 14:11:57,140
our raffle contract VRF a bowl,
we have to import the chain link

14059
14:11:57,140 --> 14:11:59,690
code, we can go back to the
documentation, and we're just

14060
14:11:59,690 --> 14:12:02,930
going to grab this bottom line
and we'll grab the top line in a

14061
14:12:02,930 --> 14:12:06,350
second. So we're going to do
import, I'm going to write it

14062
14:12:06,350 --> 14:12:09,140
out. But if you want to copy
paste, you can at chain link

14063
14:12:09,170 --> 14:12:15,950
slash contracts slash SRC slash
V 0.8, slash V RF, consumer

14064
14:12:15,980 --> 14:12:20,420
base, b two dot Sol. And since
we're importing at chainlink,

14065
14:12:20,420 --> 14:12:23,570
slash contracts, we're gonna
need to add that in by running

14066
14:12:23,570 --> 14:12:28,700
yarn, add dash dash dev at
chainlink slash contracts. And

14067
14:12:29,810 --> 14:12:32,720
now that we have this in here,
we should be able to import like

14068
14:12:32,720 --> 14:12:36,380
so. And we're going to need to
make our raffle VRF consumer

14069
14:12:36,380 --> 14:12:39,980
base double, we're gonna need to
inherit VRF consumer base go

14070
14:12:39,980 --> 14:12:46,160
into our node modules at chain
link src, V 08 VRF, consumer

14071
14:12:46,160 --> 14:12:50,360
base V two, it comes with this
function fulfill random words.

14072
14:12:50,390 --> 14:12:54,740
And you can see it's an internal
virtual function, virtual means

14073
14:12:54,770 --> 14:12:57,200
it's expecting to be
overwritten, the reason that

14074
14:12:57,200 --> 14:13:00,410
it's in the sphere of consumer
base V two is so that the VRF

14075
14:13:00,410 --> 14:13:03,380
coordinator, which we'll use in
a bit knows that it can call

14076
14:13:03,380 --> 14:13:06,110
this fulfill random words
function. And this is the

14077
14:13:06,110 --> 14:13:09,410
function that we're overriding.
So back in our raffle dot salt,

14078
14:13:09,410 --> 14:13:13,670
we're going to inherit it by
doing is VRF consumer base V

14079
14:13:13,670 --> 14:13:18,170
two. And now if we scroll down
to fulfill random words, we can

14080
14:13:18,170 --> 14:13:20,960
add in the input parameters
fulfilled pill random words,

14081
14:13:21,020 --> 14:13:28,400
which are going to be un 256,
Request ID and un 256, a memory

14082
14:13:28,430 --> 14:13:32,660
array random words. And if we
hit Save Our linter will now

14083
14:13:32,660 --> 14:13:36,440
notice, okay, this is what I'm
expecting, I'm expecting us to

14084
14:13:36,440 --> 14:13:39,740
override the Fill random words,
which takes these parameters.

14085
14:13:39,770 --> 14:13:43,370
Now if we look in our docs in
our constructor, we need to pass

14086
14:13:43,400 --> 14:13:46,850
the VRF consumer base V TOS
constructor and pass that VRF

14087
14:13:46,850 --> 14:13:49,790
coordinator. Again, this V RF
coordinator is the address of

14088
14:13:49,790 --> 14:13:52,490
the contract that does the
random number verification. So

14089
14:13:52,490 --> 14:13:57,530
right next to our constructor
will add the VRF consumer base V

14090
14:13:57,530 --> 14:14:02,180
to constructor and we need to
pass the VRF coordinator v2

14091
14:14:02,210 --> 14:14:04,790
address. So in our main
constructor, we'll add that as a

14092
14:14:04,790 --> 14:14:07,040
parameter as well. So we'll say
address

14093
14:14:08,540 --> 14:14:13,970
VRF core to Nate Torre v two,
and then we'll pass this as a

14094
14:14:13,970 --> 14:14:17,540
parameter for the VRF consumer
basically till now that we have

14095
14:14:17,540 --> 14:14:20,390
that we shouldn't see that
little underscore anymore. And

14096
14:14:20,390 --> 14:14:25,250
we should be able to run yarn
aren't had compiled. Awesome.

14097
14:14:25,280 --> 14:14:28,370
And we can see compiled two
files successfully and our code

14098
14:14:28,370 --> 14:14:34,400
is working great. Now something
that I often do is I actually

14099
14:14:34,400 --> 14:14:37,820
hate running yarn hard hat all
the time, because that's too

14100
14:14:37,820 --> 14:14:40,610
many keys for my little brain to
work with. I would prefer to

14101
14:14:40,610 --> 14:14:43,820
write as little keys as possible
hard hat also would like us to

14102
14:14:43,820 --> 14:14:46,280
write as little keys as
possible. So hard hat comes with

14103
14:14:46,310 --> 14:14:49,670
a shorthand and autocomplete
hard hat shorthand is an NPM

14104
14:14:49,670 --> 14:14:53,420
package that installs a globally
accessible binary called H H,

14105
14:14:53,480 --> 14:14:56,030
that runs the project's locally
installed hard hat and supports

14106
14:14:56,060 --> 14:14:59,000
shell auto completion for tasks.
So what we can do is we're going

14107
14:14:59,000 --> 14:15:01,640
to start with NPM, like this,
but we're gonna install it with

14108
14:15:01,640 --> 14:15:07,160
yarn, we're going to run yarn,
global, add hardhat shorthand.

14109
14:15:08,570 --> 14:15:11,720
And what this is going to do, we
can see here installed hard hat

14110
14:15:11,720 --> 14:15:15,950
shorthand with binaries H, H,
and Hardhead completion. Now

14111
14:15:15,980 --> 14:15:19,370
instead of running yarn,
Hardhead compile, which we can

14112
14:15:19,370 --> 14:15:24,800
still run, we can just run h h
compile, running h h is going to

14113
14:15:24,800 --> 14:15:27,470
be the same thing as if we had
just run the Hardhead command

14114
14:15:27,500 --> 14:15:33,410
for our local directory. So now
we need to actually have our

14115
14:15:33,410 --> 14:15:36,560
request random winner function
requests a random winner. So

14116
14:15:36,560 --> 14:15:38,840
let's go back to the
documentation. And we'll see how

14117
14:15:38,840 --> 14:15:41,900
to do that. We can look at this
function request random words

14118
14:15:42,020 --> 14:15:45,920
and see exactly how it works. On
the Vera of coordinator address.

14119
14:15:45,950 --> 14:15:48,800
We go ahead and call this
request random words function,

14120
14:15:48,830 --> 14:15:51,500
we're going to need to call this
function on the coordinator

14121
14:15:51,530 --> 14:15:54,380
contract to get the coordinator
contract. We're going to use the

14122
14:15:54,380 --> 14:15:57,590
Vera v2 coordinator interface
and the Vir of coordinator

14123
14:15:57,590 --> 14:16:00,230
address. So we're going to want
to keep track of those. We can

14124
14:16:00,230 --> 14:16:03,140
do that once again in Arkansas.
factor, we have the address

14125
14:16:03,170 --> 14:16:06,020
being passed to our Bureau of
consumer base. Let's also keep

14126
14:16:06,020 --> 14:16:09,020
it as a state variable for us.
First, let's get the interface

14127
14:16:09,050 --> 14:16:11,510
so we can interact with that
contract, we can import that

14128
14:16:11,510 --> 14:16:14,810
from chain link as well by doing
import at chain link slash

14129
14:16:14,810 --> 14:16:24,440
contracts, slash SRC slash fees
0.8, slash inter faces slash VRF

14130
14:16:24,830 --> 14:16:30,500
cord to mentor V to interface
dot Sol. And now that we import

14131
14:16:30,500 --> 14:16:34,550
this interface, same as we did
with price feeds, we can do VRF,

14132
14:16:34,550 --> 14:16:40,070
coordinator v2, interface VRF
coordinator. And then we can

14133
14:16:40,070 --> 14:16:44,180
save the sphere of coordinator
using the address so we can say

14134
14:16:44,210 --> 14:16:48,770
VRF coordinator equals this
address VRF coordinator veto.

14135
14:16:48,860 --> 14:16:50,810
And we're just going to wrap
that address around the

14136
14:16:50,810 --> 14:16:53,810
interface so that now we can
work with this VRF coordinator

14137
14:16:53,810 --> 14:16:56,870
contract. Now we're only going
to set our VRF coordinator one

14138
14:16:56,870 --> 14:16:59,900
time right in our constructor.
So what's the best thing that we

14139
14:16:59,900 --> 14:17:03,140
can do here, private, immutable,
you Gosh, darn. Right, let's do

14140
14:17:03,140 --> 14:17:06,800
private, immutable, you have
coordinator and we'll change the

14141
14:17:06,800 --> 14:17:10,730
name to I underscore the ref
coordinator so that we know that

14142
14:17:10,760 --> 14:17:13,970
your coordinator is indeed an
immutable variable. In order to

14143
14:17:14,000 --> 14:17:16,640
request the random word, we need
to give it a number of

14144
14:17:16,640 --> 14:17:20,120
parameters, I'm gonna go ahead
and copy this line into our

14145
14:17:20,120 --> 14:17:22,820
contract just so that we can
talk about exactly what's going

14146
14:17:22,820 --> 14:17:26,090
on with it. And we don't need
the AES Request ID. And instead

14147
14:17:26,090 --> 14:17:29,270
of coordinator we're going to do
I underscore fear of

14148
14:17:29,270 --> 14:17:32,000
coordinator. So we're going to
call request random words on

14149
14:17:32,000 --> 14:17:35,150
that VRF coordinator contract,
and we need to pass it the key

14150
14:17:35,150 --> 14:17:39,230
hash or the gasoline, I prefer
calling it the gas lane, we go

14151
14:17:39,230 --> 14:17:42,140
to the chain link, Doc's go to
contract addresses. And we

14152
14:17:42,140 --> 14:17:44,660
scroll down we can see different
gas lanes a different

14153
14:17:44,660 --> 14:17:47,900
configuration parameters for
different networks is key hash

14154
14:17:47,930 --> 14:17:50,690
is going to be the gasoline of
the key hash, which tells the

14155
14:17:50,690 --> 14:17:53,450
chain link node the maximum
price you're willing to pay for

14156
14:17:53,450 --> 14:17:57,170
your guests and way if for
example, gas prices skyrocket,

14157
14:17:57,200 --> 14:17:59,270
and it's going to cost you a ton
of money to get that random

14158
14:17:59,270 --> 14:18:02,300
number setting a ceiling, we'll
make it so that random number

14159
14:18:02,300 --> 14:18:04,850
doesn't come back. For us to
pick a gas lane, we're probably

14160
14:18:04,850 --> 14:18:07,940
going to want to have this gas
lane or this key hash stored

14161
14:18:07,940 --> 14:18:10,670
somewhere. So let's go ahead and
make that a parameter of our

14162
14:18:10,670 --> 14:18:13,220
constructor as well. And we'll
save that as a state variable.

14163
14:18:13,430 --> 14:18:18,350
So we'll do comma bytes 32,
gasoline or key hash or whatever

14164
14:18:18,350 --> 14:18:20,750
you want to call it. And then
we'll make a new state variable.

14165
14:18:21,890 --> 14:18:24,050
And we're only going to set this
once. So we'll make this a

14166
14:18:24,050 --> 14:18:32,810
private, immutable. I underscore
gasoline, and then we'll say

14167
14:18:33,860 --> 14:18:37,070
gasoline equals gasoline.

14168
14:18:38,120 --> 14:18:42,020
So now, we can just swap this
out, or I underscore gasoline.

14169
14:18:42,140 --> 14:18:44,900
Okay, what's next, we need a
subscription ID, the

14170
14:18:44,900 --> 14:18:47,210
subscription ID is going to be
the subscription that we need

14171
14:18:47,210 --> 14:18:50,060
for funding our requests.
There's actually a contract on

14172
14:18:50,060 --> 14:18:53,360
chain, which we can use to fund
any subscription for any of

14173
14:18:53,360 --> 14:18:56,360
these external data or external
computation bits. And in this

14174
14:18:56,360 --> 14:18:59,270
contract, there's a list of
these subscriptions for people

14175
14:18:59,270 --> 14:19:02,900
to make requests to. So we need
the ID of the subscription that

14176
14:19:02,900 --> 14:19:06,230
we're using to request our
random numbers and pay the link

14177
14:19:06,230 --> 14:19:09,140
Oracle gas, the subscription ID
is probably also going to be

14178
14:19:09,140 --> 14:19:12,710
something we're going to pass as
a parameter to our lottery. So

14179
14:19:12,710 --> 14:19:15,350
once again, let's scroll up to
our constructor, we'll add a new

14180
14:19:15,350 --> 14:19:18,290
parameter. And our subscription
ID actually doesn't need to be a

14181
14:19:18,290 --> 14:19:22,640
un 256, it can actually be a
little bit smaller with a un 64.

14182
14:19:22,760 --> 14:19:28,100
So we'll pass a un 64 sub
scription ID, we'll make a UNT

14183
14:19:28,340 --> 14:19:31,700
64. Since we're only going to
set this once we'll make this a

14184
14:19:31,700 --> 14:19:37,250
private, immutable. I underscore
sub scription ID down here and

14185
14:19:37,250 --> 14:19:42,980
we'll say I subscription ID
equals sub subscription ID.

14186
14:19:43,520 --> 14:19:46,910
Alright, awesome. So now we can
change this to our subscription

14187
14:19:46,910 --> 14:19:50,780
ID. Okay, what's next? Request
confirmations request

14188
14:19:50,780 --> 14:19:54,620
confirmations is a un 16, which
says how many confirmations the

14189
14:19:54,620 --> 14:19:57,350
chain link node should wait
before responding. So if you

14190
14:19:57,350 --> 14:20:00,350
make a request, and there's only
one block confirmation, maybe

14191
14:20:00,350 --> 14:20:02,870
you don't actually send it
because you don't you're afraid

14192
14:20:02,870 --> 14:20:05,300
of some type of blockchain
reorganization or something,

14193
14:20:05,330 --> 14:20:07,190
we're not going to worry too
much about this. And we're

14194
14:20:07,190 --> 14:20:09,950
actually just going to make this
a constant of three. So we're

14195
14:20:09,950 --> 14:20:12,890
not even going to have this be
per amortizable we're gonna have

14196
14:20:12,890 --> 14:20:17,840
this one be a constant. So we'll
say a you int 16 Private

14197
14:20:17,960 --> 14:20:24,530
constant request, confirmations
equals three, and we're using

14198
14:20:24,560 --> 14:20:28,280
the capslock and underscores for
our constant variables here. And

14199
14:20:28,280 --> 14:20:31,250
now we'll grab request
confirmations and stick it in

14200
14:20:31,280 --> 14:20:34,700
right here. What's next callback
gas limit callback gas limit is

14201
14:20:34,700 --> 14:20:37,580
going to be the limit for how
much gas to use for the callback

14202
14:20:37,580 --> 14:20:40,640
request your contracts fulfill
random words, this sets a limit

14203
14:20:40,640 --> 14:20:44,270
for how much computation are
fulfilled random words can be

14204
14:20:44,300 --> 14:20:47,000
this is a good way to protect
ourselves from spending way too

14205
14:20:47,000 --> 14:20:50,270
much gas. If, for example, we
accidentally code our contract

14206
14:20:50,270 --> 14:20:53,690
in a way where fulfill random
words is incredibly gas

14207
14:20:53,690 --> 14:20:56,360
expensive. It'll block the
random number from responding.

14208
14:20:56,420 --> 14:20:58,880
We are going to make this
parameter sizable because we

14209
14:20:58,880 --> 14:21:01,610
want to change it depending on
how we code our fulfill random

14210
14:21:01,610 --> 14:21:04,970
word. So in our constructor,
let's add one more, we'll add

14211
14:21:05,120 --> 14:21:10,910
you int 32. Since the size of
this is a un 32, callback, gas

14212
14:21:10,910 --> 14:21:17,300
limit, and we'll save the sub
top as a UNT 32, private,

14213
14:21:17,300 --> 14:21:23,810
immutable, I underscore call
back. Yes limit. And we'll save

14214
14:21:23,810 --> 14:21:30,140
this. I call back gas limit
equals call back Yes, limit. And

14215
14:21:30,140 --> 14:21:32,600
then we'll take this, and we'll
stick it here. All right, we got

14216
14:21:32,600 --> 14:21:35,810
one more number of words, this
is going to be how many random

14217
14:21:35,810 --> 14:21:38,780
numbers that we want to get, we
only want one. So we're gonna go

14218
14:21:38,780 --> 14:21:42,590
back up to the top, we're going
to create a you int 32. And

14219
14:21:42,590 --> 14:21:47,480
we'll make this also a private
constant. Num words equals one,

14220
14:21:47,600 --> 14:21:49,850
because we only want one random
number. And then that'll be the

14221
14:21:49,850 --> 14:21:54,320
last thing we need to add for
our IVF coordinator dot request

14222
14:21:54,320 --> 14:21:57,740
random words. Now this request
random words function returns a

14223
14:21:57,770 --> 14:22:02,840
request ID a un 256 Request ID a
unique ID that defines who's

14224
14:22:02,840 --> 14:22:05,570
requesting this and all this
other information. If we want to

14225
14:22:05,570 --> 14:22:10,550
save it, we can do u and 256.
Request ID IVF coordinator

14226
14:22:10,580 --> 14:22:13,820
requests random words. Now for
now, we are going to emit an

14227
14:22:13,820 --> 14:22:17,240
event with this request ID. And
we'll go over why we're going to

14228
14:22:17,240 --> 14:22:20,390
do that a little bit later,
create a new event at the top.

14229
14:22:20,570 --> 14:22:22,700
And we're not going to follow
the naming convention here.

14230
14:22:23,420 --> 14:22:25,160
Because we're going to change
the name of our functions a

14231
14:22:25,160 --> 14:22:29,630
little bit, we're going to call
this requested raffle winner.

14232
14:22:30,200 --> 14:22:37,760
And we're going to take a un 256
indexed Request ID. Down here,

14233
14:22:37,790 --> 14:22:42,260
we're gonna do omit requested
raffle winner Request ID. And

14234
14:22:42,260 --> 14:22:45,140
now we have a function that we
can use to request a random

14235
14:22:45,140 --> 14:22:47,780
winner using chain link VRF. Now
again, we're going to set this

14236
14:22:47,780 --> 14:22:50,030
up so that the chain link
keepers call this on an

14237
14:22:50,030 --> 14:22:52,820
interval, but we'll do that in a
little bit. For now, let's

14238
14:22:52,820 --> 14:22:54,620
figure out what to do once we
get that

14239
14:22:54,620 --> 14:23:02,510
random number. Once we get that
random number, we're going to

14240
14:23:02,510 --> 14:23:06,890
want to pick a random winner
from our array of players up

14241
14:23:06,890 --> 14:23:10,760
here. So what do we do? Well,
let's go in here. And let's pick

14242
14:23:10,790 --> 14:23:14,660
a random winner using something
called the module function. Now

14243
14:23:14,690 --> 14:23:18,020
we're gonna get an array back of
random words, or random numbers,

14244
14:23:18,020 --> 14:23:21,290
if you will, since we're only
requesting one random word, this

14245
14:23:21,290 --> 14:23:24,140
random words array is going to
be of size one with one random

14246
14:23:24,140 --> 14:23:27,860
word in it. Now this random word
is a un 256. So this random word

14247
14:23:27,860 --> 14:23:31,880
could be something like this.
Well, obviously without the

14248
14:23:31,880 --> 14:23:34,310
hyphens, but it could be
something absolutely massive

14249
14:23:34,340 --> 14:23:37,760
like that our players array is
only going to be so big. So how

14250
14:23:37,760 --> 14:23:41,360
do we get a random winner from
this potentially massive random

14251
14:23:41,360 --> 14:23:43,910
number, we can use something
called the modulo function, the

14252
14:23:43,910 --> 14:23:48,500
module operation, a mod N
yields, the remainder are after

14253
14:23:48,500 --> 14:23:51,200
the division of an operand a by
the blah, blah, blah, blah,

14254
14:23:51,200 --> 14:23:53,900
blah. So what does this mean?
Well, we can use the mod

14255
14:23:53,900 --> 14:23:57,050
function to get a random number
out of our players array. So

14256
14:23:57,050 --> 14:23:59,990
let's say our players array or
excuse me, our s players array

14257
14:24:00,020 --> 14:24:05,000
is of size 10. And a random
number is 200. So how do we pick

14258
14:24:05,060 --> 14:24:08,300
a random person out of this
players array, or, let's say our

14259
14:24:08,300 --> 14:24:12,860
random number is 202. If we do
202, which is our random number,

14260
14:24:12,890 --> 14:24:18,380
mod 10, we're gonna basically do
202 divided by 10. But instead

14261
14:24:18,380 --> 14:24:20,570
of having the decimals, we're
just going to say, Okay, how

14262
14:24:20,570 --> 14:24:24,800
many times is 10 evenly divide
into 202. And what's the

14263
14:24:24,800 --> 14:24:29,990
remainder, what doesn't divide
evenly into 202? Well, 20 times

14264
14:24:29,990 --> 14:24:34,550
10 equals 200, with two
leftover, so two doesn't evenly

14265
14:24:34,550 --> 14:24:40,460
divide, or multiply into 200. So
that means 202 mod 10 is going

14266
14:24:40,460 --> 14:24:43,250
to equal to two. So that's how
the module function works. And

14267
14:24:43,250 --> 14:24:46,160
we can use that so we're always
going to get a number between.

14268
14:24:46,280 --> 14:24:48,530
So we're always going to get a
number here between zero and

14269
14:24:48,530 --> 14:24:51,560
nine, which works out perfectly
because that which works out

14270
14:24:51,560 --> 14:24:54,800
perfectly, because those are the
indexes of the 10 people in our

14271
14:24:54,800 --> 14:24:58,670
array. So let's use that here.
We'll say a un 256 index of

14272
14:24:58,670 --> 14:25:04,670
winner is going to be equal to
random words, at index zero,

14273
14:25:04,670 --> 14:25:08,150
because we're only getting one
random word module, the S

14274
14:25:08,180 --> 14:25:12,080
underscore players dot length.
So this will give us the index

14275
14:25:12,080 --> 14:25:14,960
of our random winner to get that
address of the winner will do

14276
14:25:14,960 --> 14:25:24,200
address payable, recent winner
equals s players at this index

14277
14:25:24,230 --> 14:25:26,840
of winner so awesome. So now
we'll have the address of the

14278
14:25:26,840 --> 14:25:29,060
person that got this random
number, the person's that's

14279
14:25:29,060 --> 14:25:34,520
going to be our verifiably
random winner. Now, it might be

14280
14:25:34,520 --> 14:25:37,400
kind of cool to brag to people
that you're the recent winner.

14281
14:25:37,550 --> 14:25:40,370
So let's go ahead to the top and
we'll create a new state

14282
14:25:40,370 --> 14:25:43,610
variable for our most recent
winner make this state variable

14283
14:25:43,640 --> 14:25:47,240
in a new section called lottery
variables. We'll say address

14284
14:25:48,110 --> 14:25:52,940
private s underscore recent
winner and it'll start out as

14285
14:25:52,940 --> 14:25:56,510
nobody but as we get winners
update it with s recent winner

14286
14:25:56,540 --> 14:26:01,460
equals recent winner and we'll
probably want people to know who

14287
14:26:01,460 --> 14:26:05,720
this is winter is so down below,
we can do function get recent

14288
14:26:05,720 --> 14:26:09,320
winner, it's going to be a
public view that's going to

14289
14:26:09,320 --> 14:26:14,210
return that address. And then
we'll just say return s

14290
14:26:14,210 --> 14:26:17,270
underscore recent winner, since
again, the recent winner is

14291
14:26:17,270 --> 14:26:19,970
going to be a storage variable.
So now that we have a recent

14292
14:26:19,970 --> 14:26:22,610
winner, what else are we gonna
do? Well, we're probably going

14293
14:26:22,610 --> 14:26:24,860
to want to send them the money
in this contract. So we're going

14294
14:26:24,860 --> 14:26:27,860
to do exactly what we did before
with sending the money, we're

14295
14:26:27,860 --> 14:26:34,850
going to do that bull success,
comma, blank equals recent

14296
14:26:35,150 --> 14:26:40,940
winner, call, I'm gonna say
value, it's going to be address

14297
14:26:41,870 --> 14:26:45,080
of this dot balance, we're going
to send all the money in this

14298
14:26:45,080 --> 14:26:48,800
contract, and we're going to
pass it no data. And now we

14299
14:26:48,800 --> 14:26:52,160
could say require, you know,
success, whatever, we're going

14300
14:26:52,160 --> 14:26:54,290
to be a little bit more gas
efficient here. And we're just

14301
14:26:54,290 --> 14:26:59,000
gonna say, if not success, then
we're going to revert a new

14302
14:26:59,000 --> 14:27:01,910
transfer failed error. So we're
gonna go to the top, or say,

14303
14:27:01,940 --> 14:27:05,390
error name of the contract is
raffle, underscore, underscore,

14304
14:27:05,750 --> 14:27:10,790
transfer failed, like that, then
go back down, and we can now do

14305
14:27:10,790 --> 14:27:14,750
revert, raffle transfer failed
like that. And now that we've

14306
14:27:14,780 --> 14:27:17,540
picked a winner, right now, we
don't have a way to actually

14307
14:27:17,540 --> 14:27:20,570
keep track of the list of
previous winners. So we're just

14308
14:27:20,570 --> 14:27:23,120
going to omit an event. So
there's always going to be that

14309
14:27:23,390 --> 14:27:26,660
easily query double history of
event winners. So we're going to

14310
14:27:26,660 --> 14:27:30,410
create a new event in the events
section called the event winner

14311
14:27:30,410 --> 14:27:37,160
picked. And this is going to be
an address indexed winner. And

14312
14:27:37,160 --> 14:27:43,850
we'll scroll down and we'll do
MIT winner picked the address of

14313
14:27:43,850 --> 14:27:46,730
the recent winner. This looks
pretty good.

14314
14:27:46,820 --> 14:27:49,820
This looks pretty good here. Now
you'll notice our request ID as

14315
14:27:49,820 --> 14:27:53,210
this little underscore here and
saying, hey, it's an unused

14316
14:27:53,210 --> 14:27:56,090
function parameter, since we
don't use this, but we still

14317
14:27:56,090 --> 14:27:59,810
need fulfill random words to
take a request ID and a random

14318
14:27:59,810 --> 14:28:02,600
words array. But we don't use
Request ID, we can just comment

14319
14:28:02,600 --> 14:28:06,140
out just the request ID part
like this, this tells our

14320
14:28:06,140 --> 14:28:10,490
function, hey, yes, we know that
you need a un 256. But we're not

14321
14:28:10,490 --> 14:28:12,740
going to use the request ID. So
we'll leave it in here. But

14322
14:28:12,740 --> 14:28:16,010
we'll leave it blank. Now let's
run a little compile here. We'll

14323
14:28:16,010 --> 14:28:21,410
use yarn, hard hat, compile, or
hh compile, we'll see if we're

14324
14:28:21,410 --> 14:28:24,110
coding things correctly. And
indeed, we don't see any errors.

14325
14:28:24,140 --> 14:28:30,350
So perfect, we can continue. So
we've added the chain link VRF,

14326
14:28:30,350 --> 14:28:34,100
where we have a way to
verifiably get a random winner.

14327
14:28:34,340 --> 14:28:38,030
This is fantastic. Now let's
update this contract so that not

14328
14:28:38,030 --> 14:28:42,110
only can it pick a verifiable
winner, but it can also do this

14329
14:28:42,140 --> 14:28:45,260
all programmatically and
automatically trigger picking a

14330
14:28:45,260 --> 14:28:49,400
random winner based off of some
time interval without us having

14331
14:28:49,400 --> 14:28:52,880
to interact with it. And in a
decentralized context. In order

14332
14:28:52,880 --> 14:28:55,640
for us to automatically trigger
smart contracts based off of

14333
14:28:55,670 --> 14:28:59,240
some parameter be a time
parameter, maybe the price of

14334
14:28:59,240 --> 14:29:02,210
some asset is some number, maybe
there's a certain amount of

14335
14:29:02,210 --> 14:29:05,420
money in the liquidity pool or
really whatever trigger that you

14336
14:29:05,420 --> 14:29:08,810
want, we can use chain link
keepers. To do this. Steven

14337
14:29:08,810 --> 14:29:11,960
fluid has done once again, an
amazing introduction to chain

14338
14:29:11,960 --> 14:29:14,390
the keepers. So we're going to
follow along with another sub

14339
14:29:14,390 --> 14:29:16,760
video section of Steven
explaining chain link keeper

14340
14:29:16,760 --> 14:29:19,430
sauce, he's going to be using
the COVID test net, but be sure

14341
14:29:19,430 --> 14:29:22,430
to use whatever test net is in
the documentation. When you play

14342
14:29:22,430 --> 14:29:23,630
with this and you try this.

14343
14:29:23,659 --> 14:29:26,299
My name is Steven foon. Today, I
want to show you how to use the

14344
14:29:26,299 --> 14:29:29,779
chain link keeper network in
order to automate your contracts

14345
14:29:29,929 --> 14:29:32,659
and give them access to off
chain computation. Let's go

14346
14:29:32,659 --> 14:29:34,789
ahead and dive in. So what we're
going to look at today is we're

14347
14:29:34,789 --> 14:29:37,339
going to start on the chain link
documentation webpage. And if

14348
14:29:37,339 --> 14:29:39,799
you just scroll down a little
bit, you're going to find using

14349
14:29:39,799 --> 14:29:43,789
chain link keepers. Now there's
really two parts to building a

14350
14:29:43,849 --> 14:29:46,999
chain link keeper up kept smart
contract. So the first thing is

14351
14:29:46,999 --> 14:29:49,159
you need to write a smart
contract that's compatible by

14352
14:29:49,159 --> 14:29:51,589
implementing these two methods.
And then second, you want to

14353
14:29:51,589 --> 14:29:54,979
register that smart contract for
upkeep with the channeling

14354
14:29:54,979 --> 14:29:57,259
keeper network. So let's go
ahead and do both of those

14355
14:29:57,259 --> 14:30:00,409
things. So let's start off just
by copying and deploying this

14356
14:30:00,439 --> 14:30:04,339
sample code that we've got. With
this one click to remix, what

14357
14:30:04,339 --> 14:30:07,069
we're gonna see here is a very,
very simple contract. That is

14358
14:30:07,069 --> 14:30:11,599
just a simple counter. So we can
see it's got a counter here. So

14359
14:30:11,599 --> 14:30:16,489
it's got just a simple number.
And then you're able to specify

14360
14:30:16,489 --> 14:30:19,579
when you create the contract and
update interval, and then the

14361
14:30:19,579 --> 14:30:22,039
contract is going to verify Hey,
has enough time passed. And if

14362
14:30:22,039 --> 14:30:24,769
it has, let's update the
counter. And you're going to

14363
14:30:24,769 --> 14:30:27,649
notice that chinley compatible
or timekeeper network compatible

14364
14:30:27,649 --> 14:30:30,919
contracts use two really
important methods that are part

14365
14:30:30,919 --> 14:30:33,799
of this keeper compatible
interface. The first is check

14366
14:30:33,829 --> 14:30:37,249
upkeep, and check upkeep is
special because this is where

14367
14:30:37,249 --> 14:30:39,859
the off chain computation
happens. So this is a method

14368
14:30:39,859 --> 14:30:43,819
that's not actually run on
chain. This is run off chain by

14369
14:30:43,849 --> 14:30:47,029
a node from the channeling
keeper network. And so what's

14370
14:30:47,029 --> 14:30:50,779
really nice about this is that
the gas used here isn't actually

14371
14:30:50,779 --> 14:30:53,569
gas, it's on chains. This is
just being run by a chain link

14372
14:30:53,569 --> 14:30:57,199
node. And then what happens is
if your check upkeep method

14373
14:30:57,199 --> 14:31:00,589
returns, the upkeep is needed.
Then it's going to go ahead and

14374
14:31:00,589 --> 14:31:04,549
perform upkeep. On chain, so you
can actually generate data off

14375
14:31:04,549 --> 14:31:07,219
chain, and then pass that in.
That's called the check data.

14376
14:31:07,609 --> 14:31:10,759
And then that becomes the
performed data that's passed

14377
14:31:10,759 --> 14:31:14,989
into perform upkeep. And so the
PErforM upkeep method is where

14378
14:31:14,989 --> 14:31:18,289
you're going to want to verify
that things are correct. And

14379
14:31:18,289 --> 14:31:22,099
that things actually should be
modified and run on chain, and

14380
14:31:22,099 --> 14:31:25,849
then actually make the state
change. And so let's go ahead

14381
14:31:25,849 --> 14:31:28,609
and compile this contract and
deploy it to the COVID network.

14382
14:31:28,819 --> 14:31:31,849
So let's go ahead and within
remix, we can do this

14383
14:31:31,849 --> 14:31:35,389
compilation. And we're going to
compile and deploy directly to

14384
14:31:35,389 --> 14:31:38,539
COVID. So the zookeeper network
is currently as of the filming

14385
14:31:38,539 --> 14:31:42,109
of this, available on both COVID
as well as the theory of main

14386
14:31:42,109 --> 14:31:45,979
net. And let's go ahead and play
the counter contract. And let's

14387
14:31:45,979 --> 14:31:49,129
see what's not updating more
than every 30 seconds. And so

14388
14:31:49,129 --> 14:31:52,219
let's go ahead and deploy. So
meta masks can ask for a little

14389
14:31:52,219 --> 14:31:54,949
bit of payment, in order for me
to deploy this contract to the

14390
14:31:54,949 --> 14:31:58,879
COVID network. And it looks like
that is live. So now what I'm

14391
14:31:58,879 --> 14:32:00,949
going to do is I'm going to be
able to take this keeper

14392
14:32:00,949 --> 14:32:04,609
contract, and copy its address.
And now we're going to register

14393
14:32:04,609 --> 14:32:07,939
that contract for upkeep. So
we're going to jump over to the

14394
14:32:07,939 --> 14:32:10,849
application that powers the
champion keeper network, there's

14395
14:32:10,849 --> 14:32:12,529
a few different ways you can
use, you can interact directly

14396
14:32:12,529 --> 14:32:15,259
with the registry contract. But
there's a very, very nice

14397
14:32:15,259 --> 14:32:17,959
interface that lets you do this.
So let's go ahead and register a

14398
14:32:17,959 --> 14:32:20,059
new upkeep and it's giving me an
error that says you need to

14399
14:32:20,059 --> 14:32:22,879
connect your wallet. So let's go
ahead and do that. So I'm going

14400
14:32:22,879 --> 14:32:25,729
to just connect wallet here, and
I'm gonna give it access to my

14401
14:32:25,729 --> 14:32:28,969
account. And then from there, we
should actually be able to

14402
14:32:28,999 --> 14:32:33,349
register. So I'm going to use an
email address here. I'll give my

14403
14:32:33,349 --> 14:32:36,709
contract a simple name. I'll
paste in that address from the

14404
14:32:36,709 --> 14:32:40,249
deployed contract, and then I'll
give it a gas limit. And then

14405
14:32:40,399 --> 14:32:42,829
check data is this special thing
where you can actually register

14406
14:32:42,859 --> 14:32:45,889
multiple upkeeps On the same
contract in passing data to

14407
14:32:45,889 --> 14:32:49,699
specify how you want checkup
keep to be run of, we're just

14408
14:32:49,699 --> 14:32:51,859
going to ignore that that is an
optional one. And then we'll

14409
14:32:51,859 --> 14:32:55,009
give it a starting balance of
around 10 link, it's gonna go

14410
14:32:55,009 --> 14:32:58,759
ahead and use Metamask again to
register that transaction on the

14411
14:32:58,759 --> 14:33:02,329
network. And once it's
confirmed, my upkeep should be

14412
14:33:02,329 --> 14:33:05,809
registered with the network and
funded with 10 Link To kick

14413
14:33:05,809 --> 14:33:09,409
things off. Alright, if we go
ahead and view the upkeep, we

14414
14:33:09,409 --> 14:33:15,799
can see it's registered. And as
soon as the next round of the

14415
14:33:15,799 --> 14:33:19,129
keeper nodes executes, which
should be roughly about every

14416
14:33:19,129 --> 14:33:23,269
block, we should see that the
check upkeep method is going to

14417
14:33:23,299 --> 14:33:25,819
return that hey, upkeep is
actually needed because the

14418
14:33:25,819 --> 14:33:28,999
timestamp is more than 30
seconds ago. And then we should

14419
14:33:28,999 --> 14:33:32,629
go ahead and perform upkeep. So
as soon as I take a look at this

14420
14:33:32,659 --> 14:33:36,109
in remix, I can actually make
this bigger here, we're going to

14421
14:33:36,109 --> 14:33:38,629
be able to see from the methods
of the contract, if we check the

14422
14:33:38,629 --> 14:33:41,779
counter, it's going to start at
zero. And as soon as that 30

14423
14:33:41,779 --> 14:33:44,269
seconds has passed, we'll be
able to hit the counter again,

14424
14:33:44,449 --> 14:33:47,089
we'll see that the channeling
keeper network has performed

14425
14:33:47,119 --> 14:33:50,989
upkeep on my contract. Alright,
we just refresh and we see the

14426
14:33:50,989 --> 14:33:55,789
balance of the upkeep has been
decreased by about point 01

14427
14:33:55,789 --> 14:33:59,719
link. And we should also see
within our contract that our

14428
14:33:59,719 --> 14:34:02,929
counter has now updated via
proof that perform upkeep method

14429
14:34:02,929 --> 14:34:07,459
call. And now our counter is at
one showing us that our contract

14430
14:34:07,459 --> 14:34:10,249
is being approved by the
chainlink keeper network. And

14431
14:34:10,279 --> 14:34:13,639
everything is working exactly as
we expect. So as you can see, it

14432
14:34:13,639 --> 14:34:16,819
is very, very easy to create a
contract that is compatible with

14433
14:34:16,819 --> 14:34:19,969
the keeper network. And it's
very easy to register that

14434
14:34:19,969 --> 14:34:23,179
upkeep and start seeing that
your contract automation and

14435
14:34:23,179 --> 14:34:25,639
option computation are working
flawlessly.

14436
14:34:25,699 --> 14:34:27,589
Now that we've learned a little
bit more about how chainlink

14437
14:34:27,619 --> 14:34:30,439
keepers work if you want to take
some time to go through the

14438
14:34:30,439 --> 14:34:33,949
documentation and open up way
down below this open and remix

14439
14:34:33,949 --> 14:34:36,409
button. So you can actually work
with one of these and see these

14440
14:34:36,409 --> 14:34:39,709
in action for yourself on a test
net, feel free to do so we're

14441
14:34:39,709 --> 14:34:42,469
gonna be using a setup very
similar to this keepers counter

14442
14:34:42,469 --> 14:34:47,419
setup in the chain link
documentation. So now let's

14443
14:34:47,449 --> 14:34:50,629
update our code so that this
request random numbers

14444
14:34:50,659 --> 14:34:53,479
automatically happens using
chain link keepers. And if we

14445
14:34:53,479 --> 14:34:56,389
look at the example contract can
actually read more about what's

14446
14:34:56,419 --> 14:34:59,779
really important for this to
work. And we need a check upkeep

14447
14:34:59,809 --> 14:35:03,769
and a perform upkeep function in
our code. So instead of request

14448
14:35:03,769 --> 14:35:06,799
random winner, this is going to
be the PErforM upkeep that we're

14449
14:35:06,799 --> 14:35:09,799
going to change. But first let's
make this check upkeep checkup

14450
14:35:09,799 --> 14:35:12,709
keep function is basically going
to be checking to see is it time

14451
14:35:12,709 --> 14:35:15,529
for us to get a random number to
update the recent winner and to

14452
14:35:15,529 --> 14:35:17,929
send them all the funds. So
let's go ahead and make that

14453
14:35:17,929 --> 14:35:20,209
function. I'm going to add some
notes here, just so that it's

14454
14:35:20,209 --> 14:35:23,629
clear what's going on. And maybe
I'll even do natspec To tell

14455
14:35:23,629 --> 14:35:26,179
developers what's going on with
this function. So we're going to

14456
14:35:26,179 --> 14:35:30,439
create this function check
upkeep. And if we look at what

14457
14:35:30,469 --> 14:35:34,669
this needs, it needs to be
external override external

14458
14:35:35,779 --> 14:35:38,719
override. And if we see this
override keyword, this means

14459
14:35:38,719 --> 14:35:41,269
that okay, there's probably a
perform upkeep somewhere else.

14460
14:35:41,329 --> 14:35:43,819
And if we scroll to the top, and
we're going to import this

14461
14:35:43,849 --> 14:35:46,759
keeper compatible interface, so
that we make sure that we

14462
14:35:46,759 --> 14:35:50,869
implement both check upkeep and
perform upkeep in our code here.

14463
14:35:51,049 --> 14:35:54,499
If you want you can just import
keeper compatible in here or

14464
14:35:54,499 --> 14:35:56,869
just the keeper compatible
interface in our code. We're

14465
14:35:56,869 --> 14:36:04,909
going to do import at chain link
slash contracts slash SRC slash

14466
14:36:04,909 --> 14:36:13,129
V 0.8 point two interfaces slash
keeper compatible interface that

14467
14:36:13,129 --> 14:36:16,549
soul and now we're just gonna
say contract raffle is Veera of

14468
14:36:16,549 --> 14:36:19,999
consumer base V two and keeper
compatible interface and this

14469
14:36:19,999 --> 14:36:22,669
keeper compatible interface
inheritance just make sure that

14470
14:36:22,669 --> 14:36:25,639
we add checkup keep and perform
upkeep, which we're going to add

14471
14:36:25,639 --> 14:36:28,339
in a little bit. And if we look
back at the docs we can see

14472
14:36:28,339 --> 14:36:32,359
checkup keep takes a bytes
called Data check data as an

14473
14:36:32,359 --> 14:36:37,339
input parameter. So we'll do
bytes called data. Check data as

14474
14:36:37,339 --> 14:36:40,699
a parameter. Now this check
upkeep bytes call data allows us

14475
14:36:40,699 --> 14:36:44,539
to specify really anything that
we want when we call this check

14476
14:36:44,569 --> 14:36:47,629
upkeep function. Having this
check data be of type bytes

14477
14:36:47,659 --> 14:36:51,649
means that we can even specify
this to call other functions,

14478
14:36:51,709 --> 14:36:54,709
there's a lot of advanced things
you can do by just having an

14479
14:36:54,709 --> 14:36:58,399
input parameter as type of bytes
for us though, we're going to

14480
14:36:58,399 --> 14:37:00,949
keep it a little bit simple. And
we're actually not going to use

14481
14:37:00,949 --> 14:37:03,739
this check data piece. So
similar to how below we're not

14482
14:37:03,739 --> 14:37:06,559
using Request ID, we can just
comment it out. However, we

14483
14:37:06,559 --> 14:37:09,589
still need to make sure that
this parameter is type of bytes

14484
14:37:09,589 --> 14:37:12,469
called data. Now anyways, let's
go ahead and annotate this check

14485
14:37:12,499 --> 14:37:16,819
upkeep function, we'll say this
is the function that the chain

14486
14:37:16,819 --> 14:37:25,849
link keeper nodes call they look
for the to return true. Look

14487
14:37:25,849 --> 14:37:28,879
back at the documentation, we
can see that this check upkeep

14488
14:37:28,999 --> 14:37:33,169
returns both and upkeep needed
and to perform data, which

14489
14:37:33,199 --> 14:37:36,679
again, we're going to ignore
this upkeep needed is going to

14490
14:37:36,679 --> 14:37:41,029
be true or false. If it's true,
that means it's time to get a

14491
14:37:41,029 --> 14:37:46,129
new random number following
should be true in order to

14492
14:37:46,279 --> 14:37:50,599
return true. So in order for it
to be time to request a random

14493
14:37:50,599 --> 14:37:54,019
winner, what should happen, our
time interval should have

14494
14:37:54,019 --> 14:37:58,489
passed, which we haven't defined
yet. But we will lottery should

14495
14:37:58,489 --> 14:38:04,429
have at least one player and
have some eath. And then our

14496
14:38:04,429 --> 14:38:09,439
subscription is funded with Link
similar to how with channeling

14497
14:38:09,439 --> 14:38:12,499
Vir f your subscription needs to
be funded with Link, the same

14498
14:38:12,499 --> 14:38:15,919
thing needs to happen for check
upkeep and keepers to run your

14499
14:38:15,919 --> 14:38:18,019
subscription needs to be funded
with link. Now we're going to

14500
14:38:18,019 --> 14:38:21,319
add one more additional piece
here, we're going to say for the

14501
14:38:21,319 --> 14:38:26,359
lottery should be in an open
state, something that we want to

14502
14:38:26,359 --> 14:38:30,349
avoid when we're waiting for a
random number to return. And

14503
14:38:30,349 --> 14:38:33,199
when we've requested a random
winner. We're technically in

14504
14:38:33,199 --> 14:38:35,779
this weird limbo state where
we're waiting for a random

14505
14:38:35,779 --> 14:38:38,479
number to be returned. And we
really shouldn't allow any new

14506
14:38:38,479 --> 14:38:40,729
players to join. So what we
actually want to do is create

14507
14:38:40,729 --> 14:38:43,999
some state variable telling us
whether the lottery is open or

14508
14:38:43,999 --> 14:38:46,879
not. And while we're waiting for
our random number to get back,

14509
14:38:46,909 --> 14:38:49,189
we'll be in a closed or a
calculating state.

14510
14:38:51,770 --> 14:38:54,650
Now what we could do at the top
of our contract, we can just say

14511
14:38:54,710 --> 14:38:59,420
Boolean, private, s underscore
is open. And we can just set

14512
14:38:59,420 --> 14:39:03,080
this to true if we're open
otherwise false. Well, what if

14513
14:39:03,080 --> 14:39:05,600
we have a ton of different
states? What if we want it to be

14514
14:39:05,600 --> 14:39:10,790
like pending, open, closed,
calculating, etc? What do we

14515
14:39:10,790 --> 14:39:14,360
have a ton of different states?
Well, we could make this a U and

14516
14:39:14,360 --> 14:39:18,530
256. Private s underscore state.
And we could just keep track of

14517
14:39:18,530 --> 14:39:21,860
the state having like zero b
pending a one reopen to be

14518
14:39:21,860 --> 14:39:24,830
closed, three, be calculating,
etc. But this can be a little

14519
14:39:24,830 --> 14:39:27,710
tricky to keep track of. So a
better way to actually keep

14520
14:39:27,710 --> 14:39:31,220
track of all this in our code is
to use an enum enums, can be

14521
14:39:31,220 --> 14:39:35,270
used to create custom types with
a finite set of constant values.

14522
14:39:35,300 --> 14:39:39,110
So we can create, for example, a
state created locked inactive,

14523
14:39:39,200 --> 14:39:42,680
and it's basically a new type
for a smart contract for us,

14524
14:39:42,710 --> 14:39:45,080
we're going to create a new
type. And if we go back to the

14525
14:39:45,080 --> 14:39:48,170
layout of variables, and our
smart contract types should

14526
14:39:48,170 --> 14:39:50,840
actually be first thing in our
contract. So we're going to

14527
14:39:50,840 --> 14:39:54,920
create an E new called raffle
state. And for now, and we're

14528
14:39:54,920 --> 14:39:57,590
just going to have it be open,
we're just gonna have to be open

14529
14:39:57,650 --> 14:40:02,570
or calculating. Now when we
create an enum like this, we're

14530
14:40:02,570 --> 14:40:07,610
kind of secretly creating a un
256, where zero equals open, and

14531
14:40:07,610 --> 14:40:12,020
one equals calculating. However,
this is much more explicit that

14532
14:40:12,020 --> 14:40:15,080
we know what each one of these
numbers actually means. Now that

14533
14:40:15,080 --> 14:40:18,290
we've created this new type
called raffle state, we can

14534
14:40:18,290 --> 14:40:21,980
create a new lottery state
variable of type raffle state.

14535
14:40:22,100 --> 14:40:25,190
So the exact same way we declare
any other variable, we'll name

14536
14:40:25,190 --> 14:40:28,070
its type, which is going to be
raffle state. And this is going

14537
14:40:28,070 --> 14:40:31,520
to be a storage variable. So
we'll go ahead and do private s

14538
14:40:31,550 --> 14:40:34,910
underscore raffle state in our
constructor, right when we

14539
14:40:34,910 --> 14:40:38,060
launched this contract, we
should open up this raffle. So

14540
14:40:38,060 --> 14:40:43,340
we'll say s, raffle state equals
and we could use a un 256.

14541
14:40:43,730 --> 14:40:48,260
Wrapped in type raffle state
like so. Or we can be more

14542
14:40:48,260 --> 14:40:52,460
explicit and say raffle state
DOT open. Now we know that the

14543
14:40:52,460 --> 14:40:55,760
raffle state is in an open state
and we only want checkup keep to

14544
14:40:55,760 --> 14:40:59,090
work is if the lottery is
actually open. Additionally, we

14545
14:40:59,090 --> 14:41:01,730
probably only want people to be
able to enter if the law

14546
14:41:01,730 --> 14:41:04,730
battery's open. So let's go
ahead and create another if

14547
14:41:04,730 --> 14:41:07,760
statement and revert if the
lottery isn't open. So we can

14548
14:41:07,760 --> 14:41:14,630
say if s underscore raffle state
does not equal raffle state DOT

14549
14:41:14,630 --> 14:41:19,400
open, then we're going to revert
with a new error, we're going to

14550
14:41:19,400 --> 14:41:24,530
create raffle underscore
underscore, not open. And of

14551
14:41:24,530 --> 14:41:29,990
course, at the top will create
error, raffle not open. Now

14552
14:41:29,990 --> 14:41:33,980
additionally, let's go down when
we're requesting a random word.

14553
14:41:34,100 --> 14:41:37,310
Let's update the state to be
calculating so other people

14554
14:41:37,310 --> 14:41:41,300
can't jump in here. So right
above our VRF coordinator dot

14555
14:41:41,300 --> 14:41:45,890
request, random words will do s
underscore raffle state equals

14556
14:41:46,700 --> 14:41:51,950
raffle state DOT calculating so
that nobody can enter our

14557
14:41:51,950 --> 14:41:56,060
lottery and nobody can trigger a
new update. And then once we

14558
14:41:56,060 --> 14:41:59,960
fulfill after we pick our
winner, we'll say s raffle state

14559
14:41:59,990 --> 14:42:07,070
equals raffle state DOT open
again. Something else that we

14560
14:42:07,070 --> 14:42:10,880
forgot to do was after we pick a
winner from s players, we need

14561
14:42:10,880 --> 14:42:14,180
to reset our players array. So
let's add that in here as well

14562
14:42:14,690 --> 14:42:21,890
as players equals new address
payable. array of size zero. So

14563
14:42:21,890 --> 14:42:24,980
we'll reset the raffle state.
And we'll reset our players

14564
14:42:24,980 --> 14:42:27,350
array. Alright, great. So now
that we've learned about enum,

14565
14:42:27,530 --> 14:42:30,230
let's add it to our checkup keep
here, we're going to check these

14566
14:42:30,230 --> 14:42:33,650
four things. And if they all
pass checkup keys will be true

14567
14:42:33,680 --> 14:42:36,890
and will trigger the chain the
keepers to request a new random

14568
14:42:36,890 --> 14:42:41,510
winner. So first, we'll say bool
is open. It's going to be equal

14569
14:42:41,510 --> 14:42:48,590
to raffle state. That open
equals equals s underscore

14570
14:42:49,640 --> 14:42:53,900
raffle state. So you can think
of that as this boolean is open

14571
14:42:53,990 --> 14:42:58,100
is going to be true if raffle
state is in an open state, and

14572
14:42:58,100 --> 14:43:01,550
it will be false if raffle state
is in any other state. So great.

14573
14:43:01,580 --> 14:43:04,820
We haven't is open Boolean that
we can check later on. What else

14574
14:43:04,820 --> 14:43:07,250
do we need? Well, we need to
check to make sure our time

14575
14:43:07,250 --> 14:43:10,850
interval is past well, we don't
have a time interval yet. So

14576
14:43:10,850 --> 14:43:14,030
let's create a time interval. In
order to check the time we can

14577
14:43:14,030 --> 14:43:17,420
use another one a solidity is
globally available variables

14578
14:43:17,480 --> 14:43:20,840
with block dot timestamp block
that timestamp returns the

14579
14:43:20,840 --> 14:43:23,300
current timestamp of the
blockchain to get the current

14580
14:43:23,300 --> 14:43:26,090
timestamp, we're gonna need
block dot timestamp. But to get

14581
14:43:26,090 --> 14:43:28,640
if enough time has passed, we're
going to need to get the current

14582
14:43:28,640 --> 14:43:33,260
block dot timestamp minus the
last block timestamp, which we

14583
14:43:33,260 --> 14:43:35,900
don't have yet. Let's go ahead
and create a state variable to

14584
14:43:35,900 --> 14:43:39,350
keep track of the previous block
timestamp. So this is going to

14585
14:43:39,350 --> 14:43:41,660
be a new state variable that
we're going to make. I'm gonna

14586
14:43:41,660 --> 14:43:47,570
say u and 256. Private s
underscore last timestamp.

14587
14:43:49,250 --> 14:43:52,280
And right when we deploy this
contract, we'll update this with

14588
14:43:52,280 --> 14:43:56,360
the current timestamp s last
timestamp equals block dot

14589
14:43:56,390 --> 14:44:01,910
timestamp. Alright, awesome. Now
we have a last block timestamp.

14590
14:44:01,940 --> 14:44:04,430
But we're going to need to check
that the difference between the

14591
14:44:04,430 --> 14:44:07,940
current timestamp and the last
timestamp is greater than some

14592
14:44:07,940 --> 14:44:10,670
interval. So we also need to
create an interval. And this is

14593
14:44:10,670 --> 14:44:13,430
going to be some interval, this
is going to be some number in

14594
14:44:13,430 --> 14:44:18,110
seconds of how long we want to
wait between lottery runs. So

14595
14:44:18,110 --> 14:44:21,590
let's go ahead and add this to
our constructor as well. And do

14596
14:44:21,590 --> 14:44:25,820
a comma here. And we'll do u and
256. Interval. And we're going

14597
14:44:25,820 --> 14:44:31,070
to create another global
variable u and 256 Private s

14598
14:44:31,100 --> 14:44:34,970
underscore interval. And in our
constructor and we'll say s

14599
14:44:34,970 --> 14:44:38,780
interval equals interval. Now
interval isn't going to change

14600
14:44:38,780 --> 14:44:42,290
after we set it. So instead of
making a storage variable, let's

14601
14:44:42,290 --> 14:44:46,340
make it an immutable variable to
save some gas. Okay, perfect.

14602
14:44:46,400 --> 14:44:48,920
Now that we have all this, I'm
actually create a boolean to

14603
14:44:48,920 --> 14:44:51,800
check to see if enough time has
passed. So we'll say Boolean

14604
14:44:52,280 --> 14:44:59,900
time passed equals the current
block that timestamp minus s

14605
14:44:59,930 --> 14:45:05,510
underscore last timestamp. And
we should check to see that this

14606
14:45:05,570 --> 14:45:09,680
is actually greater than I
underscore interval. So we have

14607
14:45:09,680 --> 14:45:12,680
a Boolean check to see if we're
open. It'll be true if we're

14608
14:45:12,680 --> 14:45:15,560
open and we'll have a boolean to
see if enough time has passed.

14609
14:45:15,590 --> 14:45:18,140
This will be true if enough time
has passed. What else should we

14610
14:45:18,140 --> 14:45:21,110
check? While we should check to
see if we have enough players.

14611
14:45:21,200 --> 14:45:26,300
So we'll do Boolean has players
equals and we'll check to see if

14612
14:45:26,300 --> 14:45:32,240
s underscore players dot length
is greater than zero. If s

14613
14:45:32,240 --> 14:45:34,970
players dot length is greater
than zero as players will be

14614
14:45:34,970 --> 14:45:38,210
true, otherwise it'll be false.
And we'll also see if we have a

14615
14:45:38,210 --> 14:45:44,840
balance so we'll do Boolean has
balance equals address. This dot

14616
14:45:44,840 --> 14:45:48,680
balance is greater than zero.
Then finally, we're going to

14617
14:45:48,680 --> 14:45:52,280
take all these booleans and turn
them into the return variable

14618
14:45:52,310 --> 14:45:54,950
that we're looking for. We're
gonna say Boolean up keep

14619
14:45:54,950 --> 14:46:06,980
needed. Equals is open and time
passed. And as players and as

14620
14:46:06,980 --> 14:46:11,330
balance, like that, so all these
combined is gonna be this

14621
14:46:11,330 --> 14:46:15,020
Boolean upkeep needed. And if
this returns true, it's time to

14622
14:46:15,020 --> 14:46:18,800
request a new random number and
it's time to end the lottery. If

14623
14:46:18,800 --> 14:46:21,440
this is false, it's not time
yet, it's not time to end the

14624
14:46:21,440 --> 14:46:24,290
lottery up. Now again, if we go
to the chainlink, documentation

14625
14:46:24,440 --> 14:46:28,100
upkeep needed, actually needs to
return that Boolean upkeep

14626
14:46:28,100 --> 14:46:30,890
needed and some bytes memory
perform data. So we need to

14627
14:46:30,890 --> 14:46:34,850
update we need to update our
function here. And say returns

14628
14:46:35,360 --> 14:46:44,300
full upkeep needed, comma, bytes
memory, perform data star slash.

14629
14:46:44,480 --> 14:46:47,120
And since we've initialized
Boolean up, keep needed up here,

14630
14:46:47,150 --> 14:46:51,770
we don't need to say what type
of upkeep needed is down here.

14631
14:46:52,040 --> 14:46:55,130
Since this will automatically
get returned performed data is

14632
14:46:55,130 --> 14:46:58,610
something that we can use. If we
want to have checkup, keep do

14633
14:46:58,610 --> 14:47:02,060
some other stuff. Depending on
how this checkup keep went. We

14634
14:47:02,060 --> 14:47:04,100
don't really need it to do
anything else. So we can just

14635
14:47:04,100 --> 14:47:07,580
leave it as such. Right. So now
we have a check upkeep, we have

14636
14:47:07,580 --> 14:47:11,000
a way to check to see if it's
time to trigger picking our

14637
14:47:11,000 --> 14:47:12,830
random winner of our lottery

14638
14:47:12,920 --> 14:47:18,170
or our raffle. Now that we
learned how to actually do this

14639
14:47:18,170 --> 14:47:21,260
trigger, let's write the
function that gets executed

14640
14:47:21,290 --> 14:47:25,130
after this returns true. This is
going to be our perform upkeep

14641
14:47:25,130 --> 14:47:28,280
function, which we can see an
example again in the chainlink

14642
14:47:28,280 --> 14:47:31,730
documentation. Now when it's
time to pick a random winner,

14643
14:47:31,790 --> 14:47:34,160
actually, what we're going to do
is just we're just going to call

14644
14:47:34,160 --> 14:47:36,770
this request random winner
function. So instead of having

14645
14:47:36,770 --> 14:47:40,160
this extra function, let's just
transform our request random

14646
14:47:40,160 --> 14:47:44,030
winner function into this
perform upkeep. Since once check

14647
14:47:44,060 --> 14:47:47,000
upkeep returns true, the chain
link nodes will automatically

14648
14:47:47,000 --> 14:47:50,270
call this perform upkeep
function. So in function request

14649
14:47:50,270 --> 14:47:54,380
random winner, let's rename this
to perform upkeep. And we'll

14650
14:47:54,380 --> 14:47:58,070
have it take the input parameter
bytes called Data perform data

14651
14:47:58,400 --> 14:48:03,650
bytes, called data, perform
data. In our checkup, keep we

14652
14:48:03,650 --> 14:48:06,560
had to perform data, we would
automatically pass it to our

14653
14:48:06,560 --> 14:48:08,780
performance keep, we're not
going to pass anything to

14654
14:48:08,780 --> 14:48:11,840
perform upkeep, we can leave it
commented out like this. Since

14655
14:48:11,840 --> 14:48:14,630
perform upkeep is actually
identified in the keeper

14656
14:48:14,630 --> 14:48:17,360
compatible interface, this is
now going to have to override

14657
14:48:17,390 --> 14:48:20,150
that function. Now we want to do
a little bit of validation

14658
14:48:20,150 --> 14:48:24,050
before we continue here. Because
right now anybody can call our

14659
14:48:24,050 --> 14:48:26,930
perform upkeep function. So we
want to make sure that it only

14660
14:48:26,930 --> 14:48:30,710
gets called when checkup keep is
true. An easy way for us to do

14661
14:48:30,710 --> 14:48:33,740
that is to actually call our own
checkup, keep function. Now

14662
14:48:33,740 --> 14:48:36,980
right now, checkup keep it's an
external. So we actually can't

14663
14:48:36,980 --> 14:48:39,830
call our own checkup keep
function. So let's change it to

14664
14:48:39,830 --> 14:48:42,950
public so that even our own
smart contracts can call this

14665
14:48:42,950 --> 14:48:45,950
checkup keep function. Now that
we've made it public in perform

14666
14:48:45,950 --> 14:48:49,400
upkeep, we can call checkup,
keep passing nothing, and then

14667
14:48:49,400 --> 14:48:52,400
return the upkeep needed and
perform data which we don't

14668
14:48:52,400 --> 14:48:56,660
really care about. So we'll get
we'll get that ball up keep

14669
14:48:57,860 --> 14:49:01,640
needed. And then we don't care
about perform data. So we'll

14670
14:49:01,640 --> 14:49:06,500
leave that blank equals check up
keep. And we'll pass it a blank

14671
14:49:06,530 --> 14:49:10,280
called data. Now, we want to
make sure that this is true in

14672
14:49:10,280 --> 14:49:12,680
order to keep going with the
function. So we could write a

14673
14:49:12,680 --> 14:49:19,280
require here, but we're going to
do if not up keep needed, then

14674
14:49:19,280 --> 14:49:22,640
we're going to revert with a new
error that we create raffle.

14675
14:49:24,529 --> 14:49:29,269
upkeep not needed. And we're
going to pass some variables to

14676
14:49:29,269 --> 14:49:29,719
this error

14677
14:49:29,720 --> 14:49:32,690
so that whoever was running into
this bug can hopefully see why

14678
14:49:32,690 --> 14:49:34,940
they're getting this error. So
we'll pass the balance of this

14679
14:49:34,940 --> 14:49:38,360
contract just in case there's no
ether in here. We'll add the

14680
14:49:38,360 --> 14:49:41,990
players dot length, just in case
there's no players. And we'll

14681
14:49:41,990 --> 14:49:47,990
add a un 256 s underscore raffle
state. Make sure that the

14682
14:49:47,990 --> 14:49:52,130
raffles actually open. And then
of course, we'll need to create

14683
14:49:52,130 --> 14:49:56,030
this air at the top air, raffle
upkeep not needed, which is

14684
14:49:56,030 --> 14:50:03,710
going to take a un 256 current
balance un 256 non players and

14685
14:50:03,710 --> 14:50:08,720
you went to fit six raffle
state. Our code is starting to

14686
14:50:08,720 --> 14:50:11,960
look really professional. This
is awesome. Now something that

14687
14:50:11,960 --> 14:50:14,630
we forgot to do back in the
fulfill random words because we

14688
14:50:14,630 --> 14:50:17,960
actually forgot to reset
timestamp every time a winner is

14689
14:50:17,960 --> 14:50:21,230
picked. We want to reset the
timestamp as well so that we can

14690
14:50:21,230 --> 14:50:23,720
wait another interval and let
people participate in the

14691
14:50:23,720 --> 14:50:27,110
lottery for that interval. So
we'll scroll down into fulfill

14692
14:50:27,110 --> 14:50:31,430
random words. And right after we
reset players will also reset

14693
14:50:31,460 --> 14:50:34,490
the timestamp. Okay great and I
think we're just about done

14694
14:50:34,490 --> 14:50:40,730
here. Let's add a little bit of
natspec to make this look even

14695
14:50:40,730 --> 14:50:43,040
more professional and and give
people who are reading our

14696
14:50:43,040 --> 14:50:48,020
contract even more information.
So let's add title here at title

14697
14:50:48,230 --> 14:50:52,220
and we'll say a sample raffle
contract will say an author is

14698
14:50:52,220 --> 14:50:55,400
going to be me Patrick Collins
or you can put your own name

14699
14:50:55,400 --> 14:51:00,980
there as well at notice. This
contract is for creating and

14700
14:51:01,010 --> 14:51:05,900
untampered orrible decentralized
smart contract. And then we'll

14701
14:51:05,900 --> 14:51:12,470
do add Dev, this implements
chain link VRF v two, and chain

14702
14:51:12,470 --> 14:51:16,220
link keepers. Alright, awesome.
We've got our type declarations,

14703
14:51:16,250 --> 14:51:19,250
we've got our state variables,
we've got lottery variables,

14704
14:51:19,250 --> 14:51:22,430
which are still state variables,
we've got our events. Now it's

14705
14:51:22,430 --> 14:51:26,480
time for our functions.
Afterwards, we've done a little

14706
14:51:26,480 --> 14:51:29,360
bit of natspec, at least on our
check upkeep. If you want to add

14707
14:51:29,360 --> 14:51:32,600
some more natspec on things like
enter, raffle, perform upkeep,

14708
14:51:32,600 --> 14:51:35,720
etc, you can absolutely do so.
And then down at the bottom, we

14709
14:51:35,720 --> 14:51:38,720
have our views slash pure getter
functions. Let's see, do we want

14710
14:51:38,720 --> 14:51:41,540
any other getter functions here?
Well, we probably want to give

14711
14:51:41,540 --> 14:51:43,760
people the chance to get a
raffle state. So we'll do

14712
14:51:43,760 --> 14:51:50,270
function, get raffle state, this
will be a public, you returns a

14713
14:51:50,810 --> 14:51:57,440
raffle state. We'll say return s
underscore raffle state, we

14714
14:51:57,440 --> 14:52:00,080
probably want to give people the
chance to get the number of

14715
14:52:00,080 --> 14:52:03,020
words. And this is going to be a
little bit interesting here

14716
14:52:03,290 --> 14:52:09,890
running. So if we do function,
get num words, public view

14717
14:52:10,010 --> 14:52:15,380
returns, you went to the six
return num words, you'll see

14718
14:52:15,380 --> 14:52:19,640
something interesting happened
here. We pull up our compiler

14719
14:52:19,970 --> 14:52:24,260
and run hh compile. Hopefully
everything works here. Oh, and

14720
14:52:24,260 --> 14:52:27,890
everything doesn't work because
I didn't import this correctly.

14721
14:52:28,250 --> 14:52:30,470
Let's fix that. Let's try again.

14722
14:52:31,520 --> 14:52:35,150
Oh, there's a couple things I
missed. Let's fix es players.

14723
14:52:35,240 --> 14:52:37,760
This is why it's good to compile
as you code as players dot

14724
14:52:37,760 --> 14:52:42,320
length. Let's try again. And I
spelt interval wrong. I

14725
14:52:42,320 --> 14:52:47,420
underscore inter vol strike to
compile again, see how many more

14726
14:52:47,420 --> 14:52:51,560
spelling mistakes I made. And
there it is. I underscore in

14727
14:52:51,800 --> 14:52:56,270
error go to paste that and we do
get another error here. Invalid

14728
14:52:56,270 --> 14:52:59,210
type for argument in a function
call invalid implicit conversion

14729
14:52:59,210 --> 14:53:02,300
from literal string to bytes
called data requested. Since

14730
14:53:02,300 --> 14:53:06,020
we're passing this empty string
here. And checkup keep needs a

14731
14:53:06,020 --> 14:53:09,140
call data called data actually
doesn't work with strings. So we

14732
14:53:09,140 --> 14:53:12,590
need to make this bytes memory
instead. And our compiler is now

14733
14:53:12,590 --> 14:53:15,650
happy with us. And I spell it
the timestamp wrong. That's a

14734
14:53:15,650 --> 14:53:19,820
lowercase s so and you might see
some squiggles here on Check

14735
14:53:20,000 --> 14:53:23,210
upkeep, we could make this a
view function since we're not

14736
14:53:23,210 --> 14:53:26,210
actually modifying any state.
But I want to keep it public for

14737
14:53:26,210 --> 14:53:29,330
reasons I'll show you a little
bit later. But finally we get

14738
14:53:29,330 --> 14:53:32,360
the the yellow squiggly that I
was looking for here. And if we

14739
14:53:32,360 --> 14:53:37,100
run hh compile, we should see a
warning in our compiler as well.

14740
14:53:37,220 --> 14:53:39,950
Okay, so we see all those yellow
squigglies here. Unnamed return

14741
14:53:39,950 --> 14:53:43,490
variable can remain unassigned.
We need this bytes memory in

14742
14:53:43,490 --> 14:53:46,250
here because that's what the
keepers are looking for. Morning

14743
14:53:46,280 --> 14:53:49,310
function state mutability can be
restricted to view for our

14744
14:53:49,310 --> 14:53:52,520
function checkup key. You can
make a view if you want, but I'm

14745
14:53:52,520 --> 14:53:54,890
going to keep it public for
reasons I'll show you a little

14746
14:53:54,890 --> 14:53:58,160
bit later. And finally, function
state mutability can be

14747
14:53:58,160 --> 14:54:01,880
restricted to pure this is what
I wanted to show you since num

14748
14:54:01,880 --> 14:54:05,420
words is actually in the
bytecode, since it's a constant

14749
14:54:05,420 --> 14:54:08,570
variable technically isn't
reading from storage, and

14750
14:54:08,570 --> 14:54:13,250
therefore this can be a pure
function. Returning num words

14751
14:54:13,280 --> 14:54:16,250
doesn't actually read in
storage, it literally will go

14752
14:54:16,280 --> 14:54:20,900
and read the number one. So
doing get num words in solidity

14753
14:54:20,930 --> 14:54:23,600
with num words being a constant
variable, it's going to

14754
14:54:23,600 --> 14:54:27,110
literally be the exact same as
saying get one and we would

14755
14:54:27,110 --> 14:54:29,450
return one here, we might also
want to get the number of

14756
14:54:29,450 --> 14:54:34,100
players. So we'll create a
function get number of players.

14757
14:54:35,510 --> 14:54:42,140
And this will be a public view,
returns a un 256. Turn s

14758
14:54:42,140 --> 14:54:47,840
underscore players dot length.
We're also probably going to

14759
14:54:47,840 --> 14:54:51,590
want the latest timestamp. So
we'll do function get latest

14760
14:54:51,860 --> 14:54:58,610
timestamp. public view returns
you in 256. And we're just going

14761
14:54:58,610 --> 14:55:05,270
to return s underscore last
timestamp. And maybe we'll want

14762
14:55:05,270 --> 14:55:09,020
to do request confirmation. So
we'll do function GET request

14763
14:55:09,380 --> 14:55:14,270
confirmations. Public pure since
request confirmations is also a

14764
14:55:14,270 --> 14:55:19,790
constant function returns you
went to you went to 56 Turn

14765
14:55:20,060 --> 14:55:25,430
request confirmations. All
right, we've got some wonderful

14766
14:55:25,430 --> 14:55:28,940
getters here. Some views slash
pure functions, we have a way to

14767
14:55:28,940 --> 14:55:32,870
get a random number we have a
way in a decentralized context.

14768
14:55:33,080 --> 14:55:36,500
Automatic automatically execute.
picking a random winner we have

14769
14:55:36,500 --> 14:55:40,340
a way for people to enter our
raffle to enter this lottery.

14770
14:55:40,550 --> 14:55:46,340
And we have a bullet proof way
to solve creating a truly fair

14771
14:55:46,370 --> 14:55:50,180
decentralized lottery. Oh my
goodness. Let's do one more

14772
14:55:50,180 --> 14:55:54,380
compile for good measure H H
compile. And these are just

14773
14:55:54,380 --> 14:55:57,560
warnings. So we're good to go
here. Our code is compiling

14774
14:55:57,590 --> 14:56:03,620
successfully. Like I said
Normally, this definitely isn't

14775
14:56:03,650 --> 14:56:05,840
going to be the way that you're
going to write your smart

14776
14:56:05,840 --> 14:56:09,410
contracts, it's almost
impossible to write a full smart

14777
14:56:09,410 --> 14:56:11,900
contract without making any
mistakes. And without flipping

14778
14:56:11,900 --> 14:56:14,840
back and forth between
documentation, I have already

14779
14:56:14,840 --> 14:56:18,800
written this contract many times
myself, and I still made a whole

14780
14:56:18,800 --> 14:56:21,950
bunch of mistakes. So it is
totally reasonable and totally

14781
14:56:21,950 --> 14:56:25,340
rational for anybody and
everybody to make mistakes going

14782
14:56:25,340 --> 14:56:28,040
through this. And to use
resources and to write tests

14783
14:56:28,070 --> 14:56:31,070
along the way. Now that we have
our raffle dot Seoul created,

14784
14:56:31,370 --> 14:56:34,700
it's time to add everything
else. So we're going to come

14785
14:56:34,700 --> 14:56:38,210
over here, we're gonna create a
new folder, and add our deploy

14786
14:56:38,210 --> 14:56:39,350
folder per usual.

14787
14:56:39,440 --> 14:56:41,840
And we're going to do exactly
what we've already done a couple

14788
14:56:41,840 --> 14:56:44,420
of times, we're going to create
some scripts to deploy our

14789
14:56:44,420 --> 14:56:46,910
raffle contract. Now with our
raffle contract, there's a

14790
14:56:46,910 --> 14:56:49,340
couple of things in here that we
want to make note of first thing

14791
14:56:49,340 --> 14:56:53,000
is that our constructor right
now is absolutely massive. There

14792
14:56:53,000 --> 14:56:56,120
are a ton of parameters in here
that we need to account for.

14793
14:56:56,210 --> 14:56:58,520
Let's take a look at our
constructors and see if there's

14794
14:56:58,520 --> 14:57:01,340
any contracts that we're already
interacting with. Okay, VRF,

14795
14:57:01,340 --> 14:57:05,450
coordinator v2. This is a
contract address, entrance fee,

14796
14:57:05,450 --> 14:57:09,650
no gasline, no subscription ID
no callback, guestimate No, and

14797
14:57:09,650 --> 14:57:13,190
interval. No. So knowing that
this is an address should be a

14798
14:57:13,190 --> 14:57:15,890
tip that Ah, okay, we're
probably going to need to deploy

14799
14:57:15,920 --> 14:57:19,040
some mocks. For this, since
we're going to need to interact

14800
14:57:19,040 --> 14:57:22,520
with a VRF coordinator contract
that's outside of our project.

14801
14:57:22,550 --> 14:57:24,650
But let's go ahead and start
working on our raffle deployment

14802
14:57:24,650 --> 14:57:27,770
script first, and we know we're
going to have to deploy some

14803
14:57:27,770 --> 14:57:30,770
mocks. So we'll just keep that
in mind. So let's create a new

14804
14:57:30,770 --> 14:57:38,450
file. Oh, one, deploy raffle.js.
And let's get started deploying

14805
14:57:38,480 --> 14:57:41,180
our raffle contract. Now, this
is going to look really similar

14806
14:57:41,180 --> 14:57:43,610
to what we've done before. And
we're going to do it again here.

14807
14:57:43,640 --> 14:57:46,040
If you want to use your previous
deploy scripts as a reference, I

14808
14:57:46,040 --> 14:57:48,920
absolutely recommend you do so.
But let's get started with

14809
14:57:49,340 --> 14:57:56,090
module that exports equals an
async function. That's going to

14810
14:57:56,090 --> 14:58:04,070
take get named accounts and
deployments. As input

14811
14:58:04,070 --> 14:58:10,220
parameters, then we're going to
do const. Deploy log equals

14812
14:58:10,340 --> 14:58:15,710
deployments, then we're gonna
say const, Deployer, equals

14813
14:58:15,740 --> 14:58:21,050
await, get named accounts. Let's
go to our config and update

14814
14:58:21,050 --> 14:58:24,350
module that exports to to have
this I'm just going to copy

14815
14:58:24,350 --> 14:58:27,740
paste, so that employer is going
to be defaulted to account zero

14816
14:58:27,770 --> 14:58:30,380
and player is going to be
defaulted to account one, if you

14817
14:58:30,380 --> 14:58:32,630
want to go ahead and write this
out, feel free to pause and

14818
14:58:32,630 --> 14:58:34,730
write out your name accounts.
Right now, there's gonna be a

14819
14:58:34,730 --> 14:58:38,900
lot of boilerplate in our heart
hat.config.js. So feel free to

14820
14:58:38,900 --> 14:58:42,350
have the GitHub repo for this
lesson up with you or your

14821
14:58:42,350 --> 14:58:44,780
previous scripts that you've
already written as a reference

14822
14:58:44,840 --> 14:58:47,660
named accounts Deployer. And
we're also going to have a

14823
14:58:47,660 --> 14:58:51,500
player named account so that we
can separate different users or

14824
14:58:51,500 --> 14:58:53,900
different players who are
interacting with our contracts.

14825
14:58:53,990 --> 14:58:56,000
But for now, we're gonna grab
our Deployer. And we're gonna

14826
14:58:56,000 --> 14:58:59,090
get started. Now similar to last
time, we would just do const,

14827
14:58:59,120 --> 14:59:05,570
raffle equals await ploy,
raffle, comma, and then add all

14828
14:59:05,570 --> 14:59:09,530
of our stuff in here, right? So
this would be from Deployer.

14829
14:59:10,610 --> 14:59:14,210
args, we're going to have a ton
of args. So we're going to come

14830
14:59:14,210 --> 14:59:19,250
back to this. And then log is
going to be true. And then we're

14831
14:59:19,250 --> 14:59:21,080
going to have wait
confirmations, there's a little

14832
14:59:21,080 --> 14:59:23,750
bit more boilerplate we need to
work with here in our Hardhead

14833
14:59:23,750 --> 14:59:26,840
config, we don't have a network
here. So let's add our network

14834
14:59:26,840 --> 14:59:29,420
information. So we can get those
block confirmations will be

14835
14:59:29,420 --> 14:59:33,320
specific in here, as well. And
we'll say default network is

14836
14:59:33,320 --> 14:59:35,960
going to be hard hat. And then
we'll say

14837
14:59:37,460 --> 14:59:40,370
networks, and we'll add our
network information that's going

14838
14:59:40,370 --> 14:59:46,190
to be working with heart hub,
which has a chain ID of 31337

14839
14:59:46,220 --> 14:59:49,490
miles, we'll put that in here as
well. And block confirmations

14840
14:59:49,580 --> 14:59:53,000
were just set to one lot this
column here, we're also gonna be

14841
14:59:53,000 --> 14:59:56,150
running some staging tests on
the Rinkeby network. So we'll

14842
14:59:56,150 --> 15:00:01,640
add rink B in here with a chain
ID of four, block confirmations

14843
15:00:02,240 --> 15:00:07,490
of six, and we need to add a URL
and then also some accounts for

14844
15:00:07,490 --> 15:00:11,870
our URL. We've done this 100
times. We'll do const. rinky

14845
15:00:12,260 --> 15:00:18,530
dink could be RPC URL equals
process study and v dot rake,

14846
15:00:18,530 --> 15:00:22,370
the RPC URL, that's private key,
blah, blah, blah, we're going to

14847
15:00:22,370 --> 15:00:26,030
add all these same variables
from our last projects. So I'm

14848
15:00:26,030 --> 15:00:28,790
going to ask you to pause here
and just copy paste all those

14849
15:00:28,790 --> 15:00:32,270
variables from our last project.
Boom, like so since running

14850
15:00:32,270 --> 15:00:35,720
rink, prpc, URL, private key
corn market cap and ether scan,

14851
15:00:35,720 --> 15:00:39,230
we're also going to want to make
sure you folder, excuse me, new

14852
15:00:39,230 --> 15:00:43,400
file, dot env. And we're going
to drop all of our information

14853
15:00:43,400 --> 15:00:47,870
in here our rink, prpc, URL,
private key, ether scan API key,

14854
15:00:47,900 --> 15:00:50,780
and then our coin market cap API
key as well. Now that we have

14855
15:00:50,780 --> 15:00:56,060
our private key or ring prpc URL
down in URL, B RPC URL, and for

14856
15:00:56,060 --> 15:00:59,450
accounts, we're just going to
add that single private key. Now

14857
15:00:59,450 --> 15:01:02,750
for weight confirmations is
going to equal For network

14858
15:01:03,590 --> 15:01:10,700
config dot block con formations,
or one, we're gonna have to

14859
15:01:10,700 --> 15:01:13,520
import network from Hardhead,
which looks like my VS code

14860
15:01:13,550 --> 15:01:16,670
automatically did for me. Thanks
VS code. So this is how we're

14861
15:01:16,670 --> 15:01:19,220
going to deploy a raffle.
Obviously, we have a ton of

14862
15:01:19,220 --> 15:01:22,070
arguments that we need to
account for. So let's get to it.

14863
15:01:22,280 --> 15:01:24,590
Let's look at our raffle
constructor to see what we need

14864
15:01:24,590 --> 15:01:27,170
to get. Okay, well, the first
thing that we need to get via of

14865
15:01:27,170 --> 15:01:30,410
coordinator v2, we're gonna use
the same strategy we used in our

14866
15:01:30,410 --> 15:01:34,100
Funmi project with using mocks,
if we're on a development chain,

14867
15:01:34,190 --> 15:01:37,040
and using the actual contract
address if we're on a test net,

14868
15:01:37,070 --> 15:01:40,460
or a live network, so let's get
to it. So let's go ahead,

14869
15:01:40,850 --> 15:01:46,670
recreate that helper, hard hat
config dot j s and create that

14870
15:01:46,670 --> 15:01:53,600
const. Network. Config, say it
equals for hard hat, we're going

14871
15:01:53,600 --> 15:01:56,420
to use a mock. So we don't need
to put that in here for now. But

14872
15:01:56,420 --> 15:02:01,100
for rink B, let's go ahead, but
a foreign here, so the name is

14873
15:02:01,100 --> 15:02:04,640
going to be Rinkeby. And we're
going to need to go to the chain

14874
15:02:04,640 --> 15:02:07,400
link documentation, the VRF
contracts, and we're going to

14875
15:02:07,400 --> 15:02:11,900
need to grab the RF coordinator
for the Rinkeby. Test net, we're

14876
15:02:11,900 --> 15:02:15,170
going to grab this address here,
plop it in here, we'll say V RF

14877
15:02:15,350 --> 15:02:20,720
core did an eight tour v two,
bam, right like that. So back in

14878
15:02:20,720 --> 15:02:23,060
our deploy raffle, we're gonna
have to pick whether or not to

14879
15:02:23,060 --> 15:02:26,750
use the V RF coordinator v two
in the network config or some

14880
15:02:26,750 --> 15:02:30,560
mock that we deployed, which of
course, leads us to us having to

14881
15:02:30,560 --> 15:02:37,430
deploy a mock, let's create the
new file 00. Deploy marks.js. So

14882
15:02:37,460 --> 15:02:43,010
same thing module that exports
equals async function where it's

14883
15:02:43,010 --> 15:02:48,830
taking, get named accounts, and
deployments, as its input

14884
15:02:48,830 --> 15:02:51,830
variables from the heart at
runtime environment, or do const

14885
15:02:52,160 --> 15:02:57,860
deploy COMM A log equals
deployments. And then const,

14886
15:02:58,160 --> 15:03:05,570
Deployer equals await, get named
accounts, Excel, and then we're

14887
15:03:05,570 --> 15:03:08,180
going to grab the chain ID as
well as we're going to only

14888
15:03:08,180 --> 15:03:11,240
wants to deploy this on a
development chain. So we'll do

14889
15:03:11,240 --> 15:03:17,780
const chain ID equals network
dot config dot chain ID. Now

14890
15:03:17,810 --> 15:03:19,850
we're going to only want to
deploy mocks, if we're on a

14891
15:03:19,850 --> 15:03:22,370
development chain. So once
again, we're going to go to our

14892
15:03:22,370 --> 15:03:24,920
helper config, we're going to
add those development chains in

14893
15:03:24,920 --> 15:03:31,130
here. We'll say const,
development chains equals hard

14894
15:03:31,130 --> 15:03:35,360
hat, and localhost. And then
we're gonna want to export both

14895
15:03:35,360 --> 15:03:41,780
of these. So module, dot
exports, equals network config,

14896
15:03:42,470 --> 15:03:47,180
and development chance. Now in
our deploy mocks, we're gonna

14897
15:03:47,180 --> 15:03:54,590
want to grab those are saying
const development chains, equals

14898
15:03:55,190 --> 15:04:01,220
require dot dot slash helper
helper hardhat config. Now we

14899
15:04:01,220 --> 15:04:07,190
can check to see if development
chains dot includes the network

14900
15:04:07,220 --> 15:04:10,580
dot name that we're currently
on. If we're in a development

14901
15:04:10,580 --> 15:04:14,210
chain, we're gonna go ahead and
log local network, the

14902
15:04:14,330 --> 15:04:20,690
protected, deploying box. And
now we'll have to deploy a mock

14903
15:04:20,870 --> 15:04:25,340
VRF coordinator, where do we get
a mock VRF to coordinator Well,

14904
15:04:25,340 --> 15:04:26,870
let's go ahead and create one of
those.

14905
15:04:29,510 --> 15:04:33,560
We go to the chainlink. GitHub
again, we go to contracts. So C

14906
15:04:33,980 --> 15:04:39,470
0.8, actually have a mocks
folder with VF coordinator v2

14907
15:04:39,470 --> 15:04:42,680
Mach dot Sol, and we're just
going to use this as our mock.

14908
15:04:42,800 --> 15:04:45,800
So in our contracts folder,
we're gonna create a new file

14909
15:04:45,830 --> 15:04:53,270
called test new file called V RF
core, in a core, the two mock

14910
15:04:53,330 --> 15:04:56,960
dot Sol, and we're just going to
import this mock and have it be

14911
15:04:56,960 --> 15:05:03,710
our mock. So we'll do spdx.
We'll do pragma, solidity,

14912
15:05:04,130 --> 15:05:08,870
carrot zero, point 8.0, or seven
or whatever we want to do, we'll

14913
15:05:08,870 --> 15:05:14,990
do import at chainlink slash
contracts slash SRC slash v 0.8.

14914
15:05:15,410 --> 15:05:23,210
Slash, mocks, slash VRF. Pour
did a tour B to mock that soul.

14915
15:05:23,450 --> 15:05:25,460
And we'll just check to see if
it compiles with Hardhead

14916
15:05:25,460 --> 15:05:28,850
compile, and it looks like it's
compiling as well. Awesome. So

14917
15:05:28,850 --> 15:05:31,730
now that we have our mock
contract, we can actually go

14918
15:05:31,730 --> 15:05:38,450
ahead and deploy it. So we'll do
a weight loi, the RF core de ne

14919
15:05:38,450 --> 15:05:40,070
Tor V to Mach

14920
15:05:41,120 --> 15:05:44,420
comma, and then we'll give it
our parameters in here. We'll

14921
15:05:44,420 --> 15:05:49,880
say from Deployer. Log is going
to be true, and then we're going

14922
15:05:49,880 --> 15:05:53,570
to do our arguments. Now, what
are the arguments of this VRF

14923
15:05:53,690 --> 15:05:57,050
coordinator, v2 Mk. Well, if we
open the VRF coordinator v2

14924
15:05:57,050 --> 15:06:01,670
Mock, right in our VS code, or
on GitHub, we can actually see

14925
15:06:02,030 --> 15:06:05,060
We will roll over to the
constructor that it takes two

14926
15:06:05,060 --> 15:06:10,010
things. It takes a base fee and
a gas price link. What are these

14927
15:06:10,040 --> 15:06:14,390
first one? Well, the first one
is this const base fee. If we go

14928
15:06:14,390 --> 15:06:17,510
back to the documentation, we
can see that there's this

14929
15:06:17,510 --> 15:06:22,550
premium section of 0.25 Link
rink B, this means that for each

14930
15:06:22,550 --> 15:06:27,920
request, there's a base fee of
0.25 link for every request. So

14931
15:06:27,920 --> 15:06:30,980
anytime we want to request a
random number on Rinckey, it's

14932
15:06:30,980 --> 15:06:35,480
going to cost us 0.25. Link, or
you can think of it as 0.25

14933
15:06:35,510 --> 15:06:39,770
Oracle gas to make this request.
So back in our deploy mocks, we

14934
15:06:39,770 --> 15:06:44,300
can say base V equals, we could
resemble Rinckey here and do 25,

14935
15:06:44,300 --> 15:06:49,490
blah, blah, blah, or we could do
ethers dot utils dot parse eath,

14936
15:06:49,670 --> 15:06:55,730
of 0.25. And I'll even put a
little comment here, say 0.25 is

14937
15:06:55,730 --> 15:07:02,180
the premium, it costs 0.25 Link
per request. And remember, the

14938
15:07:02,180 --> 15:07:06,410
reason that this cost 0.25 Link
per request versus the price

14939
15:07:06,410 --> 15:07:09,320
feeds didn't cost anything is
because the price feeds. If we

14940
15:07:09,320 --> 15:07:13,610
look back at a chain that link,
each one of these price feeds is

14941
15:07:13,610 --> 15:07:17,810
being sponsored by a group of
protocols who are paying for all

14942
15:07:17,810 --> 15:07:20,630
these requests already, since
there isn't a sponsor for this,

14943
15:07:20,660 --> 15:07:24,110
we are the only ones requesting
the randomness, we get to be the

14944
15:07:24,110 --> 15:07:26,720
ones to actually sponsor getting
this random number, then the

14945
15:07:26,720 --> 15:07:30,230
second thing here is going to be
the gas price link. So let's

14946
15:07:30,230 --> 15:07:35,990
create another const here to
const. gas price link. But what

14947
15:07:35,990 --> 15:07:39,920
this is, is actually a
calculated value is a calculated

14948
15:07:39,920 --> 15:07:44,750
value based on the gas price of
the chain. Here's an example if

14949
15:07:44,750 --> 15:07:47,360
we were to request a random
number on Aetherium, and the

14950
15:07:47,360 --> 15:07:52,010
eath price skyrocketed up to
like to like a billion dollars,

14951
15:07:52,070 --> 15:07:55,370
gas would be incredibly,
incredibly expensive. Now when

14952
15:07:55,370 --> 15:07:59,780
chain link nodes respond chain
link nodes pay the gas fees, who

14953
15:07:59,990 --> 15:08:05,330
give us randomness, and do
external execution, the chain

14954
15:08:05,330 --> 15:08:07,730
link nodes are actually the ones
that pay the gas when returning

14955
15:08:07,730 --> 15:08:11,570
randomness or executing an
upkeep or etc. If we go to our

14956
15:08:11,570 --> 15:08:15,860
raffle dot soul, and scroll down
to perform upkeep, or fulfill

14957
15:08:15,860 --> 15:08:18,770
random words, it's actually the
chain link nodes that are

14958
15:08:18,770 --> 15:08:21,260
calling these two functions and
paying the gas for it, they get

14959
15:08:21,260 --> 15:08:24,920
paid in Oracle gas to offset
those costs. But if the price of

14960
15:08:24,950 --> 15:08:28,490
eath, or any native blockchain
skyrocketed the chain that nodes

14961
15:08:28,490 --> 15:08:31,610
itself to pay the gas fee. So
the chain link nodes have a

14962
15:08:31,610 --> 15:08:34,310
calculated price have a
calculated variable called the

14963
15:08:34,310 --> 15:08:37,880
gas price per link, which
fluctuates based off the price

14964
15:08:37,880 --> 15:08:40,790
of the actual chain, so that
they never go bankrupt.

14965
15:08:41,000 --> 15:08:43,610
Basically, the price of a
request changes based off the

14966
15:08:43,610 --> 15:08:45,830
price of gas for that
blockchain, you can kind of

14967
15:08:45,830 --> 15:08:49,700
think of this as the link per
gas, if you will, for now we can

14968
15:08:49,700 --> 15:08:52,340
kind of just set it to whatever
we want. And we'll just set it

14969
15:08:52,340 --> 15:08:58,250
to one e nine, which is going to
be equivalent to 1123456789. So

14970
15:08:58,250 --> 15:09:01,700
now that we have the base fee,
and the gas price link, we'll

14971
15:09:01,700 --> 15:09:05,420
grab this base fee, we'll have
these be the arguments for our

14972
15:09:05,450 --> 15:09:08,420
VR chord, enter V to mock, so
we'll say and actually we can

14973
15:09:08,420 --> 15:09:14,990
delete that will say const, args
equals base fee, and gas price

14974
15:09:15,290 --> 15:09:18,920
link, then we can take this args
variable and just plop it in

14975
15:09:18,920 --> 15:09:23,480
here. Now we can do log mocks
deployed, then we can do log

14976
15:09:23,570 --> 15:09:26,330
that a little line like this to
let people know that this deploy

14977
15:09:26,330 --> 15:09:29,720
script is done, then we'll just
do a module that exports dot

14978
15:09:29,720 --> 15:09:35,600
tags equals all and mocks. So
now that we have a view of

14979
15:09:35,600 --> 15:09:38,690
coordinator v2 Mock deployed,
we'll come back over to our

14980
15:09:38,690 --> 15:09:42,200
raffle and make some code around
it. Similar to what we just did

14981
15:09:42,230 --> 15:09:46,790
with our deploy mocks. We can
say if development chains that

14982
15:09:46,820 --> 15:09:51,440
includes network dot name, we'll
do some stuff. And we need to

14983
15:09:51,470 --> 15:09:54,650
import development chains from
our helper Hardhead config. And

14984
15:09:54,650 --> 15:09:57,290
we need to import network from
hard hat. My VS code

14985
15:09:57,290 --> 15:10:00,320
automatically added them Wow,
thanks VS code. Let's even just

14986
15:10:00,320 --> 15:10:03,890
do const args and make this
variable down here. Stick it in

14987
15:10:03,890 --> 15:10:07,610
args. Our first argument is
going to need to be this Vera fi

14988
15:10:07,610 --> 15:10:12,290
to coordinator so let's make a
variable we'll say let VRF core

14989
15:10:12,770 --> 15:10:17,270
need torby to address and if
we're on a development chain,

14990
15:10:17,300 --> 15:10:21,020
we're going to grab that mock
contract. So we'll say const

14991
15:10:21,050 --> 15:10:28,010
PRF, Cor de ATAR V to mock
equals await ethers dot get

14992
15:10:28,040 --> 15:10:35,990
contract, the RF cord the cord
to NATO Tor v two MK, and then

14993
15:10:35,990 --> 15:10:40,820
we can set the RF coordinator v
two address equals VRF core

14994
15:10:40,850 --> 15:10:43,490
denater V two mach dot

14995
15:10:43,520 --> 15:10:50,780
address. Cool. We have that
address here. Else if we're not

14996
15:10:50,780 --> 15:10:54,290
on a local network, the VRF v2
coordinator address is simply

14997
15:10:54,290 --> 15:10:58,010
going to be derived from our
network config. So let's import

14998
15:10:58,010 --> 15:11:01,640
the network config as well from
our helper Hardhead config and

14999
15:11:01,640 --> 15:11:06,530
we'll say else VRF coordinator
v2 address equals network config

15000
15:11:07,160 --> 15:11:11,390
of our chain ID. Let's which
actually sorry, we do need the

15001
15:11:11,390 --> 15:11:16,310
chain ID cons chain ID equals
network dot config dot chain ID,

15002
15:11:16,850 --> 15:11:23,390
chain ID of VR coordinator V to
chain ID. You're a coordinator

15003
15:11:23,420 --> 15:11:27,200
v2. Alright, perfect. We've got
the setup to work with our VRF

15004
15:11:27,200 --> 15:11:29,990
coordinator v2 address. What
else do we need from our raffle?

15005
15:11:30,110 --> 15:11:33,020
Well, we need an entrance fee,
we probably want to change the

15006
15:11:33,020 --> 15:11:35,690
entrance fee depending on what
chain we're on, we're on a more

15007
15:11:35,690 --> 15:11:38,270
expensive chain, we might want
to make this higher than others.

15008
15:11:38,540 --> 15:11:41,990
So let's go ahead back to our
helper Hardhead config and make

15009
15:11:42,020 --> 15:11:47,210
an entrance fee based off of the
blockchain, so for NP, maybe we

15010
15:11:47,210 --> 15:11:52,040
want to make it 0.01 eath. So we
could say ethers dot utils,

15011
15:11:52,400 --> 15:11:58,640
parse ether of 0.01. And once
again, thank you VS code for

15012
15:11:58,640 --> 15:12:01,070
automatically dropping that in
for me. And we're also going to

15013
15:12:01,070 --> 15:12:03,800
want an entrance fee for our
heart app, we can also set a

15014
15:12:03,800 --> 15:12:07,190
default in here, but let's just
be a little more explicit. So

15015
15:12:07,190 --> 15:12:12,350
we'll say 31337. The name of
this is Art app, we don't need

15016
15:12:12,350 --> 15:12:14,720
to give it a veneer of
coordinator v2 address because

15017
15:12:14,720 --> 15:12:17,540
we're going to deploy a mock.
But we do want an entrance fee.

15018
15:12:17,600 --> 15:12:20,360
And let's just give it the exact
same entrance fee here. So we'll

15019
15:12:20,360 --> 15:12:24,890
say ethers dot utils dot parse
ether 0.01 E. Alright, great. So

15020
15:12:24,890 --> 15:12:30,350
on our deploy here, we can just
say const entrance fee equals

15021
15:12:31,220 --> 15:12:39,140
network config. Chain ID of
entrance fee. Let's start

15022
15:12:39,140 --> 15:12:42,290
populating our arcs here. So the
first one is going to be your Fe

15023
15:12:42,290 --> 15:12:44,930
two coordinator address. Next
one is going to be our entrance

15024
15:12:44,930 --> 15:12:49,820
fee. Got it? Got it. Now we need
our gas lane. On Rigby and other

15025
15:12:49,820 --> 15:12:52,100
networks, there are different
gas lanes that we can choose

15026
15:12:52,100 --> 15:12:55,970
from, let's grab the only gas
Lane from Rinckey, the 30, gray

15027
15:12:56,060 --> 15:13:00,050
key hash, let's drop this, of
course into our network config

15028
15:13:00,110 --> 15:13:03,230
as gasoline, pop it in here,
we're hard hat, our mock

15029
15:13:03,230 --> 15:13:05,600
actually doesn't care what gas
line we're working on, because

15030
15:13:05,600 --> 15:13:07,850
we're going to be mocking the
gasoline anyways. So we can just

15031
15:13:07,850 --> 15:13:10,910
say gas lane, we can just go
ahead and use the same one or

15032
15:13:10,940 --> 15:13:13,610
really anything here, it doesn't
really matter. Now here we'll

15033
15:13:13,610 --> 15:13:16,880
say const, gasoline equals
network config.

15034
15:13:18,260 --> 15:13:23,810
Chain ID, gasoline, and we'll
grab the gas lane. And we'll

15035
15:13:23,810 --> 15:13:26,540
stick it into our argument
array, we've got this one, we've

15036
15:13:26,540 --> 15:13:28,970
got this one, we've got this
one. Now it's time for the

15037
15:13:28,970 --> 15:13:32,150
subscription ID. Now if you
haven't run through docstoc

15038
15:13:32,150 --> 15:13:35,510
chain link for the chain link
VRF, I highly recommend you do

15039
15:13:35,510 --> 15:13:38,630
so so that you can understand
what this subscription ID is we

15040
15:13:38,630 --> 15:13:41,570
know that we can actually make a
subscription ID using that front

15041
15:13:41,570 --> 15:13:45,440
end using that website VRF dot
chain dot link, which is great

15042
15:13:45,440 --> 15:13:48,800
and all but what if we're on all
local chains, we can get a

15043
15:13:48,800 --> 15:13:52,100
subscription ID no problem in
here. But it's a little bit

15044
15:13:52,100 --> 15:13:55,160
harder on a local network. Now
I'm actually going to teach you

15045
15:13:55,160 --> 15:13:57,770
how to create and fund
subscription it is completely

15046
15:13:57,770 --> 15:14:00,920
programmatically. So you don't
even need to use the UI if you

15047
15:14:00,920 --> 15:14:03,170
don't want to. However, for the
purpose of this course, we're

15048
15:14:03,170 --> 15:14:05,060
still going to use the user
interface, we're still going to

15049
15:14:05,060 --> 15:14:08,360
use that website for us to get
our own subscription IDs. But

15050
15:14:08,360 --> 15:14:11,780
you could 100% automate the
process of creating a

15051
15:14:11,780 --> 15:14:14,870
subscription ID and funding a
subscription ID. Because when

15052
15:14:14,870 --> 15:14:17,690
you create and fund subscription
IDs, you're just calling create

15053
15:14:17,690 --> 15:14:20,540
subscription and fund
subscription on that smart

15054
15:14:20,540 --> 15:14:23,690
contract. So on our development
chain, we have our V RF

15055
15:14:23,690 --> 15:14:26,450
coordinator v2 Mock, and what
we're going to do and on our

15056
15:14:26,450 --> 15:14:29,090
development chain, we're going
to create that subscription. So

15057
15:14:29,090 --> 15:14:33,650
we're gonna say const,
transaction, response equals

15058
15:14:33,680 --> 15:14:42,290
await VRF coordinator v2 Mock
dot create sub scription. And

15059
15:14:42,290 --> 15:14:48,560
then we'll run const transaction
receipt equals weight trends

15060
15:14:48,590 --> 15:14:54,080
action response, dot Wait, wait
one block confirmation. And

15061
15:14:54,110 --> 15:14:57,770
inside this transaction receipt,
there's actually an event that's

15062
15:14:57,770 --> 15:15:00,860
emitted with our subscription
that we can get this is another

15063
15:15:00,860 --> 15:15:04,670
place where emitting events is
incredibly helpful. So in fact,

15064
15:15:04,700 --> 15:15:08,270
if we open back up a Vera v2
coordinator mark, and we look

15065
15:15:08,270 --> 15:15:13,250
for create subscription, we see
we emit subscription created

15066
15:15:13,310 --> 15:15:17,060
with the subscription ID, we can
actually get this event emitted

15067
15:15:17,090 --> 15:15:20,510
from our transaction receipt.
Now to assign it, let's go ahead

15068
15:15:20,510 --> 15:15:24,530
and create a sub subscription ID
up here. And then we'll say

15069
15:15:24,560 --> 15:15:30,590
subscription ID equals
transaction receipt that events

15070
15:15:31,190 --> 15:15:37,040
of zero dot args dot sub ID. And
again, be sure to watch that

15071
15:15:37,040 --> 15:15:39,830
events video if you want to
learn more about how to work

15072
15:15:39,830 --> 15:15:42,500
with events in hardware. Now
that we have a subscription, we

15073
15:15:42,500 --> 15:15:45,800
need to fund the subscription on
a real network, you'd need the

15074
15:15:45,800 --> 15:15:48,590
link token to actually fund the
subscription. The current

15075
15:15:48,590 --> 15:15:51,350
iteration of the mock allows you
to fund a subscription without

15076
15:15:51,350 --> 15:15:54,890
the link token. So what we can
do is we can just run a wait

15077
15:15:54,920 --> 15:16:01,700
your F corps inator Mark, if
coordinator B to Mach dot fund

15078
15:16:02,120 --> 15:16:07,280
subscription, and we'll give it
the subscription ID and we'll

15079
15:16:07,280 --> 15:16:09,950
need to do some fundamental
this, we can just create some

15080
15:16:09,950 --> 15:16:15,680
variable, we'll say const VRF,
subscription fund amount equals

15081
15:16:15,710 --> 15:16:22,100
ethers dot utils, dot parse
ether, of, we'll say 30 VRF

15082
15:16:22,130 --> 15:16:26,480
subscription, fundament. We'll
just paste that down here. We

15083
15:16:26,480 --> 15:16:29,840
could do this as well for a real
test net or live networks. But

15084
15:16:29,840 --> 15:16:32,510
just so that we become familiar
with the user interface, we're

15085
15:16:32,510 --> 15:16:35,630
not going to do a test net
programmatically. And for a test

15086
15:16:35,630 --> 15:16:37,880
net, we're just going to use
exactly what we've been doing so

15087
15:16:37,880 --> 15:16:40,430
far. Or we can put a
subscription ID and our helper

15088
15:16:40,430 --> 15:16:44,870
config. So we'll say
subscription ID, we'll put

15089
15:16:44,870 --> 15:16:47,240
something in here right now,
we'll just leave it as zero. But

15090
15:16:47,240 --> 15:16:50,060
later on, when we actually
create a subscription, we'll

15091
15:16:50,060 --> 15:16:55,040
update our subscription ID. And
so we'll say subscription ID

15092
15:16:55,610 --> 15:17:04,670
equals network config. Change ID
of subscription ID. Perfect. Now

15093
15:17:04,670 --> 15:17:09,230
we can add this to our arguments
array. What else do we need

15094
15:17:09,230 --> 15:17:12,500
subscription ID, we need a
callback gas limit or callback,

15095
15:17:12,500 --> 15:17:15,380
gas limit is going to vary
network to network. So once

15096
15:17:15,380 --> 15:17:18,710
again, we're gonna go into our
helper configure callback gas

15097
15:17:18,740 --> 15:17:23,480
limit. And for us, we'll set a
pretty high limit of 500,000

15098
15:17:23,480 --> 15:17:29,450
gas. So we'll say call a gas
limit of 5.123 500,000. Gas. And

15099
15:17:29,450 --> 15:17:32,570
for hard hat, we'll do the same
thing. So we can say const,

15100
15:17:32,870 --> 15:17:38,480
callback, gas limit equals
network config, chain ID,

15101
15:17:39,860 --> 15:17:44,120
callback, gas limit, grab this,
put it into our argument array.

15102
15:17:44,510 --> 15:17:47,870
What else do we need? All we
need now is the interval. So we

15103
15:17:47,870 --> 15:17:51,500
can change this network to
network as well. Rigby will say,

15104
15:17:51,770 --> 15:17:56,060
interval will ever just be 30
seconds for both hard hat and

15105
15:17:56,060 --> 15:17:59,120
for Rigby. So we'll do the same
thing here. Say const.

15106
15:17:59,150 --> 15:18:07,910
Interval equals network config.
Chain ID, interval, and we'll

15107
15:18:07,910 --> 15:18:12,110
grab this, pop it in the end of
our array. All right, awesome.

15108
15:18:12,140 --> 15:18:15,230
Now we have an argument array
and drop it right in here and

15109
15:18:15,230 --> 15:18:18,200
perfect. Everything in our
constructor for our raffle

15110
15:18:18,200 --> 15:18:21,440
contract. Great. This is looking
fantastic. We've got wait

15111
15:18:21,440 --> 15:18:25,430
confirmations we got logging
arguments Deployer. Okay, well,

15112
15:18:25,460 --> 15:18:29,330
what next? Well, let's go ahead
and add that verification piece.

15113
15:18:29,630 --> 15:18:34,310
So once again, create a new
folder utils, new file

15114
15:18:34,790 --> 15:18:38,060
verify.js. We can either copy
paste this from our last

15115
15:18:38,060 --> 15:18:41,180
project, or we can grab this
from the GitHub repo associated

15116
15:18:41,180 --> 15:18:43,940
with this course, once we have
our verify script in here, we're

15117
15:18:43,940 --> 15:18:51,230
going to import it by saying
const. Verify equals require dot

15118
15:18:51,230 --> 15:18:57,140
dot slash helper Hardhead
config. And then we can add that

15119
15:18:57,140 --> 15:19:00,950
same bit of code down here to
verify our contract, we'll say

15120
15:19:00,980 --> 15:19:11,810
if we're not on a development
chain. And we have process

15121
15:19:11,810 --> 15:19:16,400
studying v dot ether scan API
key, then we're going to log

15122
15:19:16,430 --> 15:19:22,490
verifying dot dot and then await
verify raffle dot address and

15123
15:19:22,490 --> 15:19:26,090
the arcs. Now we'll just do a
log of a whole bunch of hyphens

15124
15:19:26,150 --> 15:19:31,070
say that this script is done
module dot exports dot tags

15125
15:19:31,100 --> 15:19:36,200
equals say this will be all and
raffle. All right, so let's test

15126
15:19:36,200 --> 15:19:41,450
this out. We'll do hardhat
deploy, or yarn, hard hat deploy

15127
15:19:41,690 --> 15:19:45,020
and see if this script works
correctly. Looks like we ran

15128
15:19:45,020 --> 15:19:49,250
into an error network config not
defined. So let's spell this

15129
15:19:49,250 --> 15:19:52,760
right. Network config. There we
go. And that looks much better.

15130
15:19:52,850 --> 15:19:55,700
Let's try this again. It looks
like our deploy scripts are

15131
15:19:55,700 --> 15:19:58,640
working well. local networks
protected, deploying mocks

15132
15:19:58,700 --> 15:20:02,300
deployed VRF coordinator v2 Mock
mocks deployed and then we went

15133
15:20:02,330 --> 15:20:08,750
ahead and deployed our raffle.
Awesome, this is massive. Now

15134
15:20:08,750 --> 15:20:11,030
we're not going to test the
deploying this to a test net

15135
15:20:11,030 --> 15:20:14,120
quite yet, because well, we
don't have any unit tests yet.

15136
15:20:14,180 --> 15:20:17,390
We need to write unit tests
before we want to ever test

15137
15:20:17,390 --> 15:20:20,240
running this on a test net. So
we have our deploy script, we

15138
15:20:20,240 --> 15:20:23,510
have our contracts, that means
it's time for us to write some

15139
15:20:23,510 --> 15:20:26,420
tests. We'll come over here
we'll create a new folder called

15140
15:20:26,420 --> 15:20:29,840
test. And for now, we'll just
make our unit tests. So unit

15141
15:20:29,930 --> 15:20:35,030
tests, and in here we create a
new file called raffle.test.js.

15142
15:20:35,090 --> 15:20:38,360
And let's write some unit tests.
Now for these unit tests, we are

15143
15:20:38,360 --> 15:20:40,640
going to be a little bit verbose
here, we're going to make our

15144
15:20:40,640 --> 15:20:43,370
coverage really, really good
here. It's not gonna be perfect,

15145
15:20:43,370 --> 15:20:46,370
but this is going to be pretty
verbose. So I'm gonna go pretty

15146
15:20:46,370 --> 15:20:49,340
quickly here. So you can feel
free to pause, slow me down,

15147
15:20:49,340 --> 15:20:53,600
speed me up whatever you need to
learn this section. It is really

15148
15:20:53,600 --> 15:20:56,060
good muscle memory to go through
writing these tests and

15149
15:20:56,060 --> 15:20:58,850
understand what you should be
thinking about when you're

15150
15:20:58,850 --> 15:21:01,940
writing these tests. So feel
free to speed up the parts You

15151
15:21:01,940 --> 15:21:04,520
already know and slow down the
new parts. Because we are going

15152
15:21:04,520 --> 15:21:08,300
to go over some new information
here. writing tests may seem

15153
15:21:08,300 --> 15:21:11,390
like a tedious process. But I
promise as you get better at

15154
15:21:11,390 --> 15:21:13,940
writing these tests, you'll
realize that these are the

15155
15:21:13,940 --> 15:21:17,300
things that you can rely on when
stuff doesn't work. And when

15156
15:21:17,300 --> 15:21:19,520
you're not sure how to code,
something, getting this muscle

15157
15:21:19,520 --> 15:21:23,000
memory down, writing these tests
is going to make you a fantastic

15158
15:21:23,000 --> 15:21:25,310
engineer. So let's go through
and we'll write some of these

15159
15:21:25,340 --> 15:21:28,520
verbose tests here to try to
make this really good and have

15160
15:21:28,520 --> 15:21:30,920
this have really good coverage.
And if you want to go back later

15161
15:21:30,920 --> 15:21:33,320
on, and see if you can give it
even more coverage, and even

15162
15:21:33,320 --> 15:21:36,560
better tests, please feel free
to do so. But let's get started.

15163
15:21:36,590 --> 15:21:39,350
Let's write some tests. So we're
going to start out pretty much

15164
15:21:39,350 --> 15:21:41,390
the same way we've been starting
everything out, we're going to

15165
15:21:41,390 --> 15:21:44,660
grab our development chains, so
that we only run our unit tests

15166
15:21:44,690 --> 15:21:48,680
on a development chain. So we'll
do const development chains,

15167
15:21:49,070 --> 15:21:55,610
equals require dot dot slash dot
dot slash helper, RD, hard hat

15168
15:21:55,640 --> 15:22:00,230
config, and then we'll say not
development chains, that

15169
15:22:00,230 --> 15:22:07,490
includes network dot name, and
describe that skip. Otherwise,

15170
15:22:07,520 --> 15:22:10,460
we'll do describe, so this first
describe is going to be our

15171
15:22:10,490 --> 15:22:16,130
raffle unit tests. And this is
going to be an async. function.

15172
15:22:16,280 --> 15:22:19,160
So raffle unit tests so that it
comes on the next line, it looks

15173
15:22:19,160 --> 15:22:21,050
a little bit better. Alright,
great. Now, what are some of the

15174
15:22:21,050 --> 15:22:23,420
main things that we're going to
need to deploy? Well, we're

15175
15:22:23,420 --> 15:22:26,000
gonna need to deploy a raffle,
we're probably going to want a

15176
15:22:26,000 --> 15:22:31,370
VRF core to a tour be to mock
graded before each, that's going

15177
15:22:31,370 --> 15:22:35,420
to be an async function, where
we go ahead and we get these

15178
15:22:35,570 --> 15:22:40,760
will say const. Employer equals
await, get named accounts.

15179
15:22:41,540 --> 15:22:44,540
So we're gonna need to import
get named accounts or require

15180
15:22:44,540 --> 15:22:47,000
get name accounts from hard hat,
then we're going to want to

15181
15:22:47,000 --> 15:22:51,770
deploy these using our fixtures.
So we can say await deployments.

15182
15:22:51,890 --> 15:22:55,250
And then we're going to import
deployments as well from hardhat

15183
15:22:55,280 --> 15:23:00,230
dot fixture, and we're going to
call all, we're going to deploy

15184
15:23:00,290 --> 15:23:03,800
everything. And again, if we
look at our one, our raffle has

15185
15:23:03,800 --> 15:23:07,910
the alt tag, and our Oh, our
mocks also have the alt tag,

15186
15:23:07,940 --> 15:23:12,080
okay, perfect. Once we deploy
everything, we can say raffle

15187
15:23:12,290 --> 15:23:17,270
equals await ethers dot get to
contract. And we got to import

15188
15:23:17,300 --> 15:23:21,200
ethers from hard hat, like so.
And we'll say it will get the

15189
15:23:21,200 --> 15:23:27,380
raffle contract and we'll
connect it to our Deployer. And

15190
15:23:27,380 --> 15:23:30,050
then we're going to do the same
thing with VRF coordinator v2

15191
15:23:30,050 --> 15:23:37,550
Mock equals await ethers dot get
contract, the RF coordinator, B

15192
15:23:37,550 --> 15:23:41,150
to MK connect this to deployer
as well. Alright, great, our

15193
15:23:41,150 --> 15:23:44,270
first set of tests describe,
they're going to be the

15194
15:23:44,270 --> 15:23:50,330
constructor. And this is going
to be an async function. And

15195
15:23:50,330 --> 15:23:55,340
let's do this. Let's create an
IT initial initializes the

15196
15:23:55,340 --> 15:24:02,270
raffle correctly, this is going
to be an async function. Now I

15197
15:24:02,270 --> 15:24:06,440
just want to make a note,
because ideally, we make our

15198
15:24:06,440 --> 15:24:12,200
tests have just one assert, or
it just keep that in mind is

15199
15:24:12,200 --> 15:24:14,450
that ideally, we want to have
just one assert for it. But

15200
15:24:14,450 --> 15:24:17,060
we're going to have a bunch
because like I said, we're being

15201
15:24:17,060 --> 15:24:19,520
a little bit loose here. So we
want to just make sure that our

15202
15:24:19,520 --> 15:24:24,860
raffle is initialized correctly.
So we'll say const raffle state,

15203
15:24:24,980 --> 15:24:27,860
and we'll get that raffle state
because we want to make sure

15204
15:24:28,010 --> 15:24:31,430
that we start in an open raffle
state. So we'll say const,

15205
15:24:31,430 --> 15:24:39,470
raffle state equals await raffle
dot get raffle state. And then

15206
15:24:39,470 --> 15:24:43,460
we want to say assert dot equal
ope and then we need to import

15207
15:24:43,520 --> 15:24:47,960
assert from Chai. So assert
equals require Chai assert dot

15208
15:24:47,960 --> 15:24:53,630
equal raffle state.to string
because again, raffle state is

15209
15:24:53,630 --> 15:24:57,860
going to be a big number. And
even though a raffle state is of

15210
15:24:57,860 --> 15:25:01,820
type raffle state, it'll return
a zero if it's open and a one if

15211
15:25:01,820 --> 15:25:06,410
it's calculating. So this gets
transformed just into a un 256.

15212
15:25:06,440 --> 15:25:09,710
When we call it like this, a
raffle state variable here will

15213
15:25:09,710 --> 15:25:13,280
be a big number. So we want to
just to string a file. So assert

15214
15:25:13,280 --> 15:25:16,880
dot equal raffle state DOT two
string zero. We'll also make

15215
15:25:16,880 --> 15:25:20,060
sure our interval gets set
correctly. So we'll do const

15216
15:25:20,240 --> 15:25:28,580
interval equals await raffle dot
get interval. And I don't know

15217
15:25:28,580 --> 15:25:32,840
if we have one of those it's
actually C inter ball see if we

15218
15:25:32,840 --> 15:25:35,990
have one of those. We don't have
a good interval let's go ahead

15219
15:25:35,990 --> 15:25:39,680
and add again interval function
so we'll do function get in

15220
15:25:40,850 --> 15:25:48,500
trouble. We have public view
returns you went to six return I

15221
15:25:48,500 --> 15:25:53,780
underscore interval will have
good interval will say raffle

15222
15:25:53,780 --> 15:25:58,910
dot get interval and will also
say assert dot equal interval.to

15223
15:25:58,910 --> 15:26:04,010
string. It should equal one Ever
is in our helper config, right?

15224
15:26:04,040 --> 15:26:06,860
Because we're using the interval
and helper config. So we say

15225
15:26:06,860 --> 15:26:11,120
interval.to string should equal.
So we'll import that as well.

15226
15:26:11,690 --> 15:26:15,770
Network config. And we'll say
the interval should equal

15227
15:26:16,010 --> 15:26:22,550
network config. Of let's also
make, get our chain ID up here,

15228
15:26:22,610 --> 15:26:29,510
chain ID, say const. Chain ID
equals network dot config, a

15229
15:26:29,510 --> 15:26:35,780
chain ID, network config of the
chain ID of interval. Alright,

15230
15:26:35,780 --> 15:26:40,130
cool. So let's test this so far,
HH test or yarn, hard hat test.

15231
15:26:41,390 --> 15:26:44,210
And cool looks like it passed.
And we have our little gas

15232
15:26:44,210 --> 15:26:47,600
output here. Awesome. Let's go
to our Hardhead config, just so

15233
15:26:47,600 --> 15:26:50,600
that it doesn't always print out
at gas, but there for now. So

15234
15:26:50,600 --> 15:26:54,020
I'm going to copy paste the gas
reporter section from our last

15235
15:26:54,020 --> 15:26:57,140
project, like so. And we're
going to have enabled gas be

15236
15:26:57,200 --> 15:27:00,080
false for now. So now if we run
a Hardhead test, again, we

15237
15:27:00,080 --> 15:27:02,480
shouldn't have that gas bid
printed out, we should just see

15238
15:27:02,480 --> 15:27:05,390
the tests and perfect, that's
what we see. And our constructor

15239
15:27:05,390 --> 15:27:09,470
test passes. Yay, what's next,
got our constructor. And we

15240
15:27:09,470 --> 15:27:11,690
probably could have written more
tests for the rest of these. But

15241
15:27:11,720 --> 15:27:14,090
let's just move on. Alright,
enter raffle, that's going to be

15242
15:27:14,090 --> 15:27:17,240
our next describe block. So it
will do describe,

15243
15:27:19,850 --> 15:27:24,980
enter, raffle. And this is going
to be an async function. And

15244
15:27:24,980 --> 15:27:30,200
we'll say it reverts when you
don't pay enough, right, because

15245
15:27:30,200 --> 15:27:32,780
one of the first things that we
check is that they're paying

15246
15:27:32,780 --> 15:27:36,020
enough. So we want to make sure
that this actually reverts if

15247
15:27:36,020 --> 15:27:40,910
they don't pay enough. So this
will be an async function. Where

15248
15:27:40,940 --> 15:27:44,750
we're going to do that same
expect await thing. So we're

15249
15:27:44,750 --> 15:27:48,590
going to import expect from
Chai, which comes from those

15250
15:27:48,620 --> 15:27:55,100
waffle matchers. And we're gonna
say await, expect raffle dot

15251
15:27:55,190 --> 15:27:59,870
enter a raffle. And we're not
going to pass any value here,

15252
15:27:59,930 --> 15:28:06,320
we're going to expect it to dot
b dot reverted with. And if we

15253
15:28:06,320 --> 15:28:09,980
look here, we want it to be
reverted with this raffle not

15254
15:28:09,980 --> 15:28:13,970
enough eath entered. So we can
put that in quotes raffle not

15255
15:28:14,000 --> 15:28:17,810
enough eath entered. Now we can
try this out. Make sure that it

15256
15:28:17,810 --> 15:28:22,670
actually works. Ah ah test dash
dash grep. Put this in quotes

15257
15:28:22,670 --> 15:28:26,420
that you don't pay enough. And
awesome. We're passing there.

15258
15:28:26,450 --> 15:28:29,060
What else do we want to test?
Well, we want to test that if

15259
15:28:29,060 --> 15:28:31,940
the raffle isn't open, we also
revert but we'll test that in a

15260
15:28:31,940 --> 15:28:34,730
little bit. As we kind of test
the rest of the functionality.

15261
15:28:34,760 --> 15:28:40,280
We want to see that it records
players when they enter. So this

15262
15:28:40,280 --> 15:28:44,450
will be an async function. And
now we'll enter the raffle.

15263
15:28:44,480 --> 15:28:47,060
First we're going to need that
raffle entrance fee. Let's go

15264
15:28:47,060 --> 15:28:50,720
ahead and save that at the top.
So we'll say let raffle VRF

15265
15:28:50,720 --> 15:28:54,440
coordinator be to mock raffle
entrance fee and then our before

15266
15:28:54,440 --> 15:28:59,210
each will say raffle entrance
fee equals a weight ethers dot

15267
15:28:59,480 --> 15:29:05,300
get entrance fee. This should be
raffle dot get entrance fee. So

15268
15:29:05,330 --> 15:29:08,450
now we have this raffle entrance
fee, you can use it to enter the

15269
15:29:08,450 --> 15:29:15,380
raffle we'll say a weight raffle
dot enter raffle with a value of

15270
15:29:15,860 --> 15:29:20,180
raffle entrance fee. And we can
make sure that our Deployer here

15271
15:29:20,180 --> 15:29:23,270
has been correctly recorded. So
since right now we're connected

15272
15:29:23,270 --> 15:29:26,690
to the Deployer. We'll just make
sure that that deployer actually

15273
15:29:26,720 --> 15:29:31,910
is in our contract. So we'll say
const player from contract

15274
15:29:32,030 --> 15:29:38,720
equals await raffle dot get
player of zero, because we

15275
15:29:38,720 --> 15:29:42,500
record them in our players array
and we have our get players

15276
15:29:42,500 --> 15:29:46,160
function which pulls them out.
And then we'll say assert dot

15277
15:29:46,160 --> 15:29:51,050
equal player, player from
contract should be the Deployer.

15278
15:29:51,770 --> 15:29:54,650
So now we can grep for this in
our hard head test. Make sure

15279
15:29:54,650 --> 15:30:00,350
this works. HH test dash dash
grep. Deployer is not defined.

15280
15:30:00,410 --> 15:30:02,600
We've got it up here. But we
actually didn't save it

15281
15:30:02,600 --> 15:30:07,520
globally. So we got to do let
common Deployer. And we'll say

15282
15:30:07,880 --> 15:30:11,720
deployer equals await get named
accounts. And we'll wrap it like

15283
15:30:11,720 --> 15:30:15,740
this to get the deployer
Awesome. Let's try this again.

15284
15:30:16,280 --> 15:30:21,980
And awesome. What else should
this do? Well, it's also

15285
15:30:22,010 --> 15:30:25,430
emitting an event. So let's make
sure it emits an event. So we'll

15286
15:30:25,430 --> 15:30:31,070
say it emits event on enter.
This will be an async function

15287
15:30:31,370 --> 15:30:34,700
as well. And this will be the
first time that we're testing to

15288
15:30:34,700 --> 15:30:38,270
make sure a function emits an
event and the syntax is going to

15289
15:30:38,270 --> 15:30:41,870
look really similar to what we
test for when we check to see if

15290
15:30:41,870 --> 15:30:47,450
an error is fired. So we're
gonna say await expect raffle

15291
15:30:47,450 --> 15:30:57,560
dot enter raffle with value of
raffle entrance fee dot two dot

15292
15:30:57,590 --> 15:31:03,380
omit and this.to dot emit we get
from During woful, these chime

15293
15:31:03,380 --> 15:31:07,100
matches for emitting events we
can do a wait expect to emit,

15294
15:31:07,160 --> 15:31:09,830
and then the event that we're
expecting to emit. So we're

15295
15:31:09,830 --> 15:31:15,590
saying to omit the raffle
contract to emit a raffle enter

15296
15:31:15,620 --> 15:31:19,850
event. We can copy this, try to
test this in our terminal. So

15297
15:31:19,850 --> 15:31:24,470
we'll say hard hat. Test dash
dash grep. Just put this in

15298
15:31:24,470 --> 15:31:32,060
quotes. And that passes as well.
Great. Let's now go ahead and

15299
15:31:32,060 --> 15:31:35,300
test to make sure that we can't
enter the raffle whenever this

15300
15:31:35,300 --> 15:31:39,200
raffle is not open or it's
calculating. So we'll say it

15301
15:31:39,560 --> 15:31:46,580
doesn't allow entrance, when
raffle is Cal cumulating. And

15302
15:31:46,580 --> 15:31:51,890
this will be an async function.
And first we'll enter will say

15303
15:31:51,890 --> 15:31:55,040
await raffle dot enter raffle

15304
15:31:56,600 --> 15:32:03,140
value is raffle entrance fee.
Now what we want to do we want

15305
15:32:03,140 --> 15:32:07,370
to get this raffle into a closed
state. So we want to get it out

15306
15:32:07,370 --> 15:32:10,730
of its open state. Well, how do
we move this raffle from raffle

15307
15:32:10,730 --> 15:32:14,540
dot open to raffle dot closed in
perform upkeep, remove the

15308
15:32:14,540 --> 15:32:18,350
raffle from raffle that open to
raffle dot calculating but

15309
15:32:18,380 --> 15:32:22,430
perform upkeep can only be
called if check upkeep returns

15310
15:32:22,430 --> 15:32:26,150
true. Otherwise, it'll revert
with raffle upkeep not needed.

15311
15:32:26,300 --> 15:32:29,660
So what we need to do is we need
to make check upkeep return

15312
15:32:29,660 --> 15:32:33,590
true. And we will pretend to be
the channeling keeper network to

15313
15:32:33,590 --> 15:32:36,080
keep calling checkup keep
waiting for it to be true. And

15314
15:32:36,080 --> 15:32:38,480
once we make it true, then we'll
pretend to be the channeling

15315
15:32:38,480 --> 15:32:42,140
keepers and call perform upkeep
to put this contract in a state

15316
15:32:42,170 --> 15:32:48,350
of calculating. Now how do we
actually do that? Well, in order

15317
15:32:48,350 --> 15:32:51,350
for checkup keep to be true, we
first need to see that we are

15318
15:32:51,350 --> 15:32:54,590
indeed open, which we are. The
next thing that we need to do

15319
15:32:54,590 --> 15:32:57,890
though, is we need to do this
time passed bit. We need to

15320
15:32:57,890 --> 15:33:02,540
actually wait that 30 seconds
for time to pass. Now, that kind

15321
15:33:02,540 --> 15:33:05,840
of sounds awful. Do we have to
wait 30 seconds for all of our

15322
15:33:05,840 --> 15:33:09,860
tests? What if our interval was
10 days when we have to wait 10

15323
15:33:09,860 --> 15:33:13,820
days to run our tests? It sounds
ridiculous. Well, hard hat

15324
15:33:13,820 --> 15:33:17,390
actually comes built in with a
ton of functions for us to

15325
15:33:17,390 --> 15:33:20,810
manipulate our blockchain to do
literally whatever we want it to

15326
15:33:20,810 --> 15:33:23,390
do. In the hard hat
documentation. There's a section

15327
15:33:23,390 --> 15:33:26,210
called Hard Hat Network
reference inside the Hard Hat

15328
15:33:26,240 --> 15:33:29,570
Network section. And in here,
there's a ton of information

15329
15:33:29,630 --> 15:33:32,030
about how the hard hat network
actually works and different

15330
15:33:32,030 --> 15:33:35,210
configs that we can do with it.
If we scroll down low enough, we

15331
15:33:35,210 --> 15:33:38,780
can see the JSON RPC methods
that we can use on this

15332
15:33:38,780 --> 15:33:41,240
blockchain, we can do eath
accounts block number call

15333
15:33:41,240 --> 15:33:44,090
chinetti. We can do all these
RPC methods that a normal

15334
15:33:44,090 --> 15:33:47,870
blockchain has. Additionally, we
can do even more than that, we

15335
15:33:47,870 --> 15:33:51,350
can use these things called Hard
Hat Network methods. Since this

15336
15:33:51,350 --> 15:33:53,600
is our local Hard Hat Network.
And we're using this for

15337
15:33:53,600 --> 15:33:57,230
testing, we want to be able to
test any scenario. And it's

15338
15:33:57,230 --> 15:34:00,530
these methods that give us the
ability to do that, you can go

15339
15:34:00,530 --> 15:34:02,990
through this and play around and
see all the different things you

15340
15:34:02,990 --> 15:34:05,300
can do. One of them in
particular is going to be set

15341
15:34:05,300 --> 15:34:07,910
storage set where you can set
storage at any place, which is

15342
15:34:07,940 --> 15:34:10,490
really fun. But some of the
special testing debugging

15343
15:34:10,490 --> 15:34:14,780
methods are going to be EVM
increase time, and EVM. Mine

15344
15:34:14,810 --> 15:34:17,990
increased time allows us to
automatically increase the time

15345
15:34:18,020 --> 15:34:22,820
of our blockchain and EVM. Mine
allows us to mine or create new

15346
15:34:22,820 --> 15:34:26,030
blocks, because if we increase
the time, it doesn't do anything

15347
15:34:26,060 --> 15:34:29,810
unless there's a new block
mined. So what we can do is we

15348
15:34:29,810 --> 15:34:34,550
can run a wait network, and
we'll import network from Hard

15349
15:34:34,550 --> 15:34:45,110
Hat Network await network dot
provider that send EVM in crease

15350
15:34:46,130 --> 15:34:49,370
time, comma, we can send a list
of parameters to send with it,

15351
15:34:49,370 --> 15:34:54,770
which for us are just going to
be our interval.to number. And

15352
15:34:54,770 --> 15:34:57,350
then we'll do plus one. Now
right now, our interval isn't

15353
15:34:57,350 --> 15:34:59,510
stored globally, so we're
probably going to want to do

15354
15:34:59,510 --> 15:35:03,560
that. So let's go ahead and do
interval. And then in our before

15355
15:35:03,560 --> 15:35:09,110
each, we'll do interval equals
await, raffle dot raffle dot get

15356
15:35:09,110 --> 15:35:11,840
interval, I'm just going to copy
this and we're going to delete

15357
15:35:11,840 --> 15:35:15,740
this whole line. Wait raffle dot
get interval. Since now we're

15358
15:35:15,740 --> 15:35:18,350
just going to call it interval
at a global level, since we're

15359
15:35:18,350 --> 15:35:20,780
going to use it a lot. Now we're
gonna say interval that to

15360
15:35:20,780 --> 15:35:24,470
number plus one. So we want to
increase the time by whatever

15361
15:35:24,470 --> 15:35:27,800
our interval is to make sure
that we can actually get that

15362
15:35:27,800 --> 15:35:30,410
checkup keep to return true. So
additionally, we're going to

15363
15:35:30,410 --> 15:35:39,320
want to do a weight network dot
provider. Dot send EVM mine with

15364
15:35:39,470 --> 15:35:42,410
an empty array just because we
just want to mine it one extra

15365
15:35:42,410 --> 15:35:46,730
block. You can also do network
dot provider that request with

15366
15:35:46,730 --> 15:35:49,400
an await here, these two would
be basically the same, but this

15367
15:35:49,400 --> 15:35:51,710
one's a little quicker, right?
So we've increased the time of

15368
15:35:51,710 --> 15:35:55,070
our blockchain. We've mined a
block to move forward. It should

15369
15:35:55,070 --> 15:35:58,760
be open time has passed. Do we
have a player? We do indeed,

15370
15:35:58,760 --> 15:36:01,070
because we've entered the
raffle. We should have a balance

15371
15:36:01,070 --> 15:36:03,710
because we've entered the right
Apple, check upkeep should now

15372
15:36:03,710 --> 15:36:07,010
return true. So we should be
able to call perform upkeep and

15373
15:36:07,010 --> 15:36:09,020
pretend to be a chain lock
keeper. So we're going to

15374
15:36:09,020 --> 15:36:13,040
pretend to be a chain the keeper
and call await raffle dot

15375
15:36:13,040 --> 15:36:18,230
perform upkeep. And we're going
to pass this some empty call

15376
15:36:18,230 --> 15:36:22,460
data just by passing a blank
array like that. And now this

15377
15:36:22,460 --> 15:36:26,120
should be in a calculating
state. So now that it's in a

15378
15:36:26,120 --> 15:36:30,230
calculating state, we can say
our enter raffle reverts

15379
15:36:30,230 --> 15:36:34,280
correctly if the raffle isn't
open. So now we'll say await,

15380
15:36:34,610 --> 15:36:41,540
expect raffle dot enter, raffle.
And we'll send it value of

15381
15:36:41,930 --> 15:36:47,330
raffle entrance fee. We're
expecting this.to dot b dot

15382
15:36:47,330 --> 15:36:55,700
reverted with that raffle
underscore underscore not open

15383
15:36:55,850 --> 15:37:02,270
error. Okay, let's try just this
in our tests now. So we'll run

15384
15:37:02,270 --> 15:37:07,400
Hardhead test dash dash grep.
Put this in quotes. And perfect

15385
15:37:07,430 --> 15:37:08,660
that passes as well.

15386
15:37:11,210 --> 15:37:13,880
Now if we run Hardhead test,
let's just test everything

15387
15:37:13,880 --> 15:37:17,510
together right now. And
everything is passing. Oh, this

15388
15:37:17,510 --> 15:37:20,690
is wonderful. Awesome. Let's
keep it going. And if we run

15389
15:37:20,690 --> 15:37:24,380
Hardhead coverage, we'll see our
coverage is bumping up, we are

15390
15:37:24,410 --> 15:37:27,740
already drastically better than
where we were before. Let's keep

15391
15:37:27,740 --> 15:37:31,130
going well, let's go ahead and
test our check upkeep now. So

15392
15:37:31,130 --> 15:37:34,970
we'll do describe, check upkeep.
And this will be an async

15393
15:37:34,970 --> 15:37:35,570
function,

15394
15:37:36,230 --> 15:37:44,990
where we'll say it returns
false. If people have been sent

15395
15:37:45,560 --> 15:37:49,790
an E, E, it's been a sync
function.

15396
15:37:49,970 --> 15:37:53,630
So we'll have everything in here
be true except for the fact that

15397
15:37:53,630 --> 15:37:57,920
nobody's entered yet. So we'll
do a weight network dot provider

15398
15:37:57,950 --> 15:38:09,620
dot send EVM increase time,
comma interval.to number plus

15399
15:38:09,620 --> 15:38:10,070
one

15400
15:38:11,630 --> 15:38:20,360
will do a weight network dot
provider. That send UVM mine. No

15401
15:38:20,360 --> 15:38:27,950
parameters. Now we're going to
call check upkeep. Now here's

15402
15:38:27,950 --> 15:38:31,100
the thing, check. upkeep is a
public function.

15403
15:38:31,490 --> 15:38:36,380
So if we just run await, raffle
dot check upkeep, and we pass

15404
15:38:36,380 --> 15:38:40,370
nothing in this is going to kick
off a transaction, because hard

15405
15:38:40,370 --> 15:38:43,160
had knows Oh, okay, it's a
public function, they're clearly

15406
15:38:43,160 --> 15:38:46,850
trying to send a transaction
here. If this was a public view

15407
15:38:46,880 --> 15:38:49,760
function, it wouldn't, it would
return that view. But the thing

15408
15:38:49,760 --> 15:38:52,520
is, I don't really want to send
a transaction. But I want to

15409
15:38:52,520 --> 15:38:56,120
simulate sending this
transaction and seeing what this

15410
15:38:56,150 --> 15:38:59,690
upkeep needed would return.
Well, I can actually get that by

15411
15:38:59,690 --> 15:39:03,290
using something called call
static, I can simulate calling

15412
15:39:03,290 --> 15:39:06,710
this transaction and seeing what
it will respond. So instead of

15413
15:39:06,740 --> 15:39:11,780
raffle dot, check upkeep, I can
do raffle dot cost static, that

15414
15:39:11,780 --> 15:39:16,250
check upkeep. And this will give
me the return of upkeep needed

15415
15:39:16,490 --> 15:39:19,880
and the bytes perform data, I
can extrapolate just the upkeep

15416
15:39:19,880 --> 15:39:25,760
needed out of this return or
writing const upkeep needed

15417
15:39:26,840 --> 15:39:33,950
equals this, and then I can do
assert not upkeep needed,

15418
15:39:34,280 --> 15:39:38,480
because right now upkeep needed
to return false. So we'll say

15419
15:39:38,510 --> 15:39:42,740
assert, not false, which is
true. If upkeep needed was true,

15420
15:39:42,740 --> 15:39:44,840
then this would be false. And
this would break. So that's what

15421
15:39:44,840 --> 15:39:48,200
we want to do. So let's go
ahead, we'll run this, see if it

15422
15:39:48,200 --> 15:39:54,590
worked. Our hat test, dash dash
grep. And we're in passing, we

15423
15:39:54,590 --> 15:40:00,620
are in business. Awesome. So
this is working perfectly. Well,

15424
15:40:00,620 --> 15:40:06,860
and let's also test that it
returns false. If raffle isn't

15425
15:40:07,100 --> 15:40:12,230
open. This will be an async
function. And we'll do

15426
15:40:12,230 --> 15:40:15,680
everything except and we'll do
everything in here. But we'll

15427
15:40:15,680 --> 15:40:19,520
make the raffle in the
calculating state. So do a

15428
15:40:19,520 --> 15:40:28,250
weight, raffle dot enter, raffle
value, raffle entrance fee await

15429
15:40:29,090 --> 15:40:33,650
network dot provider that send
and I'm just going to copy these

15430
15:40:33,650 --> 15:40:36,710
two lines here. Because we're
going to go ahead and do those.

15431
15:40:36,770 --> 15:40:42,230
We're also going to do a weight,
raffle dot perform upkeep. And

15432
15:40:42,230 --> 15:40:45,650
another way to send a blank
bytes object is to do a string

15433
15:40:45,650 --> 15:40:49,700
like 0x hardhat is smart enough
to know that this should be

15434
15:40:49,730 --> 15:40:53,360
transformed into just kind of a
blank bytes object. So either

15435
15:40:53,360 --> 15:40:56,750
one of these should work. Now
we're do const, raffle state

15436
15:40:56,780 --> 15:41:01,940
equals await, raffle dot get
raffle state and we'll Get

15437
15:41:01,940 --> 15:41:05,180
upkeep needed. So we'll say
const. upkeep needed, we'll do

15438
15:41:05,180 --> 15:41:11,060
exactly what we did above raffle
dot call static dot check

15439
15:41:11,090 --> 15:41:16,640
upkeep. Let's say excuse me a
weight, raffle dot call static.

15440
15:41:16,910 --> 15:41:22,250
Now we can do assert dot equal,
say raffle state is going to be,

15441
15:41:22,520 --> 15:41:25,850
or excuse me raffle state.to
string, it's going to be

15442
15:41:25,850 --> 15:41:30,320
calculating, and I started dot
equal upkeep needed, it's going

15443
15:41:30,320 --> 15:41:38,900
to be false. Let's run a GREP on
that. And perfect. That's also

15444
15:41:38,900 --> 15:41:41,900
working correctly. Great. Now
I'm going to skip over these

15445
15:41:41,900 --> 15:41:44,660
next two tests, because we
haven't really learned anything

15446
15:41:44,660 --> 15:41:47,570
from them. So I'm just going to
copy paste them from the GitHub,

15447
15:41:47,600 --> 15:41:50,870
we're going to return false if
enough time hasn't passed. And

15448
15:41:50,870 --> 15:41:54,020
we're going to return true. If
enough time has passed, we have

15449
15:41:54,020 --> 15:41:58,430
players Eve and is open. So
we're just asserting true down

15450
15:41:58,430 --> 15:42:00,980
here. And we're starting not
true up here, you want to pause

15451
15:42:00,980 --> 15:42:03,590
the video and copy paste these
and write these out, you

15452
15:42:03,590 --> 15:42:05,930
absolutely can copy paste them
from the GitHub repo, you

15453
15:42:05,930 --> 15:42:09,170
absolutely can't like I said,
going through this and making

15454
15:42:09,170 --> 15:42:11,870
yourself write these and making
yourself understand these tests

15455
15:42:11,870 --> 15:42:14,660
is going to make you a
substantially better coder. And

15456
15:42:14,660 --> 15:42:18,920
let's just test that it all
looks good with hh test. Now, as

15457
15:42:18,920 --> 15:42:21,560
I was recording this, I just
realized that for all of our

15458
15:42:21,560 --> 15:42:24,620
describe blocks, I've been
making them async functions

15459
15:42:24,650 --> 15:42:28,820
describe blocks actually don't
realize and can't recognize and

15460
15:42:28,820 --> 15:42:31,880
can't work with promises. So
having the be async actually

15461
15:42:31,880 --> 15:42:34,700
doesn't do anything. So in your
describe block, we want to get

15462
15:42:34,700 --> 15:42:37,910
rid of the async word because
it's actually not helping us at

15463
15:42:37,910 --> 15:42:40,610
all. In fact, it's just an extra
word, and it looks kind of

15464
15:42:40,610 --> 15:42:43,190
gross. So now all of our
describe blocks, we're gonna get

15465
15:42:43,190 --> 15:42:46,910
rid of that async keyword, and
just have them be functions. Of

15466
15:42:46,910 --> 15:42:49,460
course, all of our it's, though,
are going to be using

15467
15:42:49,490 --> 15:42:52,250
asynchronous functions, which is
what we want. So we've written

15468
15:42:52,250 --> 15:42:56,060
some tests for a checkup keep.
Now let's go ahead to perform

15469
15:42:56,060 --> 15:42:56,510
upkeep.

15470
15:42:56,630 --> 15:43:01,250
Let's create a new describe,
block, ascribe or perform

15471
15:43:01,340 --> 15:43:05,720
upkeep. This is going to be a
regular function. And in here,

15472
15:43:05,720 --> 15:43:10,940
we're going to start and say it
can only run if check upkeep is

15473
15:43:10,940 --> 15:43:14,240
true. And this will be an async
function. Because we only want

15474
15:43:14,240 --> 15:43:18,140
to perform keep to work if
checkup keep is indeed true. So

15475
15:43:18,170 --> 15:43:22,730
we'll say await raffle dot
enter. raffle we'll send it some

15476
15:43:22,730 --> 15:43:27,530
value, raffle entrance fee, I'm
sorry, there should be curly

15477
15:43:27,530 --> 15:43:32,930
braces instead. And we'll do a
weight network dot provider that

15478
15:43:32,930 --> 15:43:43,310
send EVM increase time inter
vol.to number plus one await

15479
15:43:43,370 --> 15:43:51,050
network dot provider that send
UVM mine an empty array there to

15480
15:43:51,170 --> 15:43:53,660
the reason that we're moving
time forward and moving our

15481
15:43:53,660 --> 15:43:55,940
block forward, of course is
gonna be the same thing as

15482
15:43:55,940 --> 15:43:58,850
above, we want our check upkeep
to return true. And then we're

15483
15:43:58,850 --> 15:44:04,730
gonna say const X or transaction
equals await raffel dot perform

15484
15:44:04,820 --> 15:44:11,030
upkeep. We can either do a blank
array, or we could do 0x Doesn't

15485
15:44:11,030 --> 15:44:15,830
matter. And we can assert the X.
Now if TX doesn't work, or this

15486
15:44:15,860 --> 15:44:19,460
error is out or something, this
will fail. Right. So that's how

15487
15:44:19,460 --> 15:44:22,880
we know that this actually can
work. So let's test this out. We

15488
15:44:22,880 --> 15:44:26,300
want this only to work if
checkup keep is true. And we

15489
15:44:26,330 --> 15:44:30,080
made checkup keep true by all
the stuff that we did above. So

15490
15:44:30,080 --> 15:44:35,390
now we'll do yarn hardhat test
dash dash grep with our IT block

15491
15:44:35,390 --> 15:44:40,610
here. And I spelled perform
upkeep wrong perform upkeep.

15492
15:44:40,610 --> 15:44:43,580
Let's try spelling things
correctly. And let's run that

15493
15:44:43,580 --> 15:44:47,450
test again. And great. That's
working. I will What else do we

15494
15:44:47,450 --> 15:44:52,010
want to do? We want it to revert
with raffel. upkeep not needed

15495
15:44:52,100 --> 15:44:57,320
if checkup keep is false. So in
here we're gonna say it reverts.

15496
15:44:57,830 --> 15:45:02,990
When check up keep is false.
This will be an async function.

15497
15:45:03,530 --> 15:45:08,450
And we're going to do that same
syntax await expect raffle dot

15498
15:45:08,480 --> 15:45:16,130
perform upkeep empty bytes
object that to.be reverted with.

15499
15:45:16,370 --> 15:45:18,470
And what do we want it to be
reverted with? Or hoping it's

15500
15:45:18,470 --> 15:45:24,860
reverted with this with that, we
can run this test here Hardhead

15501
15:45:24,860 --> 15:45:29,300
test dash dash grep paste that
in. And we see that is indeed

15502
15:45:29,300 --> 15:45:32,000
passing now something that
you'll notice here is that our

15503
15:45:32,000 --> 15:45:35,360
revert actually goes ahead and
reverts with all this extra

15504
15:45:35,360 --> 15:45:38,930
stuff as well. Our test is smart
enough to know that if all we do

15505
15:45:38,930 --> 15:45:42,740
is put the name of the error
that is getting reverted with

15506
15:45:42,770 --> 15:45:45,860
then it's good enough. If we
want to be super specific, we

15507
15:45:45,860 --> 15:45:49,160
can actually go ahead and make
this a string interpolation and

15508
15:45:49,190 --> 15:45:53,150
add all of these in here. So we
can add the balance that we

15509
15:45:53,150 --> 15:45:56,150
expect we can add the players
that we expect. And we can add

15510
15:45:56,150 --> 15:45:58,970
the raffle statement for now
we're just going to keep it as

15511
15:45:59,180 --> 15:46:02,570
we're expecting this but if you
want to be super specific you

15512
15:46:02,570 --> 15:46:06,650
can have your tests expect for
exactly the specific values that

15513
15:46:06,650 --> 15:46:09,440
you're looking for. But alright,
what is the last thing we should

15514
15:46:09,470 --> 15:46:12,920
expect form? Well, we should
check to see that this actually

15515
15:46:12,920 --> 15:46:16,310
gets called the raffle state
gets changed. And we admit this

15516
15:46:16,340 --> 15:46:21,440
event. So let's go ahead and add
that. We'll say it updates the

15517
15:46:21,440 --> 15:46:30,230
raffle state admits an event and
calls the VRF coordinator to be

15518
15:46:30,230 --> 15:46:34,790
an async function as well. Let's
do this. So let's go ahead and

15519
15:46:34,790 --> 15:46:37,820
let's make checkup keep true,
I'm just going to copy paste

15520
15:46:37,820 --> 15:46:40,040
these first three lines, since
it's going to be exactly the

15521
15:46:40,040 --> 15:46:42,590
same. We're going to enter the
raffle we're going to increase

15522
15:46:42,590 --> 15:46:44,960
the time we're going to mind a
new block, then we're going to

15523
15:46:44,960 --> 15:46:48,950
call perform upkeep. So we're
going to say const, TX response

15524
15:46:49,160 --> 15:46:55,970
equals await raffle dot perform
upkeep with an empty bytes

15525
15:46:55,970 --> 15:47:02,480
object, and we're going to do
const TX receipt equals await TX

15526
15:47:02,480 --> 15:47:07,790
response dot wait for one block.
From this receipt, we're gonna

15527
15:47:07,790 --> 15:47:12,980
get the request ID, we're gonna
say const Request ID equals, we

15528
15:47:12,980 --> 15:47:17,210
can get the request ID. From
this omitted event. However, we

15529
15:47:17,210 --> 15:47:21,230
should look at our VRF
coordinator mock again, when we

15530
15:47:21,230 --> 15:47:25,640
call request random words, both
in the mock and then in the

15531
15:47:25,640 --> 15:47:30,350
actual contract, you'll notice
that it also emits an event with

15532
15:47:30,350 --> 15:47:33,590
random words requested. And if
you look in here, the second

15533
15:47:33,590 --> 15:47:38,270
parameter that it has is indeed
the request ID. So in reality,

15534
15:47:38,450 --> 15:47:42,380
US omitting the request ID is
redundant, we can just use the

15535
15:47:42,380 --> 15:47:45,920
admitted Request ID from the VRF
coordinator for the purpose of

15536
15:47:45,920 --> 15:47:48,410
this course and showing you what
an event looks like. We're going

15537
15:47:48,410 --> 15:47:50,960
to leave it in there. But if you
want to go back and refactor

15538
15:47:50,960 --> 15:47:54,050
this, you would definitely want
to remove this omit. But for

15539
15:47:54,050 --> 15:47:58,550
this test, let's do TX receipt
dot events. And this is going to

15540
15:47:58,550 --> 15:48:02,210
be the first event instead of
the zero with event because

15541
15:48:02,240 --> 15:48:06,170
before this event gets emitted,
this function is going to emit

15542
15:48:06,200 --> 15:48:09,710
an event. So instead of the zero
with event, this is the first

15543
15:48:09,740 --> 15:48:12,920
event that gets emitted after
this one. So tax receipts dot

15544
15:48:12,920 --> 15:48:17,360
events of one dot args dot
request, ID, and then we're

15545
15:48:17,360 --> 15:48:23,330
gonna say cert request id.to
number is greater than zero. And

15546
15:48:23,330 --> 15:48:25,460
then we'll also assert that the

15547
15:48:26,510 --> 15:48:31,160
raffle state equals equals one.
So we're gonna do const, raffle

15548
15:48:31,160 --> 15:48:37,430
state equals await, raffle dot
get raffle state. And this

15549
15:48:37,430 --> 15:48:41,990
should actually be raffle
state.to Number, or to string

15550
15:48:41,990 --> 15:48:44,300
and then you know, do whatever
we want to do. And this is a

15551
15:48:44,360 --> 15:48:48,650
very big it, but we're going to
copy the whole thing anyways. HH

15552
15:48:48,650 --> 15:48:52,670
test, dash dash grep, paste that
in there, we run it, excuse

15553
15:48:52,670 --> 15:48:59,810
me.to string equals equals one,
transformer time and perfect, we

15554
15:48:59,810 --> 15:49:03,440
are passing Great, now it's time
for fulfill random words. And

15555
15:49:03,440 --> 15:49:06,380
this is where we're going to
learn a lot of fantastic stuff

15556
15:49:06,380 --> 15:49:09,140
here. So we're gonna make a new
describe block zoomed out a

15557
15:49:09,140 --> 15:49:15,470
little bit here. And this is
going to be our fulfill random

15558
15:49:15,470 --> 15:49:20,060
words. It's going to be a
function, of course. And in

15559
15:49:20,060 --> 15:49:23,210
here, we're actually going to
add another before each want to

15560
15:49:23,210 --> 15:49:26,990
have somebody have entered the
raffle before we run any tests

15561
15:49:26,990 --> 15:49:31,010
in here. So we're going to do a
before each, which will be an

15562
15:49:31,040 --> 15:49:37,160
async. function. And we're just
going to run await, raffle that

15563
15:49:37,160 --> 15:49:44,600
enter raffle with a value of
raffle entrance fee. And then

15564
15:49:44,600 --> 15:49:50,330
we're going to do a wait network
dot provider dot send EVM

15565
15:49:50,570 --> 15:49:58,880
increase time of interval, that
to number plus one, and then a

15566
15:49:58,880 --> 15:50:06,260
wait network dot provider dot
send EVM mine. Comma. Before

15567
15:50:06,260 --> 15:50:09,020
we've tried to do any testing of
or fulfilled random words, we're

15568
15:50:09,020 --> 15:50:11,600
gonna have somebody enter the
lottery. And we're going to have

15569
15:50:11,600 --> 15:50:15,020
increased the time and mined a
new block. Okay, cool. So the

15570
15:50:15,020 --> 15:50:17,930
first thing we want to do is
want to see that fulfill random

15571
15:50:17,930 --> 15:50:22,520
words can only be called so long
as there's a request in flight,

15572
15:50:22,550 --> 15:50:26,030
so long as there's a requested
as long as request random words

15573
15:50:26,060 --> 15:50:28,490
has been called. So we can
actually check that by running

15574
15:50:28,520 --> 15:50:34,760
it can only be called after
perform. This will be an async

15575
15:50:34,760 --> 15:50:38,930
function. And in here, we're
going to revert on some requests

15576
15:50:38,930 --> 15:50:44,420
that don't exist. So we'll do
await, expect the RF core didn't

15577
15:50:44,420 --> 15:50:51,500
a tour be to mock dot fulfill
random words. And if we look at

15578
15:50:51,500 --> 15:50:57,440
our V RF, coordinator v2 Mark in
here has the fulfill random

15579
15:50:57,440 --> 15:51:00,470
words function, which is what
the chain link node actually

15580
15:51:00,470 --> 15:51:03,590
calls and inside Add this
function in the actual contract

15581
15:51:03,590 --> 15:51:06,560
calls another contract that does
the random number verification.

15582
15:51:06,620 --> 15:51:09,740
So we're basically checking this
part right here. If the request

15583
15:51:09,740 --> 15:51:13,130
doesn't exist, we're going to
get this non existent request

15584
15:51:13,130 --> 15:51:16,610
here. And as you can see, it
needs a request ID and a

15585
15:51:16,610 --> 15:51:20,690
consumer address. So we're going
to guess zero. And the consumer

15586
15:51:20,690 --> 15:51:23,780
addresses, of course, it's gonna
be raffled out at address, we're

15587
15:51:23,780 --> 15:51:31,580
going to expect this to be
reverted, with non existent

15588
15:51:31,820 --> 15:51:35,690
request. And then we're going to
do this exact same thing with a

15589
15:51:35,720 --> 15:51:39,320
different Request ID or request
ID one. And hopefully, we're

15590
15:51:39,320 --> 15:51:42,050
also going to get non existent
requests. Now ideally, no

15591
15:51:42,050 --> 15:51:45,830
request here would ever allow
this fulfill random words to go

15592
15:51:45,830 --> 15:51:49,010
through. Now, it obviously would
be really hard for us to test

15593
15:51:49,040 --> 15:51:52,100
every single possible Request
ID, we're going to see a way in

15594
15:51:52,100 --> 15:51:56,360
the future to actually test for
a ton of these variables with

15595
15:51:56,360 --> 15:51:58,940
something called fuzz testing.
But we'll get to that in the

15596
15:51:58,940 --> 15:52:01,730
future. And I spelt the scribe
wrong, let's let's actually

15597
15:52:01,730 --> 15:52:05,210
spelled the scribe correctly, go
ahead and run this hh test dash

15598
15:52:05,210 --> 15:52:05,930
dash grep.

15599
15:52:07,970 --> 15:52:13,970
And great it passed. Now I'm
going to make just one more test

15600
15:52:13,970 --> 15:52:17,450
here, that's gonna be way too
big. But right now the test that

15601
15:52:17,450 --> 15:52:19,820
we're about to write is going to
be it's going to be a really big

15602
15:52:19,820 --> 15:52:22,250
test. And we probably want to
split it up into different

15603
15:52:22,250 --> 15:52:25,190
sections, but actually figured
that this was actually the best

15604
15:52:25,190 --> 15:52:27,500
way to show this section. And
it's going to be exactly what

15605
15:52:27,500 --> 15:52:30,350
we're going to do. When we get
to our staging test, we're going

15606
15:52:30,350 --> 15:52:33,680
to write this test literally
almost exactly the same. So

15607
15:52:33,860 --> 15:52:37,790
let's write it, this is
basically going to be the test

15608
15:52:37,790 --> 15:52:40,970
that puts everything together.
So we're going to test that this

15609
15:52:40,970 --> 15:52:47,240
indeed, so winner resets the
lottery, and sends money, which

15610
15:52:47,240 --> 15:52:50,210
is kind of a lot for a single
it, we probably would want to

15611
15:52:50,210 --> 15:52:53,390
split those into their own
pieces. But for this, we're just

15612
15:52:53,390 --> 15:52:55,580
going to put them all into one,
and it's going to be an async

15613
15:52:55,700 --> 15:52:59,390
function. Now we are going to
learn a couple of new tricks

15614
15:52:59,390 --> 15:53:02,630
here. So definitely be sure to
follow along. Now for this one,

15615
15:53:02,630 --> 15:53:05,780
we're also going to add in some
additional entrances additional

15616
15:53:05,780 --> 15:53:08,480
people who are entering this
lottery. So we'll say const,

15617
15:53:08,870 --> 15:53:14,210
additional, and trance equals
great. We're gonna have some

15618
15:53:14,210 --> 15:53:17,930
more of those fake accounts from
ethers enter our lottery here.

15619
15:53:17,960 --> 15:53:23,180
So we're gonna say const.
Starting account, index equals

15620
15:53:23,300 --> 15:53:27,950
to, since deployer equals zero,
excuse me equals one, since the

15621
15:53:27,950 --> 15:53:30,740
player is zero, so we're going
to have new accounts start from

15622
15:53:30,770 --> 15:53:34,910
index one. And we're going to do
a little for loop or let i

15623
15:53:35,090 --> 15:53:44,150
equals starting count index, i
is less than the starting count,

15624
15:53:45,080 --> 15:53:51,470
index, plus additional and trend
sees there's gonna be entrance.

15625
15:53:52,580 --> 15:53:56,690
i plus plus, we're gonna do a
little loop and connect our

15626
15:53:56,720 --> 15:53:59,150
raffle contract to these new
accounts. And then we're going

15627
15:53:59,150 --> 15:54:04,700
to have these new accounts,
enter our raffle contest. Count,

15628
15:54:05,090 --> 15:54:13,070
connected raffle equals raffle
dot connect accounts of i and do

15629
15:54:13,070 --> 15:54:16,190
we have accounts defined
somewhere we don't. So let's get

15630
15:54:16,190 --> 15:54:20,600
accounts to find somewhere.
We'll say const accounts equals

15631
15:54:20,660 --> 15:54:24,980
await ethers dot get signers.
And then we're going to do a

15632
15:54:24,980 --> 15:54:31,190
weight account connected raffle
dot enter. raffle with a value

15633
15:54:31,220 --> 15:54:34,100
of course of raffle entrance
fee,

15634
15:54:34,220 --> 15:54:37,550
we're going to connect three
additional entrance to our

15635
15:54:37,550 --> 15:54:41,000
raffle. So we're going to have a
total of four people connect

15636
15:54:41,030 --> 15:54:43,970
into this raffle. Now that we
have them in here, we're going

15637
15:54:43,970 --> 15:54:47,060
to keep note of our starting
timestamp. So we're gonna do

15638
15:54:47,060 --> 15:54:53,750
const starting timestamp equals
await, raffle dot get last

15639
15:54:54,320 --> 15:54:56,660
timestamp. And here's where
we're going to get a little bit

15640
15:54:56,660 --> 15:55:00,800
tricky. What we want to do is a
couple of things we want to we

15641
15:55:00,800 --> 15:55:05,420
want to perform upkeep, which is
going to mock being chainlink

15642
15:55:05,420 --> 15:55:09,620
keepers, which will kick off the
chain link, which will kick off

15643
15:55:09,620 --> 15:55:14,360
calling fulfill random words.
And we're going to mock doing

15644
15:55:14,360 --> 15:55:19,340
that as well. Mock being the
chain link VRF. Once we do that,

15645
15:55:19,340 --> 15:55:22,520
we can of course just check to
see okay, did the recent winner

15646
15:55:22,520 --> 15:55:26,180
get recorded the raffle get
reset just play as we said as

15647
15:55:26,180 --> 15:55:29,450
the timestamp is everything
reset. But we want to do this in

15648
15:55:29,450 --> 15:55:33,140
a specific way. If we're doing
this on a test net after we call

15649
15:55:33,140 --> 15:55:37,130
fulfill random words, we will
have to wait for the fulfill

15650
15:55:37,280 --> 15:55:40,640
random words to be called. Now
since we're working with a

15651
15:55:40,640 --> 15:55:43,430
hardhat local chain, we don't
really need to wait for

15652
15:55:43,430 --> 15:55:46,400
anything, right because we can
just say okay, boom, snap our

15653
15:55:46,400 --> 15:55:48,800
fingers and adjust our
blockchain to do whatever we

15654
15:55:48,800 --> 15:55:51,680
want. But we're going to
simulate that we do need to wait

15655
15:55:51,920 --> 15:55:55,010
for that event to be called. So
in order for us to simulate

15656
15:55:55,010 --> 15:55:59,240
waiting for that event, we once
again need to set up a listener.

15657
15:55:59,300 --> 15:56:02,300
Now if we set up a listener we
don't want this to Just to

15658
15:56:02,300 --> 15:56:06,650
finish before the listener has
is done listening, so we need to

15659
15:56:06,650 --> 15:56:09,800
once again create a new promise.
And this is going to be

15660
15:56:09,800 --> 15:56:13,250
incredibly important, especially
for our staging tests. So we're

15661
15:56:13,250 --> 15:56:17,510
going to do await, new promise.
And this is going to be exactly

15662
15:56:17,510 --> 15:56:20,570
the same as we set it up before,
it's going to be an async

15663
15:56:20,570 --> 15:56:24,860
function that's going to take
resolve and reject as

15664
15:56:24,860 --> 15:56:27,080
parameters. And we're going to
use this little arrow syntax

15665
15:56:27,080 --> 15:56:30,920
here saying, this is an async
function, basically, and we're

15666
15:56:30,920 --> 15:56:34,520
going to set up once again, that
once syntax, we're gonna say

15667
15:56:34,520 --> 15:56:39,350
raffle that once, what's the
event name, winner picked. So

15668
15:56:39,350 --> 15:56:42,230
we're gonna say, Listen, for
this winner picked event, we're

15669
15:56:42,230 --> 15:56:46,070
gonna say raffle dot once winner
picks happens, do some stuff.

15670
15:56:46,100 --> 15:56:49,100
And again, this is just an
anonymous function. So we're

15671
15:56:49,100 --> 15:56:51,950
gonna say raffle dot once the
winner picked event gets

15672
15:56:51,950 --> 15:56:56,060
emitted, do some stuff. So we're
setting this up. Now it's in

15673
15:56:56,060 --> 15:56:58,400
this function, we're going to
add all of our certs and

15674
15:56:58,400 --> 15:57:01,910
everything because we want to
wait for winter to get picked.

15675
15:57:01,970 --> 15:57:05,180
Now before the event gets fired,
though, we of course, need to

15676
15:57:05,180 --> 15:57:08,870
actually call perform and call
fulfill random words. So this is

15677
15:57:08,870 --> 15:57:11,540
going to seem like it's a little
bit backwards. But that's

15678
15:57:11,540 --> 15:57:14,780
because we want to set up our
listeners so that when we do

15679
15:57:14,810 --> 15:57:19,040
fire, the methods that will fire
the event, our listener is

15680
15:57:19,040 --> 15:57:22,550
activated and is waiting for it.
So we're going to put all of our

15681
15:57:22,550 --> 15:57:27,050
code inside of this promise.
Now, because we put it outside

15682
15:57:27,050 --> 15:57:28,910
of the promise, we put all the
code outside of the promise,

15683
15:57:28,940 --> 15:57:31,610
this promise will never get
resolved, because the listener

15684
15:57:31,790 --> 15:57:34,790
will never fire into vent. So if
down here, you know we call

15685
15:57:34,790 --> 15:57:37,910
fulfill random words with
something, you know which the

15686
15:57:37,910 --> 15:57:40,820
spelling is bad. But let's say
we call the down here, this

15687
15:57:40,820 --> 15:57:43,700
piece of code will never reach
this fulfill random words,

15688
15:57:43,940 --> 15:57:47,060
because it's always going to be
waiting for this wants to get

15689
15:57:47,060 --> 15:57:51,290
resolved. So we need to add all
of our code inside the promise.

15690
15:57:51,500 --> 15:57:55,190
But outside this raffle dot once
now we don't want to wait

15691
15:57:55,190 --> 15:57:58,640
forever, right? Maybe there is
an issue here. And we want to be

15692
15:57:58,640 --> 15:58:02,300
able to reject this, if there's
an issue. Now what we can do is

15693
15:58:02,300 --> 15:58:06,830
in our heart hat dot config, we
can add a timeout. So we can add

15694
15:58:06,830 --> 15:58:13,190
this mocha section, we can give
ourselves a timeout of 200,000

15695
15:58:13,190 --> 15:58:17,750
milliseconds, which is going to
be 200 seconds max, if this

15696
15:58:17,780 --> 15:58:21,620
event doesn't get fired in 200
seconds, this will be considered

15697
15:58:21,650 --> 15:58:24,980
a failure and this test will
fail, which is what we want. And

15698
15:58:24,980 --> 15:58:27,770
I typically like to just wrap
this in a try catch because if

15699
15:58:27,770 --> 15:58:31,550
something fails, it'll cause you
a whole bunch of headache catch

15700
15:58:31,910 --> 15:58:35,840
E. And if anything fails, we'll
also reject, there's an issue

15701
15:58:35,840 --> 15:58:38,030
with us calling some function,
we'll just say, Hey, okay,

15702
15:58:38,030 --> 15:58:41,150
that's a failure. But you fail,
that way, our promise can get

15703
15:58:41,150 --> 15:58:43,910
resolved in a timely manner,
we're going to add this code in

15704
15:58:43,910 --> 15:58:47,240
a little bit. But let's keep
going. Let's keep going. And

15705
15:58:47,300 --> 15:58:50,960
excuse me, the trycatch should
be in the ones, the ones above

15706
15:58:50,960 --> 15:58:54,020
the results, excuse me, because
this is the listener. So sorry,

15707
15:58:54,050 --> 15:58:56,990
we want the trycatch to be
inside the ones if this takes

15708
15:58:56,990 --> 15:58:59,600
too long, we want to just go
ahead and throw an error.

15709
15:58:59,810 --> 15:59:01,880
Otherwise, we're going to
resolve now outside the

15710
15:59:01,880 --> 15:59:04,640
listener, but inside of the
promise, we're going to do this

15711
15:59:04,640 --> 15:59:11,480
bit here, where we go const TX
equals await raffle dot perform

15712
15:59:11,990 --> 15:59:15,470
upkeep, and we'll pass it the
empty bytes object, we'll get

15713
15:59:15,470 --> 15:59:21,650
const TX receipt equals await TX
dot weight of one block.

15714
15:59:21,889 --> 15:59:27,409
And then we're going to do a
weight VRF core didn't a tour be

15715
15:59:27,409 --> 15:59:35,059
to mock dot fulfill random
words, CX receipt dot events of

15716
15:59:35,059 --> 15:59:41,569
one dot args dot Request ID come
a raffle that address. So then

15717
15:59:41,569 --> 15:59:43,639
the final thing that we're going
to do is we're going to get this

15718
15:59:43,639 --> 15:59:46,639
veer off coordinator be to mock
we're going to have it call

15719
15:59:47,239 --> 15:59:50,869
fulfill random words, which
takes the request ID and the

15720
15:59:50,869 --> 15:59:53,869
consumer address. So we're going
to mock it, give it the request

15721
15:59:53,869 --> 15:59:56,539
ID which we get from the
transaction receipt, and the

15722
15:59:56,539 --> 15:59:59,539
consumer address here. All
inside this promise, we're

15723
15:59:59,539 --> 16:00:02,809
setting up a listener for this
winner picked event. And then

15724
16:00:02,809 --> 16:00:05,809
we're mocking the channeling
keepers and then we're mocking

15725
16:00:05,839 --> 16:00:09,949
the chainlink VRF. And once this
function gets called this

15726
16:00:09,949 --> 16:00:14,629
function should emit a winner
picked event. So this raffle

15727
16:00:14,659 --> 16:00:18,139
that was set up that was
listening for this to get

15728
16:00:18,169 --> 16:00:22,159
emitted will pick up and go Ah
okay, I found it I found the

15729
16:00:22,159 --> 16:00:26,209
winner picked event. Now we can
go ahead and do some stuff. So

15730
16:00:26,209 --> 16:00:29,539
once the winner picked event
gets fired, we'll do a little

15731
16:00:29,539 --> 16:00:35,149
console dot log found the event
like this and we'll jump into

15732
16:00:35,149 --> 16:00:38,329
our try catch and this trycatch
is going to be basically us

15733
16:00:38,359 --> 16:00:41,659
doing all these asserts in here.
So first we want to say const

15734
16:00:42,199 --> 16:00:48,349
recent winner equals await
raffle dot get recent winner and

15735
16:00:48,349 --> 16:00:50,749
we're going to be checking just
everything in this raffle right

15736
16:00:50,749 --> 16:00:53,119
we're gonna be checking that the
recent winners right that that

15737
16:00:53,119 --> 16:00:55,519
the raffle state's been reset
the players have reversed, you

15738
16:00:55,519 --> 16:00:59,239
know, players has been reset,
etc, etc. So we'll say const

15739
16:00:59,689 --> 16:01:05,599
raffle state equals awaits
raffle dot get raffle state

15740
16:01:06,799 --> 16:01:12,499
we'll say const. Ending
timestamp equals await, raffle

15741
16:01:12,499 --> 16:01:17,539
dot get last timestamp. And
let's start doing some asserts.

15742
16:01:17,569 --> 16:01:21,859
So first we should assert that
this es players array has been

15743
16:01:21,889 --> 16:01:25,489
reset to zero. So if we call get
number of players it should be

15744
16:01:25,519 --> 16:01:32,719
zero. So we can do const num
players equals await raffle dot

15745
16:01:32,749 --> 16:01:39,289
get number of players like so.
And we can do assert dot equal

15746
16:01:40,069 --> 16:01:45,289
nine players.to string is going
to be zero. What else can we

15747
16:01:45,289 --> 16:01:52,279
assert? Well, we can assert dot
equal raffle state should be

15748
16:01:52,279 --> 16:01:58,969
back to being open. So raffle
state.to string should be zero,

15749
16:01:59,029 --> 16:02:04,459
we should assert that the ending
timestamp is now greater than

15750
16:02:04,459 --> 16:02:09,649
the starting timestamp. Because
the last timestamp should have

15751
16:02:09,649 --> 16:02:12,439
been updated. We also want to
make sure our recent winner is

15752
16:02:12,439 --> 16:02:16,489
correct. But we'll do console
dot log recent winner. Now we

15753
16:02:16,489 --> 16:02:20,389
can go to the VRF coordinator
mock. And we could simulate this

15754
16:02:20,389 --> 16:02:22,939
and try to figure out who the
random winner is to console dot

15755
16:02:22,939 --> 16:02:27,349
log accounts to. And then just
to show a bunch of them, we'll

15756
16:02:27,349 --> 16:02:35,389
do 01 and three a raffle dot
once this needs to be an async

15757
16:02:35,389 --> 16:02:38,449
function, not just a regular
function. Let's try that one

15758
16:02:38,449 --> 16:02:42,319
more time, get latest timestamp
is the correct function. So

15759
16:02:42,319 --> 16:02:45,709
let's update this with the
correct latest. Let's put latest

15760
16:02:45,709 --> 16:02:49,159
in there. Because I'm spelling
something's wrong. I sure am

15761
16:02:49,279 --> 16:02:52,699
looks like we're printing out
recent winner here when we

15762
16:02:52,699 --> 16:02:55,279
haven't even initialized it. So
let's move it up. And then we'll

15763
16:02:55,279 --> 16:02:59,659
do console dot log recent
winner. So I know this is a

15764
16:02:59,659 --> 16:03:03,019
massive test here. But let's
give it a try and see if

15765
16:03:03,049 --> 16:03:05,419
everything kind of does what we
think it should do. And it's

15766
16:03:05,419 --> 16:03:08,959
slowing down here, which is good
because we're doing a lot of

15767
16:03:08,959 --> 16:03:13,279
stuff. And uh huh, we finally
get this passing thing to come

15768
16:03:13,279 --> 16:03:17,029
out. And we did a ton of console
dot logging so so there's a lot

15769
16:03:17,029 --> 16:03:19,789
of stuff in here of the signers
are getting printed out. So

15770
16:03:19,789 --> 16:03:22,339
let's just make this a little
easier to read. We'll add dot

15771
16:03:22,339 --> 16:03:27,079
address to all these, we can see
who the winner is. So it looks

15772
16:03:27,079 --> 16:03:30,289
like the winner is going to be
account number one, which is

15773
16:03:30,289 --> 16:03:33,079
great. So what we can do now
that we know account number one

15774
16:03:33,079 --> 16:03:35,659
is going to be the winner, we
can get that winners starting

15775
16:03:35,659 --> 16:03:40,159
balance way down here before we
call fulfill random words. So

15776
16:03:40,159 --> 16:03:47,449
we'll say const winner, starting
balance equals await accounts

15777
16:03:47,479 --> 16:03:51,739
one dot get balance, yes, you
can just call get balance right

15778
16:03:51,739 --> 16:03:55,399
like that. And now that we have
the winner starting balance back

15779
16:03:55,399 --> 16:04:01,249
in our tests, we can say const
winner, ending balance equals

15780
16:04:01,279 --> 16:04:07,729
await ounce one dot get balance.
And we can make sure that this

15781
16:04:07,729 --> 16:04:11,869
winner got paid what they need.
So now we're going to do a big

15782
16:04:11,869 --> 16:04:14,419
assert with some money stuff,
just trust me, this is what the

15783
16:04:14,419 --> 16:04:18,229
math is. So we're going to do
assert dot equal winner

15784
16:04:18,229 --> 16:04:20,179
balance.to string,

15785
16:04:21,140 --> 16:04:25,460
excuse me winter ending
balance.to string should equal

15786
16:04:26,150 --> 16:04:34,430
the winner starting balance dot
add the raffle entrance fee that

15787
16:04:34,430 --> 16:04:41,600
multiplied by the additional and
trance that add the raffle

15788
16:04:41,600 --> 16:04:45,410
entrance fee that we paid.to
string. So this math is

15789
16:04:45,410 --> 16:04:49,940
basically saying the winner
should end with a balance of all

15790
16:04:50,000 --> 16:04:53,030
of the money that everybody else
added to this contract. And

15791
16:04:53,030 --> 16:04:57,110
that's it. So we can run this
test one more time. And Gosh,

15792
16:04:57,110 --> 16:05:00,410
darn it, it passed. Okay, so
there was a lot of code here.

15793
16:05:00,470 --> 16:05:03,170
And this might have been one of
the hardest pieces of this

15794
16:05:03,170 --> 16:05:06,290
entire course is going to be
this part right here. So if you

15795
16:05:06,290 --> 16:05:08,630
struggled a little bit with
this, don't let that bog you

15796
16:05:08,630 --> 16:05:11,780
down. This is probably one of
the more difficult sections of

15797
16:05:11,780 --> 16:05:15,440
this course, let's do a quick
refresher of just this test that

15798
16:05:15,440 --> 16:05:18,170
we're doing. And then we'll see
in an action when we do it. In

15799
16:05:18,170 --> 16:05:21,410
our staging test. What we did is
we're picking a winner resetting

15800
16:05:21,410 --> 16:05:23,180
the lottery and we're sending
money. Basically what we're

15801
16:05:23,180 --> 16:05:26,420
doing is we're testing that this
fulfill random words thing does

15802
16:05:26,420 --> 16:05:29,030
what we want it to do a random
winner wins and they get the

15803
16:05:29,030 --> 16:05:31,700
money. So how do we actually do
that? Well, we first started off

15804
16:05:31,700 --> 16:05:34,460
by having a bunch of random
people enter the lottery. Great.

15805
16:05:34,490 --> 16:05:38,510
Sounds good. Now what we wanted
to do was we want to call

15806
16:05:38,510 --> 16:05:42,080
perform upkeep and fulfill
random words, we want to pretend

15807
16:05:42,080 --> 16:05:45,110
that the random number was
drawn. And that's what this code

15808
16:05:45,110 --> 16:05:48,770
down here does is it calls that
random number but and what we

15809
16:05:48,770 --> 16:05:51,170
could have done was we could
have had all these assert and

15810
16:05:51,170 --> 16:05:54,800
checked all the variables. After
we did this, right. We could

15811
16:05:54,800 --> 16:05:58,370
have totally done that. However,
on a test net where we don't

15812
16:05:58,400 --> 16:06:00,980
always know exactly when a
transaction is going to finish.

15813
16:06:01,010 --> 16:06:03,980
We have to wait If we have to
listen for an event to be fired,

15814
16:06:04,250 --> 16:06:07,550
before, we could call the
transactions that would end this

15815
16:06:07,550 --> 16:06:10,670
whole thing, we needed to set
something up to listen for that

15816
16:06:10,670 --> 16:06:14,330
event to be fired. And we said,
hey, only once this event is

15817
16:06:14,330 --> 16:06:18,710
fired only once this transaction
is called, can we do our testing

15818
16:06:18,770 --> 16:06:22,160
now for our local network, we
are mocking the VRF

15819
16:06:22,160 --> 16:06:24,860
coordinators, we have control,
we know exactly when this is

15820
16:06:24,860 --> 16:06:28,460
going to run. But on a test net,
we don't. So you'll see in our

15821
16:06:28,460 --> 16:06:31,790
staging tests, we won't have any
of this here. And we'll have to

15822
16:06:31,790 --> 16:06:37,040
rely on setting up a listener to
listen for the channeling VRF

15823
16:06:37,040 --> 16:06:40,280
and the keepers to fire their
events. And that's why the

15824
16:06:40,280 --> 16:06:43,010
staging test is going to be so
important to make sure that

15825
16:06:43,010 --> 16:06:45,440
we're doing everything correct.
And that's why we set up our

15826
16:06:45,440 --> 16:06:48,800
local tests like this, so that
it mimics what we're going to be

15827
16:06:48,800 --> 16:06:51,080
doing on our statement test what
we're going to be doing on a

15828
16:06:51,110 --> 16:06:54,560
real network here. And again,
we're setting up this listener

15829
16:06:54,560 --> 16:06:58,370
and we're saying, Ah, once we do
here, this event, then we're

15830
16:06:58,370 --> 16:07:01,730
going to try to actually check
all of the balances and check

15831
16:07:01,730 --> 16:07:04,550
that everything is working as
intended. And if we don't see

15832
16:07:04,550 --> 16:07:07,130
it, we're going to reject. And
if there's a timeout, if it

15833
16:07:07,130 --> 16:07:09,590
takes more than 200 seconds,
we're going to say okay,

15834
16:07:09,680 --> 16:07:11,930
something went wrong, we're
going to cancel it. And

15835
16:07:11,930 --> 16:07:13,790
actually, I'm going to bump this
up to 300 seconds, because I

15836
16:07:13,790 --> 16:07:17,180
think 200 seconds is not going
to be enough. And depending on

15837
16:07:17,180 --> 16:07:19,970
how quick the rink B test that
is, you might have to bump this

15838
16:07:19,970 --> 16:07:27,320
up even bigger. So just keep
that in mind. But who, okay, we

15839
16:07:27,320 --> 16:07:30,920
have just built some fantastic
tests. Let's go ahead, and let's

15840
16:07:30,920 --> 16:07:35,240
just run h h test to see if all
of our tests are going to pass.

15841
16:07:36,470 --> 16:07:40,580
And well, 14 passing, everything
is passing here we are looking

15842
16:07:40,610 --> 16:07:41,030
good.

15843
16:07:41,330 --> 16:07:46,460
This is fantastic. Alright, so
now that we have our unit tests,

15844
16:07:46,460 --> 16:07:50,270
let's go ahead and create a
staging test. Our staging test

15845
16:07:50,300 --> 16:07:53,510
is going to look really similar
to that massive test that we

15846
16:07:53,510 --> 16:07:56,660
just created down here. And the
reason we set up our unit test

15847
16:07:56,660 --> 16:07:59,780
to do this a weight promise
thing with the raffle dot once

15848
16:07:59,840 --> 16:08:02,480
was because this is actually how
we're going to need to wait on a

15849
16:08:02,480 --> 16:08:06,020
test net or main net for a
winner to be picked. We cannot

15850
16:08:06,050 --> 16:08:09,560
on an actual test net, pretend
to be the chain link V REF, we

15851
16:08:09,560 --> 16:08:11,930
can pretend to be the chain link
keepers if we want. But we're

15852
16:08:11,930 --> 16:08:14,810
not going to make sure that the
10 the keepers is actually

15853
16:08:14,810 --> 16:08:17,300
working. But we are going to be
doing this because we want to

15854
16:08:17,300 --> 16:08:21,380
listen for that event to be
fired, we want to listen for the

15855
16:08:21,380 --> 16:08:25,760
chain link VRF to respond with
the winner. So let's create a

15856
16:08:25,760 --> 16:08:29,180
staging test. And this is a test
that we're going to run on an

15857
16:08:29,210 --> 16:08:33,650
actual test net here. Okay, so
we're going to create a new test

15858
16:08:33,650 --> 16:08:38,090
called raffle dot staging dot
test dot Jas and this is where

15859
16:08:38,090 --> 16:08:41,150
we're going to put our staging
test. Now we can actually code

15860
16:08:41,150 --> 16:08:44,210
this pretty quickly because most
of our staging tests is gonna

15861
16:08:44,210 --> 16:08:47,660
look real similar to our raffle
test here. So for now, let's

15862
16:08:47,660 --> 16:08:51,290
just grab this whole first part,
and then we'll adjust it as we

15863
16:08:51,290 --> 16:08:54,200
need. And then we'll close it
off. Because we're definitely

15864
16:08:54,200 --> 16:08:57,320
gonna need a raffle, we're not
going to need a VRF coordinator

15865
16:08:57,320 --> 16:09:00,080
mock because again, we're not
going to be using a mock. Since

15866
16:09:00,080 --> 16:09:02,510
we're on an actual test net, we
will need the raffle entrance

15867
16:09:02,510 --> 16:09:06,020
fee, we will need Deployer, we
will need a Deployer. And we

15868
16:09:06,020 --> 16:09:08,660
might need the interval. But
let's delete it for now we

15869
16:09:08,660 --> 16:09:11,120
probably won't need the chain
ID. So let's delete that as

15870
16:09:11,120 --> 16:09:14,090
well. Awesome. Something that we
want to keep in mind is that

15871
16:09:14,090 --> 16:09:17,060
when it comes to our staging
tests, we only want our steam

15872
16:09:17,060 --> 16:09:19,670
test to run when we're on a
test. Net, we don't need to run

15873
16:09:19,670 --> 16:09:22,280
our unit tests because our unit
tests aren't checking that

15874
16:09:22,280 --> 16:09:25,460
compatibility with a test net,
we want our unit tests to only

15875
16:09:25,460 --> 16:09:29,120
run on a local network. And we
want our staging tests to only

15876
16:09:29,120 --> 16:09:32,420
run on a test network. This is
where again, in our test, we're

15877
16:09:32,420 --> 16:09:35,930
going to check to make sure what
type of chain we're on. And

15878
16:09:35,930 --> 16:09:38,480
oops, it looks like I already
imported the development changes

15879
16:09:38,480 --> 16:09:41,150
here. So we're actually in our
staging tests, we're going to

15880
16:09:41,150 --> 16:09:44,870
check before we run any test
what kind of network we're on.

15881
16:09:44,900 --> 16:09:49,490
So we're gonna say, if our
development chains that includes

15882
16:09:49,700 --> 16:09:52,730
network dot name, we're gonna
say if our development chains

15883
16:09:52,730 --> 16:09:55,760
includes network to name, so if
the chain we're on is in the

15884
16:09:55,760 --> 16:09:58,490
development chains, and again,
we're going to use this ternary

15885
16:09:58,490 --> 16:10:01,430
operator where we say, if we're
on a development chain, do

15886
16:10:01,430 --> 16:10:03,680
something. And then if we're not
on a development chain, do

15887
16:10:03,680 --> 16:10:06,860
something else. If we are on a
development chain, what are we

15888
16:10:06,860 --> 16:10:09,500
going to do? Well want to skip
this and we can actually skip

15889
16:10:09,500 --> 16:10:13,730
this by putting in this describe
dot skip. And this will skip

15890
16:10:13,760 --> 16:10:17,000
this whole section here. And
then we can say, if we are the

15891
16:10:17,000 --> 16:10:20,120
development chain, go ahead and
do our thing. So this is some

15892
16:10:20,120 --> 16:10:23,930
really nice syntax that allows
us to skip our staging tests if

15893
16:10:23,930 --> 16:10:27,140
we're on a local network. And
additionally, we can grab this

15894
16:10:27,140 --> 16:10:30,740
syntax, go into our raffle dot
test dot j s where we have our

15895
16:10:30,740 --> 16:10:34,520
unit tests and add the bang
operator, which is the knot and

15896
16:10:34,520 --> 16:10:38,000
hit Save. And now we're saying
if we're not on a development

15897
16:10:38,000 --> 16:10:41,120
chain, skip it and only run this
if we aren't in development

15898
16:10:41,120 --> 16:10:44,090
chain. So this says run this
only on a test net or main net.

15899
16:10:44,120 --> 16:10:47,660
And then this has run this only
on a local network. Great. So we

15900
16:10:47,660 --> 16:10:50,300
have a deployer which we're
going to need. We are not going

15901
16:10:50,300 --> 16:10:54,020
to need to deploy any fixtures
because we're going to run our

15902
16:10:54,020 --> 16:10:57,320
deploy script and our contracts
should already be deployed. We

15903
16:10:57,320 --> 16:11:00,740
will need a raffle we won't need
a VRF coordinator mocks we can

15904
16:11:00,740 --> 16:11:03,530
delete that We will need the
entrance fee, and we probably

15905
16:11:03,530 --> 16:11:05,780
won't need the interval. So we
can go ahead and delete that

15906
16:11:05,780 --> 16:11:08,390
too. Alright, awesome. So we
have our describe, we have our

15907
16:11:08,390 --> 16:11:11,360
before each, let's make our
tests. And I'm just going to

15908
16:11:11,360 --> 16:11:15,650
make one giant test to test kind
of everything end to end. And

15909
16:11:15,650 --> 16:11:18,620
you can add more tests later on
yourself, if you want to our

15910
16:11:18,620 --> 16:11:22,100
staging test is going to be
really similar to this massive

15911
16:11:22,100 --> 16:11:25,190
test that we made down here. And
in fact, we're going to use most

15912
16:11:25,190 --> 16:11:27,890
of this code here as our
boilerplate. So let's create a

15913
16:11:27,890 --> 16:11:31,190
describe. And we'll say, and
we'll actually just copy this

15914
16:11:31,190 --> 16:11:34,340
describe the four random words
and paste it in here. Because

15915
16:11:34,340 --> 16:11:36,920
again, we're going to be using a
lot of the same code in our

15916
16:11:36,920 --> 16:11:42,050
staging tests here. Great. So
now we'll say it works with live

15917
16:11:42,290 --> 16:11:48,590
chain link keepers and chain
link VRF, we get a random

15918
16:11:48,650 --> 16:11:53,390
winner, acing function. So this
is going to be our test in here.

15919
16:11:53,450 --> 16:11:57,680
So in this test, we of course,
we want to enter the raffle. And

15920
16:11:57,680 --> 16:12:01,310
we shouldn't have to do anything
else except for enter this

15921
16:12:01,310 --> 16:12:03,890
raffle. Because the chain the
keepers and the only VRF are

15922
16:12:03,890 --> 16:12:06,710
going to be the ones to actually
kick off this lottery for us,

15923
16:12:06,740 --> 16:12:10,040
we'll do a quick grabbing of the
starting timestamp to have it

15924
16:12:10,040 --> 16:12:13,430
before all this kicks off. So
we'll say const starting

15925
16:12:13,430 --> 16:12:19,700
timestamp equals await raffle
dot get last to me get latest

15926
16:12:20,540 --> 16:12:23,780
timestamp, get latest timestamp,
we're gonna grab this because

15927
16:12:23,780 --> 16:12:26,240
later on, we're going to test to
see if the timestamp has indeed

15928
16:12:26,300 --> 16:12:29,030
moved forward, we want to enter
the lottery, right, we want to

15929
16:12:29,030 --> 16:12:31,730
run the command we've been
running over here all the time,

15930
16:12:31,760 --> 16:12:35,840
we want to do you know await
raffle dot enter raffle, but we

15931
16:12:35,840 --> 16:12:39,020
don't want to call it yet.
Because same as what we did over

15932
16:12:39,020 --> 16:12:43,580
here, we want to set up our
listener first. Now in here, we

15933
16:12:43,580 --> 16:12:46,580
probably should have set up our
listener before we entered the

15934
16:12:46,580 --> 16:12:50,030
raffle. However, we controlled
the blockchain. So putting it in

15935
16:12:50,030 --> 16:12:53,930
that order was is was okay. But
we want to set up the listener

15936
16:12:54,050 --> 16:12:58,670
before we enter the raffle just
in case the blockchain moves

15937
16:12:58,760 --> 16:13:01,520
really fast. And we're going to
set up the listener the exact

15938
16:13:01,520 --> 16:13:05,090
same way, we did it over here.
So we're gonna say await new

15939
16:13:05,090 --> 16:13:08,210
promise. And it's going to be an
async function that takes a

15940
16:13:08,210 --> 16:13:11,840
resolve and a reject. And we're
going to use a little arrow

15941
16:13:11,840 --> 16:13:14,450
notation here. And in here,
we're going to set up the

15942
16:13:14,450 --> 16:13:18,170
listener, we're gonna say raffle
dot once, once that winner is

15943
16:13:18,170 --> 16:13:21,890
picked, we're going to do
another async function using

15944
16:13:21,890 --> 16:13:22,730
that Arrow.

15945
16:13:24,289 --> 16:13:29,389
Arrow function syntax, we'll say
console dot log winner picked

15946
16:13:30,469 --> 16:13:35,359
the event fired. And only once
we get this winner picked, can

15947
16:13:35,359 --> 16:13:38,959
we start doing our asserts in
here, can we start making sure

15948
16:13:38,989 --> 16:13:42,349
that there's a winner, there's a
verifiably random winner, it's

15949
16:13:42,349 --> 16:13:44,749
been picked, the money has been
moved, etc. This is where we'll

15950
16:13:44,749 --> 16:13:49,549
do our try catch. And if there's
any error, we're just going to

15951
16:13:49,579 --> 16:13:52,519
automatically reject, we're
going to reject the promise. And

15952
16:13:52,519 --> 16:13:56,029
if all goes well, of course,
we're going to resolve the

15953
16:13:56,029 --> 16:13:58,609
promise. So our listener has
been set up here. We haven't

15954
16:13:58,609 --> 16:14:01,579
added our asserts here. But we
will, let's just go ahead and

15955
16:14:01,579 --> 16:14:04,699
write the rest of the test. And
then we'll go back and we'll

15956
16:14:04,729 --> 16:14:08,089
update this listener so so our
listener has been added. And

15957
16:14:08,089 --> 16:14:10,789
inside here is actually where
we're going to enter the raffle.

15958
16:14:10,819 --> 16:14:17,329
So inside here, await, raffle
dot enter raffle value is going

15959
16:14:17,329 --> 16:14:23,539
to be raffle entrance fee. And
really that's it. Right? So

15960
16:14:23,539 --> 16:14:26,509
we're setting up the listener,
setting up the listener, then

15961
16:14:26,539 --> 16:14:33,079
entering the raffle. And this
code won't complete until our

15962
16:14:33,079 --> 16:14:37,009
listener has finished listening
because again, this whole SEC is

15963
16:14:37,009 --> 16:14:40,579
in a wait. So we're gonna say
okay, cool setup, the listener,

15964
16:14:40,669 --> 16:14:43,309
wait for this to finish. And
then when it gets here, it goes

15965
16:14:43,339 --> 16:14:46,519
out okay, this is the end of the
code Are we all done executing

15966
16:14:46,579 --> 16:14:50,359
Oh, no resolve or reject hasn't
been called yet. And that's

15967
16:14:50,359 --> 16:14:52,219
because we're still waiting for
the listener to finish

15968
16:14:52,219 --> 16:14:56,179
listening. Now, once we get this
winner picked event emitted in

15969
16:14:56,179 --> 16:14:58,999
here, we're going to get that
recent winner so we'll say const

15970
16:14:59,509 --> 16:15:04,939
recent winner equals await
raffle dot get recent winner

15971
16:15:05,749 --> 16:15:09,979
will get the raffle state we'll
say const. raffle state equals

15972
16:15:10,009 --> 16:15:14,509
await raffle dot get raffle
state, we'll get the winners

15973
16:15:14,509 --> 16:15:19,999
balance. So we'll say const.
Winner balance equals await

15974
16:15:21,139 --> 16:15:25,339
recent winner. And since we're
only entering with our Deployer

15975
16:15:25,369 --> 16:15:28,849
we should check to see the
deployers balance at the end and

15976
16:15:28,849 --> 16:15:31,909
we can't do it right with this
deployer object here. So we'll

15977
16:15:31,909 --> 16:15:37,999
have to do the player account
equals await ethers dot get

15978
16:15:38,059 --> 16:15:42,259
signers, no wrap this actually
actually will just say this is

15979
16:15:43,069 --> 16:15:46,459
accounts here like that. And
then we'll just do a count of

15980
16:15:46,459 --> 16:15:49,369
zero because it counts as zero
is going to be our Deployer. So

15981
16:15:49,369 --> 16:15:52,369
our winner balance is going to
be accounts a zero dot get

15982
16:15:52,369 --> 16:15:57,259
balance. And then we're going to
do const ending timestamp equals

15983
16:15:57,289 --> 16:16:04,429
a weight raffle dot get latest
To timestamp, and we should also

15984
16:16:04,429 --> 16:16:08,179
get the starting balance. So
we'll say winner ending balance,

15985
16:16:08,419 --> 16:16:12,409
we should also get the starting
balance right after we enter. So

15986
16:16:12,409 --> 16:16:17,839
we'll say const. Winner,
starting balance equals await

15987
16:16:18,019 --> 16:16:23,569
accounts. Zero dot get balance,
so that now we can do some

15988
16:16:23,569 --> 16:16:26,569
comparisons. All right, great.
Let's do the comparisons now. So

15989
16:16:26,569 --> 16:16:30,439
we should first expect the
raffle to be reset. So we can do

15990
16:16:30,439 --> 16:16:34,129
this a few different ways. Down
here. We did number of players.

15991
16:16:34,429 --> 16:16:43,039
We can also say, await, expect
raffle dot get player 0.2 dot v

15992
16:16:43,069 --> 16:16:48,109
dot reverted, right because Get
Player zero should get reverted

15993
16:16:48,109 --> 16:16:50,749
because there's not even going
to be an object at zero. So

15994
16:16:50,749 --> 16:16:53,449
that's another way we can check
to see if our players array has

15995
16:16:53,449 --> 16:16:57,919
been reset. Next, we can do
assert dot equal recent

15996
16:16:57,949 --> 16:17:04,609
winner.to string, this should
equal our account zero dot

15997
16:17:04,609 --> 16:17:08,989
address. Okay, our Deployer What
else can we do? We will assert

15998
16:17:09,079 --> 16:17:14,539
dot equal raffle state to zero.
We want this email to go back to

15999
16:17:14,539 --> 16:17:17,629
open after we're done. And then
we finally want to make sure

16000
16:17:17,629 --> 16:17:19,879
that the money has been
transferred correctly. So we'll

16001
16:17:19,879 --> 16:17:25,669
do assert dot equal, this should
be a winner ending balance. That

16002
16:17:25,669 --> 16:17:32,329
to string should be equal to
winner starting balance, add

16003
16:17:34,219 --> 16:17:38,929
raffle entrance fee.to string.
So if we look down here, they

16004
16:17:38,929 --> 16:17:42,139
enter the raffle we check their
starting balance right after

16005
16:17:42,139 --> 16:17:45,109
they enter. And they basically
should just get that raffle

16006
16:17:45,109 --> 16:17:48,529
entrance fee back right because
they are the only ones who have

16007
16:17:48,529 --> 16:17:51,049
entered this raffle. And then we
can do one more assert, do

16008
16:17:51,049 --> 16:17:56,209
assert that the ending timestamp
is greater than the starting

16009
16:17:56,239 --> 16:18:00,709
timestamp. And then we'll of
course, say resolve. So this all

16010
16:18:00,709 --> 16:18:04,759
goes well, we resolve. If
there's an issue with any of

16011
16:18:04,759 --> 16:18:07,129
these asserts, we're going to
catch those errors and we're

16012
16:18:07,129 --> 16:18:09,949
going to reject and this is
going to be false. And this

16013
16:18:09,949 --> 16:18:12,679
whole test is gonna go ah, there
was an issue, we now have a

16014
16:18:12,679 --> 16:18:15,799
staging test that looks really
good here. Let's try

16015
16:18:15,800 --> 16:18:22,940
this out. Let's try our staging
test out from start to finish.

16016
16:18:23,000 --> 16:18:27,350
So now in order for us to test
this staging test, from end to

16017
16:18:27,350 --> 16:18:30,440
end, you first going to need to
get our sub ID for the

16018
16:18:30,440 --> 16:18:32,600
channeling fear F then we're
going to need to deploy our

16019
16:18:32,600 --> 16:18:35,960
contract using the sub ID, we're
going to need to register the

16020
16:18:35,960 --> 16:18:39,560
contract with chain link VRF.
And it's somebody we're going to

16021
16:18:39,590 --> 16:18:42,260
then need to register it with
chain link keepers. And then of

16022
16:18:42,260 --> 16:18:45,140
course, we're going to run the
staging tests. So let's do it.

16023
16:18:45,350 --> 16:18:48,200
So first thing we're going to
need to do is what? Get our sub

16024
16:18:48,200 --> 16:18:51,110
ID for chain link VRF. Okay,
great. So we're going to come

16025
16:18:51,110 --> 16:18:54,920
over to VRF dot chain dot link.
And we're going to need to

16026
16:18:54,920 --> 16:18:58,850
create a new subscription. If we
don't have enough rink B eath.

16027
16:18:58,940 --> 16:19:02,540
Let's we want to head over to
the full blockchain solidity

16028
16:19:02,540 --> 16:19:05,030
course, here, we're going to
scroll down. And we're going to

16029
16:19:05,030 --> 16:19:08,030
look for the recommended test
and here, which is ranked v. And

16030
16:19:08,030 --> 16:19:11,120
we're going to use the faucets
link to get some Rigby link, run

16031
16:19:11,120 --> 16:19:15,410
Fosses dot chain dot link, let's
switch over from COVID to a

16032
16:19:15,410 --> 16:19:18,890
cerium. Rigby, we know we're
going to need some link and some

16033
16:19:18,920 --> 16:19:23,900
eath. So let's just go ahead and
get both. Alright, great now

16034
16:19:23,900 --> 16:19:26,780
that our transaction has gone
through, let's just double check

16035
16:19:26,780 --> 16:19:30,230
our wallet here. And it looks
like we do indeed have Ethereum

16036
16:19:30,230 --> 16:19:33,140
here. And if you don't see the
link, you can head over to link

16037
16:19:33,140 --> 16:19:35,960
token contracts, Link token
contracts in the chain link

16038
16:19:35,960 --> 16:19:39,140
documentation. We'll scroll down
to Rigby, we'll grab this

16039
16:19:39,140 --> 16:19:43,730
contract address import tokens
and we'll paste it in here. Add

16040
16:19:43,730 --> 16:19:48,050
Custom tokens, import tokens.
Great. Now I can see my eath and

16041
16:19:48,050 --> 16:19:51,440
my link here, perfect. We have
some eath we have some link,

16042
16:19:51,560 --> 16:19:53,720
let's head over to V REF
subscription management. And

16043
16:19:53,720 --> 16:19:56,420
we're going to create a new
subscription. Again, we could

16044
16:19:56,420 --> 16:19:58,550
totally do this
programmatically, because the

16045
16:19:58,550 --> 16:20:02,090
user interface here is only
helping us facilitate call

16046
16:20:02,090 --> 16:20:05,450
contracts to the registration
contract that's completely

16047
16:20:05,450 --> 16:20:07,790
decentralized and on chain. So
let's go ahead and create

16048
16:20:07,790 --> 16:20:10,850
subscription will create
subscription will confirm the

16049
16:20:10,850 --> 16:20:14,780
transaction and Metamask on the
Rinkeby network will do a little

16050
16:20:14,780 --> 16:20:17,540
bit of wading in great once it's
gone through, you can go ahead

16051
16:20:17,540 --> 16:20:20,150
and click the add funds button.
I'm going to show you what it

16052
16:20:20,150 --> 16:20:23,360
looks like if you accidentally
refresh and jump off though. So

16053
16:20:23,360 --> 16:20:26,690
if you refresh and you go back
to veer off the chain dot link,

16054
16:20:26,840 --> 16:20:29,870
you should have a new active
subscription. And you'll see

16055
16:20:29,870 --> 16:20:33,410
this number here. If you click
on it, this is your subscription

16056
16:20:33,440 --> 16:20:38,120
ID great. So we can actually
take this, come back to our code

16057
16:20:38,210 --> 16:20:41,900
into our helper Hardhead config.
And we can paste our

16058
16:20:41,900 --> 16:20:45,830
subscription ID under
subscription ID for our Rinkeby

16059
16:20:45,860 --> 16:20:49,040
network here. Awesome. Now that
we have a subscription we can

16060
16:20:49,040 --> 16:20:52,280
see it's not funded with any
link. So we don't have any

16061
16:20:52,280 --> 16:20:55,970
Oracle gas here. And we don't
have any consumers. Right our

16062
16:20:55,970 --> 16:20:59,600
consumer is going to be a raffle
or a lottery contract. So let's

16063
16:20:59,600 --> 16:21:02,240
add some funds first and we
don't need to add A whole lot

16064
16:21:02,240 --> 16:21:05,060
because we're only going to be
testing once. So let's go just

16065
16:21:05,060 --> 16:21:08,240
go ahead and add to link here,
this number might change

16066
16:21:08,240 --> 16:21:10,970
depending on different costs of
the test nets and how much link

16067
16:21:10,970 --> 16:21:13,520
token there's available. So if
you're actually working on a

16068
16:21:13,520 --> 16:21:16,580
main net, be sure to head over
Doc's touching that link EVM

16069
16:21:16,580 --> 16:21:20,210
chains contract addresses, you
can read more about the costs

16070
16:21:20,240 --> 16:21:22,700
some of these different chains,
so you can figure out exactly

16071
16:21:22,700 --> 16:21:25,340
how much to put in here. And if
you go to the full blockchain

16072
16:21:25,340 --> 16:21:29,480
solidity course, Jas, we can
scroll down to Lesson Nine,

16073
16:21:29,510 --> 16:21:32,990
there's a recommended link
amounts or rinky saving tests

16074
16:21:33,080 --> 16:21:35,180
for chain link VRF. For now
we're going to put two for

16075
16:21:35,180 --> 16:21:37,490
keepers, we're going to put
eight, but feel free to refer to

16076
16:21:37,490 --> 16:21:40,160
here so you know how much to put
in. So let's go ahead and

16077
16:21:40,160 --> 16:21:43,340
confirm, we're going to approve
adding funds here, go ahead and

16078
16:21:43,340 --> 16:21:47,270
confirm. And we're now funding
our subscription to so we can

16079
16:21:47,270 --> 16:21:50,300
pay that Oracle gas to get our
random numbers. Great. And once

16080
16:21:50,300 --> 16:21:53,390
we're funded, we can close it,
we'll do a little refresh. And

16081
16:21:53,390 --> 16:21:56,720
we can see the balance is now to
link when we don't have any

16082
16:21:56,720 --> 16:22:00,980
consumers perfect. So we've got
our sub ID, we funded it. Now

16083
16:22:01,010 --> 16:22:05,120
let's go ahead and deploy our
contract. And we already know

16084
16:22:05,450 --> 16:22:08,570
that we should be all good for
deploying our contract, we go to

16085
16:22:08,570 --> 16:22:12,290
our Dotty and V will need to add
all of those same parameters

16086
16:22:12,320 --> 16:22:14,840
from our previous projects,
we'll need to shrink the RPC

16087
16:22:14,840 --> 16:22:18,770
URL, we'll need our private key.
If we want to verify we'll need

16088
16:22:18,770 --> 16:22:22,040
our ether scan API key. And if
we want to do gas output, we'll

16089
16:22:22,040 --> 16:22:25,100
need our coin market cap API
key. So let's make sure we have

16090
16:22:25,100 --> 16:22:28,070
all that. And we'll look at our
deploy script. Once again, just

16091
16:22:28,070 --> 16:22:31,220
real quick look at our helper
hardcat config just real quick,

16092
16:22:31,220 --> 16:22:34,040
and it looks like we do indeed
have everything in here. And we

16093
16:22:34,040 --> 16:22:36,260
should just be able to deploy it
in one command.

16094
16:22:40,369 --> 16:22:44,659
So we should be able to do yarn,
hard hat or just h h again,

16095
16:22:44,839 --> 16:22:51,139
ploy, dash dash network Rinkeby.
Let's go try this out. All

16096
16:22:51,139 --> 16:22:53,569
right, it looks like we've
compiled successfully, we've

16097
16:22:53,569 --> 16:22:57,259
deployed it successfully. And
we've even verified it, we can

16098
16:22:57,259 --> 16:23:00,829
go and open it up on Rinku ether
scan. And we can see our code

16099
16:23:00,829 --> 16:23:04,309
here has been verified. And it's
looking beautiful. We can read

16100
16:23:04,309 --> 16:23:07,009
from it, which is great. We can
see all these commands here now

16101
16:23:07,009 --> 16:23:09,709
that it's verified. And if we
look at the Git raffle state, we

16102
16:23:09,709 --> 16:23:12,319
should indeed see that it's
open, right, and it's going to

16103
16:23:12,319 --> 16:23:16,009
stay open until somebody ends
the raffle and updates the

16104
16:23:16,009 --> 16:23:19,189
amount of eath that the contract
actually has. Now that we've

16105
16:23:19,189 --> 16:23:22,369
deployed a contract using that
sub ID, we need to register the

16106
16:23:22,369 --> 16:23:25,639
contract with chain link V REF.
And with chain link keepers. So

16107
16:23:25,639 --> 16:23:29,659
we need to add this consumer
does tell chinley VRF. Hey, this

16108
16:23:29,659 --> 16:23:31,789
is the contract that you're
looking for now. So we're gonna

16109
16:23:31,789 --> 16:23:34,909
go back to V REF dot chain dot
link, and we're going to grab

16110
16:23:34,909 --> 16:23:38,089
this contract address, and we're
going to add it as a consumer,

16111
16:23:38,149 --> 16:23:40,639
your subscription is ready, you
can now add consumers we're

16112
16:23:40,639 --> 16:23:43,909
gonna add consumer. And again,
this website is just here to

16113
16:23:43,909 --> 16:23:47,059
help facilitate us interacting
with the contract. So we're

16114
16:23:47,059 --> 16:23:49,729
going to approve that user,
we'll go ahead and confirm and

16115
16:23:49,729 --> 16:23:52,189
the transaction is going
through. While we wait for this

16116
16:23:52,189 --> 16:23:56,689
to go through, we can go to
keepers dot chain dot link, and

16117
16:23:56,689 --> 16:23:59,779
do the same thing work with the
user interface to register a new

16118
16:23:59,779 --> 16:24:04,369
upkeep. So we'll go ahead and
add our email Hardhead free code

16119
16:24:04,369 --> 16:24:09,949
camp@gmail.com. We'll call this
raffle upkeep. We'll paste our

16120
16:24:09,949 --> 16:24:13,249
upkeep address in here we have
our admin address, and you can

16121
16:24:13,249 --> 16:24:16,129
ignore this bit right here. For
gas limit, this is going to be

16122
16:24:16,129 --> 16:24:19,399
the gas limit of the PErforM
upkeep function. If we did our

16123
16:24:19,429 --> 16:24:22,399
gas estimator, we could just
check to see how much that

16124
16:24:22,429 --> 16:24:25,069
perform upkeep costs. But for
now, I'm just going to put

16125
16:24:25,099 --> 16:24:29,269
500,000 That's probably
overkill, but that's fine. Check

16126
16:24:29,269 --> 16:24:32,419
data, we're going to keep blank
because again, our checkup keep

16127
16:24:32,419 --> 16:24:35,239
doesn't take anything. And then
starting balance, we're going to

16128
16:24:35,239 --> 16:24:38,479
put as eight. And if you forget
to put a starting balance here,

16129
16:24:38,479 --> 16:24:41,749
you can always find it later. So
let's go ahead and register,

16130
16:24:42,559 --> 16:24:45,649
we're gonna get a Metamask pop
up, we're gonna go ahead and hit

16131
16:24:45,649 --> 16:24:50,029
Confirm. And we can go back to
our VRF and see that it's indeed

16132
16:24:50,029 --> 16:24:53,359
been added and awesome, we now
have a consumer on our VRF. So

16133
16:24:53,359 --> 16:24:55,819
now let's just wait for our
keepers to go through upkeep

16134
16:24:55,819 --> 16:24:59,539
registration requests submitted
successfully on domain net, you

16135
16:24:59,539 --> 16:25:02,239
might actually have to wait a
little bit for your request to

16136
16:25:02,239 --> 16:25:04,819
go through, but I'll test that
it should automatically go

16137
16:25:04,819 --> 16:25:08,509
through. Now if we go back to
keepers dot chain dot link, we

16138
16:25:08,509 --> 16:25:12,409
should now see we now if we
scroll down to my upkeeps We

16139
16:25:12,409 --> 16:25:15,859
have a raffle upkeep here and I
have to because I accidentally

16140
16:25:15,919 --> 16:25:18,439
use the same account that I
tested on, you can ignore the

16141
16:25:18,439 --> 16:25:21,169
two you'll have one but this is
the one that we just created.

16142
16:25:21,289 --> 16:25:24,589
And we can actually see what our
balances and then what the

16143
16:25:24,589 --> 16:25:26,809
minimum balance for this
actually is. So it looks like

16144
16:25:26,839 --> 16:25:30,499
eight Link was a little bit too
low. So let's go back to Fosses

16145
16:25:30,499 --> 16:25:35,959
dot chain dot link slash rinky.
Now that we have some more link,

16146
16:25:35,989 --> 16:25:38,899
we can come back to our raffle
upkeep. And we go ahead and hit

16147
16:25:38,899 --> 16:25:43,009
add funds. And we'll add just
three. And we'll go ahead and

16148
16:25:43,009 --> 16:25:47,239
confirm we first need to give
permission to spend. We approved

16149
16:25:47,239 --> 16:25:50,179
our link transfer now let's
actually transfer the link to

16150
16:25:50,179 --> 16:25:53,569
the contract and alright funds
added successfully. So now let's

16151
16:25:53,569 --> 16:25:56,659
do a little refresh. Now we no
longer see that message saying

16152
16:25:56,659 --> 16:25:59,539
that it's underfunded and we
have our balance and we can see

16153
16:25:59,539 --> 16:26:02,359
that it's more than the minimum
balance. We have See the history

16154
16:26:02,359 --> 16:26:05,509
that we just funded this twice.
Once this actually kicks off,

16155
16:26:05,539 --> 16:26:09,079
we'll see activity type will be
like perform upkeep or something

16156
16:26:09,109 --> 16:26:12,259
got our sub ID, we've deployed
the contract, we've registered

16157
16:26:12,259 --> 16:26:14,389
with chain link V REF, we've
registered it with chain link

16158
16:26:14,389 --> 16:26:18,079
keepers. Now all we need to do
is run the staging tests. Now

16159
16:26:18,079 --> 16:26:20,899
running our staging test is
essentially going to be the same

16160
16:26:20,989 --> 16:26:24,589
as us calling this enter script,
right, because all we're doing

16161
16:26:24,679 --> 16:26:27,349
in our staging test is entering
the lottery. And then we just

16162
16:26:27,349 --> 16:26:29,839
have a whole bunch of validators
that we're running to make sure

16163
16:26:29,839 --> 16:26:33,409
that things are doing as we
expect, since our contract is

16164
16:26:33,409 --> 16:26:37,069
actually verified, what we could
do on Rigby ether scan is we can

16165
16:26:37,069 --> 16:26:39,739
actually go to this right
contract section of the

16166
16:26:39,739 --> 16:26:44,659
contract. And we could even
connect our wallets to it. And

16167
16:26:44,659 --> 16:26:48,079
once this turns from red to
green, after a little refresh,

16168
16:26:48,139 --> 16:26:51,409
we'll now see that it's green,
it's connected, we can even call

16169
16:26:51,409 --> 16:26:55,279
functions on this contract
ourself, so we could enter the

16170
16:26:55,279 --> 16:26:58,309
raffle ourself, we would add,
you know, however much eath to

16171
16:26:58,309 --> 16:27:01,069
enter the raffle, and that would
kick off the keepers in the VRF,

16172
16:27:01,069 --> 16:27:03,889
as well. So we could call it via
ether scan, we could obviously

16173
16:27:03,889 --> 16:27:06,559
call it via our staging tests
here, we could call it via our

16174
16:27:06,559 --> 16:27:09,109
scripts, we could call it via
the console, there's a ton of

16175
16:27:09,109 --> 16:27:12,949
ways to actually do this. But
moment of truth here, we're

16176
16:27:12,949 --> 16:27:15,949
gonna run our staging tests,
which is going to have us enter

16177
16:27:15,949 --> 16:27:19,609
the lottery, and set up a
listener to make sure that

16178
16:27:19,609 --> 16:27:23,089
everything works correctly. And
additionally, we'll see on our

16179
16:27:23,089 --> 16:27:26,839
raffle upkeep history, we'll see
a transaction go through, and

16180
16:27:26,839 --> 16:27:30,769
then we'll see a transaction on
our chain like VRF as well. Are

16181
16:27:30,769 --> 16:27:32,719
you ready? I sure am.

16182
16:27:32,900 --> 16:27:40,250
Let's do this. So we'll do h h,
test, dash dash network, rink B.

16183
16:27:40,400 --> 16:27:43,220
And that should be all we need
to do. In our state and tests,

16184
16:27:43,220 --> 16:27:46,040
we probably should have added
some console dot logs in here to

16185
16:27:46,040 --> 16:27:49,160
tell us hey, to tell us what
steps that we're on with each.

16186
16:27:49,400 --> 16:27:52,640
But we forgot to. So if you
follow along with the repo

16187
16:27:52,640 --> 16:27:55,160
associated with this, we've
added the console dot logs in

16188
16:27:55,160 --> 16:27:58,700
the test there. But all right,
if we go to the ether scan for

16189
16:27:58,700 --> 16:28:01,580
this contract, we go back to the
rink the ether scan for this, we

16190
16:28:01,580 --> 16:28:04,730
paste in that address, the first
step that we're doing in this

16191
16:28:04,730 --> 16:28:08,210
test, of course, while we're
setting up this listener, the

16192
16:28:08,210 --> 16:28:11,210
first transaction is going to be
entering the raffle that's going

16193
16:28:11,210 --> 16:28:13,970
to kick everything off. Right.
So if we refresh a little bit on

16194
16:28:13,970 --> 16:28:17,720
ether scan, we do indeed see
we've entered the raffle. And

16195
16:28:17,720 --> 16:28:22,400
we've updated the balance of the
raffle. Okay, awesome. So raffle

16196
16:28:22,400 --> 16:28:26,600
has been entered. Now then what
happens? Well, if the raffle has

16197
16:28:26,600 --> 16:28:30,140
been entered, if we go to raffle
dot soul, if it's open, if

16198
16:28:30,140 --> 16:28:32,540
enough time has passed, if
there's players and it has a

16199
16:28:32,540 --> 16:28:36,110
balance, which we just checked
does, this will get kicked off

16200
16:28:36,110 --> 16:28:39,530
by the keepers. So if we go to
the keepers, and we do a little

16201
16:28:39,530 --> 16:28:43,190
refresh here, after a little
bit, we do indeed see checkup

16202
16:28:43,190 --> 16:28:46,280
key passed and we see a perform
upkeep having gone through

16203
16:28:46,670 --> 16:28:50,960
great, what does perform upkeep
to well perform upkeep calls the

16204
16:28:50,960 --> 16:28:55,220
chainlink VRF. So now if we go
over to chainlink, VRF, we do a

16205
16:28:55,220 --> 16:28:59,900
refresh here, go down to
history, we do indeed see one of

16206
16:28:59,900 --> 16:29:02,060
the transactions has gone
through we can see the

16207
16:29:02,060 --> 16:29:05,030
transaction hash, the link
spent, etc. And now if we go

16208
16:29:05,030 --> 16:29:08,480
back to our tests, we do indeed
see raffle unit tests for friend

16209
16:29:08,510 --> 16:29:12,830
fulfill random request winner
pick event fired. And this means

16210
16:29:12,830 --> 16:29:16,460
that we just went through this
entire process of having a

16211
16:29:16,460 --> 16:29:20,090
perfectly truly decentralized
raffle work on an actual

16212
16:29:20,090 --> 16:29:22,460
Testament with our integration
tests working correctly.

16213
16:29:22,490 --> 16:29:25,130
Absolutely massive, huge
congratulations if you've made

16214
16:29:25,130 --> 16:29:27,230
it this far. And if you just
walk through the integration

16215
16:29:27,230 --> 16:29:30,320
test with me now bounce over
contract has now been reset to

16216
16:29:30,320 --> 16:29:33,560
zero because our wallet address
just won the lottery right and

16217
16:29:33,560 --> 16:29:36,890
got the money back. Now you
might be wondering, Hey, I see

16218
16:29:36,890 --> 16:29:40,580
the Create raffle function. And
I see enter raffle but I don't

16219
16:29:40,580 --> 16:29:43,550
see didn't the chain link nodes
just call perform upkeep and

16220
16:29:43,550 --> 16:29:46,880
fulfill random words, I'll come
no matter how often I refresh, I

16221
16:29:46,880 --> 16:29:49,430
don't see those transactions
here. Well, those are actually

16222
16:29:49,430 --> 16:29:52,730
going to be considered internal
transactions fulfill random

16223
16:29:52,730 --> 16:29:55,910
words, it's actually called
through the VRF coordinator and

16224
16:29:55,910 --> 16:29:59,510
the VRF coordinator contract
then calls for full randomness.

16225
16:29:59,840 --> 16:30:03,320
So we can go to internal
transactions. And one of these

16226
16:30:03,320 --> 16:30:06,110
transactions is going to be the
transaction to the VRF

16227
16:30:06,110 --> 16:30:10,220
coordinator contract, which
calls our contract. Same thing

16228
16:30:10,220 --> 16:30:13,580
with perform upkeep. Perform
upkeep, the chain link nodes

16229
16:30:13,580 --> 16:30:16,190
actually call through the
registry contract and then the

16230
16:30:16,190 --> 16:30:19,370
registry contract calls perform
upkeep. That's what we see here.

16231
16:30:19,550 --> 16:30:22,070
And if we go through the
internal transactions, we'll see

16232
16:30:22,070 --> 16:30:25,490
him there. Now let's look at
this enter raffle as well. And

16233
16:30:25,490 --> 16:30:28,880
since we've learned about events
and logs, we can actually go to

16234
16:30:28,910 --> 16:30:33,680
the logs section now. And we can
see our log or event being

16235
16:30:33,710 --> 16:30:37,190
emitted here we can see the name
raffle, enter, we can see the

16236
16:30:37,190 --> 16:30:40,610
topic zero which is going to
identify this entire event. And

16237
16:30:40,610 --> 16:30:44,600
then we also see this number
here which is what which is

16238
16:30:44,600 --> 16:30:48,170
index topic, one address player
and then there's no data

16239
16:30:48,170 --> 16:30:50,780
associated with this right
because we only have index

16240
16:30:50,780 --> 16:30:54,770
parameters which again show up
as topics so this is absolutely

16241
16:30:54,770 --> 16:31:01,370
phenomenal. Wow, absolutely
massive and we can rerun a unit

16242
16:31:01,370 --> 16:31:05,600
test Just by hh test in this
will only run our unit tests.

16243
16:31:06,080 --> 16:31:08,600
And we can see that these are
all passing as well, things are

16244
16:31:08,600 --> 16:31:12,590
looking fantastic here. And we
have just successfully created a

16245
16:31:12,620 --> 16:31:17,870
verifiably random, autonomous,
decentralized, raffle and or

16246
16:31:17,870 --> 16:31:21,470
lottery deployed on the
blockchain, you should be so

16247
16:31:21,470 --> 16:31:24,050
excited right now. Now, I'm not
going to show you how to push

16248
16:31:24,050 --> 16:31:26,900
this up to GitHub. However, if
you want to push this up to get

16249
16:31:26,900 --> 16:31:30,020
up, and again, tweet at me,
tweet at chainlink tweet at Free

16250
16:31:30,020 --> 16:31:33,380
Code Camp, please feel free to
do so because you just did an

16251
16:31:33,380 --> 16:31:36,200
amazing job getting this far.
And if you're gonna want to push

16252
16:31:36,200 --> 16:31:38,750
this up to GitHub, remember,
we're going to want to put a dot

16253
16:31:38,750 --> 16:31:42,860
Git ignore. In here, we add a
ton of stuff like that VS code

16254
16:31:42,890 --> 16:31:47,000
artifacts, cash deployments,
known modules, etc. Type chain

16255
16:31:47,000 --> 16:31:51,410
types, all this stuff, you can
find a sample dot Git ignore, of

16256
16:31:51,410 --> 16:31:54,770
course, in the GitHub repo
associated with this, this is an

16257
16:31:54,770 --> 16:31:58,400
advanced project, we did a lot
of really advanced things here.

16258
16:31:58,730 --> 16:32:03,080
And this is the section of the
course, where I think at this

16259
16:32:03,080 --> 16:32:06,320
point, you've got most of the
fundamentals down. And now we're

16260
16:32:06,320 --> 16:32:08,150
going to move into more front
end. And we're going to move

16261
16:32:08,150 --> 16:32:11,210
into more industry specific and
more advanced topics that are

16262
16:32:11,210 --> 16:32:15,230
really going to supercharge you
and make you one of the masters

16263
16:32:15,230 --> 16:32:17,600
of the blockchain in the smart
contract realm. So huge

16264
16:32:17,600 --> 16:32:20,120
congratulations, one more time,
definitely go celebrate,

16265
16:32:20,120 --> 16:32:22,550
definitely go for that walk,
take a quick break, let

16266
16:32:22,550 --> 16:32:25,760
everything we just learned
settling your brain and get

16267
16:32:25,760 --> 16:32:26,810
ready for the next one.

16268
16:32:39,980 --> 16:32:43,130
Alright, now we're gonna go over
the TypeScript edition of this

16269
16:32:43,130 --> 16:32:46,010
lesson, we're gonna go a little
bit quickly here, because we're

16270
16:32:46,010 --> 16:32:49,250
not learning too much new stuff
for this TypeScript edition. So

16271
16:32:49,340 --> 16:32:51,830
if you want to just follow
along, you can open up the repo

16272
16:32:51,830 --> 16:32:55,460
here and use the TypeScript
branch. One thing to note that

16273
16:32:55,460 --> 16:32:58,070
is a little bit different is
when we do our promise in our

16274
16:32:58,070 --> 16:33:01,460
tests, we're doing a weight
promise void, because we're not

16275
16:33:01,460 --> 16:33:04,070
going to be returning anything
with our promise here. But the

16276
16:33:04,070 --> 16:33:07,370
rest is going to be exactly the
same. We're going to have a hard

16277
16:33:07,370 --> 16:33:10,070
hat dot config to TypeScript
that's going to use imports.

16278
16:33:10,100 --> 16:33:13,940
Once again, everything else is
pretty much the same. We're

16279
16:33:13,940 --> 16:33:17,810
going to export the config like
we did last time. In our package

16280
16:33:17,810 --> 16:33:20,960
dot JSON. Of course, we're going
to have all of our TypeScript

16281
16:33:20,960 --> 16:33:23,900
dependencies as well. And then
our deploy scripts are going to

16282
16:33:23,900 --> 16:33:26,900
follow that same functionality
that we've used before. So now

16283
16:33:26,900 --> 16:33:30,710
our deploy scripts use a type
deploy function on our variables

16284
16:33:30,740 --> 16:33:34,940
that we export at the bottom.
And we also import the hard hat

16285
16:33:34,940 --> 16:33:37,610
runtime environment type, which
where we pull the deployments

16286
16:33:37,610 --> 16:33:40,730
get named account and networks
from in our tests. Of course,

16287
16:33:40,760 --> 16:33:44,270
we're still importing the types
of these contracts from type

16288
16:33:44,270 --> 16:33:47,690
chain slash types, like you see
here, like for example, raffle

16289
16:33:47,690 --> 16:33:51,290
is going to be signed to raffle
VRF coordinator V to mock is

16290
16:33:51,290 --> 16:33:54,500
going to be signed to type VRF
coordinator V to MK and if we

16291
16:33:54,500 --> 16:33:57,260
wanted to deploy with these
contract factories, we could as

16292
16:33:57,260 --> 16:33:59,120
well. So those are going to be
the main differences with

16293
16:33:59,120 --> 16:34:02,030
TypeScript. There's not anything
really new there. But again, if

16294
16:34:02,030 --> 16:34:04,130
you want to follow along with
TypeScript, and you want to code

16295
16:34:04,130 --> 16:34:06,590
everything in TypeScript, and
example is here for you

16296
16:34:10,520 --> 16:34:13,850
All right, welcome back. I hope
your break was absolutely

16297
16:34:13,850 --> 16:34:18,500
fantastic because now we are
getting into more advanced full

16298
16:34:18,500 --> 16:34:21,410
stack slash front end
development. We've done the back

16299
16:34:21,410 --> 16:34:24,170
end development, we've created
smart contracts, we created our

16300
16:34:24,170 --> 16:34:28,670
lottery. In our last section, we
have all this wonderful code

16301
16:34:28,670 --> 16:34:32,360
that allows us to work with our
own provably decentralized

16302
16:34:32,390 --> 16:34:35,330
lottery. In order for regular
everyday people to use our

16303
16:34:35,330 --> 16:34:39,020
lottery, we're going to need to
build a front end. Now

16304
16:34:39,020 --> 16:34:42,350
previously, we learned to build
a front end with raw HTML

16305
16:34:42,380 --> 16:34:46,100
JavaScript, with our Funmi
project, we created a front end

16306
16:34:46,100 --> 16:34:49,190
with just pure HTML and
JavaScript, just creating

16307
16:34:49,190 --> 16:34:51,830
applications with HTML and
JavaScript is great. And if

16308
16:34:51,830 --> 16:34:55,070
that's what you want to do, you
absolutely can. But doing it

16309
16:34:55,070 --> 16:34:58,580
with those vanilla protocols has
some limitations. And working

16310
16:34:58,580 --> 16:35:00,500
with a framework, like what
we're going to be working with

16311
16:35:00,500 --> 16:35:04,010
in this section is going to make
our lives a lot easier, we're

16312
16:35:04,010 --> 16:35:06,890
going to be able to develop
quicker, have more

16313
16:35:06,890 --> 16:35:10,610
functionality, and do more in
less time. As you remember back

16314
16:35:10,610 --> 16:35:13,760
to the project wasn't really a
fleshed out project, if you

16315
16:35:13,760 --> 16:35:16,490
remember, it was just a bunch of
buttons. And that was really it.

16316
16:35:16,490 --> 16:35:19,910
So working with a framework is
really going to enable us to put

16317
16:35:19,940 --> 16:35:23,510
more features and add more
styling to our applications

16318
16:35:23,690 --> 16:35:27,350
really easy. Once again, the
code for this entire section is

16319
16:35:27,350 --> 16:35:30,290
located in our lesson and is
located in this GitHub

16320
16:35:30,290 --> 16:35:33,410
repository associated with the
course. Now I have to put an

16321
16:35:33,410 --> 16:35:36,980
asterisk here, as I've said many
times, the front end sections of

16322
16:35:36,980 --> 16:35:39,860
this course are not required,
we're not going to learn

16323
16:35:39,860 --> 16:35:43,340
anything new about the back end
in this front end section. So if

16324
16:35:43,340 --> 16:35:45,650
you don't care about building
websites, all you want to do is

16325
16:35:45,650 --> 16:35:49,100
learn the smart contract aspect
of this course, you can skip

16326
16:35:49,130 --> 16:35:51,380
these sections. But if you do
want to learn how to build these

16327
16:35:51,410 --> 16:35:55,490
front end applications, if you
do want to give users and non

16328
16:35:55,490 --> 16:35:57,680
developers the abilities to
interact with our smart

16329
16:35:57,680 --> 16:36:00,860
contracts, then please continue
to watch. Now I also have to put

16330
16:36:00,860 --> 16:36:03,290
an asterix here, because if you
haven't worked with some of

16331
16:36:03,290 --> 16:36:06,680
these frameworks before, the
learning curve can seem a little

16332
16:36:06,680 --> 16:36:09,500
bit steep. And as I've said many
times, this isn't going to be a

16333
16:36:09,500 --> 16:36:12,050
front end course that would take
several more hours than what we

16334
16:36:12,050 --> 16:36:14,840
want to do for this video. So if
you've never done front end

16335
16:36:14,840 --> 16:36:17,660
before, this is one of the
sections where I do recommend

16336
16:36:18,020 --> 16:36:21,110
you follow along with one of
these optional sub lessons,

16337
16:36:21,110 --> 16:36:23,330
we're not going to play them
here. But if you follow along

16338
16:36:23,330 --> 16:36:25,520
with one of these sub lessons,
that will definitely be

16339
16:36:25,520 --> 16:36:28,100
incredibly helpful. One of the
videos that I have for the sub

16340
16:36:28,100 --> 16:36:31,880
lessons is this video right
here, how to connect your smart

16341
16:36:31,880 --> 16:36:35,420
contracts to Metamask. And it
shows a number of ways

16342
16:36:35,420 --> 16:36:37,880
connecting your smart contracts
and building kind of these these

16343
16:36:37,880 --> 16:36:41,360
front ends. It does start with a
raw HTML and JavaScript edition.

16344
16:36:41,360 --> 16:36:44,090
So you can really get some more
practice in here with HTML and

16345
16:36:44,090 --> 16:36:47,660
JavaScript. And then it moves to
index js ethers and a few other

16346
16:36:47,660 --> 16:36:50,720
next Jas based applications.
Doing it a few different ways

16347
16:36:50,720 --> 16:36:53,450
will install a new some more
insight on what you should be

16348
16:36:53,450 --> 16:36:56,120
thinking about when you're
approaching these. So this is

16349
16:36:56,120 --> 16:36:59,000
absolutely a video to watch if
you're new to front end

16350
16:36:59,000 --> 16:37:01,610
development. Additionally, for
this section, like I said, we're

16351
16:37:01,610 --> 16:37:03,950
going to be using a framework.
And in particular, we're going

16352
16:37:03,950 --> 16:37:07,850
to be using the next Jas
framework. Now. Next, Jas is a

16353
16:37:07,850 --> 16:37:11,210
react based framework. React is
a framework for building front

16354
16:37:11,210 --> 16:37:14,960
end and full stack applications.
Next, Jas is a framework on top

16355
16:37:14,990 --> 16:37:17,870
of the React framework. So if
you already know react, most of

16356
16:37:17,870 --> 16:37:20,840
this is going to come very
naturally to the reason that

16357
16:37:20,840 --> 16:37:24,740
we're using React in next Jas is
because React is easily as of

16358
16:37:24,740 --> 16:37:27,590
right now one of the most
popular frameworks and languages

16359
16:37:27,590 --> 16:37:30,350
out there. And it's no surprise
why we've got a little article

16360
16:37:30,350 --> 16:37:33,440
in the GitHub repo titled Why
you should use React js for web

16361
16:37:33,440 --> 16:37:36,230
development, which we'll go into
a little bit more. Some of the

16362
16:37:36,230 --> 16:37:38,960
biggest applications like
Facebook and Instagram use React

16363
16:37:38,960 --> 16:37:42,860
js and a number of other Fortune
500 companies and React js

16364
16:37:42,890 --> 16:37:46,130
especially in the blockchain
space is easily the most popular

16365
16:37:46,160 --> 16:37:49,730
with protocols like uniswap, and
Avi also using React Jas. Now

16366
16:37:49,730 --> 16:37:53,600
the reason we're using this next
Jas on top of React Jas is that

16367
16:37:53,720 --> 16:37:58,070
next Jas, I think makes working
with react much easier. And I

16368
16:37:58,070 --> 16:38:01,250
want us to work with the easiest
and most powerful framework out

16369
16:38:01,250 --> 16:38:04,880
there. Next, Jas is also getting
a ton of steam has some really

16370
16:38:04,880 --> 16:38:08,960
advanced but in my mind easier
to use features than just raw

16371
16:38:09,050 --> 16:38:11,330
react. Now, like I said, if
you've never worked with React

16372
16:38:11,330 --> 16:38:14,270
before, if you've never worked
with next Jas before, and you

16373
16:38:14,270 --> 16:38:16,730
want to do a little brush up,
definitely watch my video six

16374
16:38:16,730 --> 16:38:19,460
ways to connect your depth to a
wallet. And if you find yourself

16375
16:38:19,460 --> 16:38:21,650
struggling with with this
section, because the front end

16376
16:38:21,650 --> 16:38:25,190
stuff doesn't really make sense.
We also have a next Jas crash

16377
16:38:25,190 --> 16:38:27,740
course in the GitHub repo
associated with this course.

16378
16:38:28,040 --> 16:38:30,890
It's about an hour long and it
is absolutely phenomenal. Free

16379
16:38:30,890 --> 16:38:34,460
Code Camp also has some next Jas
crash courses. So if you're

16380
16:38:34,460 --> 16:38:37,340
struggling with the front of it,
go take it next Jas course, and

16381
16:38:37,340 --> 16:38:40,190
then come back to this section
or skip the front end sections

16382
16:38:40,190 --> 16:38:42,890
all together, do the rest of the
course of just the back end, and

16383
16:38:42,890 --> 16:38:45,050
then come back and do these
front end sections. We're going

16384
16:38:45,050 --> 16:38:48,350
to show you the cutting edge
ways to interact and work with

16385
16:38:48,350 --> 16:38:51,170
your front end and then also
deploy them. And if you follow

16386
16:38:51,170 --> 16:38:53,360
along correctly, by the end of
this, you'll have a website

16387
16:38:53,360 --> 16:38:56,480
deployed that you can show off
and you can send a link of it to

16388
16:38:56,510 --> 16:38:59,450
your friends. And now I know we
already showed you what this

16389
16:38:59,450 --> 16:39:01,880
looks like but I'm going to show
you it one more time just so we

16390
16:39:01,880 --> 16:39:04,460
can walk through and see exactly
what we're doing. So we're going

16391
16:39:04,460 --> 16:39:07,250
to have this decentralized
lottery where we can go ahead

16392
16:39:07,250 --> 16:39:10,550
with can connect our wallet if
not already connected. And we

16393
16:39:10,550 --> 16:39:13,880
can switch, we can switch around
between networks. And our app

16394
16:39:13,880 --> 16:39:16,940
will actually recognize it and
say, hey, the only supported

16395
16:39:16,940 --> 16:39:20,240
chains that we're working with
here are going to be 31337,

16396
16:39:20,270 --> 16:39:23,870
which is localhost, or four,
which is ring feed. And we'll

16397
16:39:23,870 --> 16:39:26,870
learn how to add this validation
into our application so that our

16398
16:39:26,870 --> 16:39:30,920
app only works when we're on a
chain that we want, then we can

16399
16:39:30,920 --> 16:39:33,920
go ahead and interact with it.
Normally, we can click a button

16400
16:39:33,920 --> 16:39:36,710
Metamask will pop up, we can go
ahead and confirm we'll get a

16401
16:39:36,710 --> 16:39:39,560
little transaction notification
saying that transaction is

16402
16:39:39,560 --> 16:39:43,340
complete. And we'll get our
front end updated. And then on

16403
16:39:43,340 --> 16:39:46,040
the back end, we'll be able to
see the chain link nodes and the

16404
16:39:46,040 --> 16:39:49,130
Chinuch V REF do their work. And
once they actually pick a

16405
16:39:49,130 --> 16:39:52,880
winner, after a refresh, we'll
be able to see that the back end

16406
16:39:52,910 --> 16:39:56,750
node was updated, we do indeed
have a previous winner. Awesome.

16407
16:39:56,960 --> 16:39:59,600
Now, not only that, we're going
to show you how to build this,

16408
16:39:59,600 --> 16:40:04,130
but also, we're going to show
you how to host it on an actual

16409
16:40:04,160 --> 16:40:07,790
site. So you'll be able to push
it up to your own blockchain.

16410
16:40:07,790 --> 16:40:11,510
And additionally, we're gonna
host it in a decentralized

16411
16:40:11,510 --> 16:40:14,090
context. So this site that we
have here is it's going to be

16412
16:40:14,090 --> 16:40:18,260
hosted on a technology that
allows us to host websites in

16413
16:40:18,260 --> 16:40:21,290
decentralized contexts as well
swore backends. And even our

16414
16:40:21,290 --> 16:40:25,580
front ends can be hosted in
decentralized context. So So I

16415
16:40:25,580 --> 16:40:27,860
hope you're incredibly excited
for this because we're going to

16416
16:40:27,860 --> 16:40:31,700
be showing you the cutting edge
tools that many of the top

16417
16:40:31,700 --> 16:40:35,030
blockchain projects use. And
let's just jump right into it.

16418
16:40:37,790 --> 16:40:40,400
Now, I'm currently in the
Hardhead smart contract lottery

16419
16:40:40,400 --> 16:40:43,280
project, the project that we
just did, we did this hard hat

16420
16:40:43,280 --> 16:40:45,410
smart contract lottery, which is
great. What we're going to do

16421
16:40:45,410 --> 16:40:48,470
now is we're going to create a
new folder, although we are

16422
16:40:48,470 --> 16:40:51,260
going to be coming back to this
folder from time to time to make

16423
16:40:51,290 --> 16:40:53,930
a couple of updates. So if you
want to keep it open, you

16424
16:40:53,930 --> 16:40:56,930
absolutely can. But for me, I'm
gonna go ahead and CD download

16425
16:40:56,930 --> 16:41:00,050
directory to kind of my main
directory for this whole course.

16426
16:41:00,440 --> 16:41:05,510
And we're going to create a new
directory called next Jas. smart

16427
16:41:05,510 --> 16:41:11,990
contract. Lottery, FCC, then
we're going to cd into next Jas

16428
16:41:11,990 --> 16:41:15,050
smart contract lottery FCC, and
go ahead and hit code period.

16429
16:41:15,320 --> 16:41:17,960
And like I said, if you want to
keep that one up and have this

16430
16:41:17,960 --> 16:41:21,200
new folder up, you absolutely
can. But basically, again, we're

16431
16:41:21,200 --> 16:41:24,500
just opening up our VS code in
this next Jas smart contract

16432
16:41:24,500 --> 16:41:27,200
lottery folder. Now for this
front end stuff, in particular,

16433
16:41:27,230 --> 16:41:30,020
if you want to be absolutely
sure you're using the same

16434
16:41:30,020 --> 16:41:33,080
versions as I am, what you can
do is you can git clone this

16435
16:41:33,080 --> 16:41:37,310
repo, and then copy the yarn dot
lock and package dot JSON, and

16436
16:41:37,310 --> 16:41:40,250
then run yarn, this will make
sure you're always using the

16437
16:41:40,250 --> 16:41:43,880
exact same packages that I'm
using, and you'll never run into

16438
16:41:43,880 --> 16:41:46,730
any weird issues. So if you do
run into an issue, one of the

16439
16:41:46,730 --> 16:41:49,520
first things to do, especially
for these front end parts is to

16440
16:41:49,520 --> 16:41:53,660
go back, make sure you have the
exact same yarn dot lock and

16441
16:41:53,660 --> 16:41:56,690
package that JSON that I do in
my examples here, and go from

16442
16:41:56,690 --> 16:41:59,630
there. Now we're here in our
front end project. And we're

16443
16:41:59,630 --> 16:42:02,900
going to create a website, we're
gonna create a front end for

16444
16:42:02,900 --> 16:42:05,660
application, like I said, we're
gonna be using next Jas, if you

16445
16:42:05,660 --> 16:42:08,240
want to follow along with the
next Jas documentation here,

16446
16:42:08,330 --> 16:42:10,730
they do have a great getting
started and walking through

16447
16:42:10,730 --> 16:42:17,420
this. So for us, we're going to
do yarn, create next app, and

16448
16:42:17,420 --> 16:42:19,880
then put a little period saying
we want our next app in this

16449
16:42:19,880 --> 16:42:22,370
directory. If you don't put this
period, it'll create it in a new

16450
16:42:22,370 --> 16:42:26,420
folder, and you'll have double
folders. Okay, awesome. So and

16451
16:42:26,420 --> 16:42:29,990
once we do this, in our little
files explorer section, we now

16452
16:42:29,990 --> 16:42:34,430
can see all the different files
that come boilerplate with this.

16453
16:42:34,490 --> 16:42:36,620
Now, let me just do a quick
walkthrough of what's going on

16454
16:42:36,620 --> 16:42:39,440
here. Again, we also go through
this in those two videos that I

16455
16:42:39,440 --> 16:42:42,470
recommended, but it doesn't hurt
to go over it twice. So node

16456
16:42:42,470 --> 16:42:44,900
modules, of course, is going to
be the package in the

16457
16:42:44,900 --> 16:42:47,780
installations pages is going to
be the different pages on our

16458
16:42:47,780 --> 16:42:50,720
site. Let me let me show you
what I mean by this. To run this

16459
16:42:50,720 --> 16:42:54,890
whole thing. Actually, we can
just run yarn, run Dev, and

16460
16:42:54,890 --> 16:42:57,890
we'll get started server on
blah, blah, blah, blah, blah,

16461
16:42:58,220 --> 16:43:01,670
you can command click it or copy
paste it into your browser. And

16462
16:43:01,670 --> 16:43:05,360
now you'll see on localhost
3000, we have our page up here.

16463
16:43:05,510 --> 16:43:09,410
Now what we can do, actually, so
index.js is going to be our

16464
16:43:09,410 --> 16:43:12,560
default page, which is, you
know, considered this slash

16465
16:43:12,560 --> 16:43:16,160
here. But what we can do is we
can create new pages. So I could

16466
16:43:16,160 --> 16:43:21,080
do new file, you know, dog dot
Jas. And then you know, just

16467
16:43:21,080 --> 16:43:25,100
copy paste index into dog to
Jas, paste it, delete everything

16468
16:43:25,100 --> 16:43:27,200
inside the div, you don't have
to follow along here and just go

16469
16:43:27,200 --> 16:43:34,310
Hi, save this, go back here. I
can now put in dog and get this.

16470
16:43:34,550 --> 16:43:37,490
So pages is going to be all kind
of these different routes to

16471
16:43:37,490 --> 16:43:40,700
these different spots on our
website. And index is going to

16472
16:43:40,700 --> 16:43:44,030
be our default, kind of like our
homepage. So I'm going to delete

16473
16:43:44,030 --> 16:43:47,210
Dardo. And inside these files is
going to be something called

16474
16:43:47,240 --> 16:43:51,890
react syntax or JSX. They come
as Jas but they're basically

16475
16:43:51,890 --> 16:43:54,860
reacts in text. Next, Jas is
based on React, you'll see these

16476
16:43:54,860 --> 16:43:59,960
pages are this weird combination
of both JavaScript and HTML. We

16477
16:43:59,960 --> 16:44:02,900
see some import stuff at this at
the top, which reminds us of

16478
16:44:02,900 --> 16:44:06,410
JavaScript and again, you'll see
some important stuff at the top

16479
16:44:06,440 --> 16:44:11,690
and then down here, you'll See,
like div head main h1 P, you'll

16480
16:44:11,690 --> 16:44:15,710
see all these like HTML tags
react index js allow us to do

16481
16:44:15,710 --> 16:44:20,540
this combination of JavaScript
and HTML. And it actually makes

16482
16:44:20,540 --> 16:44:24,050
life a lot easier. Now, you'll
also notice we're doing imports

16483
16:44:24,050 --> 16:44:27,830
in here. Remember, I told you
all this earlier, imports work

16484
16:44:27,860 --> 16:44:31,370
with our front end require does
not. So that's some of the

16485
16:44:31,370 --> 16:44:35,300
difference between node does not
equal JavaScript, right? This is

16486
16:44:35,300 --> 16:44:37,700
where the differences can start
getting a little bit confusing.

16487
16:44:37,700 --> 16:44:40,580
But the way that I usually like
to think about it is I just say,

16488
16:44:40,670 --> 16:44:45,410
no JS, excuse me, I'll just say
back end. I can J S is a little

16489
16:44:45,470 --> 16:44:49,250
different from front end. Yes.
So back end, Jas and front end

16490
16:44:49,250 --> 16:44:51,260
Jas are a little bit different.
That's kind of the way I like to

16491
16:44:51,260 --> 16:44:54,500
think about it. app.js is going
to be our entry point for

16492
16:44:54,530 --> 16:44:58,010
everything the way react and
next Jas work is everything is

16493
16:44:58,010 --> 16:45:01,670
what's called component based in
all of our files here, you're

16494
16:45:01,670 --> 16:45:05,930
gonna see this export default
function home or something along

16495
16:45:05,930 --> 16:45:10,400
those lines. What react and next
Jas do is they say, Hey, this

16496
16:45:10,400 --> 16:45:15,530
huge clump of HTML stuff that
has a hodgepodge of JavaScript

16497
16:45:15,530 --> 16:45:19,910
inside of it is considered a
component. And so all of our

16498
16:45:19,910 --> 16:45:24,230
pages get wrapped through this
underscore app.js page. So this

16499
16:45:24,230 --> 16:45:27,050
is a page but it's kind of like
the main entry point. And they

16500
16:45:27,050 --> 16:45:31,340
get stuck into this component
section of our app that Jas so

16501
16:45:31,340 --> 16:45:34,250
you can think of this on this
graph. The GS is kind of the

16502
16:45:34,250 --> 16:45:38,840
whole application or whole front
end. And on this homepage, this

16503
16:45:38,840 --> 16:45:41,660
component, we're sticking index
dot j s right in here, we're

16504
16:45:41,660 --> 16:45:44,990
swapping out component for index
dot J. S. Now API is what we

16505
16:45:44,990 --> 16:45:50,150
wanted to do if we wanted to do
like some HTTP, GET HTTP POST

16506
16:45:50,150 --> 16:45:52,670
requests, but we're not going to
do any of that. So we're going

16507
16:45:52,670 --> 16:45:55,940
to pretty much ignore API for
now public is just going to be

16508
16:45:56,000 --> 16:46:00,020
some public images like a
favicon or Versaille, that SVG

16509
16:46:00,170 --> 16:46:05,150
styles is going to be the CSS
for our project. CSS stands for

16510
16:46:05,150 --> 16:46:08,630
Cascading Style Sheets. And it's
basically a way to style your

16511
16:46:08,630 --> 16:46:11,720
HTML, we're going to change the
way we do styling and a little

16512
16:46:11,720 --> 16:46:14,780
bit, but that's basically what
these both do the ESLint I'm

16513
16:46:14,780 --> 16:46:17,450
dumping this right now we have
our dot Git ignore which we know

16514
16:46:17,450 --> 16:46:21,230
what it does. We have our next
dot config dot J. S. This is a

16515
16:46:21,230 --> 16:46:24,530
configuration file or next. Jas,
of course, we have our package

16516
16:46:24,560 --> 16:46:28,460
json, we have a readme, and we
have our yarn dot lock. So most

16517
16:46:28,460 --> 16:46:31,250
of what we're going to do is
actually going to be inside this

16518
16:46:31,250 --> 16:46:34,040
Pages folder. And we're also
going to create a couple other

16519
16:46:34,040 --> 16:46:37,370
folders that are going to be our
main stuff now, because I'm me,

16520
16:46:37,400 --> 16:46:39,590
and like I said, I love working
with prettier, I'm going to

16521
16:46:39,590 --> 16:46:43,190
automatically dump a prettier
RC, and a prettier ignore in

16522
16:46:43,190 --> 16:46:46,520
here, just so that I can format
my code a little bit nicer, you

16523
16:46:46,520 --> 16:46:49,640
can grab your prettier RC from
our last projects, you can grab

16524
16:46:49,640 --> 16:46:53,300
your prettier ignore as well. Or
you can just pause me right now

16525
16:46:53,300 --> 16:46:55,850
copy, paste them from the GitHub
repo associated with this

16526
16:46:55,850 --> 16:46:59,330
lesson, paste them in, and then
we'll do yarn, add dash dash

16527
16:46:59,330 --> 16:47:02,990
Dev, prettier, so that we can
auto format all of our code for

16528
16:47:02,990 --> 16:47:06,020
come back over to here, we can
save and boom, stuff gets auto

16529
16:47:06,020 --> 16:47:08,330
formatted. Now, again, we're
going to be using the multi

16530
16:47:08,330 --> 16:47:11,930
terminal feature. So right now I
have one running my front end.

16531
16:47:11,960 --> 16:47:14,270
So if I come back to the front
end, I hit refresh. It's still

16532
16:47:14,270 --> 16:47:16,940
running. And then I have one to
do, you know my scripts and

16533
16:47:16,940 --> 16:47:19,940
stuff. We have yarn run dev
running right now. And if we go

16534
16:47:19,940 --> 16:47:23,960
to our package, JSON, running
yarn, run dev just runs next

16535
16:47:23,960 --> 16:47:27,860
Dev. And actually, let me cancel
it and just do yarn dev yarn is

16536
16:47:27,860 --> 16:47:30,620
actually smart enough that don't
need to do run Dev, but it just

16537
16:47:30,620 --> 16:47:34,730
runs next Dev. And this next
command comes built in once we

16538
16:47:34,730 --> 16:47:37,970
installed next, which we did
when we did yarn create next

16539
16:47:37,970 --> 16:47:40,850
app. So next Jas comes with
these scripts already built in

16540
16:47:40,880 --> 16:47:45,020
for us, we want to build our
front end to enable people to

16541
16:47:45,020 --> 16:47:48,050
interact with our lottery in a
fair way, and connect with the

16542
16:47:48,050 --> 16:47:51,020
smart contract that's running.
Let's create some simple front

16543
16:47:51,020 --> 16:47:53,450
end pieces for this. So first
thing we're gonna do is we're

16544
16:47:53,450 --> 16:47:56,990
gonna go to Pages, and we're
going to go to index.js. All

16545
16:47:56,990 --> 16:48:00,140
this stuff in here is cute and
nice. And thank you next, Jas,

16546
16:48:00,140 --> 16:48:03,350
but we're going to delete it all
and delete everything except for

16547
16:48:03,350 --> 16:48:05,870
that headpiece, we're gonna
leave that up, we're just going

16548
16:48:05,870 --> 16:48:08,930
to change the name. But this way
down here, we're going to change

16549
16:48:08,930 --> 16:48:15,380
the name from Crate next app to
smart contract lottery or raffle

16550
16:48:15,380 --> 16:48:19,700
or whatever we want to do.
description will be our smart

16551
16:48:19,730 --> 16:48:23,360
contract, lottery. And then
right below the head, we're

16552
16:48:23,360 --> 16:48:28,490
going to write hello, blue, and
save. And if we look at our

16553
16:48:28,490 --> 16:48:31,850
front end, we now see that it
says smart contract lottery and

16554
16:48:31,850 --> 16:48:33,620
the top and I'm going to move
this all the way over here,

16555
16:48:33,800 --> 16:48:37,070
smart contract lottery and the
top and we see Hello, so smart

16556
16:48:37,070 --> 16:48:39,680
contract lottery. Hello, the
description here, we're not

16557
16:48:39,680 --> 16:48:41,930
going to see this is going to be
something that web scrapers and

16558
16:48:41,930 --> 16:48:42,860
stuff we're going to find.

16559
16:48:45,380 --> 16:48:48,110
Now one of the first things that
we're going to need to do is

16560
16:48:48,110 --> 16:48:50,690
we're going to need to create
that connect button. We've done

16561
16:48:50,690 --> 16:48:53,600
this in the past with raw
JavaScript, but now we're going

16562
16:48:53,600 --> 16:48:57,350
to do it with next js and react.
The one that we made previously

16563
16:48:57,350 --> 16:49:00,470
was pretty minimalistic. In
fact, we bring it back up it

16564
16:49:00,470 --> 16:49:03,320
checked to see if there was
windows that Aetherium and then

16565
16:49:03,320 --> 16:49:06,080
went and requested and connected
and said okay, cool. You're

16566
16:49:06,080 --> 16:49:09,560
connected. Now what did didn't
do was a lot of things that we

16567
16:49:09,560 --> 16:49:13,130
would want an application to do.
When we change networks, our

16568
16:49:13,130 --> 16:49:15,830
application didn't detect that
when we change users or

16569
16:49:15,830 --> 16:49:19,370
application didn't detect that
it was really stringent in the

16570
16:49:19,370 --> 16:49:22,730
functionality that it actually
had for connecting to a wallet.

16571
16:49:22,730 --> 16:49:25,100
So we're going to make our
wallet connect button,

16572
16:49:25,400 --> 16:49:28,400
incredibly powerful, so that you
can connect with the button, you

16573
16:49:28,400 --> 16:49:30,500
can switch networks, you can
switch accounts, you can pretty

16574
16:49:30,500 --> 16:49:33,470
much do anything in our
application will know our

16575
16:49:33,470 --> 16:49:36,500
application will be responsive.
So that's gonna be one of the

16576
16:49:36,500 --> 16:49:38,300
first things that we're going to
do, we're going to create a

16577
16:49:38,330 --> 16:49:42,290
header and connect button nav
bar one a little navbar here,

16578
16:49:42,290 --> 16:49:45,350
saying, hey, you know, you can
connect with this button. So

16579
16:49:45,350 --> 16:49:47,120
that's gonna be the first thing
that we're going to do. Now we

16580
16:49:47,120 --> 16:49:50,060
can build our whole connect
button in this index dot j s and

16581
16:49:50,060 --> 16:49:52,820
stick it in here. But instead,
what we're going to do is we're

16582
16:49:52,820 --> 16:49:55,520
going to make it a what's called
a component. So we're going to

16583
16:49:55,520 --> 16:49:59,300
create a new folder called
components. And we're going to

16584
16:49:59,300 --> 16:50:03,680
create a new file in here called
header.js. And you might also

16585
16:50:03,680 --> 16:50:08,570
see a lot of people do
header.js x.js and.js x do

16586
16:50:08,600 --> 16:50:11,750
literally the exact same thing,
you can do either one, I'm going

16587
16:50:11,750 --> 16:50:16,400
to do dot JSX, just to remind me
that this is a React file that

16588
16:50:16,400 --> 16:50:18,230
we're creating. This is a
component that we're creating.

16589
16:50:18,230 --> 16:50:21,230
But yeah, you can do J S JSX. If
you want to learn a little bit

16590
16:50:21,230 --> 16:50:24,260
more about components, we've got
a link to learning about

16591
16:50:24,260 --> 16:50:27,290
components. They're basically
independent and reusable bits of

16592
16:50:27,290 --> 16:50:30,230
code. They serve the same
purpose as JavaScript functions,

16593
16:50:30,230 --> 16:50:33,620
but work in isolation and return
HTML. So basically, we're going

16594
16:50:33,620 --> 16:50:37,760
to create like a little chunk of
HTML that we're going to export

16595
16:50:37,970 --> 16:50:40,670
into our index such as like what
we've done in the past, this

16596
16:50:40,670 --> 16:50:43,820
just helps modularize and reuse
this header component, you know,

16597
16:50:43,820 --> 16:50:46,250
across our project. Now, we're
only going to be using our

16598
16:50:46,250 --> 16:50:49,700
header in one area. However,
it's still nice to modularize

16599
16:50:49,700 --> 16:50:52,880
the project regardless. And to
get start, this is going to be

16600
16:50:52,910 --> 16:50:55,370
what's called a functional base
component. So we're going to

16601
16:50:55,370 --> 16:50:59,540
create basically a function
called home write really pretty

16602
16:50:59,540 --> 16:51:02,990
much exactly like what we see in
JavaScript, except it's going to

16603
16:51:02,990 --> 16:51:09,230
return some HTML. So we can do
like a little div. And my VS

16604
16:51:09,230 --> 16:51:12,110
code auto created the closing
div here. And in here, I'm going

16605
16:51:12,110 --> 16:51:15,920
to be like hi from header. This
is going to be a real

16606
16:51:15,920 --> 16:51:19,370
minimalistic component like this
is a valid component here. Now

16607
16:51:19,370 --> 16:51:23,660
we have this function that
returns HTML. And to give other

16608
16:51:23,660 --> 16:51:26,990
applications, the ability to use
this component will do export

16609
16:51:27,110 --> 16:51:32,570
default function home. And then
in our index.js, we can import

16610
16:51:32,570 --> 16:51:36,590
it with imports. Home actually,
excuse me, I'm not going to call

16611
16:51:36,590 --> 16:51:39,290
it home, we're going to call it
header, header, excuse me,

16612
16:51:39,320 --> 16:51:44,210
export default function header,
and then import header from the

16613
16:51:44,210 --> 16:51:49,850
down directory components slash
header, like so. So now we've

16614
16:51:49,850 --> 16:51:53,270
imported our header in index
such as if we go back to our

16615
16:51:53,270 --> 16:51:56,090
front end, which is still
running, we don't see it in

16616
16:51:56,090 --> 16:51:59,420
here, right? Remember,
everything goes through our app.

16617
16:51:59,450 --> 16:52:03,500
And when we're on the slash
page, that's going to go to our

16618
16:52:03,530 --> 16:52:08,000
index.js. index js is importing
our header, but it's not

16619
16:52:08,000 --> 16:52:11,240
returning our header, right, we
see. And here, we see it

16620
16:52:11,240 --> 16:52:15,260
returns. And this is the HTML
that it's returning. And as you

16621
16:52:15,260 --> 16:52:17,330
can see, there's clearly no
header in here. So now that

16622
16:52:17,330 --> 16:52:20,750
we've imported our header, we
need to actually add our header

16623
16:52:20,780 --> 16:52:24,590
in here. So we'll do header, and
then adds the closing tag right

16624
16:52:24,590 --> 16:52:27,320
here. If you don't add any
stuff, you know, in between two

16625
16:52:27,320 --> 16:52:30,710
tags, you can go ahead and just
do this one liner here, with a

16626
16:52:30,710 --> 16:52:34,490
backslash at the end saying,
Hey, this is an open and closed

16627
16:52:34,550 --> 16:52:36,680
tag here. Now that we've
imported it, what do you think

16628
16:52:36,710 --> 16:52:39,530
we'll see on the front end, now
that we've added it to our index

16629
16:52:39,560 --> 16:52:43,790
js, you're right, we see hi from
header, because we added our

16630
16:52:43,790 --> 16:52:46,940
header here. And then we see
Hello. So high from header,

16631
16:52:47,150 --> 16:52:51,470
hello, boom. Now, anything that
we do, obviously now in our

16632
16:52:51,500 --> 16:52:55,130
header.js, will see reflected on
our front end. So we can do hi

16633
16:52:55,130 --> 16:52:58,310
from header, blah, blah, blah,
you know, just a bunch of

16634
16:52:58,310 --> 16:53:00,950
dribbles, and we'll see it on
our front end. So this is going

16635
16:53:00,950 --> 16:53:03,110
to be our section where we're
going to make our header or a

16636
16:53:03,110 --> 16:53:05,720
navbar or all the functionality
for the Connect button. Now I'm

16637
16:53:05,720 --> 16:53:07,700
going to tell you something, and
some of you are going to love

16638
16:53:07,700 --> 16:53:09,950
this summer, you're going to
hate this. I'm going to show

16639
16:53:09,950 --> 16:53:13,760
you. I'm going to show you the
hard way first, then the easy

16640
16:53:13,760 --> 16:53:16,310
way. Why am I going to show you
the hard way first? Well,

16641
16:53:16,340 --> 16:53:18,890
because I want you to become
familiar with what's actually

16642
16:53:18,890 --> 16:53:21,560
going on behind the scenes and
what's actually going on with

16643
16:53:21,560 --> 16:53:23,960
some of these components because
it is really helpful when

16644
16:53:23,960 --> 16:53:26,390
building these front ends to
understand, Okay, here's what's

16645
16:53:26,390 --> 16:53:28,310
going on. If you don't
understand what's going on

16646
16:53:28,310 --> 16:53:30,860
behind the scenes, you're gonna
go to try to build more advanced

16647
16:53:30,860 --> 16:53:33,740
applications, and you're gonna
have no idea what to do because

16648
16:53:33,740 --> 16:53:35,870
you've just learned the
shortcut. I like to think of it

16649
16:53:35,870 --> 16:53:38,510
as like calculus, like we're
going to learn how to calculate

16650
16:53:38,540 --> 16:53:40,400
a derivative first, and then
we're going to learn the

16651
16:53:40,400 --> 16:53:44,030
shortcut to quickly getting
derivatives. So don't skip this

16652
16:53:44,030 --> 16:53:47,750
part, because this is going to
help you well and beyond down

16653
16:53:47,750 --> 16:53:51,170
the line. Okay, we're going to
learn this the harder way to set

16654
16:53:51,170 --> 16:53:55,340
everything up in our HTML Funmi.
We just use raw ethers to kind

16655
16:53:55,340 --> 16:53:58,490
of do everything and you
absolutely can use raw ethers to

16656
16:53:58,490 --> 16:54:01,490
do everything. However, there
are some packages especially for

16657
16:54:01,490 --> 16:54:05,120
React that make life developing
a front end substantially better

16658
16:54:05,150 --> 16:54:08,390
and in our full blockchain
solidity course, Jas. We have a

16659
16:54:08,390 --> 16:54:11,300
number of other packages that
you can use will stack

16660
16:54:11,300 --> 16:54:13,850
development and other libraries.
And if you watch this six ways

16661
16:54:13,850 --> 16:54:15,920
to connect your depth to a
wallet, you'll actually

16662
16:54:15,950 --> 16:54:18,740
understand some of the
differences. So if you haven't

16663
16:54:18,740 --> 16:54:21,350
watched that video, go back,
watch that video. But there's a

16664
16:54:21,350 --> 16:54:24,500
whole bunch of libraries that we
can use that are going to make

16665
16:54:24,500 --> 16:54:27,890
our lives a lot easier. We've
listed some of them here. React

16666
16:54:27,890 --> 16:54:30,530
Morales is the one that we're
going to be using today, they

16667
16:54:30,530 --> 16:54:32,600
have some additional plugins,
and they have probably my

16668
16:54:32,600 --> 16:54:34,610
favorite thing on the planet,
which I'm going to show you how

16669
16:54:34,610 --> 16:54:38,060
to do very soon. But these are
also open source, Ross also

16670
16:54:38,060 --> 16:54:41,270
comes with some optional
functionality to hook into your

16671
16:54:41,300 --> 16:54:44,930
own back end to give your app
even more features and even more

16672
16:54:44,930 --> 16:54:46,940
functionality. And that's the
other reason that we're doing

16673
16:54:46,940 --> 16:54:49,250
it. So and we're gonna go over
that later. And if you want to

16674
16:54:49,250 --> 16:54:52,220
use pure ethers, you absolutely
still can. A lot of these

16675
16:54:52,220 --> 16:54:55,430
packages that we're using do
rely on ethers, but we're not

16676
16:54:55,430 --> 16:54:58,550
going to use just ether. So we
go to the React Morales page.

16677
16:54:58,580 --> 16:55:02,000
And to get started, we can just
do this bit right here. So we're

16678
16:55:02,000 --> 16:55:05,060
literally going to copy this and
bring it into our project. And

16679
16:55:05,060 --> 16:55:08,060
if you go to our package that
JSON, we actually already have

16680
16:55:08,060 --> 16:55:13,280
react and react DOM. So we can
just do yarn, add Morales, and

16681
16:55:13,340 --> 16:55:19,130
react oralis. Now you'll notice
I'm not doing these as dev

16682
16:55:19,130 --> 16:55:23,510
dependencies, I didn't do yarn,
add dash dash dev here. The

16683
16:55:23,510 --> 16:55:26,390
reason is, because for our
production builds, when we

16684
16:55:26,390 --> 16:55:29,540
actually create the website
here, you will need Morales and

16685
16:55:29,540 --> 16:55:33,020
you will need react Morales we
don't need prettier to create a

16686
16:55:33,020 --> 16:55:37,100
website prettier is a tool that
we're using as developers. So in

16687
16:55:37,100 --> 16:55:40,640
all of our projects, so far,
we've been using just dev

16688
16:55:40,640 --> 16:55:43,880
dependencies. That's because
we've only been building our

16689
16:55:43,880 --> 16:55:47,450
projects for developers, our
GitHub repos, they haven't been

16690
16:55:47,480 --> 16:55:50,840
made to build a website, they've
only been to do things on the

16691
16:55:50,840 --> 16:55:53,330
back end, for our website, we're
actually going to be building a

16692
16:55:53,330 --> 16:55:56,630
front end. So we need to put
this in the dependencies

16693
16:55:56,660 --> 16:55:59,510
section, because we need to say,
Hey, these are the ones that we

16694
16:55:59,540 --> 16:56:02,660
need to bundle up together for
the front end, and you can

16695
16:56:02,660 --> 16:56:05,180
ignore these ones. And if it's
just like a tool to make our

16696
16:56:05,180 --> 16:56:07,850
lives better, it's gonna go in
dev dependencies. So we're

16697
16:56:07,850 --> 16:56:11,030
adding Morales and react
Morales. And a lot of the syntax

16698
16:56:11,030 --> 16:56:13,100
that we're going to do for our
header is actually going to be

16699
16:56:13,100 --> 16:56:16,040
really similar to what we've
been seeing so far. So let's do

16700
16:56:16,040 --> 16:56:18,140
this. And then actually, we're
just going to change this name

16701
16:56:18,140 --> 16:56:21,650
to manual header, manual header
update imports for manual

16702
16:56:21,650 --> 16:56:25,700
header, you can go ahead and hit
yes to man you all header here,

16703
16:56:25,850 --> 16:56:28,850
we're gonna copy manual header,
make sure it's in our index.js

16704
16:56:29,360 --> 16:56:31,610
it we're gonna change header to
manual header, and we're gonna

16705
16:56:31,610 --> 16:56:34,640
change how to manual header
here. And the reason we're doing

16706
16:56:34,640 --> 16:56:36,830
this is because like I said,
we're going to create a much

16707
16:56:36,860 --> 16:56:40,250
simpler header after we create
this kind of harder one. And

16708
16:56:40,250 --> 16:56:42,350
we're going to want to create
that connect button, which

16709
16:56:42,350 --> 16:56:46,550
again, we made in HTML Funmi. By
calling eath request accounts,

16710
16:56:46,580 --> 16:56:49,250
what we can do actually with
Morales is we can just do this

16711
16:56:49,250 --> 16:56:53,090
thing called Enable Web three.
So at the top, we're going to

16712
16:56:53,090 --> 16:56:56,060
import, use mirallas.

16713
16:56:57,320 --> 16:57:03,020
From react ralis. And if you go
to the React Morales page here

16714
16:57:03,050 --> 16:57:06,080
or to their GitHub, you'll learn
how to set all this up too and

16715
16:57:06,080 --> 16:57:08,030
learn more about the
documentation. So we're going to

16716
16:57:08,030 --> 16:57:11,840
import use Morales from react
Morales, and inside our function

16717
16:57:11,840 --> 16:57:17,270
here, but outside of our return,
we're going to say const, Enable

16718
16:57:17,270 --> 16:57:23,480
Web three equals use mirallas.
Now use Morales is what's known

16719
16:57:23,510 --> 16:57:27,110
as a hook as a React hook. And
it's a way to keep track of

16720
16:57:27,110 --> 16:57:30,710
state in our application. Now,
in order to use mirallas, our

16721
16:57:30,710 --> 16:57:33,680
entire application needs to be
wrapped around what's called a

16722
16:57:33,680 --> 16:57:37,220
Morales provider, which is going
to be a context provider for us.

16723
16:57:37,520 --> 16:57:39,650
And I'll explain what that means
in a minute. But basically, what

16724
16:57:39,650 --> 16:57:43,280
we need to do is we need to add
this Morales provider to our

16725
16:57:43,280 --> 16:57:49,580
app.js. So in here, we're going
to import oralis provider from

16726
16:57:50,120 --> 16:57:55,310
react oralis. And we're going to
wrap our entire app around this

16727
16:57:55,310 --> 16:57:58,460
Morales provided so we're going
to do some little parentheses

16728
16:57:58,460 --> 16:58:03,140
here. New Line, we're going to
paste morass provider like this,

16729
16:58:04,160 --> 16:58:07,910
it's going to give us the
closing tag, copy it, paste it

16730
16:58:07,910 --> 16:58:12,440
like this and save. And then in
here, we're going to write in

16731
16:58:12,440 --> 16:58:18,980
the sheet allies on Mount equals
false. This initialize on Mount

16732
16:58:19,010 --> 16:58:23,510
piece here is the optionality to
hook into a server to add some

16733
16:58:23,510 --> 16:58:26,330
more features to our website. We
don't want to hook into a server

16734
16:58:26,330 --> 16:58:28,340
for this application, we want
everything just to be open

16735
16:58:28,340 --> 16:58:30,800
source, and we don't need any of
this additional functionality.

16736
16:58:30,980 --> 16:58:33,020
So we're just going to do
initialize on Mount equals

16737
16:58:33,020 --> 16:58:35,600
false. Now that the whole thing
is wrapped in this Morales

16738
16:58:35,600 --> 16:58:38,420
provider, we go to the front end
we should be able to refresh

16739
16:58:38,420 --> 16:58:41,810
everything looks pretty much the
same. And we can start using

16740
16:58:41,840 --> 16:58:47,810
these hooks. Now this use
Morales is what's known as a

16741
16:58:47,840 --> 16:58:51,860
hook and hooks can be a little
bit confusing to understand at

16742
16:58:51,860 --> 16:58:54,980
first glance, but they're
incredibly powerful and they are

16743
16:58:55,010 --> 16:58:58,700
the de facto way for us to build
react projects. And if you're

16744
16:58:58,700 --> 16:59:01,220
familiar with class components,
we're not gonna be using class

16745
16:59:01,220 --> 16:59:04,040
components because hooks are
much better hooks allow function

16746
16:59:04,040 --> 16:59:07,430
components to have access to
state and other react feature

16747
16:59:07,430 --> 16:59:10,160
ers state being probably one of
the biggest ones and the most

16748
16:59:10,160 --> 16:59:13,460
popular ones, we want our
application to be different if

16749
16:59:13,460 --> 16:59:16,670
we're connected to Metamask,
versus if we're not, right, if

16750
16:59:16,670 --> 16:59:20,210
we go back, if we go back to our
example website here, right, if

16751
16:59:20,210 --> 16:59:23,030
we're not connected, we want to
say, Please connect to a wallet.

16752
16:59:23,060 --> 16:59:25,880
And then when we are connected,
we want to go ahead and be

16753
16:59:25,880 --> 16:59:28,880
connected. If I have, let's say,
I have some variable like, and I

16754
16:59:28,880 --> 16:59:32,540
don't have this hook here, I
have like, let connected equals

16755
16:59:32,540 --> 16:59:35,870
false, right, or enable Web
three, or is web three enabled,

16756
16:59:35,870 --> 16:59:38,360
let's say I've led connected
equals false. And then I have,

16757
16:59:38,390 --> 16:59:41,900
you know, let's say have some
button that connects us and

16758
16:59:41,900 --> 16:59:47,210
changes connected to be true,
changing connected to be true is

16759
16:59:47,210 --> 16:59:51,080
great and all but it won't
rerender our application, you

16760
16:59:51,080 --> 16:59:54,560
see, when I disconnect and I
reconnect here, our application

16761
16:59:54,560 --> 16:59:57,800
actually changes based off of
whether or not we're connected.

16762
16:59:57,830 --> 17:00:01,220
And this is what we want, we
want our front end to rerender.

16763
17:00:01,340 --> 17:00:04,850
When we're connected, if I just
use a variable like this inside

16764
17:00:04,850 --> 17:00:08,690
of our component, our front end
isn't going to rerender. Or even

16765
17:00:08,690 --> 17:00:12,080
worse, if I use it outside, our
component doesn't even know

16766
17:00:12,110 --> 17:00:15,800
anything about this changing. So
hooks are a way for us to

16767
17:00:15,800 --> 17:00:19,160
actually work with state
especially and automatically

16768
17:00:19,160 --> 17:00:22,580
rerender when something changes
and enable Web three is going to

16769
17:00:22,580 --> 17:00:25,730
be a function that we get from
this use Morales hook to do

16770
17:00:25,730 --> 17:00:28,250
that. So for a lot of our
components, instead of just

16771
17:00:28,250 --> 17:00:32,840
saying like, let web three
enabled equals true, like we did

16772
17:00:32,870 --> 17:00:35,420
in normal JavaScript, we're
going to be doing a lot of this,

16773
17:00:35,450 --> 17:00:38,690
these hooks. For the most part,
we usually want our website to

16774
17:00:38,690 --> 17:00:42,860
change based off of if some
variable has changed and enabled

16775
17:00:42,860 --> 17:00:46,040
web three is a function that we
get from this hook that says,

16776
17:00:46,070 --> 17:00:48,830
Okay, go ahead and connect
Enable Web three is basically

16777
17:00:48,830 --> 17:00:52,700
the equivalent of saying try
await Aetherium dot request,

16778
17:00:52,970 --> 17:00:55,940
like this. Now enable Web three,
the way we're going to use it

16779
17:00:55,940 --> 17:00:58,640
here only works on Metamask. But
we will show you how to get this

16780
17:00:58,640 --> 17:01:01,730
kind of this cool little module
up where we can choose between

16781
17:01:01,730 --> 17:01:03,080
different ways to connect our
app.

16782
17:01:05,660 --> 17:01:08,390
We have our enabled web three,
let's go ahead and create a

16783
17:01:08,390 --> 17:01:12,290
button, that's going to do the
same as what we did in our HTML

16784
17:01:12,290 --> 17:01:15,590
Funmi in our return, but here,
instead of hi friend header,

16785
17:01:15,650 --> 17:01:17,720
we're going to add a new
component, or we're going to add

16786
17:01:17,720 --> 17:01:20,480
a new tag, we're gonna add the
button tag, and for me it

16787
17:01:20,480 --> 17:01:24,140
automatically close to, and I'm
just gonna call it connect, I'm

16788
17:01:24,140 --> 17:01:26,600
gonna go ahead and save. Now we
see a little button that says

16789
17:01:26,600 --> 17:01:28,730
connect. And obviously, it
doesn't do anything, we're gonna

16790
17:01:28,730 --> 17:01:32,180
give this some functionality,
we're gonna say on click now

16791
17:01:32,180 --> 17:01:37,280
since again, this is a JSX
component. This isn't raw HTML,

16792
17:01:37,400 --> 17:01:41,240
in raw HTML, we can't just kind
of stick JavaScript wherever we

16793
17:01:41,240 --> 17:01:45,200
want. But in JSX files, we can
stick JavaScript kind of

16794
17:01:45,200 --> 17:01:49,070
wherever we want. So inside of
this, inside of this block of

16795
17:01:49,070 --> 17:01:52,700
HTML, we can actually stick
JavaScript in here by adding

16796
17:01:52,700 --> 17:01:55,130
these little brackets. So adding
these little brackets in our

16797
17:01:55,130 --> 17:01:58,370
jobs can return. But here, we
can add JavaScript. And what we

16798
17:01:58,370 --> 17:02:02,510
want to do is we want to have
our On Click Call Enable Web

16799
17:02:02,510 --> 17:02:06,560
three, we're going to call an
async function, we're going to

16800
17:02:06,560 --> 17:02:08,840
use the arrow syntax here, one
click, we're gonna call this

16801
17:02:08,870 --> 17:02:12,860
async function, which is just
going to be await, Enable Web

16802
17:02:12,860 --> 17:02:16,670
three, await Enable Web three,
let's add the little parentheses

16803
17:02:16,670 --> 17:02:19,880
here. And essentially, with just
this, we've done pretty much

16804
17:02:19,910 --> 17:02:23,390
everything that we had back in
this big connect function here.

16805
17:02:23,450 --> 17:02:26,060
Now if we go back to our front
end, do a little refresh, we can

16806
17:02:26,060 --> 17:02:28,970
see that right now, we can see
that I'm actually connected, I'm

16807
17:02:28,970 --> 17:02:31,580
gonna go ahead and disconnect.
I'm still connected from some of

16808
17:02:31,580 --> 17:02:34,640
the last applications I was
doing, we can hit Connect, and

16809
17:02:34,640 --> 17:02:38,180
now we see metamath does indeed
pop up, we'll hit Next connect,

16810
17:02:38,510 --> 17:02:40,970
and boom. And that's all we need
to do. Now, if we look at our

16811
17:02:40,970 --> 17:02:43,880
Metamask, it says connected.
Great. Okay, cool. So now we

16812
17:02:43,880 --> 17:02:46,310
have a way to actually connect
here, let's add some

16813
17:02:46,310 --> 17:02:48,800
functionality and make our
application smart enough to have

16814
17:02:48,800 --> 17:02:51,110
the connect button if we're
connected. And if we're not

16815
17:02:51,110 --> 17:02:54,260
connected, not have that button.
So what we'll do now is use

16816
17:02:54,260 --> 17:02:58,730
Morales comes with another hook
called is web three, enabled,

16817
17:02:58,850 --> 17:03:01,850
which is just a variable part of
our hook that keeps track of

16818
17:03:01,850 --> 17:03:04,790
whether or not our Metamask is
connected. But we can actually

16819
17:03:04,790 --> 17:03:08,240
do one better, we can actually
check to see if there's an

16820
17:03:08,240 --> 17:03:11,900
account because maybe web three
is connected. But but they

16821
17:03:11,900 --> 17:03:15,680
didn't connect it to an account.
So let's go ahead and we'll

16822
17:03:15,770 --> 17:03:19,100
import count from us. Morales
will check to see if there's an

16823
17:03:19,100 --> 17:03:22,580
account. So what we'll do is
inside of our div tags, we'll do

16824
17:03:22,580 --> 17:03:25,250
a little JavaScript, we'll do
that ternary operator again,

16825
17:03:25,340 --> 17:03:28,280
we'll put a count here with a
question mark. And we'll do that

16826
17:03:28,310 --> 17:03:32,060
that same syntax that we've seen
before, we'll say account, if

16827
17:03:32,060 --> 17:03:35,840
account exists, do this. If
there's no account, do this. And

16828
17:03:35,840 --> 17:03:39,260
if there's no account, we want
to add this Connect button. So

16829
17:03:39,260 --> 17:03:42,230
we'll go ahead and we'll stick
this in here. If there is an

16830
17:03:42,230 --> 17:03:45,440
account, we'll just show that
account, right. So we'll do div

16831
17:03:45,560 --> 17:03:50,000
backslash div in here, we'll
just say connected, like that.

16832
17:03:50,150 --> 17:03:53,930
Now if we go back to our front
end, we see connected. If we do

16833
17:03:53,930 --> 17:03:57,470
a little refresh, it'll go away.
So we'll we'll re hit Connect,

16834
17:03:57,500 --> 17:04:00,110
and now we're connected, which
is great. Let's make it even

16835
17:04:00,110 --> 17:04:04,250
smarter. We'll have it show our
account here. So instead of just

16836
17:04:04,250 --> 17:04:08,390
saying connected, we'll say
connected to I'll put some

16837
17:04:08,390 --> 17:04:10,850
JavaScript, we'll put some
JavaScript inside of our

16838
17:04:10,850 --> 17:04:14,240
JavaScript. But since this is
that HTML stuff, we got to use

16839
17:04:14,240 --> 17:04:17,300
these brackets to say JavaScript
again. So we'll put JavaScript

16840
17:04:17,300 --> 17:04:20,540
inside of the JavaScript, we'll
say connected to, we can just

16841
17:04:20,540 --> 17:04:23,810
say account. Now go back to our
front end, we see connected to

16842
17:04:23,840 --> 17:04:25,910
blah, blah, blah, blah, blah,
you'll notice if you hit

16843
17:04:25,910 --> 17:04:28,430
refresh, you'll have to
reconnect, we'll get to that in

16844
17:04:28,430 --> 17:04:30,770
a minute, what a lot of people
do is they'll do a count dot

16845
17:04:30,770 --> 17:04:35,720
slice, zero, comma six. And then
outside of the brackets, they'll

16846
17:04:35,720 --> 17:04:41,180
do dot that dot, another set of
brackets account, that slice,

16847
17:04:42,320 --> 17:04:46,160
count dot length minus four,
close that off like that, we

16848
17:04:46,160 --> 17:04:49,070
have our account, when we hit
Connect, now it says connected

16849
17:04:49,070 --> 17:04:52,760
to blah, blah, blah, hello. And
because of these hooks, when I

16850
17:04:52,760 --> 17:04:56,210
switch accounts, and I connect
with these new accounts, it even

16851
17:04:56,240 --> 17:04:59,600
automatically re renders
switching accounts. So these

16852
17:04:59,600 --> 17:05:02,690
hooks are really good for re
rendering our websites whenever

16853
17:05:02,690 --> 17:05:07,250
some value changes. For example,
if I said like, let count number

16854
17:05:07,340 --> 17:05:10,130
equals seven, and we had a
button, that updated account

16855
17:05:10,130 --> 17:05:13,520
number, our front end wouldn't
rerender unless we told it

16856
17:05:13,520 --> 17:05:16,490
specifically to rerender, which
gets really annoying. So hooks

16857
17:05:16,490 --> 17:05:19,910
kind of help us a lot with doing
that. And it allows us to keep

16858
17:05:19,910 --> 17:05:22,250
track of states between renders.

16859
17:05:24,830 --> 17:05:27,530
Now, here's something that right
now it doesn't do, if I hit

16860
17:05:27,530 --> 17:05:31,160
refresh, I have to re hit this
connect button, even though my

16861
17:05:31,160 --> 17:05:34,040
Metamask says, Hey, we're
connected. But if I refresh, I

16862
17:05:34,040 --> 17:05:36,230
have to re hit this Connect
button. Why is this happening.

16863
17:05:36,380 --> 17:05:39,680
Or when I hit refresh, our
website doesn't know that we've

16864
17:05:39,680 --> 17:05:42,440
hit enable Web three already,
right, because we basically go

16865
17:05:42,440 --> 17:05:45,500
back to blank when I refresh,
and then I have to hit Connect,

16866
17:05:45,530 --> 17:05:48,740
which is really obnoxious and
really annoying. So we want to

16867
17:05:48,770 --> 17:05:52,610
add some functionality, so that
automatically the instant we

16868
17:05:52,610 --> 17:05:55,640
render, we go ahead and we check
to see if we're already

16869
17:05:55,640 --> 17:05:58,730
connected. And if we're
connected to show this. Now to

16870
17:05:58,730 --> 17:06:03,230
do that, we can use another hook
called use effect. And this is a

16871
17:06:03,230 --> 17:06:10,400
core react hook. So we'll do
import use effect from react

16872
17:06:11,270 --> 17:06:15,530
like this. This is a core hook
directly from react. And it's

16873
17:06:15,530 --> 17:06:18,200
one of the most popular out
there along with use state. And

16874
17:06:18,230 --> 17:06:21,140
we've left some links to
learning more about the effect

16875
17:06:21,140 --> 17:06:23,810
hook in the GitHub repo
associated with this course, I'm

16876
17:06:23,810 --> 17:06:27,050
gonna give you my summary of
basically what this use effect

16877
17:06:27,050 --> 17:06:29,360
does, we basically have this
function called use effect,

16878
17:06:29,390 --> 17:06:32,720
which takes two parameters, it
takes a function as its first

16879
17:06:32,720 --> 17:06:36,950
parameter, and then second, it
optionally takes a dependency

16880
17:06:36,980 --> 17:06:40,130
array. And what this use effect
is going to do is it's going to

16881
17:06:40,130 --> 17:06:44,120
keep checking the values in this
dependency array. And if

16882
17:06:44,120 --> 17:06:48,110
anything in this dependency rate
changes, it's going to call some

16883
17:06:48,110 --> 17:06:52,220
function, and then rerender, the
front end. So for example, using

16884
17:06:52,220 --> 17:06:56,300
Morales comes with this function
called is web three enabled or

16885
17:06:56,300 --> 17:06:59,660
this variable called is what
three enabled. If we add this to

16886
17:06:59,660 --> 17:07:03,050
our dependency array, what we
can do in our use effect is do

16887
17:07:03,050 --> 17:07:10,040
console dot log, hi. And then we
can do console dot log is web

16888
17:07:10,040 --> 17:07:13,730
three enabled, what this use
effect is going to be doing is

16889
17:07:13,760 --> 17:07:16,430
it's going to constantly be
running, this is running all the

16890
17:07:16,430 --> 17:07:20,150
time. And it's going to be
listening to see if is web three

16891
17:07:20,150 --> 17:07:23,570
enabled changes, right? And
anytime we run Enable Web three

16892
17:07:23,600 --> 17:07:27,020
is web three enabled becomes
true. So so now if we go to the

16893
17:07:27,020 --> 17:07:31,190
front end, we do a little
refresh, we see high false, high

16894
17:07:31,190 --> 17:07:34,760
false. Now why do we see this
twice is web three enabled only

16895
17:07:34,760 --> 17:07:38,780
changed once? Well, this is
because of how use effect works,

16896
17:07:38,810 --> 17:07:43,490
it will automatically run on
load or right or the first time

16897
17:07:43,580 --> 17:07:48,110
it does and then it'll run
checking the value. So we're

16898
17:07:48,110 --> 17:07:50,720
basically seeing this run twice,
it runs the first time we load

16899
17:07:50,720 --> 17:07:53,420
it, and then it'll check the
value and run again. So we see

16900
17:07:53,420 --> 17:07:55,880
go twice, even though it's
really just once. But if we go

16901
17:07:55,880 --> 17:07:59,570
back here, sorry, let me just do
a quick reload again. We hit

16902
17:07:59,570 --> 17:08:04,610
Connect, we now see Hi is now
true, because it saw is what

16903
17:08:04,610 --> 17:08:07,700
three enabled change to true
because enabled web three made

16904
17:08:07,760 --> 17:08:11,570
is what enabled return true. And
it ran this again, right. So

16905
17:08:11,570 --> 17:08:14,600
that's how that actually works.
And there's a couple of

16906
17:08:14,600 --> 17:08:17,150
different ways to think about
this. Actually, we actually

16907
17:08:17,150 --> 17:08:19,790
don't even need to give this an
array. And what happens if we

16908
17:08:19,790 --> 17:08:23,150
don't give this an array? Well,
let's refresh. We'll hit

16909
17:08:23,150 --> 17:08:26,540
Connect, and we'll see it's
still ran a couple of times. So

16910
17:08:26,540 --> 17:08:31,010
if we don't give it array, no
dependency array, it'll run any

16911
17:08:31,010 --> 17:08:34,610
time something re renders. And
you need to be careful with

16912
17:08:34,610 --> 17:08:38,990
this. Because then you can get
circular renders, if you have

16913
17:08:38,990 --> 17:08:42,230
some use effect that changes
some value. And you have another

16914
17:08:42,230 --> 17:08:44,960
use effect that re renders when
that value changes while they're

16915
17:08:44,960 --> 17:08:47,330
both just going to keep changing
back and back and forth. So no

16916
17:08:47,330 --> 17:08:50,690
dependency array like this. It
will run anytime something re

16917
17:08:50,690 --> 17:08:54,230
renders we'll give it a blank
dependency array. It'll just run

16918
17:08:54,230 --> 17:08:57,860
once on load, just run one time.
So now like we have a blank

16919
17:08:57,860 --> 17:09:01,370
dependency right in here, we
reload. Right? We see that it

16920
17:09:01,370 --> 17:09:04,610
runs twice. That's actually
because we're basically re

16921
17:09:04,610 --> 17:09:07,220
rendering once in the
background. So it really is just

16922
17:09:07,220 --> 17:09:09,290
running Once but there's
something else going on in the

16923
17:09:09,290 --> 17:09:11,720
background. So it looks like
it's running twice. Now if we

16924
17:09:11,720 --> 17:09:16,040
just add is web three enabled,
do a little refresh, it'll do

16925
17:09:16,040 --> 17:09:19,550
the exact same thing, it'll run
the same amount as if this was

16926
17:09:19,550 --> 17:09:22,850
blank. But when we connect,
it'll add here. If this was a

16927
17:09:22,850 --> 17:09:27,020
blank array, when we refresh,
we'll see kick out twice, which

16928
17:09:27,380 --> 17:09:29,600
should be ones. But like I said,
there's something going on in

16929
17:09:29,600 --> 17:09:32,120
the background. If we hit
connect. Now, we don't see

16930
17:09:32,120 --> 17:09:36,080
anything here, because the blank
dependency array says, Hey, I'm

16931
17:09:36,080 --> 17:09:39,560
only going to run one time on
load. Now, if there's our stuff

16932
17:09:39,560 --> 17:09:42,230
in this array, like is web three
enabled, it's going to run

16933
17:09:42,230 --> 17:09:45,740
anytime something in this array
changes, right. So again, we'll

16934
17:09:45,740 --> 17:09:50,510
refresh will connect, we see it
ran again, after a hit Connect

16935
17:09:50,510 --> 17:09:55,940
will refresh. Hi, hi connected,
ran one more time. So so that's

16936
17:09:55,940 --> 17:09:58,790
kind of the cheat sheet here. If
we give it no dependency array,

16937
17:09:58,820 --> 17:10:01,520
it's going to run any time
anything in this project re

16938
17:10:01,520 --> 17:10:04,520
renders, if we give it a blank
dependency array, it's just

16939
17:10:04,520 --> 17:10:08,510
going to run one time, or like
we saw, it ran twice. But that's

16940
17:10:08,510 --> 17:10:10,790
because there's something else
we render in the background. And

16941
17:10:10,790 --> 17:10:13,100
if we give it dependencies in
this array, it's going to run

16942
17:10:13,100 --> 17:10:16,820
anytime something in this array
changes. And this is really

16943
17:10:16,820 --> 17:10:19,730
helpful, because oftentimes,
we're going to want our front

16944
17:10:19,730 --> 17:10:23,060
ends to rerender, this use
effect will say, oh, cool, some

16945
17:10:23,060 --> 17:10:26,240
value changed, I'm going to run
this function, and then I'm

16946
17:10:26,240 --> 17:10:27,890
going to rerender, your front
end.

16947
17:10:30,500 --> 17:10:33,200
And now we're going to use this
use effect thing to make sure

16948
17:10:33,200 --> 17:10:35,870
that when we refresh, it
remembers that we're actually

16949
17:10:35,870 --> 17:10:38,720
connected. So how do we do that
inside here, we are going to use

16950
17:10:38,720 --> 17:10:41,870
this is web three enabled thing.
And the first thing that we want

16951
17:10:41,870 --> 17:10:46,190
to just do is we want to say if
is what three enabled, then

16952
17:10:46,190 --> 17:10:49,370
we'll just return. Because if
we're already connected to web

16953
17:10:49,370 --> 17:10:52,880
three, then we don't need to do
anything. Now, if we're not

16954
17:10:52,880 --> 17:10:55,730
connected to web three, and we
don't have an account, we'll

16955
17:10:55,730 --> 17:10:58,910
want to go ahead and call Enable
Web three, right want to

16956
17:10:58,910 --> 17:11:02,900
automatically enable Web three.
So now if I go back, you'll see

16957
17:11:02,930 --> 17:11:06,050
with just this code, I'm just
always automatically calling

16958
17:11:06,080 --> 17:11:09,170
Enable Web three. But this can
get really annoying. Because if

16959
17:11:09,170 --> 17:11:13,160
I disconnect, right, let's go
disconnect everything. Now

16960
17:11:13,160 --> 17:11:18,260
refresh, it's going to always
call Enable Web three, right,

16961
17:11:18,260 --> 17:11:20,780
every time we refresh, it's
going to automatically call

16962
17:11:20,780 --> 17:11:23,390
enabled through without us even
hitting the Connect button. So

16963
17:11:23,390 --> 17:11:26,870
that's no good to we want to
actually see if we're connected.

16964
17:11:26,900 --> 17:11:29,480
So the way we do this, like I
said, we want to use our local

16965
17:11:29,480 --> 17:11:32,930
storage, again, application, or
these little, this little thing

16966
17:11:32,930 --> 17:11:37,070
here go to Application, we want
our we want our application to

16967
17:11:37,070 --> 17:11:40,100
remember that somebody hit this
connect button, and they went

16968
17:11:40,100 --> 17:11:43,070
and connected to us. So what
we're going to do is in our

16969
17:11:43,070 --> 17:11:46,040
little onClick function down
here, we're not just going to

16970
17:11:46,040 --> 17:11:49,640
call await Enable Web three,
we're also going to store a

16971
17:11:49,640 --> 17:11:53,060
little remembrance here saying,
Hey, we actually did connect

16972
17:11:53,060 --> 17:11:57,830
recently. So below this, we're
going to run window, dot local

16973
17:11:57,830 --> 17:12:07,370
storage, dot set item,
connected, comma injected. I'm

16974
17:12:07,370 --> 17:12:09,290
actually going to comment this
out for now, because my friend

16975
17:12:09,290 --> 17:12:12,620
is just going to keep popping up
like that. So what this does is

16976
17:12:12,620 --> 17:12:16,310
we're saying, okay, in our
window, because again, if you go

16977
17:12:16,310 --> 17:12:20,360
back to the window, you go to
console, a type window, you're

16978
17:12:20,360 --> 17:12:23,450
actually going to see this giant
window thing here, right, which

16979
17:12:23,450 --> 17:12:26,090
we showed you before, there's
always this window object in

16980
17:12:26,090 --> 17:12:29,750
here. And we're going to do
window dot local storage, which

16981
17:12:29,780 --> 17:12:34,340
relates to if we go to this
application section, this local

16982
17:12:34,340 --> 17:12:38,450
storage section here, that set
item connected to inject it. So

16983
17:12:38,450 --> 17:12:41,540
we're going to set a new key
value in here, we're doing it

16984
17:12:41,540 --> 17:12:44,540
like this because in the future,
maybe you want to do you know

16985
17:12:44,540 --> 17:12:48,740
connect it to Wallet connect or
connected to Coinbase wallet or

16986
17:12:48,740 --> 17:12:51,140
something, right, but we're just
gonna say injected, meaning

16987
17:12:51,140 --> 17:12:54,050
we're connected to that meta
mask. And in some versions of

16988
17:12:54,050 --> 17:12:56,930
next, Jas next, Jas has a hard
time knowing about this window

16989
17:12:56,930 --> 17:13:02,990
variable. So we can just do if
type of window does not equal

16990
17:13:02,990 --> 17:13:07,580
equal, undefined, then we're
going to do this. So we're just

16991
17:13:07,580 --> 17:13:10,490
making sure that window doesn't
equal undefined that there is a

16992
17:13:10,490 --> 17:13:13,160
window. So now if I go back to
the front end, and I hit

16993
17:13:13,160 --> 17:13:18,410
Connect, and we go ahead, and we
connect here, we'll see now in

16994
17:13:18,410 --> 17:13:23,060
our application, local storage,
we'll see we've added this

16995
17:13:23,060 --> 17:13:26,510
connected injected bit here,
we're storing in the browser

16996
17:13:26,510 --> 17:13:29,570
that we are indeed connected to
this. Now that we've added this

16997
17:13:29,600 --> 17:13:33,440
into our browser, we can roll
back up to our use effect here

16998
17:13:33,620 --> 17:13:36,020
and say, Okay, if they're
already connected, great, we'll

16999
17:13:36,020 --> 17:13:39,320
be done. But before we do
anything, let's check to see if

17000
17:13:39,320 --> 17:13:41,990
they have this here. And if they
already are connected, let's

17001
17:13:41,990 --> 17:13:47,420
just run that connect bit. So
we'll say if type of window does

17002
17:13:47,420 --> 17:13:51,710
not equal, undefined, right,
because we want to check for

17003
17:13:51,710 --> 17:13:56,720
that window object. Again, we'll
say if window dot local storage

17004
17:13:57,140 --> 17:14:02,630
dot get item connected,
connected, so if that connected

17005
17:14:02,630 --> 17:14:07,970
key exists, then we'll just run
Enable Web three. So now We have

17006
17:14:07,970 --> 17:14:11,450
some functionality in here,
which even when we refresh, it

17007
17:14:11,450 --> 17:14:14,270
will automatically run enable of
three for us. So now if I go

17008
17:14:14,270 --> 17:14:17,750
ahead and refresh the front end,
we don't have to press that

17009
17:14:17,750 --> 17:14:21,410
connect button anymore, because
it goes, Oh, I see that locally,

17010
17:14:21,410 --> 17:14:25,940
we stored this connected key
whenever you refresh. Now, it

17011
17:14:25,940 --> 17:14:28,880
checks for this first it sees it
and then runs enabled web three.

17012
17:14:28,910 --> 17:14:32,390
Now on the other side, though,
if we're in here, and now we

17013
17:14:32,390 --> 17:14:35,990
disconnect, and then we refresh.
This will show up, which is

17014
17:14:35,990 --> 17:14:38,660
really annoying. And every time
we refresh, it'll keep showing

17015
17:14:38,660 --> 17:14:40,940
up, which we don't want. We want
it to be that when we

17016
17:14:40,940 --> 17:14:44,360
disconnect, we tell it hey,
we've we've gone ahead and

17017
17:14:44,360 --> 17:14:48,470
disconnected here. So back in
our application, we can add

17018
17:14:48,500 --> 17:14:52,760
another use effect to check to
see if we've disconnected. So

17019
17:14:52,760 --> 17:14:56,270
let's create another use effect.
That's going to costly just look

17020
17:14:56,270 --> 17:14:59,870
for us being connected, we'll
say use effect, do a little

17021
17:14:59,870 --> 17:15:03,890
arrow bracket thing here. And
we're going to do this anytime.

17022
17:15:04,160 --> 17:15:06,320
And oh my goodness, anytime I
save, it's going to keep popping

17023
17:15:06,320 --> 17:15:08,690
up. So I'm just going to just
going to comment that out for

17024
17:15:08,690 --> 17:15:11,600
now. So in here, we want to say
okay, whatever, there's a

17025
17:15:11,600 --> 17:15:15,530
rerender we want to run if any
account has changed. And Morales

17026
17:15:15,530 --> 17:15:18,620
has some functionality for us to
do this as well. So from user

17027
17:15:18,620 --> 17:15:22,580
morass, we're going to import
more Alice, and then down here

17028
17:15:22,700 --> 17:15:26,450
in our use effect. Inside the
little function, we're gonna say

17029
17:15:26,450 --> 17:15:29,900
mirallas.on account, changed

17030
17:15:31,460 --> 17:15:36,080
of account, we're gonna do some
stuff. So on account changed,

17031
17:15:36,170 --> 17:15:39,830
takes a function as an input
parameter. So we'll say console

17032
17:15:39,860 --> 17:15:47,240
dot log, account, change to
account. And what we can do is

17033
17:15:47,240 --> 17:15:50,390
we can check to see if this
account is not. And we can say

17034
17:15:50,420 --> 17:15:55,790
if account equals equals no,
then if the account is null, we

17035
17:15:55,790 --> 17:15:59,480
can assume they've disconnected.
So we can say window dot local

17036
17:15:59,480 --> 17:16:05,720
storage, dot remove item,
connected, we'll also run a

17037
17:16:05,720 --> 17:16:10,790
deactivate web three function.
So from Ross, deactivate, web

17038
17:16:10,790 --> 17:16:16,760
three will also run, deactivate
web three, which is going to set

17039
17:16:17,060 --> 17:16:20,390
is web three enabled to false.
So we're going to disconnect the

17040
17:16:20,390 --> 17:16:23,780
web three, and then we're going
to say console dot log.

17041
17:16:25,190 --> 17:16:25,940
No

17042
17:16:27,350 --> 17:16:30,920
count found. So let's try this
out. Now. Let's go back to our

17043
17:16:30,920 --> 17:16:33,350
front end, we'll do a little
refresh here. So right now it

17044
17:16:33,350 --> 17:16:36,560
says we're connected. Even
though in my meta mask, we're

17045
17:16:36,560 --> 17:16:38,750
not connected, right? And to
start from scratch here, you can

17046
17:16:38,750 --> 17:16:41,300
go ahead and disconnect it. But
but my browser says, Hey, we're

17047
17:16:41,300 --> 17:16:44,600
connected, right? So now we'll
connect. And we'll actually be

17048
17:16:44,600 --> 17:16:48,170
connected right, next connect,
and it and it just overrode

17049
17:16:48,170 --> 17:16:50,720
connected, you know, with
inject, let's, let's make this

17050
17:16:50,720 --> 17:16:55,460
injected. And then we'll remove
Yep, okay, injected, we'll

17051
17:16:55,460 --> 17:16:58,880
refresh, like, connect, and now
it says injected. Okay, cool. So

17052
17:16:58,880 --> 17:17:03,110
now we're connected here. If in
here, if I just switch accounts,

17053
17:17:03,320 --> 17:17:07,220
right, let's go to Account
three, I'll connect. If we go

17054
17:17:07,220 --> 17:17:10,910
back to our console real quick,
we'll say account change to

17055
17:17:10,910 --> 17:17:14,150
blah, blah, blah, I can change
back, right, we'll go change

17056
17:17:14,180 --> 17:17:17,030
account change to blah, blah,
blah. Now, if we go back to our

17057
17:17:17,030 --> 17:17:22,340
application, go in here. And we
disconnect. Now let's disconnect

17058
17:17:22,340 --> 17:17:27,770
both of these disconnect. And
disconnect. We'll see it's now

17059
17:17:27,770 --> 17:17:31,490
been removed from local storage.
And if we go to our console,

17060
17:17:31,490 --> 17:17:36,050
it'll say, no account, change
the No, no account found and

17061
17:17:36,080 --> 17:17:39,440
removed it. Now if I hit
refresh, nothing happens here, I

17062
17:17:39,440 --> 17:17:44,150
can go ahead and connect. Right
next connect, I can refresh.

17063
17:17:44,390 --> 17:17:47,690
Oops, I need to go back in here
and re enable this. So sorry,

17064
17:17:47,690 --> 17:17:51,650
let's add this back in here. But
now it can refresh. Let's go

17065
17:17:51,650 --> 17:17:56,240
ahead and disconnect here. Let's
connect. Let's go back to the

17066
17:17:56,240 --> 17:18:02,090
console, we can connect thing
will pop up next connect, I can

17067
17:18:02,090 --> 17:18:07,760
refresh. It stays connected for
me, I can switch accounts, I can

17068
17:18:07,760 --> 17:18:11,390
go ahead and here, I can switch
accounts, I can even disconnect.

17069
17:18:12,320 --> 17:18:14,960
And it will automatically update
for me, which is what we want.

17070
17:18:15,080 --> 17:18:19,010
So now we've essentially made a
way more robust connect button,

17071
17:18:19,400 --> 17:18:22,310
where it goes back and forth
with when we're connected now.

17072
17:18:24,980 --> 17:18:28,070
Now one more thing that we might
want to do, or application is

17073
17:18:28,070 --> 17:18:30,770
when we hit Connect, we want to
maybe disable this button,

17074
17:18:30,950 --> 17:18:34,400
right? We don't want it to allow
it to be able to be pressed. So

17075
17:18:34,400 --> 17:18:36,830
I'm gonna hit Cancel, we're just
gonna add one more bit of

17076
17:18:36,830 --> 17:18:42,050
functionality here, we're going
to add this is web three enable

17077
17:18:42,260 --> 17:18:46,100
loading. And what this does is
it just checks to see if

17078
17:18:46,100 --> 17:18:49,250
Metamask has popped up. And so
what our button after the on

17079
17:18:49,250 --> 17:18:55,340
click section, we can add
disabled. Equals is web three

17080
17:18:55,340 --> 17:18:58,880
enable loading, so it'll be
disabled if we're loading here.

17081
17:18:58,910 --> 17:19:02,750
So let's go ahead and we'll
disconnect disconnect. Now we'll

17082
17:19:02,750 --> 17:19:05,990
hit Connect, and you'll see the
button can be clicked. So that

17083
17:19:05,990 --> 17:19:09,920
just makes it a little bit nice.
Turn, Next connect Bada bing,

17084
17:19:09,920 --> 17:19:14,630
bada boom, awesome, we have just
made a way more robust front end

17085
17:19:14,660 --> 17:19:17,780
than what we had before this
connect button is super slick.

17086
17:19:17,780 --> 17:19:19,790
And it allows us to kind of flip
back and forth. And our

17087
17:19:19,790 --> 17:19:23,720
application is incredibly
powerful and knows how to handle

17088
17:19:23,720 --> 17:19:28,670
all these different changes. Now
that we've learned how to do it

17089
17:19:28,670 --> 17:19:31,460
the manual way, let me give you
the Chiti way, in our

17090
17:19:31,460 --> 17:19:34,880
components, we're gonna create a
new file header dot j s, and

17091
17:19:34,880 --> 17:19:37,970
what we're going to do is we're
going to install this web three

17092
17:19:38,000 --> 17:19:40,760
UI kit, it's a front end kit,
and it has a whole bunch of

17093
17:19:40,760 --> 17:19:43,880
these components already built
for us. So we can build like a

17094
17:19:43,880 --> 17:19:47,120
header component and a connect
button component just by using

17095
17:19:47,120 --> 17:19:50,810
this. So to install, install it,
we're gonna come back here,

17096
17:19:50,870 --> 17:19:53,390
we're gonna stop our front end.
And we're just going to run

17097
17:19:53,390 --> 17:19:58,820
yarn, add web three UI kit, like
that. And again, we don't want

17098
17:19:58,820 --> 17:20:01,160
this to be a dev dependency,
because it is going to be a part

17099
17:20:01,160 --> 17:20:05,000
of our website, and then we'll
do in our header.js, we'll do

17100
17:20:05,000 --> 17:20:12,050
import connect button from web
three UI kit. And then we'll do

17101
17:20:12,080 --> 17:20:18,890
export default function header.
And then all we'll do is return

17102
17:20:19,610 --> 17:20:23,660
do like a div. And then inside
this div, we'll do next button.

17103
17:20:24,740 --> 17:20:27,110
With a little backslash here, we
aren't going to need this for

17104
17:20:27,110 --> 17:20:29,240
this project. But if we want to
be super explicit, we'll say

17105
17:20:29,240 --> 17:20:34,880
Morales off equals false. Just
again, to reiterate, hey, we're

17106
17:20:34,880 --> 17:20:37,010
not trying to connect to a
server here just to make that

17107
17:20:37,010 --> 17:20:40,910
super explicit. But this connect
button does everything, this

17108
17:20:40,910 --> 17:20:44,870
manual header thing that we just
created, does. So back in our

17109
17:20:44,870 --> 17:20:49,820
index.js, we can comment or
delete this line will do import

17110
17:20:50,180 --> 17:20:56,180
header from dot dot slash
components slash header. And

17111
17:20:56,180 --> 17:21:01,790
then instead of manual header,
we'll just do header. We start

17112
17:21:01,790 --> 17:21:03,470
our app back up with yarn dev
again,

17113
17:21:04,850 --> 17:21:08,330
we go back to the page, we do a
little refresh here, we now see

17114
17:21:08,330 --> 17:21:10,910
we have this connect Wallet
button. And it's even looks a

17115
17:21:10,910 --> 17:21:13,940
lot nicer. It's got some nice
styling to it as well, we can

17116
17:21:13,940 --> 17:21:17,900
hit Connect wallet. And it'll
give us this little ngModel

17117
17:21:17,960 --> 17:21:20,870
asking us which wallet we want
to connect to. So asking us

17118
17:21:20,870 --> 17:21:23,690
which wall we want to connect to
is kind of similar in our manual

17119
17:21:23,690 --> 17:21:28,220
header to this or set item
connected, injected, right or

17120
17:21:28,220 --> 17:21:31,220
wallet connect, it would do
connected wallet Connect for

17121
17:21:31,220 --> 17:21:34,400
trust wallet, it would it would
set item as connected wallet

17122
17:21:34,400 --> 17:21:38,390
connect, etc. So it allows us to
connect in different ways. And

17123
17:21:38,390 --> 17:21:41,690
we if we hit Metamask, we go
ahead and connect like so even

17124
17:21:41,690 --> 17:21:45,230
had some nice styling here where
it gives us our wallet address

17125
17:21:45,230 --> 17:21:49,010
here. But it also gives us our
wallet balance as well. And

17126
17:21:49,010 --> 17:21:51,080
again, if we go ahead and
disconnect, we'll see it

17127
17:21:51,080 --> 17:21:54,680
automatically disconnect. We
connect like so we can reconnect

17128
17:21:54,680 --> 17:21:57,860
like so boom, boom. If we switch
accounts, it's smart enough to

17129
17:21:57,860 --> 17:22:00,710
know that we're switching
accounts. So I know I showed you

17130
17:22:00,710 --> 17:22:02,780
kind of the hard way. But I
wanted to show you kind of

17131
17:22:02,780 --> 17:22:05,240
what's going on. It's setting
this local storage in the

17132
17:22:05,240 --> 17:22:08,300
background so that it knows
which where it's actually

17133
17:22:08,300 --> 17:22:11,180
connected. But for headers
moving forward, this is all you

17134
17:22:11,180 --> 17:22:14,630
need. And your life will be
drastically drastically easier.

17135
17:22:14,660 --> 17:22:19,610
And let's just add a centralized
lottery or decentralized raffle

17136
17:22:19,640 --> 17:22:22,190
or whatever you want to our
header as well. So it says

17137
17:22:22,190 --> 17:22:27,440
decentralized lottery, you know
the button Hello. Now that we

17138
17:22:27,440 --> 17:22:30,950
have that, what else do we need?
Well, well, the main thing that

17139
17:22:30,950 --> 17:22:33,890
this app needs to do is just
have a big button that says

17140
17:22:33,890 --> 17:22:36,230
enter the lottery. And then
ideally, you know, show how many

17141
17:22:36,230 --> 17:22:38,540
people are in the lottery and
then the recent winner as well.

17142
17:22:38,570 --> 17:22:41,900
So let's go ahead, we'll create
a new component called lottery

17143
17:22:41,930 --> 17:22:44,840
entrance. And we'll grab that
component similar to like what

17144
17:22:44,840 --> 17:22:49,070
we did with our header, we'll
drop this component right here.

17145
17:22:49,100 --> 17:22:51,980
And then our app will pretty
much be done. So let's create

17146
17:22:51,980 --> 17:22:57,020
this lottery entrance component,
lottery entrance, that Jas,

17147
17:22:57,350 --> 17:22:59,060
right and again, in the reason
we're putting these in

17148
17:22:59,060 --> 17:23:02,510
components, we could 100% Stick
it all, you know all our code in

17149
17:23:02,510 --> 17:23:05,720
here to make it more modular so
that we in the future, if we

17150
17:23:05,720 --> 17:23:08,420
want to have more pages or do
other stuff, I'm going to zoom

17151
17:23:08,420 --> 17:23:11,180
out a little bit just so that we
can see all of our code a little

17152
17:23:11,180 --> 17:23:14,840
bit easier. This is our whole
index j s. This is our whole

17153
17:23:14,840 --> 17:23:18,230
header. Let's create a new
lottery entrance app just for

17154
17:23:18,230 --> 17:23:23,810
the boilerplate code here we're
going to export default lottery

17155
17:23:24,230 --> 17:23:28,940
entrance, excuse me, export
default function, lottery

17156
17:23:28,940 --> 17:23:31,310
entrance, and this is just going
to be you know, another

17157
17:23:31,310 --> 17:23:35,900
component where we're going to
return some that JSX HTML stuff,

17158
17:23:35,930 --> 17:23:40,670
right? So we're gonna do div and
do like hi from lottery

17159
17:23:40,670 --> 17:23:44,870
entrance, Excel. And now that we
do that, we can go back to our

17160
17:23:45,380 --> 17:23:51,950
index.js. We can do import
lottery entrance from dot dot

17161
17:23:51,950 --> 17:23:57,890
slash components. Slash lottery
entrance, will stick it right

17162
17:23:57,890 --> 17:24:01,760
underneath the header like that.
And if we go back to our

17163
17:24:01,790 --> 17:24:05,330
website, we see high from
lottery entrance so our lottery

17164
17:24:05,330 --> 17:24:07,430
entrance is going to be right
underneath the header would

17165
17:24:07,430 --> 17:24:09,350
Here's what we want. And then
we'll delete this line that

17166
17:24:09,350 --> 17:24:12,650
says, Hello. So lottery
entrance, what is the what is

17167
17:24:12,650 --> 17:24:15,470
the first thing that we really
need to do in here? Well, we're

17168
17:24:15,470 --> 17:24:21,140
going to want to have a function
to call the lottery to enter the

17169
17:24:21,140 --> 17:24:24,980
lottery. Let's go ahead and do
this. Now let's go back to how

17170
17:24:24,980 --> 17:24:28,730
we did this with HTML fund me
recall that old fun function

17171
17:24:28,760 --> 17:24:31,490
like this, but doing it like
this won't rerender. And there's

17172
17:24:31,490 --> 17:24:33,890
a whole lot of other
functionality that doing it like

17173
17:24:33,890 --> 17:24:37,280
this won't give us so we're
going to use Morales to actually

17174
17:24:37,280 --> 17:24:40,610
call some of these functions,
because mirallas has in React

17175
17:24:40,610 --> 17:24:43,490
mirallas. Again, they have hooks
for us to do pretty much

17176
17:24:43,490 --> 17:24:47,240
anything we want to do. And one
of these hooks is called use web

17177
17:24:47,240 --> 17:24:50,990
three contract. And what this
does is it gives us a hook that

17178
17:24:50,990 --> 17:24:55,400
will give us the data returned
from a function called an error

17179
17:24:55,400 --> 17:24:59,330
returned, a little function that
we can use to call any function.

17180
17:24:59,690 --> 17:25:02,420
And then we also have these
really helpful is fetching in is

17181
17:25:02,420 --> 17:25:06,170
loading. So if we want everyone
to have our UI or our website,

17182
17:25:06,170 --> 17:25:09,530
do something while it's fetching
or while it's loading the

17183
17:25:09,530 --> 17:25:12,500
transaction, we can use these
two variables to do that. And

17184
17:25:12,500 --> 17:25:14,840
then all we need to do is we
just need to pass it the

17185
17:25:14,840 --> 17:25:17,240
contract information, which
similar to ethers is going to be

17186
17:25:17,240 --> 17:25:21,560
the ABI contract address, we'll
pass the function name, and then

17187
17:25:21,560 --> 17:25:24,410
any parameters for that
function. So we're going to use

17188
17:25:24,410 --> 17:25:27,740
this syntax here to make that
transaction to the blockchain.

17189
17:25:28,040 --> 17:25:30,500
And to call these functions. So
what we're going to do is we're

17190
17:25:30,500 --> 17:25:34,010
going to import us web three
contract

17191
17:25:35,600 --> 17:25:40,100
from react mirallas. And inside
our function, but before I

17192
17:25:40,100 --> 17:25:44,150
return, of course, we're going
to say const. And then we'll do

17193
17:25:44,180 --> 17:25:47,840
kind of exactly what we see in
here. For now, let's just get

17194
17:25:47,870 --> 17:25:50,120
the function, let's just get
this run contract function,

17195
17:25:50,120 --> 17:25:53,240
because this is going to be the
function that we can call to

17196
17:25:53,240 --> 17:25:57,350
actually enter the lottery. So
we'll say const, run contract

17197
17:25:57,380 --> 17:26:00,440
function, and we're actually
going to call this enter raffle.

17198
17:26:00,590 --> 17:26:05,180
And we'll say equals, use web
three contract, and we need to

17199
17:26:05,180 --> 17:26:10,640
pass the ABI, we're gonna need
to pass the contract address,

17200
17:26:11,300 --> 17:26:14,030
we're gonna need to give it the
function name, we'll need to

17201
17:26:14,030 --> 17:26:17,210
give it the params, which
actually we do know it's going

17202
17:26:17,210 --> 17:26:20,180
to be blank. But then finally,
we will need the message value.

17203
17:26:20,390 --> 17:26:23,720
Because if we remember back into
raffle doesn't take any

17204
17:26:23,720 --> 17:26:27,860
parameters, all it takes is this
message dot value bit. So that's

17205
17:26:27,860 --> 17:26:33,200
all we're going to need to pass.
So how do we get all this stuff,

17206
17:26:33,230 --> 17:26:35,630
and I'm going to leave this in
here. But we're going to comment

17207
17:26:35,630 --> 17:26:39,440
it out for now, because this is
what we need to do. But we need

17208
17:26:39,440 --> 17:26:42,260
to get all of this stuff into
our code here. So how do we

17209
17:26:42,260 --> 17:26:46,040
actually get all that stuff?
Well, ABI is easy, right? Abi

17210
17:26:46,070 --> 17:26:49,760
isn't going to change at all, no
matter what network or on ABI is

17211
17:26:49,790 --> 17:26:52,550
always going to stay the same.
Now if you've already deployed

17212
17:26:52,550 --> 17:26:55,100
your smart contracts, and you
know exactly what address it is,

17213
17:26:55,100 --> 17:26:57,200
because you've deployed to a
main net, or you've deployed to

17214
17:26:57,200 --> 17:27:00,500
a test net, all this stuff isn't
really going to change. And we

17215
17:27:00,500 --> 17:27:04,130
can just hard code it all right
into here. Or we can do what a

17216
17:27:04,130 --> 17:27:06,980
lot of people do is they'll
create a constants folder. And

17217
17:27:06,980 --> 17:27:12,050
in here, they'll add like an API
dot JSON, maybe they'll add a

17218
17:27:12,410 --> 17:27:16,550
contract addresses dot JSON. And
then they'll add maybe like an

17219
17:27:16,550 --> 17:27:19,100
index dot j s or something,
we're gonna build our

17220
17:27:19,100 --> 17:27:23,030
application in a way we can
actually test locally using our

17221
17:27:23,030 --> 17:27:26,000
own Hard Hat Network, and then
compare it to what it looks like

17222
17:27:26,030 --> 17:27:28,250
on the actual test net as well.
So we're going to make it

17223
17:27:28,280 --> 17:27:31,670
network agnostic. So the front
end works exactly the same no

17224
17:27:31,670 --> 17:27:34,940
matter what network that we're
on. And we can go back, download

17225
17:27:34,970 --> 17:27:39,890
a directory back into our CD,
hard hat smart contract lottery

17226
17:27:39,890 --> 17:27:44,690
Free Code Camp, and spin up our
node here, right with hh node or

17227
17:27:44,690 --> 17:27:48,860
yarn hard hat node. And we'll
use this as the blockchain that

17228
17:27:48,860 --> 17:27:51,830
we're going to connect to. The
thing is, if I go back here, and

17229
17:27:51,830 --> 17:27:53,900
I'm building the front end, and
I go, ah, like this would be

17230
17:27:53,900 --> 17:27:57,140
better if we did X, Y, or Z. And
maybe I changed the name of some

17231
17:27:57,140 --> 17:28:00,950
functions, you know, blah, blah,
blah, something else, I want

17232
17:28:00,980 --> 17:28:04,340
that change to be reflected on
my front end. And I want to be

17233
17:28:04,340 --> 17:28:07,880
able to code my front end as
such. So since we are the only

17234
17:28:07,880 --> 17:28:10,610
developer right now, we kind of
have the ability of where we

17235
17:28:10,610 --> 17:28:13,970
both know, the back end code and
the front end code. So something

17236
17:28:13,970 --> 17:28:16,400
that I like to do to make my
life a little bit easier is I

17237
17:28:16,400 --> 17:28:20,090
like to create an update front
end deploy script. So after we

17238
17:28:20,090 --> 17:28:24,140
deploy stuff, we run a little
script that will create this

17239
17:28:24,140 --> 17:28:27,710
constants folder for us with a
whole bunch of stuff, right?

17240
17:28:27,710 --> 17:28:30,980
It'll give an ABI, it'll give
contract addresses and anything

17241
17:28:30,980 --> 17:28:34,760
else we might need in our front
end from our back end. So what I

17242
17:28:34,760 --> 17:28:38,690
like to do is I like to come
back to my original code and an

17243
17:28:38,720 --> 17:28:42,590
update this for a new script. So
I'll come in here in this deploy

17244
17:28:42,590 --> 17:28:46,370
script, I'll create a new file,
and I'll call it oh two or even

17245
17:28:46,370 --> 17:28:54,500
like 9999, up, date, front, and
dot Jas. And the reason I do 99,

17246
17:28:54,500 --> 17:28:57,380
obviously, is because we want
this to be always the last

17247
17:28:57,380 --> 17:28:59,870
script in our deploy folder. And
then we can just write a little

17248
17:28:59,870 --> 17:29:03,110
script that's connected. We just
write a little script that's

17249
17:29:03,110 --> 17:29:06,200
connected to our front end here
so that whenever we deploy

17250
17:29:06,200 --> 17:29:09,860
contracts, no matter what chain,
we can update that constants

17251
17:29:09,860 --> 17:29:12,470
folder on our front end. So
let's go ahead and create that

17252
17:29:12,470 --> 17:29:17,810
script right now we'll do module
dot exports, equals async

17253
17:29:17,810 --> 17:29:21,650
function. And we'll add all our
stuff in here, we don't really

17254
17:29:21,650 --> 17:29:24,350
need to deploy any contracts,
because we're just updating the

17255
17:29:24,350 --> 17:29:26,540
front end. So we can just leave
the parameters of this one

17256
17:29:26,540 --> 17:29:30,140
blank. And the other thing I
like to do, because sometimes I

17257
17:29:30,140 --> 17:29:34,010
don't care about the front end,
what I'll do is I'll only update

17258
17:29:34,010 --> 17:29:38,000
the front end if we've specified
a dot env variable. So I'll

17259
17:29:38,000 --> 17:29:43,970
create a dot env variable called
up date, front end. And then

17260
17:29:43,970 --> 17:29:47,420
I'll set this to true. And now
in our script here, we can say

17261
17:29:47,450 --> 17:29:53,480
if process dot E and V dot
update, front end. And we can

17262
17:29:53,480 --> 17:29:58,490
just say like console dot log,
updating front end. And now back

17263
17:29:58,490 --> 17:30:01,730
in here, right, if a mat if I'm
in the correct directory in

17264
17:30:01,730 --> 17:30:03,710
here, if our own hard hit
Deploy,

17265
17:30:05,060 --> 17:30:07,280
you know, get this little
updating front end. And now we

17266
17:30:07,280 --> 17:30:10,100
can update front end. So let's
do it. So I'm actually going to

17267
17:30:10,100 --> 17:30:15,620
create one function called
Update contract addresses. And

17268
17:30:15,620 --> 17:30:17,060
this is going to be our function
that we're going to use to

17269
17:30:17,060 --> 17:30:19,580
update contract addresses, then
I'm going to make one called

17270
17:30:19,610 --> 17:30:23,000
Update API, where we just update
the API's and the front end so

17271
17:30:23,090 --> 17:30:25,670
so we're going to call this
update contract addresses. So

17272
17:30:25,670 --> 17:30:29,900
I'm going to create a new
function async function, update

17273
17:30:29,900 --> 17:30:35,180
contract addresses. And first,
we're going to get that raffle

17274
17:30:35,180 --> 17:30:37,580
contract since we're going to
need to get its address. So

17275
17:30:37,580 --> 17:30:40,370
we're gonna say const, raffle
equals await. And we're gonna do

17276
17:30:40,370 --> 17:30:45,020
the same thing we've been doing
ethers dot get contract, raffle,

17277
17:30:45,140 --> 17:30:48,530
and then my VS code auto
imported, it doesn't const

17278
17:30:48,560 --> 17:30:51,710
ethers equals require Hardhead,
like so. So we have raffle in

17279
17:30:51,710 --> 17:30:55,670
here. And we're gonna want to
pass this raffle address to our

17280
17:30:55,670 --> 17:30:58,670
front end, since this is going
to be a variable that we might

17281
17:30:58,670 --> 17:31:03,230
use a lot of places, we can just
add it like const, front end

17282
17:31:03,230 --> 17:31:07,820
location, addresses file,
equals, and we're going to give

17283
17:31:07,820 --> 17:31:10,760
it the relative path to where we
are now, which is going to be

17284
17:31:10,760 --> 17:31:15,800
you know, if we see the download
directory to next year's smart

17285
17:31:15,800 --> 17:31:20,030
contract lottery, FCC, I can
even just copy this, paste that

17286
17:31:20,030 --> 17:31:23,510
in here. And then it's in the
constants folder, and it's going

17287
17:31:23,510 --> 17:31:28,550
to be contract addresses dot
JSON. And let's get the ABI

17288
17:31:28,550 --> 17:31:35,270
file, we'll say const. Front and
a bi file is going to equal and

17289
17:31:35,270 --> 17:31:38,510
this is going to be nearly the
same thing. So we can just copy

17290
17:31:38,510 --> 17:31:44,450
paste that. And then we'll do
slash API dot JSON. And now in

17291
17:31:44,450 --> 17:31:48,410
our update contract addresses
function, we can say const,

17292
17:31:48,800 --> 17:31:55,400
current addresses, equals and we
can read again, in our front

17293
17:31:55,400 --> 17:31:58,340
end, we can read from this file.
So I'll usually start out with

17294
17:31:58,340 --> 17:32:01,250
just two brackets. So that's
like JSON compatible in both of

17295
17:32:01,250 --> 17:32:05,180
these files. And so to read it,
we're gonna say JSON dot parse,

17296
17:32:05,690 --> 17:32:11,690
FS dot read file sync, we're
gonna have to import, say const.

17297
17:32:11,720 --> 17:32:16,520
FS equals require, I know we've
used Fs extra in the past, but

17298
17:32:16,790 --> 17:32:19,460
this one, we're just gonna use
Fs, which is going to be our

17299
17:32:19,490 --> 17:32:26,420
front and addresses file, we're
going to read it in with UTF

17300
17:32:27,080 --> 17:32:29,540
eight encoding. So now this is
going to be our current

17301
17:32:29,540 --> 17:32:32,330
addresses. And we're going to
update the list of current

17302
17:32:32,330 --> 17:32:35,090
addresses with some new
addresses. Because our contract

17303
17:32:35,090 --> 17:32:37,430
addresses we want this to be
chain agnostic, we would do

17304
17:32:37,430 --> 17:32:40,970
something like for you know, and
then the addresses on rink B, we

17305
17:32:40,970 --> 17:32:45,500
could do 31337, and then the
addresses on our local host,

17306
17:32:45,530 --> 17:32:48,200
right, we want to be able to
keep track of all the different

17307
17:32:48,200 --> 17:32:51,560
addresses across all the
different chains. So back in our

17308
17:32:51,590 --> 17:32:58,550
function here, then we'll say if
if network, dot config dot chain

17309
17:32:58,550 --> 17:33:05,900
id.to string in contract
addresses that were config ideas

17310
17:33:05,900 --> 17:33:08,660
in there, then we're just gonna
go ahead and add this new

17311
17:33:08,660 --> 17:33:11,180
contract address in there. But
before we add this new address

17312
17:33:11,180 --> 17:33:13,310
in there, let's just check to
make sure it's not are already

17313
17:33:13,310 --> 17:33:18,410
in there. So we're just gonna
say if contract addresses of

17314
17:33:18,410 --> 17:33:23,180
network dot config dot chain
id.to string, this is so long, I

17315
17:33:23,180 --> 17:33:25,550
don't want to keep writing that
I'm gonna say const chain ID

17316
17:33:25,640 --> 17:33:31,580
equals network, config that
chain id.to string, and we're

17317
17:33:31,580 --> 17:33:36,140
just gonna use chain ID. If
chain ID and contract address

17318
17:33:36,200 --> 17:33:41,600
then if we don't already have
that includes raffle dot

17319
17:33:41,600 --> 17:33:51,290
address. We're gonna go ahead
and add this new address and

17320
17:33:51,290 --> 17:33:54,620
then if the chain ID doesn't
even exist, we're gonna go ahead

17321
17:33:54,680 --> 17:34:01,040
and do contract addresses
current addresses, equals or

17322
17:34:01,040 --> 17:34:05,240
assuming current addresses of
chain ID equals and then we'll

17323
17:34:05,240 --> 17:34:08,300
just create a new array, raffled
that out address. So we're

17324
17:34:08,300 --> 17:34:10,940
saying if the chain ID doesn't
exist in current addresses,

17325
17:34:10,970 --> 17:34:13,100
we're just going to add this new
array in there. And then

17326
17:34:13,100 --> 17:34:16,040
finally, now that we've updated
its object, we're gonna write it

17327
17:34:16,040 --> 17:34:22,430
back to this file, we'll say Fs
dot write, file sync, front and

17328
17:34:22,880 --> 17:34:26,150
addresses file. And then we're
gonna do JSON dot string of

17329
17:34:26,150 --> 17:34:29,900
five. So we're going to
Stringify this JSON object, so

17330
17:34:29,900 --> 17:34:32,450
we're just gonna go ahead and
write it back. And then bottom

17331
17:34:32,600 --> 17:34:39,080
module that exports that tags
equals all and then front end. I

17332
17:34:39,080 --> 17:34:41,900
cool. So we have a function to
update the contract addresses,

17333
17:34:41,900 --> 17:34:46,280
but we also need the ABI. So
we're gonna do date API, and

17334
17:34:46,280 --> 17:34:50,540
we're gonna create another
function async function, update

17335
17:34:50,540 --> 17:34:54,500
API. And in here, we're gonna do
the exact same thing on raffle

17336
17:34:54,620 --> 17:34:59,300
equals await ethers that
contract,

17337
17:35:00,799 --> 17:35:08,359
raffle FX dot right file, sync,
front and abi. It's just going

17338
17:35:08,359 --> 17:35:13,339
to copy paste it front end, AVI
file. And then to pass just the

17339
17:35:13,339 --> 17:35:16,639
ABI, we can actually get it
directly from this raffle

17340
17:35:16,639 --> 17:35:23,269
object, we can actually just do
raffle dot interface that format

17341
17:35:23,989 --> 17:35:29,149
ethers dot utils, dot format
types, dot JSON. If you look in

17342
17:35:29,149 --> 17:35:32,449
the ethers, Docs, ethers has
this contract dot interface

17343
17:35:32,479 --> 17:35:35,299
thing which returns an interface
which is different from a

17344
17:35:35,299 --> 17:35:38,599
solidity interface. But it
allows us basically just to get

17345
17:35:38,599 --> 17:35:41,449
the API with this one line of
code. So in our back end code

17346
17:35:41,449 --> 17:35:46,909
here, now if you run h h deploy
or H H node, we should

17347
17:35:46,939 --> 17:35:50,869
automatically update our
contract addresses in our API

17348
17:35:50,869 --> 17:35:55,639
dot JSON. So let's go and try
this. So we'll run h h node. So

17349
17:35:55,639 --> 17:35:58,999
we'll start a node, right in
this terminal over here, we'll

17350
17:35:58,999 --> 17:36:03,529
flip back to the front end. And
if we open ABI to JSON, we do

17351
17:36:03,529 --> 17:36:07,699
indeed, now see, we have the
raffle API in this file. And if

17352
17:36:07,699 --> 17:36:12,319
we go to contract addresses, we
see on network 31337, here's our

17353
17:36:12,319 --> 17:36:15,139
first address, right. And if we
deploy to different chains, this

17354
17:36:15,139 --> 17:36:18,979
will get populated with
different network IDs, and then

17355
17:36:18,979 --> 17:36:21,679
a list of addresses associated
with them. So it helps make our

17356
17:36:21,679 --> 17:36:25,069
front ends a lot easier to
maintain, and bounce around and

17357
17:36:25,069 --> 17:36:27,859
kind of test and work with. Now
that we've done all this, we can

17358
17:36:27,859 --> 17:36:31,249
actually close our hardhat smart
contract lottery Free Code Camp,

17359
17:36:31,249 --> 17:36:33,829
the hard hat project for this,
and we're just going to have all

17360
17:36:33,829 --> 17:36:37,099
of our terminals be in here. So
what we're gonna do is we're

17361
17:36:37,099 --> 17:36:40,849
gonna go down and directory CD
dot dot, and we're going to cd

17362
17:36:40,849 --> 17:36:44,479
into Oh, sorry, we're actually
we're already in their CDs, hard

17363
17:36:44,479 --> 17:36:47,239
hat, smart contract, lottery
Free Code Camp. And then in this

17364
17:36:47,239 --> 17:36:51,949
one, we're going to run hh node
or yarn hardhat node. Now we'll

17365
17:36:51,949 --> 17:36:55,069
have a local blockchain running
so we can test everything that

17366
17:36:55,069 --> 17:36:57,379
we're doing in the front end,
actually, I'm gonna move this up

17367
17:36:57,379 --> 17:37:01,609
one. So now in our first area,
here, we have our front end code

17368
17:37:01,609 --> 17:37:05,239
running, then we have our
blockchain running. And then in

17369
17:37:05,239 --> 17:37:07,219
this one, we're just going to
add, you know, whatever we want

17370
17:37:07,219 --> 17:37:09,919
to add. Now, we can actually go
ahead and hit this little X

17371
17:37:09,919 --> 17:37:13,129
button here to close the panel.
So that's just hiding the panel,

17372
17:37:13,159 --> 17:37:15,679
these are all still out, they
only get trashed when you

17373
17:37:15,679 --> 17:37:17,539
actually hit the little
trashcan. So we're just going to

17374
17:37:17,539 --> 17:37:20,359
close the panel. But all those
terminals are still running, I

17375
17:37:20,359 --> 17:37:24,019
promise back. So where were we?
Okay, back to our function here.

17376
17:37:24,049 --> 17:37:28,159
So we just automated the process
of updating our API's and then

17377
17:37:28,189 --> 17:37:31,879
updating our contracts as well.
And now we can import these into

17378
17:37:31,879 --> 17:37:34,669
our files. Now we can import
them one at a time, it'd be like

17379
17:37:34,699 --> 17:37:41,569
import API, from dot dot slash
constants, slash API, or we

17380
17:37:41,569 --> 17:37:44,449
could do something a little bit
clever is we could export these

17381
17:37:44,479 --> 17:37:47,209
in the same file. So if we
create a new file, a new

17382
17:37:47,209 --> 17:37:51,409
index.js, in here, we can import
them and then export them in

17383
17:37:51,409 --> 17:37:55,849
this one file. We can say const,
contract editor says equals

17384
17:37:55,849 --> 17:38:02,359
require dot slash contract
editor dot JSON, and then const

17385
17:38:02,359 --> 17:38:08,149
API equals require dot slash API
dot JSON. And then we'll do

17386
17:38:08,149 --> 17:38:14,479
module dot exports equals API
and contract addresses. So now

17387
17:38:14,479 --> 17:38:17,749
once we export them like this
back in our lottery entrance, we

17388
17:38:17,749 --> 17:38:22,279
can import them just in one
line. So we'll say import API

17389
17:38:22,279 --> 17:38:29,659
comma contract addresses from
dot dot slash constants. So we

17390
17:38:29,659 --> 17:38:32,329
can just specify the folder
instead of each individual

17391
17:38:32,329 --> 17:38:35,119
files, because we have this
index dot j s here, which

17392
17:38:35,149 --> 17:38:40,609
basically represents this whole
folder. Back in here, what do we

17393
17:38:40,609 --> 17:38:44,509
have now? Let's uncomment this
abi. Okay, great. We have the

17394
17:38:44,509 --> 17:38:48,169
ABI we're importing it from our
constants, folder, contract

17395
17:38:48,199 --> 17:38:51,529
addresses, we have our contract
addresses. And we're going to

17396
17:38:51,529 --> 17:38:56,059
need to specify the network ID
in just a second here. We have

17397
17:38:56,059 --> 17:38:59,449
the function name here, which is
going to be what enter the

17398
17:38:59,929 --> 17:39:04,879
raffle. There are no params. So
all we need to do so how do we

17399
17:39:04,879 --> 17:39:09,409
get both the chain ID and then
Also the message dot value will

17400
17:39:09,409 --> 17:39:11,989
change, it is something that we
can get really easily with

17401
17:39:11,989 --> 17:39:14,479
Morales, let's comment this
whole section out one more time,

17402
17:39:14,509 --> 17:39:18,739
just so I can show you something
we can do import. Once again,

17403
17:39:18,739 --> 17:39:25,579
we're going to get that use
Morales book from react Morales.

17404
17:39:25,639 --> 17:39:28,069
And what we can do is we can say
const.

17405
17:39:29,569 --> 17:39:37,039
Chain ID equals use ralis. Now,
the reason morality knows about

17406
17:39:37,039 --> 17:39:40,159
what chain we're on is because
back in our header component,

17407
17:39:40,369 --> 17:39:44,629
the header actually passes up
all the information about the

17408
17:39:44,629 --> 17:39:48,169
Metamask to the Morales
provider. And then the Morales

17409
17:39:48,169 --> 17:39:52,549
provider passes it down to all
the components inside those

17410
17:39:52,549 --> 17:39:55,999
Morales provided tags
concentrated equals use Morales.

17411
17:39:56,059 --> 17:39:59,539
And I'm just gonna do a little
console log chain ID because I

17412
17:39:59,539 --> 17:40:02,209
want to show you what it looks
like. So if we do a little

17413
17:40:02,209 --> 17:40:05,239
refresh, and we're in the
console here, we can ignore some

17414
17:40:05,239 --> 17:40:09,019
of these warnings here, but we
see the chain ID is actually 0x

17415
17:40:09,019 --> 17:40:12,379
Five, well, because I'm on the
rink B chain or the Grilley

17416
17:40:12,379 --> 17:40:15,079
chain excuse me, if I switch
back to hard hat localhost,

17417
17:40:15,109 --> 17:40:17,599
which you should know how to do
from a SEMA fun we bet if you

17418
17:40:17,599 --> 17:40:20,149
don't have hard hat localhost
and your Metamask go back to

17419
17:40:20,149 --> 17:40:23,359
that HTML font we bit follow
that along. Okay, great. Now

17420
17:40:23,359 --> 17:40:26,209
it's going to print this Oh x
bla bla bla bla bla. So that

17421
17:40:26,209 --> 17:40:30,829
might be a little bit confusing.
But this is the hex version of

17422
17:40:30,859 --> 17:40:34,129
our chain ID. Right. So let's
switch to Etherium main net. Now

17423
17:40:34,129 --> 17:40:37,489
we pronounce Oh x one, right?
Oh, x one is the hex version of

17424
17:40:37,489 --> 17:40:42,319
the number one. So chain ID
gives us the hex addition of the

17425
17:40:42,319 --> 17:40:45,229
chain ID. So I don't want the
hex addition, I want the actual

17426
17:40:45,229 --> 17:40:48,139
number. So what I'm going to do
is I'm going to say Okay, chain

17427
17:40:48,139 --> 17:40:52,459
ID, your name is actually going
to be chain ID hex. And we can

17428
17:40:52,459 --> 17:40:55,939
do console dot log chain ID hex,
but I want the number. So what

17429
17:40:55,939 --> 17:41:02,389
we can do is parse a built in
JavaScript parse int, CIN ID hex

17430
17:41:02,419 --> 17:41:05,929
like that. Now if I go back,
we'll do a little refresh here.

17431
17:41:06,409 --> 17:41:09,769
Scroll away from the warning, we
can see the one here. Now let's

17432
17:41:09,769 --> 17:41:14,659
switch to hard hat, localhost.
We'll scroll down we see 31337.

17433
17:41:14,689 --> 17:41:18,499
So use Morales chain ID returns
the hex we parse it with Parson

17434
17:41:18,559 --> 17:41:21,589
to get the actual number. Okay,
great. So we can stick the chain

17435
17:41:21,589 --> 17:41:24,439
ID into here. Now this raffle
address is something that we're

17436
17:41:24,439 --> 17:41:26,839
actually going to use a lot, we
might as well have it be at the

17437
17:41:26,839 --> 17:41:30,109
top of our code here, we aren't
going to be changing the raffle

17438
17:41:30,109 --> 17:41:32,719
address. So we don't need to put
it in a hook. We are going to

17439
17:41:32,719 --> 17:41:35,209
technically be changing the
address when we change networks.

17440
17:41:35,239 --> 17:41:39,199
But our header app takes care of
re rendering and dealing with

17441
17:41:39,199 --> 17:41:41,839
all that. So we can just make
this a constant variable. So we

17442
17:41:41,839 --> 17:41:47,149
can say const, raffle address
equals, first let's check the

17443
17:41:47,149 --> 17:41:50,419
chain ID hex and if there's a
chain ID hex and if there's not

17444
17:41:50,419 --> 17:41:52,429
a chain ID hex we're gonna do
something else. Excuse me, we're

17445
17:41:52,429 --> 17:41:56,089
gonna say chain ID hex in
contract addresses. And

17446
17:41:56,089 --> 17:41:58,189
actually, there's never gonna be
a chain ID hex. So we'll do

17447
17:41:58,189 --> 17:42:04,489
const chain ID equals Gen ID hex
parsed, Parsons, chinati hex,

17448
17:42:04,519 --> 17:42:06,649
and you might be thinking, hey,
this, these are both the same

17449
17:42:06,649 --> 17:42:09,919
name. Well, what we're doing up
here in use Morales is we're

17450
17:42:09,919 --> 17:42:13,519
saying hey, pull out the chin ID
object, and then rename it to

17451
17:42:13,519 --> 17:42:15,769
chain ID hex and down here,
we're saying, Hey, we're going

17452
17:42:15,769 --> 17:42:18,859
to create a new variable called
Chain ID. So we'll say contract

17453
17:42:19,519 --> 17:42:26,029
addresses of chain ID at zero.
So in here, we're saying this

17454
17:42:26,059 --> 17:42:29,929
network ID and this address,
otherwise, we'll just say no.

17455
17:42:30,559 --> 17:42:34,309
Okay, we're getting there. Let's
uncomment this, now we have the

17456
17:42:34,339 --> 17:42:37,819
raffle address, and we can just
stick it in here. All we do now

17457
17:42:37,969 --> 17:42:42,259
is the message dot value. If we
remember back to our raffle, we

17458
17:42:42,259 --> 17:42:46,069
actually set that fee
dynamically. So we have in here

17459
17:42:46,099 --> 17:42:48,409
we do entrance fee equals
entrance fee, which is the

17460
17:42:48,409 --> 17:42:51,769
parameter in the constructor. So
we want to call this get

17461
17:42:51,769 --> 17:42:54,709
entrance fee function. This is
one of the ways we can send a

17462
17:42:54,709 --> 17:42:57,949
transaction. And we can also
send functions, one of the ways

17463
17:42:57,949 --> 17:43:01,129
that we're going to do it right
when our lottery entrance loads,

17464
17:43:01,159 --> 17:43:05,389
we're going to run a function to
read that entrance fee value. So

17465
17:43:05,479 --> 17:43:08,119
how do we do that? Well, we can
use one of our hooks again,

17466
17:43:08,149 --> 17:43:11,239
right use effect use effect can
run right when something

17467
17:43:11,239 --> 17:43:13,789
changes, we're only going to
want to try to get that raffle

17468
17:43:13,789 --> 17:43:17,779
entrance fee if web three is
enabled. So what we can do is

17469
17:43:17,779 --> 17:43:21,769
back up in here and use Morales
will pull in that is web three

17470
17:43:21,769 --> 17:43:25,309
enabled. And we'll have our use
effect in our function, we'll

17471
17:43:25,309 --> 17:43:31,249
just say if this is web three
enabled, then we'll try to read.

17472
17:43:32,870 --> 17:43:36,050
So we can go ahead and use this
use web three, contract Wagan.

17473
17:43:36,140 --> 17:43:38,780
Let's go ahead and just copy
paste this. And we'll use the

17474
17:43:38,780 --> 17:43:44,120
same setup here. Except instead
of enter raffle, of course,

17475
17:43:44,120 --> 17:43:48,710
we're going to be doing get
entrance fee. So we're going to

17476
17:43:48,740 --> 17:43:52,640
get entrance fee. We need the
API we got it raffle address got

17477
17:43:52,640 --> 17:43:55,550
it. This is going to be the
function name is going to be get

17478
17:43:55,550 --> 17:43:59,480
entrance fee params nothing
message that value, nothing.

17479
17:43:59,660 --> 17:44:02,120
We're going to be calling this
get entrance fee function. And

17480
17:44:02,120 --> 17:44:05,780
now I finally show you how to
actually call one of these in

17481
17:44:05,780 --> 17:44:09,080
our contracts here. Use web
three contract, download our use

17482
17:44:09,080 --> 17:44:12,440
effect, we're actually going to
call get entrance fee. Now if we

17483
17:44:12,440 --> 17:44:15,260
just call get entrance fee like
this, and we say like, you know,

17484
17:44:15,260 --> 17:44:19,220
const something equals get
entrance fee and then console

17485
17:44:19,220 --> 17:44:22,730
dot log something, what do you
think's going to happen? And

17486
17:44:22,760 --> 17:44:27,620
oops, I need to import, I need
to import use effect from react.

17487
17:44:27,830 --> 17:44:33,380
There we go. We look or logs, I
don't see console dot log,

17488
17:44:33,380 --> 17:44:36,680
something won't get entrance fee
is going to be an async

17489
17:44:36,680 --> 17:44:40,190
function. Once again, we need to
wait we would need to do a wait

17490
17:44:40,220 --> 17:44:43,850
get into T, right? There's an
issue we can't call await in our

17491
17:44:43,850 --> 17:44:47,420
use effect. So what can we do?
Well, we can actually make an

17492
17:44:47,450 --> 17:44:52,550
async function, call it update
UI. And then we can stick this

17493
17:44:52,580 --> 17:44:56,930
inside of the async function
here. And we can call update UI

17494
17:44:57,050 --> 17:45:00,500
right outside of it like this.
So now we go back to our front

17495
17:45:00,500 --> 17:45:03,500
end, we do a little refresh. And
if we scroll up, we still see

17496
17:45:03,500 --> 17:45:07,610
nothing. Well, is web three
enabled actually changes. So the

17497
17:45:07,610 --> 17:45:11,600
first time that this runs, is
web three enabled probably is

17498
17:45:11,630 --> 17:45:15,500
false. But when it turns to
true, we want to we want to run

17499
17:45:15,500 --> 17:45:18,230
this section in our little
dependency array. We're going to

17500
17:45:18,230 --> 17:45:21,320
add this in here, right? And the
reason that it's false to start

17501
17:45:21,320 --> 17:45:25,280
with is because of exactly what
we showed in that manual header,

17502
17:45:25,340 --> 17:45:28,760
right? What does it do? Well,
first, we check to see after we

17503
17:45:28,760 --> 17:45:31,520
do a refresh, if window dot
local storage get item is

17504
17:45:31,520 --> 17:45:34,850
connected, then we call Enable
Web three, which will make this

17505
17:45:34,880 --> 17:45:38,000
enabled. So in our lottery
entrance, is what they're

17506
17:45:38,000 --> 17:45:42,020
enabled starts off as false when
we do a refresh. And then the

17507
17:45:42,020 --> 17:45:45,110
browser checks the local storage
says, oh, web three should be

17508
17:45:45,110 --> 17:45:48,140
enabled, let's enable it and
turn to true. So now if we hit

17509
17:45:48,140 --> 17:45:52,160
save, and we do a little refresh
in our console, we can now see

17510
17:45:52,190 --> 17:45:55,610
the logged out entrance fee. So
then we'll switch this to

17511
17:45:56,270 --> 17:46:03,710
entrance fee from contract. Now,
we also probably want to show

17512
17:46:03,860 --> 17:46:08,840
this entrance fee on our UI, if
we do let entrance fee, we'll

17513
17:46:08,840 --> 17:46:14,240
say equals blank. And we'll take
this and we'll update, you know,

17514
17:46:14,240 --> 17:46:16,820
and we'll update this just
saying entrance fee equals await

17515
17:46:16,820 --> 17:46:19,820
entrance fee. Cool. Now we have
this as kind of a global

17516
17:46:19,820 --> 17:46:22,940
variable, we can add it in here.
And then let's even do a weight

17517
17:46:22,940 --> 17:46:26,150
entrance fee. But this whole
thing in parentheses, and then

17518
17:46:26,150 --> 17:46:31,640
do.to string, and we can even
console dot log entrance fee.

17519
17:46:33,200 --> 17:46:36,260
Now we're adding in a new
browser. But there's still an

17520
17:46:36,260 --> 17:46:39,170
issue here. Let's see if you can
spot it, we'll do a little

17521
17:46:39,170 --> 17:46:39,980
refresh.

17522
17:46:41,330 --> 17:46:45,440
We don't see the entrance fee in
the UI here. But we do see it

17523
17:46:45,440 --> 17:46:47,750
good console dot log out, right.
And again, this is going to be

17524
17:46:47,750 --> 17:46:51,560
in a way here, what is going on
here will use effect is going to

17525
17:46:51,590 --> 17:46:54,860
rerender our browser, right? And
that's what we want is what

17526
17:46:54,860 --> 17:46:57,830
three enable goes from false to
true, our browser re renders

17527
17:46:57,860 --> 17:47:02,420
watch, once we get our entrance
fee, does our browser rerender?

17528
17:47:02,720 --> 17:47:06,170
No, it does not because entrance
fee is just one of these normal

17529
17:47:06,170 --> 17:47:09,560
variables, right. So we want to
actually change this from being

17530
17:47:09,560 --> 17:47:12,980
just a normal variable to being
a hook because entrance fee does

17531
17:47:12,980 --> 17:47:16,190
get updated, but it's not
triggering a rerender. So we

17532
17:47:16,190 --> 17:47:19,520
actually want to change this to
being what's called a use state

17533
17:47:19,520 --> 17:47:22,280
hook. So you can read some more
on the documentation about the

17534
17:47:22,280 --> 17:47:24,890
using the state hook, it's kind
of the same as doing let

17535
17:47:24,890 --> 17:47:28,070
entrance fee, you know, equals
blah, blah, blah, and setting it

17536
17:47:28,070 --> 17:47:32,090
below. But it also will trigger
a rerender for us. And to do it,

17537
17:47:32,090 --> 17:47:37,670
we actually do const entrance
fee, comma, set entrance fee

17538
17:47:38,840 --> 17:47:44,870
equals use state zero import use
state from react as well. So

17539
17:47:44,870 --> 17:47:47,630
basically, entrance fee is going
to be our value, right, so if we

17540
17:47:47,630 --> 17:47:50,480
do console dot log entrance fee,
it's going to print out the

17541
17:47:50,480 --> 17:47:53,810
entrance fee entrance fee is
going to be the variable we call

17542
17:47:53,810 --> 17:47:57,050
to get the entrance fee, the
entrance fee is going to be the

17543
17:47:57,050 --> 17:48:01,400
function we call to update or
set that entrance fee. And

17544
17:48:01,400 --> 17:48:04,700
whatever that this entrance fee
variable is set, we trigger a

17545
17:48:04,700 --> 17:48:08,360
rerender. From the front end, we
have the state or the actual

17546
17:48:08,360 --> 17:48:11,870
variable in the function to
update it. And then in the use

17547
17:48:11,870 --> 17:48:14,330
state here, we just give it its
starting values we're saying

17548
17:48:14,630 --> 17:48:18,350
entrance fee is going to start
out as zero. So now that we know

17549
17:48:18,350 --> 17:48:22,130
that, let's go back down here,
and instead of saying entrance

17550
17:48:22,130 --> 17:48:28,160
fee equals this, we can say
const entrance fee from call

17551
17:48:28,760 --> 17:48:32,960
equals away entrance fee.to
string and then we can say set

17552
17:48:32,960 --> 17:48:37,700
entrance fee to this entrance
fee from call. And now when we

17553
17:48:37,700 --> 17:48:40,730
set the use state, we're going
to trigger a rerender. So

17554
17:48:40,730 --> 17:48:43,970
entrance fee will actually be
populated. Now if we go to our

17555
17:48:43,970 --> 17:48:49,010
browser, do a little refresh
here. We can see that the

17556
17:48:49,010 --> 17:48:51,860
entrance fee has indeed been re
rendered here and we can

17557
17:48:51,860 --> 17:48:54,440
actually see it here. We see the
console dot log of zero here

17558
17:48:54,470 --> 17:48:56,870
even though we're doing console
dot log entrance fee because

17559
17:48:56,900 --> 17:48:59,630
this set entrance to function
hasn't finished running it

17560
17:48:59,630 --> 17:49:02,840
basically. So we're just gonna
get rid of that line will

17561
17:49:02,840 --> 17:49:06,860
refresh and Bada bing bada boom,
this huge number is kind of

17562
17:49:06,860 --> 17:49:10,160
gross. We might even want to
update it so that it looks a

17563
17:49:10,160 --> 17:49:16,040
little bit nicer. So once again,
we can import ethers, ethers

17564
17:49:16,070 --> 17:49:23,180
from ethers. And down below,
we'll do a little ethers dot

17565
17:49:23,180 --> 17:49:32,750
utils dot format units. And
we'll do entrance fee from call

17566
17:49:32,750 --> 17:49:36,110
and we'll do a comma and type
in. And if we refresh on the

17567
17:49:36,110 --> 17:49:40,340
front end, now we can see,
entrance fee is 0.1. So we can

17568
17:49:40,340 --> 17:49:44,180
even label this we'll say
entrance fee, blah, blah, blah.

17569
17:49:45,440 --> 17:49:49,460
Now if we do a little refresh on
the front end, entrance fee 0.1

17570
17:49:49,490 --> 17:49:49,700
E.

17571
17:49:52,400 --> 17:49:56,120
Finally, we have the entrance
fee, and now uses finally on our

17572
17:49:56,120 --> 17:49:59,540
function to enter the lottery.
So let's finally uncomment this

17573
17:49:59,540 --> 17:50:02,090
out. And for message value,
we're going to want to use this

17574
17:50:02,090 --> 17:50:04,820
entrance fee. And I'm realizing
it's actually better to store

17575
17:50:04,820 --> 17:50:08,090
this in its raw to string
format. So we're going to undo

17576
17:50:08,090 --> 17:50:11,660
this part that we just did.
We're going to add it down here.

17577
17:50:11,810 --> 17:50:15,560
So we're going to ethers, that
format units, entrance fee,

17578
17:50:15,560 --> 17:50:19,880
comma, ether, like that. So that
like that, and let's comment

17579
17:50:19,880 --> 17:50:22,880
this back out real quick. So
that at least in the UI, it

17580
17:50:22,880 --> 17:50:26,450
shows up at 0.1. But on the back
end, we're actually going to

17581
17:50:26,450 --> 17:50:30,500
save it as its raw, and have way
value. So we're saying that we

17582
17:50:30,500 --> 17:50:34,550
have this entrance fee and what
we can do uncomment, this, we

17583
17:50:34,550 --> 17:50:38,060
can just grab this entrance fee,
and plop it in here. So we need

17584
17:50:38,060 --> 17:50:41,540
to make a button that's gonna do
that. Now again, we want to make

17585
17:50:41,540 --> 17:50:44,510
our code that all this works,
even if we're connected to a

17586
17:50:44,510 --> 17:50:47,330
supported chain, though. So
before we even add this, right,

17587
17:50:47,330 --> 17:50:50,750
if we switch from hard hat to
like, Aetherium main net, do a

17588
17:50:50,750 --> 17:50:53,870
little refresh. We're getting
kind of get an error here,

17589
17:50:53,930 --> 17:50:58,460
because we're calling get
entrance fee.to string on an

17590
17:50:58,460 --> 17:51:01,220
address that doesn't exist,
right? So it's gonna get really

17591
17:51:01,220 --> 17:51:04,760
confused and be like, hey, what,
what are you doing here? Let's

17592
17:51:04,790 --> 17:51:07,580
add a little button here so that
we can actually enter the

17593
17:51:07,580 --> 17:51:11,690
raffle. Before we actually do
that, let's make sure that we

17594
17:51:11,690 --> 17:51:14,120
can only call the function so
long as there actually is a

17595
17:51:14,120 --> 17:51:18,650
raffle address. So we'll do
raffle address. And we'll do

17596
17:51:18,650 --> 17:51:22,520
this ternary operator once
again. So that only if this

17597
17:51:22,520 --> 17:51:26,060
raffle address is valid, right?
And it's not, no, we'll add all

17598
17:51:26,060 --> 17:51:28,520
this code here, right. So we'll
say if the raffle address

17599
17:51:28,520 --> 17:51:31,370
exists, we're going to do some
stuff. And for now, we can

17600
17:51:31,370 --> 17:51:35,990
actually just copy paste this
line, stick it in here. And then

17601
17:51:36,020 --> 17:51:41,060
otherwise, we'll say div.
Excellence div, close it off.

17602
17:51:41,090 --> 17:51:46,550
We'll save reformat, great.
We'll say no raffle address,

17603
17:51:46,940 --> 17:51:50,870
detected. Now we'll just do all
of our code in this section up

17604
17:51:50,870 --> 17:51:53,930
here. So we have this little div
here, which is great. Inside of

17605
17:51:53,930 --> 17:52:00,410
this div, let's add a button.
Button button, we'll save it got

17606
17:52:00,410 --> 17:52:05,240
a little button here, we'll have
it say, enter raffle. And we'll

17607
17:52:05,240 --> 17:52:09,200
say on click, well, we're going
to do some JavaScript. So let's

17608
17:52:09,200 --> 17:52:13,610
do some JavaScript, we want to
call an async function async

17609
17:52:13,610 --> 17:52:16,970
function. So I know the double
brackets is going to be

17610
17:52:16,970 --> 17:52:19,040
confusing, right. But these
brackets allow us to do

17611
17:52:19,040 --> 17:52:23,810
JavaScript in our HTML, or JSX,
or whatever. And these brackets

17612
17:52:23,840 --> 17:52:27,470
represent this function, it's
going to an async function. And

17613
17:52:27,470 --> 17:52:33,440
we're gonna say, await, enter
raffle. And that's it. So let's

17614
17:52:33,440 --> 17:52:35,750
go back to the front end. Now we
have a little enter raffle

17615
17:52:35,750 --> 17:52:40,010
function. If we do refresh,
let's just make sure our account

17616
17:52:40,010 --> 17:52:43,640
is reset here. So we're gonna go
down to settings, advanced,

17617
17:52:44,120 --> 17:52:48,680
reset accounts, yes. I hit ENTER
raffle. metamath does indeed pop

17618
17:52:48,680 --> 17:52:53,330
up. And we can go ahead and
confirm. Awesome, okay, we can

17619
17:52:53,330 --> 17:52:56,930
now enter our raffle. We're
doing incredibly well with this.

17620
17:52:59,690 --> 17:53:02,480
As you saw, we just got that pop
up. And that was pretty much it,

17621
17:53:02,480 --> 17:53:05,960
right? It's not very helpful for
the users who are following

17622
17:53:05,960 --> 17:53:09,380
along with this to look at this
and go, Okay, did it go through?

17623
17:53:09,410 --> 17:53:12,860
Or we did it fail, like, what,
what just happened? So what we

17624
17:53:12,860 --> 17:53:15,860
want to do is create what's
called notifications, right? We

17625
17:53:15,860 --> 17:53:18,800
want a little pop up saying,
Hey, you sent your transaction,

17626
17:53:18,830 --> 17:53:22,370
great job, we're going to use a
library. Again, we're going to

17627
17:53:22,370 --> 17:53:24,740
use the web through UI Kit,
which comes with some

17628
17:53:24,770 --> 17:53:27,770
notifications that we can go
ahead and use. So if you come to

17629
17:53:27,770 --> 17:53:30,920
this little interactive thing,
which is right in their GitHub,

17630
17:53:31,370 --> 17:53:34,340
there's a whole bunch of stuff
in here. And you can actually

17631
17:53:34,340 --> 17:53:36,530
click around and play with
different buttons and different

17632
17:53:36,530 --> 17:53:39,920
things. And you can actually go
ahead and even go to docs for

17633
17:53:39,920 --> 17:53:43,100
each one of these. And you can
go show code. And you can

17634
17:53:43,100 --> 17:53:45,620
literally like copy paste code
into your project, like whatever

17635
17:53:45,620 --> 17:53:49,100
you want to do styling and
everything for us. So back in

17636
17:53:49,100 --> 17:53:54,740
our app dot j s, we're going to
add import, no to vacations

17637
17:53:54,770 --> 17:54:01,490
provider from web three UI kit
and inside of the Morales

17638
17:54:01,490 --> 17:54:04,310
provider, but outside of the
components, we're gonna do

17639
17:54:04,310 --> 17:54:07,760
notification provider
notification provide Add it like

17640
17:54:07,760 --> 17:54:10,610
this. So it goes Morales
provider notification provider

17641
17:54:10,610 --> 17:54:13,670
component. So wrapping our
component in this notifications

17642
17:54:13,670 --> 17:54:18,470
thing, and that's notification
provider not notifications. And

17643
17:54:18,470 --> 17:54:22,160
this is going to allow us to
actually make notifications back

17644
17:54:22,160 --> 17:54:24,710
in our lottery entrance. Back in
our lottery entrance, we're

17645
17:54:24,710 --> 17:54:28,130
gonna scroll up to the top,
we're going to import a hook

17646
17:54:28,160 --> 17:54:34,370
those notifications called us
know, to the occasion from web

17647
17:54:34,370 --> 17:54:39,500
three UI kit. And this use
notification gives us this thing

17648
17:54:39,500 --> 17:54:43,310
back called a dispatch. So I'm
gonna say const, dispatch,

17649
17:54:43,640 --> 17:54:47,240
equals use notification. So use
notification returns this

17650
17:54:47,240 --> 17:54:49,880
dispatch, and this dispatch is
like a little pop up that will

17651
17:54:49,880 --> 17:54:54,110
give us so down here, when we
call this enter raffle, we're

17652
17:54:54,110 --> 17:54:56,330
gonna give it a little some
parameters in here, we're gonna

17653
17:54:56,330 --> 17:55:00,530
say on success, these functions
come with onsuccess, they come

17654
17:55:00,530 --> 17:55:05,120
with onComplete, they come with
an error, all this stuff. And

17655
17:55:05,150 --> 17:55:08,930
when this function is
successful, we'll do handle

17656
17:55:09,080 --> 17:55:12,950
success, we'll create a new
handle success function that

17657
17:55:12,950 --> 17:55:16,070
will handle the success. And
this is Patrick from the future

17658
17:55:16,070 --> 17:55:18,890
coming back to show one
additional point. I know I

17659
17:55:18,890 --> 17:55:23,900
mentioned it, but it is really
good to add this on error, colon

17660
17:55:24,260 --> 17:55:29,270
error console dot log error for
any run contract functions, even

17661
17:55:29,270 --> 17:55:33,290
the reads, If any of your run
contract functions break, you

17662
17:55:33,290 --> 17:55:36,500
won't know. So definitely want
to add this on error error

17663
17:55:36,500 --> 17:55:40,880
console dot log error to all of
your run contract functions. So

17664
17:55:40,880 --> 17:55:45,320
up here, before the return,
we'll create a new const handle

17665
17:55:45,320 --> 17:55:51,170
success. We'll say this is an
async function async function

17666
17:55:51,170 --> 17:55:55,190
that takes the transaction as
input parameters. And remember,

17667
17:55:55,490 --> 17:55:59,900
you can turn functions into
constant variables. And we'll

17668
17:55:59,900 --> 17:56:05,750
say await TX dot Wait, one, so
we'll wait for that transaction

17669
17:56:05,750 --> 17:56:08,750
to go through. And then we'll
create another function called

17670
17:56:08,960 --> 17:56:13,160
handle new notification, dx. And
you'll see why I'm doing it like

17671
17:56:13,160 --> 17:56:16,640
this in a minute. And we'll say
const and Linoone notification,

17672
17:56:17,240 --> 17:56:19,880
this is just going to be a
synchronous function because we

17673
17:56:19,880 --> 17:56:22,730
don't need it to be async. And
we're just going to call this

17674
17:56:22,730 --> 17:56:26,000
dispatch, we're going to set up
this notification basically. So

17675
17:56:26,000 --> 17:56:28,280
we'll say notify, or dispatch,
and then we'll add the

17676
17:56:28,280 --> 17:56:31,550
parameters in here. So it takes
an object as a parameter, we'll

17677
17:56:31,550 --> 17:56:38,600
say type info. Message, it's
going to be transaction

17678
17:56:38,690 --> 17:56:50,300
complete, the title is going to
be TX notification. Jose, Shawn,

17679
17:56:50,390 --> 17:56:55,610
we're going to say, top are and
then icon, we're going to say a

17680
17:56:55,610 --> 17:56:56,210
little bell.

17681
17:56:58,100 --> 17:57:01,430
And you can find all this stuff
right in here, type icon

17682
17:57:01,430 --> 17:57:05,180
position, you can read all about
the different parameters you can

17683
17:57:05,180 --> 17:57:07,910
kind of set this up with so
handle new notification handle

17684
17:57:07,910 --> 17:57:12,470
success. So we're saying, enter
raffle once this transaction is

17685
17:57:12,470 --> 17:57:16,010
successful, call this handle
success function, which is going

17686
17:57:16,010 --> 17:57:19,580
to call handle new notification.
Okay. And you'll see why we

17687
17:57:19,580 --> 17:57:22,820
split this into two instead of
just having handle success. Also

17688
17:57:22,820 --> 17:57:26,450
do the dispatch. When we press
our enter raffle button, we're

17689
17:57:26,450 --> 17:57:29,180
going to call enter raffle is
successful, we're going to call

17690
17:57:29,180 --> 17:57:32,000
handle success. We're going to
wait for that transaction to

17691
17:57:32,000 --> 17:57:35,720
finish Yes, it passes a
parameter to our handle success

17692
17:57:35,720 --> 17:57:38,360
function. And then all we're
going to do is we're going to

17693
17:57:38,360 --> 17:57:41,810
call handle new notification.
And we're going to dispatch

17694
17:57:41,810 --> 17:57:44,420
we're going to launch one of
these notifications. So back

17695
17:57:44,420 --> 17:57:49,010
here, let's hit enter raffle.
metamath pops up will confirm.

17696
17:57:49,280 --> 17:57:52,280
And after it completes, we get
this wonderful transaction

17697
17:57:52,280 --> 17:57:55,130
notification transaction
complete, right. So we've let

17698
17:57:55,130 --> 17:57:59,480
the user know, great job, you've
submitted a transaction. Great

17699
17:57:59,480 --> 17:58:03,050
work. So this is great. We're
giving our users some helpful

17700
17:58:03,050 --> 17:58:08,300
pieces here. Now let's add a
little bit more here so that the

17701
17:58:08,300 --> 17:58:11,210
users know what else is going on
with this lottery. But we need

17702
17:58:11,210 --> 17:58:13,820
to display a little bit more
data, right, let's display how

17703
17:58:13,820 --> 17:58:17,600
many people are in this lottery.
How many people are in this

17704
17:58:17,600 --> 17:58:21,380
game. And we can do that. Of
course, because we have a number

17705
17:58:21,410 --> 17:58:24,650
players command. We also
probably want to get the recent

17706
17:58:24,650 --> 17:58:27,830
winner. And we can do that as
well. Up here, we're going to

17707
17:58:27,830 --> 17:58:30,650
copy this get entrance fee,
we're going to create another

17708
17:58:30,650 --> 17:58:36,980
one called Get num players. And
this is going to call go back to

17709
17:58:36,980 --> 17:58:39,890
raffle dot soul. It's going to
call get number of players

17710
17:58:39,920 --> 17:58:43,100
actually so let's just call it
call it the same thing. Get

17711
17:58:43,100 --> 17:58:46,220
number of players and we're
going to call and get number of

17712
17:58:46,220 --> 17:58:50,180
players. And to store this
value. Once again up at the top.

17713
17:58:50,630 --> 17:58:55,160
We're going to copy this line,
paste it right and we'll do non

17714
17:58:55,160 --> 17:59:00,440
players. And then we'll do set
num players. And then we'll copy

17715
17:59:00,440 --> 17:59:05,150
this line again. A recent winner
so we'll do recent Winner.

17716
17:59:05,900 --> 17:59:11,600
Winner will do Set, recent
winner, then we'll copy this

17717
17:59:11,600 --> 17:59:16,520
again, instead of getting number
players will do get get recent

17718
17:59:16,520 --> 17:59:20,510
winner. So we'll call it get
recent winner get recent winner

17719
17:59:20,990 --> 17:59:24,350
in our use effect, let's do more
than just get the entrance fee,

17720
17:59:24,350 --> 17:59:30,020
let's get everything. So we can
say const num players, from call

17721
17:59:30,380 --> 17:59:37,250
equals, we'll do a weight, get
number of players.to string, and

17722
17:59:37,250 --> 17:59:42,590
then we'll do set set num
players do like that. So we'll

17723
17:59:42,590 --> 17:59:47,630
do set num players, num players
from call. And then we'll also

17724
17:59:47,630 --> 17:59:53,270
do const recent winner from call
this is going to be await get

17725
17:59:54,080 --> 17:59:57,410
recent winner. And we might need
to wrap this to string but I

17726
17:59:57,410 --> 18:00:00,920
think I don't think we need to.
So we'll do set recent winner

17727
18:00:01,310 --> 18:00:04,070
paste that in here. So now we've
had a number of players, we've

17728
18:00:04,070 --> 18:00:07,550
added a recent winner. Let's
come back down here. We have an

17729
18:00:07,550 --> 18:00:14,060
entrance fee. Let's go ahead and
do number of players. And we'll

17730
18:00:14,060 --> 18:00:19,490
add number of players or what
did we call it? Oh my god, we

17731
18:00:19,490 --> 18:00:22,970
called setting employers twice
oops, it's called non players,

17732
18:00:23,090 --> 18:00:27,020
scroll down players gonna be non
players, and then we'll do

17733
18:00:27,770 --> 18:00:28,970
recent winner.

17734
18:00:30,350 --> 18:00:35,600
And then we'll add in the recent
winner. Awesome. Okay, entrance

17735
18:00:35,600 --> 18:00:40,670
fees 0.1 eath number of players
to recent winner is nobody here.

17736
18:00:40,730 --> 18:00:45,080
And if we go ahead and we enter
the raffle metamath pops up.

17737
18:00:45,680 --> 18:00:48,680
We'll go ahead and confirm. Once
a transaction goes through,

17738
18:00:48,710 --> 18:00:53,210
we'll get transaction complete.
And if we do a refresh, we see

17739
18:00:53,210 --> 18:00:56,600
the number of players has
updated. But we had to refresh

17740
18:00:56,600 --> 18:00:58,490
which is kind of annoying,
right, let's enter the raffle

17741
18:00:58,490 --> 18:01:03,170
again, we'll go confirm
transaction complete. But this

17742
18:01:03,170 --> 18:01:06,260
didn't rerender. Right. So we
want to set something up so that

17743
18:01:06,260 --> 18:01:09,590
we automatically rerender. And
guess what's going to do that

17744
18:01:09,620 --> 18:01:11,900
the handle success that we were
talking about before. That's

17745
18:01:11,900 --> 18:01:15,650
right, all of this update UI
stuff, we can actually pull out

17746
18:01:15,650 --> 18:01:19,220
of the use effect. So we're
going to copy it all deleted

17747
18:01:19,220 --> 18:01:22,610
there. And we're going to have
it be its own standalone

17748
18:01:22,610 --> 18:01:26,120
function like this. And then in
our handle success, whenever

17749
18:01:26,120 --> 18:01:29,480
this successful transaction goes
through, we're going to update

17750
18:01:29,480 --> 18:01:33,890
the UI, right? So handle success
handled new notification, and

17751
18:01:33,920 --> 18:01:37,040
we're going to update the white.
So now if we go back here, let's

17752
18:01:37,040 --> 18:01:41,450
enter the lottery. Let's
confirm, we see we get the five

17753
18:01:41,480 --> 18:01:43,910
and we get transaction
Notification. Now we want to

17754
18:01:43,910 --> 18:01:47,810
test getting a recent winner
here. So what we can do,

17755
18:01:47,840 --> 18:01:51,440
actually back in our hard hat
project is we want to create a

17756
18:01:51,440 --> 18:01:54,350
new script. And I actually
already created it for you,

17757
18:01:54,620 --> 18:01:56,630
that's going to mock the
channeling VRF. And that's going

17758
18:01:56,630 --> 18:01:59,990
to mock being a keepers. So all
this is really doing is pretty

17759
18:01:59,990 --> 18:02:02,780
much exactly what our tests were
doing. If you want to pause

17760
18:02:02,780 --> 18:02:05,780
right now and look through this
yourself, pause here and add

17761
18:02:05,780 --> 18:02:09,440
this mock off chain, which is
both keepers and VRF. Or you can

17762
18:02:09,440 --> 18:02:13,250
just go to the GitHub repo here.
Just go to the GitHub repo for

17763
18:02:13,340 --> 18:02:17,090
Lesson Nine. It's already in
scripts go down to scripts

17764
18:02:17,390 --> 18:02:21,230
Markov chain, you can just copy
paste it here. Because I want to

17765
18:02:21,230 --> 18:02:24,740
test that that recent winner. So
in my hard hat, smart contract

17766
18:02:24,740 --> 18:02:30,110
lottery, so we'll do yarn,
hardhats run scripts, slash mock

17767
18:02:30,110 --> 18:02:34,730
off chain dash test network
local host, we're going to mock

17768
18:02:34,970 --> 18:02:37,460
you know, basically picking a
winner from an upkeep with

17769
18:02:37,460 --> 18:02:40,700
Request ID one, we're on a local
network. Okay, let's pretend the

17770
18:02:40,700 --> 18:02:43,850
recent winner was so and so. And
what we can do is we can do a

17771
18:02:43,850 --> 18:02:48,140
little refresh here, we can see
we have a winner updated. Boom.

17772
18:02:48,530 --> 18:02:51,110
Now we're gonna clean up the UI.
But I want to talk about a

17773
18:02:51,110 --> 18:02:53,780
couple of things. Before we do
that, because we're almost done

17774
18:02:53,780 --> 18:02:59,180
with this section. Something I
want to make really clear

17775
18:02:59,180 --> 18:03:02,540
because it confused me a little
bit is that this onsuccess isn't

17776
18:03:02,540 --> 18:03:05,810
checking that the transaction
has a block confirmation, it's

17777
18:03:05,810 --> 18:03:09,410
just checking to see that the
transaction was successfully

17778
18:03:09,410 --> 18:03:14,120
sent to Metamask. So onsuccess
checks to see a transaction is

17779
18:03:14,120 --> 18:03:17,000
successfully sent the Metamask.
And that's why up in that other

17780
18:03:17,000 --> 18:03:20,180
function, we do TX dot wait one
because that's the piece that

17781
18:03:20,180 --> 18:03:22,820
actually waits for the
transaction to be confirmed.

17782
18:03:25,400 --> 18:03:29,030
Right now we're using Morales to
make once we call that mocking

17783
18:03:29,030 --> 18:03:32,300
script, I had to refresh the
browser to see the winner here,

17784
18:03:32,300 --> 18:03:35,240
right and number of players
obviously got reset to zero,

17785
18:03:35,270 --> 18:03:39,080
which is great. That's not
ideal. Ideally, we want our UI

17786
18:03:39,110 --> 18:03:43,400
to just automatically update
when some event gets fired. In

17787
18:03:43,400 --> 18:03:47,630
our raffle contract, we get this
event emitted. Instead of in our

17788
18:03:47,630 --> 18:03:51,650
code doing this await success
here. What we could do is we

17789
18:03:51,650 --> 18:03:57,410
could set up a portion to listen
for that event being emitted and

17790
18:03:57,410 --> 18:04:00,140
update the front end
accordingly. With that knowledge

17791
18:04:00,140 --> 18:04:03,920
we can also listen for the
winner event being emitted. We

17792
18:04:03,920 --> 18:04:06,560
could update our front end
instead of having to refresh

17793
18:04:06,710 --> 18:04:09,320
it's your cue Yes, and you want
to see if you can add to this

17794
18:04:09,320 --> 18:04:12,230
right now, I highly recommend
you do. So

17795
18:04:14,869 --> 18:04:17,779
we've pretty much finished all
the functionality. And wow,

17796
18:04:17,779 --> 18:04:20,089
you've learned a ton in this
little bit, right? We've learned

17797
18:04:20,089 --> 18:04:23,449
about use effects use Morales,
all these hooks, all this stuff,

17798
18:04:23,449 --> 18:04:27,169
and we've got a front end that
very nicely handles interacting

17799
18:04:27,169 --> 18:04:29,839
with our smart contract. The
only thing is, is it looks

17800
18:04:29,869 --> 18:04:34,549
really ugly. This is kind of
gross. So let's make this look

17801
18:04:34,579 --> 18:04:37,369
at least a little bit nicer.
There's two things to think

17802
18:04:37,369 --> 18:04:39,379
about when it comes to building
these front ends. There's

17803
18:04:39,379 --> 18:04:42,829
component libraries, like web
three UI Kit, which we're using,

17804
18:04:42,859 --> 18:04:45,859
which gives us kind of like
components that give us, you

17805
18:04:45,859 --> 18:04:48,889
know, blocks of code, like this
connect button that are already

17806
18:04:48,919 --> 18:04:52,279
formatted for us. And then
there's CSS libraries that

17807
18:04:52,279 --> 18:04:55,849
actually will help us format the
rest of our stuff here. So we're

17808
18:04:55,849 --> 18:04:58,369
using one of these component
libraries. We're also going to

17809
18:04:58,369 --> 18:05:01,159
use one of these formatting
libraries, and the library that

17810
18:05:01,159 --> 18:05:03,829
we're going to use is tailwind.
And the reason that we're going

17811
18:05:03,829 --> 18:05:07,309
to use tailwind CSS is because
it's really popular. If you want

17812
18:05:07,309 --> 18:05:09,829
to learn CSS, there's some
wonderful resources that you can

17813
18:05:09,829 --> 18:05:12,889
use to learn CSS web three
schools is one that I've used a

17814
18:05:12,889 --> 18:05:16,219
ton. So there's going to be a
link to that in the GitHub repo

17815
18:05:16,249 --> 18:05:19,069
associated with this course so
that you can make your websites

17816
18:05:19,069 --> 18:05:21,919
look pretty when formatting
stuff but we are actually going

17817
18:05:21,919 --> 18:05:24,949
to work with tailwind because
it's going to make us doing CSS

17818
18:05:24,949 --> 18:05:28,939
stuff a lot easier. Since we're
using tailwind with next Jas.

17819
18:05:28,969 --> 18:05:31,849
There's actually a wonderful
little guide here for installing

17820
18:05:31,849 --> 18:05:34,969
tailwind with next Jas. And
we're gonna go basically go

17821
18:05:34,969 --> 18:05:37,849
ahead and follow along with
this. This link is available in

17822
18:05:37,849 --> 18:05:40,849
the GitHub repo associated with
this course with this lesson. So

17823
18:05:40,849 --> 18:05:42,919
we've already created our
project we've seeded into our

17824
18:05:42,919 --> 18:05:46,309
project. Now we're gonna go
ahead and install tailwind npm

17825
18:05:46,309 --> 18:05:49,399
install dash D instead, since
we're using yarn, we're going to

17826
18:05:49,399 --> 18:05:55,609
do yarn or pop this open, green
new yarn, add dash dash Dev,

17827
18:05:56,209 --> 18:05:59,779
paste those three in tailwind
CSS, post CSS and then

17828
18:05:59,809 --> 18:06:02,539
autoprefixer and it's the three
of these that are going to

17829
18:06:02,539 --> 18:06:06,349
basically make up tailwind with
next Jas. Once we have those

17830
18:06:06,349 --> 18:06:09,379
we're going to basically init
tailwind and make a config file

17831
18:06:09,379 --> 18:06:13,099
for tailwind. So we're gonna do
yarn tailwind CSS and it does p

17832
18:06:13,789 --> 18:06:18,139
yarn tailwind CSS init dash P
will run that. This is going to

17833
18:06:18,139 --> 18:06:23,059
give us this post CSS dot config
dot j s and this tailwind dot

17834
18:06:23,059 --> 18:06:26,569
config dot j s and what we're
going to want to do is literally

17835
18:06:26,599 --> 18:06:29,479
just hit this copy button, and
we're going to update our

17836
18:06:29,479 --> 18:06:35,059
tailwind.config.js tailwind Jas
so that it says okay, all of

17837
18:06:35,059 --> 18:06:40,039
this stuff, anything in Pages
anything with.js.ts dot JSX or

17838
18:06:40,039 --> 18:06:43,429
TSX. And anything in these
components, anything in those

17839
18:06:43,429 --> 18:06:47,029
two folders is going to be
considered tailwind double. We

17840
18:06:47,029 --> 18:06:49,969
want to use tailwind on these
two folders. Then we're going to

17841
18:06:49,969 --> 18:06:54,739
add the tailwind directives to
our global CSS files. So if we

17842
18:06:54,739 --> 18:06:57,559
go back, we're going to styles
Global's we're going to

17843
18:06:57,559 --> 18:07:01,099
overwrite everything in here
with ADD tailwind base and add

17844
18:07:01,099 --> 18:07:03,589
tailwind components at tailwind
utilities. And this makes it so

17845
18:07:03,589 --> 18:07:07,609
that our global CSS file uses
tailwind. Now, you'll see like

17846
18:07:07,639 --> 18:07:10,579
unknown rule at tailwind, what
we can do is we can go to

17847
18:07:10,579 --> 18:07:14,209
components, what we can do is we
can look up this post CSS

17848
18:07:14,209 --> 18:07:18,019
language support extension,
paste that in here, boom, let's

17849
18:07:18,019 --> 18:07:20,599
go ahead and install this. And
now we get those little

17850
18:07:20,629 --> 18:07:24,259
underscores to go away, which is
really nice. Now, per usual, we

17851
18:07:24,259 --> 18:07:27,619
can just do NPM, run Dev and
start adding tailwind to our

17852
18:07:27,619 --> 18:07:32,869
divs. Now what tailwind does is
allows us in our divs to set

17853
18:07:32,869 --> 18:07:35,449
everything as a class name, and
then just set some real

17854
18:07:35,449 --> 18:07:38,719
minimalistic text in these class
names here. So let's look at our

17855
18:07:38,719 --> 18:07:41,659
smart contract lottery here.
We've just tailwind did it. So

17856
18:07:41,659 --> 18:07:44,359
it already has been updated a
little bit. Let's update our

17857
18:07:44,359 --> 18:07:46,729
header here. Well, let's see. We
want to give our header a border

17858
18:07:46,879 --> 18:07:52,399
from the tailwind. We'll do a
quick search. Look a border we

17859
18:07:52,399 --> 18:07:55,609
can see all this border stuff
like border width border this

17860
18:07:55,609 --> 18:08:00,529
border that say we want a border
on the bottom, we can see we can

17861
18:08:00,529 --> 18:08:03,439
get a border on the bottom with
something like this. Let's do

17862
18:08:03,439 --> 18:08:07,129
border on the bottom with a
width of two pixels. We just do

17863
18:08:07,129 --> 18:08:11,179
border b two. So I'm going to
copy border B to do border b

17864
18:08:11,179 --> 18:08:14,479
two, I'm going to save it and
what we need to do for our CSS

17865
18:08:14,479 --> 18:08:18,109
and everything to take effect.
Go ahead and kill the front end.

17866
18:08:18,349 --> 18:08:20,899
And then we'll rerun it with
yarn Dev. Go back to our front

17867
18:08:20,899 --> 18:08:24,079
end now. Give it a little
refresh and Okay, cool. Now we

17868
18:08:24,079 --> 18:08:27,919
have a little border here. So
we're starting to add some stuff

17869
18:08:27,919 --> 18:08:31,339
and it's just not a whole lot
yet. Oh, and then we can also

17870
18:08:31,339 --> 18:08:35,239
add tailwind to me go to
Extensions. We can also look up

17871
18:08:35,239 --> 18:08:38,479
tailwind. There's a tailwind
extension here. So I'm just

17872
18:08:38,479 --> 18:08:40,849
going to add a whole bunch of
stuff in here. We're gonna do

17873
18:08:40,849 --> 18:08:42,829
flex, flex row.

17874
18:08:44,329 --> 18:08:47,029
We're gonna make our
decentralized lottery and h one

17875
18:08:48,589 --> 18:08:53,569
which stands for like header
one. Do class name equals, we'll

17876
18:08:53,569 --> 18:08:59,059
do the y dash force. We'll give
it padding the top of form the X

17877
18:08:59,059 --> 18:09:03,079
padding on the x axis of four.
We'll make it bold font and

17878
18:09:03,079 --> 18:09:06,559
we'll make the text three XL
size. So we'll make everything

17879
18:09:06,559 --> 18:09:11,419
bigger. Cool. Then we'll do one
more, we'll wrap our Connect

17880
18:09:11,419 --> 18:09:16,189
button in a div. So we'll say
div class name equals, and we'll

17881
18:09:16,189 --> 18:09:21,199
give it a an automatic left
margin. We'll do py too. So some

17882
18:09:21,199 --> 18:09:27,529
y padding, some x padding. See
what we have done. Okay. Now if

17883
18:09:27,529 --> 18:09:31,519
we zoom out a little bit, we can
see, if we close this too, we

17884
18:09:31,519 --> 18:09:34,249
can see now our Connect button
is on the side here. And they're

17885
18:09:34,249 --> 18:09:36,979
kind of separated like that. And
I think that looks nice. So

17886
18:09:36,979 --> 18:09:39,259
we're going to keep that now
we're going to go back to our

17887
18:09:39,259 --> 18:09:42,559
lottery entrance, we're going to
change this up just a hair,

17888
18:09:42,589 --> 18:09:48,259
we'll say div class name equals
P. Five, we'll make our button

17889
18:09:48,259 --> 18:09:53,239
look really nice. We'll say
class name equals background

17890
18:09:53,239 --> 18:10:00,619
blue 500. When we hover over, it
will say, background blue 700.

17891
18:10:00,649 --> 18:10:03,499
So now if I just say that, and
when we hover over it, it looks

17892
18:10:03,499 --> 18:10:07,369
a little different, that's
really nice. We'll say text is

17893
18:10:07,369 --> 18:10:12,169
white, we'll say the font is
bold, we'll give it some white

17894
18:10:12,169 --> 18:10:16,579
padding, I'll give it some x
padding, we'll have the bunbee

17895
18:10:16,579 --> 18:10:20,149
rounded, and we'll give it a
margin left auto, now looks a

17896
18:10:20,149 --> 18:10:22,609
lot better, right? That's a lot
prettier. We're just going to be

17897
18:10:22,609 --> 18:10:25,639
doing some basic CSS here just
to make it look a little bit

17898
18:10:25,639 --> 18:10:28,219
nicer, right, but just that by
itself already made this lottery

17899
18:10:28,219 --> 18:10:31,189
button look a lot cooler. Now
some functionality that we

17900
18:10:31,189 --> 18:10:34,849
didn't add here. So we need to
add a disabled, kind of like

17901
18:10:34,849 --> 18:10:39,589
what we did before. And in our
enter a raffle it comes with,

17902
18:10:39,589 --> 18:10:43,159
like I said, is loading and it
is fetching. None of our

17903
18:10:43,159 --> 18:10:45,769
transaction is loading or
fetching, we'll just make this

17904
18:10:45,799 --> 18:10:50,149
disabled. So we'll say is
loading or is fetching this will

17905
18:10:50,149 --> 18:10:52,489
be disabled. Right? Now, if we
go back to the front, we hit

17906
18:10:52,489 --> 18:10:57,349
enter raffle, go ahead and hit
confirm, we can add a CSS for

17907
18:10:57,349 --> 18:11:00,319
it. But when a transaction is
loading, they will not be able

17908
18:11:00,319 --> 18:11:02,719
to click that button anymore,
which that's something else

17909
18:11:02,719 --> 18:11:05,239
pretty that we want to do
speaking of is loading and is

17910
18:11:05,239 --> 18:11:09,199
fetching. When it's loading or
fetching, we probably want it to

17911
18:11:09,229 --> 18:11:11,749
have that like little spinny
thing right when we hit it right

17912
18:11:11,749 --> 18:11:15,619
now. And mash is pops up. And we
can confirm but it would be cool

17913
18:11:15,619 --> 18:11:18,769
if it had like a little spinny
thing here, right. So you can

17914
18:11:18,769 --> 18:11:22,009
usually just Google like how to
add spinny thing or stuff like

17915
18:11:22,009 --> 18:11:25,039
that, and you'll get something.
But you can again, you can just

17916
18:11:25,039 --> 18:11:27,919
copy paste this from my code,
I'm going to show you what I

17917
18:11:27,919 --> 18:11:31,369
ended up doing for this section.
And we're gonna say is, if is

17918
18:11:31,369 --> 18:11:35,899
loading or is fetching. And
we're going to use that ternary

17919
18:11:35,899 --> 18:11:39,799
operator all the time, then in
here, we're going to do a little

17920
18:11:39,799 --> 18:11:43,009
div. And otherwise, we're going
to do a different div for

17921
18:11:43,009 --> 18:11:44,959
loading or for fetching, we're
going to add like a little

17922
18:11:44,959 --> 18:11:49,129
spinny thing in here. So we're
going to add class name equals.

17923
18:11:54,409 --> 18:11:56,809
If we're loading, we're going to
add this little spinny thing,

17924
18:11:56,809 --> 18:11:59,209
which I'll show you what it
looks like in a second. And if

17925
18:11:59,209 --> 18:12:02,449
we're not loading, we're just
gonna do enter, raffle like

17926
18:12:02,449 --> 18:12:06,139
that. So we'll come back to the
front end, see answer raffle,

17927
18:12:06,169 --> 18:12:08,359
we'll click the button. Now we
get this cute little spinny

17928
18:12:08,359 --> 18:12:12,049
thing, confirm transaction goes
through. So anything goes away.

17929
18:12:12,229 --> 18:12:15,859
Nice. Well, let's put these on
different lines. So we'll just

17930
18:12:15,859 --> 18:12:16,279
do

17931
18:12:23,450 --> 18:12:26,600
so those will be on different
lines. Now boom, entrance fee,

17932
18:12:26,900 --> 18:12:31,760
number players recent winner,
once a lottery now will confirm

17933
18:12:32,210 --> 18:12:35,630
transaction complete number of
players has gone up and we have

17934
18:12:35,660 --> 18:12:38,960
done it. Now this looks a lot
nicer. It's clearly not perfect,

17935
18:12:38,960 --> 18:12:41,330
but it's much easier to read
than kind of that lump that we

17936
18:12:41,330 --> 18:12:43,370
had before. And the reason I
wanted to show you this was

17937
18:12:43,370 --> 18:12:46,520
really just kind of giving you
your footholds for making these

17938
18:12:46,520 --> 18:12:49,580
look a little bit nicer. This
definitely isn't a CSS course.

17939
18:12:52,280 --> 18:12:56,540
Oh, wow. Okay, this is
phenomenal. We have an app that

17940
18:12:56,540 --> 18:12:59,720
we really like. And we're like,
you know what, we want to deploy

17941
18:12:59,720 --> 18:13:02,540
this bad, Larry, let's talk
about how we can deploy this,

17942
18:13:02,570 --> 18:13:04,820
this section is going to be
optional, okay, because I'm

17943
18:13:04,820 --> 18:13:06,770
going to deploy something to
rank B and deploying to test

17944
18:13:06,770 --> 18:13:09,440
sets can take a long time. So
we're going to deploy our

17945
18:13:09,440 --> 18:13:12,770
contracts to rink B. And then
we're going to deploy our

17946
18:13:12,770 --> 18:13:16,670
website to a hosting provider.
So first, let's talk about

17947
18:13:16,670 --> 18:13:19,760
hosting providers for a quick
second, if we want to host our

17948
18:13:19,760 --> 18:13:22,370
beautiful website that we just
created, there are ways to

17949
18:13:22,370 --> 18:13:26,300
deploy it using things like for
cell or Google Cloud, or AWS.

17950
18:13:26,390 --> 18:13:28,910
Nettle. Phi is another really
popular one there, all these

17951
18:13:28,910 --> 18:13:31,820
different places that we can
deploy our application. Now, the

17952
18:13:31,820 --> 18:13:34,820
thing about these though, is
that these are all centralized

17953
18:13:34,820 --> 18:13:37,520
deployment places, having a
centralized deployment

17954
18:13:37,520 --> 18:13:40,550
application can still be
incredibly important, right? If

17955
18:13:40,550 --> 18:13:42,950
we look at ether scan for a
second ether scan is a

17956
18:13:42,950 --> 18:13:45,440
centralized application right at
the end of the day, but it's

17957
18:13:45,440 --> 18:13:48,230
still one that we've been using
a lot. However, if we want to

17958
18:13:48,230 --> 18:13:50,990
have a front end that's
decentralized. Well, that's a

17959
18:13:50,990 --> 18:13:53,750
little bit harder. The more
important thing for us is that

17960
18:13:53,750 --> 18:13:56,030
our back end, our smart
contracts are decentralized,

17961
18:13:56,030 --> 18:13:58,220
right? That's the most important
thing because that will give

17962
18:13:58,220 --> 18:14:00,590
users the ability to interact
with our logic in a

17963
18:14:00,590 --> 18:14:03,620
decentralized way. But maybe we
also want our front ends

17964
18:14:03,620 --> 18:14:07,040
decentralized. Now at some point
we will still use a centralized

17965
18:14:07,040 --> 18:14:10,550
service Like VSL to deploy an
application, and I'll show you

17966
18:14:10,550 --> 18:14:13,700
why when we get there, there's
some features that right now,

17967
18:14:14,000 --> 18:14:16,760
they're really just hard to do
without like a really solid

17968
18:14:16,760 --> 18:14:20,300
centralized back end. What's
important to keep in mind is

17969
18:14:20,300 --> 18:14:24,080
that our back end, the logic of
our contract is on a

17970
18:14:24,080 --> 18:14:28,580
decentralized blockchain. So
even if we host the front end on

17971
18:14:28,580 --> 18:14:32,420
a centralized hosting provider,
using some type of centralized

17972
18:14:32,450 --> 18:14:36,800
database to make the front end
easier to work with, the logic

17973
18:14:36,800 --> 18:14:39,260
of the application is
decentralized. And that's the

17974
18:14:39,260 --> 18:14:42,380
most important piece. So I'm
going to give you some tools

17975
18:14:42,410 --> 18:14:46,670
later on, and how to introduce
more of these feature richness.

17976
18:14:46,910 --> 18:14:50,840
If you choose to do so doing so
will add a centralized component

17977
18:14:50,870 --> 18:14:53,240
on your front end. And it's
something to keep in mind,

17978
18:14:53,240 --> 18:14:56,510
depending on how you want your
architecture. So when doing that

17979
18:14:56,510 --> 18:15:00,080
just be absolutely sure that the
smart contracts on the back end

17980
18:15:00,350 --> 18:15:04,400
are deployed are decentralized
on one of these blockchains.

17981
18:15:04,580 --> 18:15:07,580
Now, we'll learn about some of
those centralized ways to do

17982
18:15:07,580 --> 18:15:11,480
that in a later section. For
now, let's learn how to deploy

17983
18:15:11,480 --> 18:15:14,030
this front end in a more
decentralized way.

17984
18:15:16,640 --> 18:15:20,810
And the tool that we're going to
use is a tool called IPFS. Now,

17985
18:15:20,810 --> 18:15:24,050
let me explain a little bit
about how IPFS works. It's this

17986
18:15:24,080 --> 18:15:29,390
distributed decentralized data
structure. That's not exactly a

17987
18:15:29,390 --> 18:15:32,600
blockchain. But it's similar to
a blockchain. There's no mining,

17988
18:15:32,600 --> 18:15:35,540
though. But there is pinning
data, you can add data to this.

17989
18:15:35,540 --> 18:15:38,210
So let me explain how this
actually works. And you can read

17990
18:15:38,210 --> 18:15:40,730
how this works on the site,
there's going to be a link to

17991
18:15:40,730 --> 18:15:42,950
this and the GitHub repo
associated with this course. But

17992
18:15:42,980 --> 18:15:46,400
we give you my basic take on it.
So we have our code, or our

17993
18:15:46,400 --> 18:15:50,810
file, or whatever it is, right,
we have some piece of data. Now

17994
18:15:50,810 --> 18:15:53,960
as we know, when you really have
anything, you can hash that

17995
18:15:53,960 --> 18:15:57,020
thing, you can hash that data,
right, so you can get a unique

17996
18:15:57,050 --> 18:15:59,870
output. So and that's actually
the first thing that IPFS does.

17997
18:16:00,140 --> 18:16:04,580
It hashes our data to get a
unique hash, that only points to

17998
18:16:04,580 --> 18:16:09,410
that data. Yes, a massive code
file a ton of text. Yes, you can

17999
18:16:09,410 --> 18:16:13,850
encode all of that into a single
hash function, your IPFS node

18000
18:16:13,850 --> 18:16:17,810
does this hashing for you. And
every single IPFS node on the

18001
18:16:17,810 --> 18:16:21,470
planet has the exact same
hashing function, kind of like a

18002
18:16:21,470 --> 18:16:25,070
blockchain, right, they all kind
of run this same spec, the same

18003
18:16:25,100 --> 18:16:29,120
specification. So we can hash
our data on our IPFS node and

18004
18:16:29,120 --> 18:16:32,600
get this unique output. What we
can do then is we can pin that

18005
18:16:32,600 --> 18:16:36,290
data or pin that code, or pin
that file or pin that whatever,

18006
18:16:36,530 --> 18:16:40,220
to our node, we have some data,
we get a unique hash of it, all

18007
18:16:40,220 --> 18:16:43,610
it does is host this data and
have these hashes. That's it,

18008
18:16:43,820 --> 18:16:48,470
our node is connected to a
network of other IPFS nodes. So

18009
18:16:48,470 --> 18:16:51,740
there's a massive network of
people running IPFS nodes,

18010
18:16:51,770 --> 18:16:54,650
they're incredibly lightweight,
way lighter weight than any

18011
18:16:54,650 --> 18:16:57,860
other blockchain node. And they
all talk to each other. So if I

18012
18:16:57,860 --> 18:17:00,950
asked the network, hey, I want
to get this hash. All these

18013
18:17:00,950 --> 18:17:03,410
nodes would talk to each other.
And eventually they'd reach up

18014
18:17:03,410 --> 18:17:06,920
at our node saying, Oh, I found
a node that has that hash.

18015
18:17:07,100 --> 18:17:09,920
Here's the file associated with
it. Now, you might be thinking,

18016
18:17:09,920 --> 18:17:12,080
Okay, well, that's kind of
centralized, because we have the

18017
18:17:12,080 --> 18:17:15,290
data on one node here, right?
Well, you're right, well, here's

18018
18:17:15,290 --> 18:17:20,060
the thing, what other nodes can
do is they can say, oh, that

18019
18:17:20,060 --> 18:17:24,140
data looks really cool, I want
to have that persist, what they

18020
18:17:24,140 --> 18:17:27,650
can do is they can pin your
hash, they can pin your data,

18021
18:17:27,920 --> 18:17:31,820
and they'll get a copy of your
data on their node. And you can

18022
18:17:31,820 --> 18:17:35,930
keep doing this. And so you
easily allow an entire network

18023
18:17:36,170 --> 18:17:40,430
to easily replicate any code or
any data in a decentralized

18024
18:17:40,460 --> 18:17:42,620
sense. And they're incredibly
easy to spin up. And they're

18025
18:17:42,620 --> 18:17:46,010
incredibly easy to work with
something about IPFS, that makes

18026
18:17:46,010 --> 18:17:49,610
it drastically different than a
blockchain is the can't do smart

18027
18:17:49,610 --> 18:17:52,550
contract, there's no execution,
it can really only store it's

18028
18:17:52,550 --> 18:17:57,050
just decentralized storage that
IPFS can do. Now, the issue here

18029
18:17:57,080 --> 18:18:00,830
is that in order for our data to
really be decentralized, another

18030
18:18:00,830 --> 18:18:04,280
node does need to pin our data,
right? Because if we're the only

18031
18:18:04,280 --> 18:18:08,300
IPFS node that's got this hash,
it's kind of centralized on our

18032
18:18:08,300 --> 18:18:11,600
node, if our node goes down,
that data is gone, and the

18033
18:18:11,600 --> 18:18:14,510
network won't be able to access
that data anymore. So we'll talk

18034
18:18:14,510 --> 18:18:17,450
about strategies in the future
about having other people pin

18035
18:18:17,450 --> 18:18:21,140
your data. But for now, this is
a way we can host data, we can

18036
18:18:21,140 --> 18:18:25,520
send code and have it be in a
decentralized context. So unlike

18037
18:18:25,520 --> 18:18:29,000
a blockchain, where every single
node in a blockchain is going to

18038
18:18:29,030 --> 18:18:33,050
have a copy of the entire
blockchain IPFS nodes get to

18039
18:18:33,080 --> 18:18:37,070
optionally choose which data
they want to pin, and they can't

18040
18:18:37,070 --> 18:18:39,920
do any execution. So you could
have an IPFS node, half a

18041
18:18:39,920 --> 18:18:42,650
megabyte, and you could have an
IPFS node, that several

18042
18:18:42,650 --> 18:18:46,970
terabytes, it's up to the node
operators, how much data and

18043
18:18:46,970 --> 18:18:50,270
what data they want to pin. Now
that we know about IPFS.

18044
18:18:52,909 --> 18:18:57,709
Let's actually deploy our
wonderful application to IPFS so

18045
18:18:57,709 --> 18:19:00,799
that anybody can use it and
anybody can connect to it. So

18046
18:19:00,799 --> 18:19:05,479
long as our node is up. Are you
ready? Okay, get excited here.

18047
18:19:05,539 --> 18:19:08,239
We're first going to do this
kind of the Manuel Wait, because

18048
18:19:08,239 --> 18:19:10,819
I'm going to show you how to
install IPFS. And work with

18049
18:19:10,819 --> 18:19:14,419
IPFS. Hit get started, there's a
number of ways to install and

18050
18:19:14,419 --> 18:19:18,619
work with IPFS, you can get it
with a desktop application, get

18051
18:19:18,619 --> 18:19:23,299
a command line. And then we can
also add IPFS to our browser

18052
18:19:23,419 --> 18:19:28,099
using something like brave or I
think Firefox to some this IPFS

18053
18:19:28,099 --> 18:19:30,439
router is automatically built
it. But if using something like

18054
18:19:30,439 --> 18:19:33,109
Chrome, you might have to add a
little companion, because what

18055
18:19:33,109 --> 18:19:37,339
we want to do is we can actually
use those little hashes as URLs

18056
18:19:37,369 --> 18:19:40,879
for websites, right, and so we
want to be able to put that URL

18057
18:19:41,149 --> 18:19:45,079
in our browser and connect to
that node or that piece of code.

18058
18:19:45,109 --> 18:19:48,139
So what we're gonna do is we're
gonna have you install the IPFS

18059
18:19:48,169 --> 18:19:51,079
desktop, so you're gonna hit
that. And when you do that, you

18060
18:19:51,079 --> 18:19:54,859
should be able to open up IPFS.
Now, if you install it, you

18061
18:19:54,859 --> 18:19:58,429
might get this little guy, this
little box here in your upper

18062
18:19:58,429 --> 18:20:01,159
section. Otherwise, you might be
able to open it up with with

18063
18:20:01,159 --> 18:20:04,939
IPFS desktop and see it as a
regular desktop app. Well, once

18064
18:20:04,939 --> 18:20:08,659
you install it, you might see
IPFS is running, you can restart

18065
18:20:08,659 --> 18:20:11,869
stop, you can do all this stuff,
we're gonna go to the file

18066
18:20:11,869 --> 18:20:15,079
section, and we're gonna get a
little pop up that looks like

18067
18:20:15,079 --> 18:20:17,899
this. Now, I've got a ton of
stuff in here, because I've been

18068
18:20:17,899 --> 18:20:20,839
using IPFS for some time in
here, right now, you might have

18069
18:20:20,839 --> 18:20:24,469
no data. So let's just go ahead
and import some file. And maybe

18070
18:20:24,469 --> 18:20:27,619
for now we'll just import, you
know, our next dot config dot j

18071
18:20:27,619 --> 18:20:30,439
s, right? It doesn't matter,
just import something. And now

18072
18:20:30,439 --> 18:20:34,369
in here, we have this next dot
config dot j s or whatever file

18073
18:20:34,369 --> 18:20:37,849
you import it. So what we can do
with this is we can actually

18074
18:20:37,879 --> 18:20:43,039
copy the CID. And we can view
this in our browser. So if we do

18075
18:20:43,039 --> 18:20:47,299
IPFS dot dot slash slash, and we
paste it in, we hit enter, we

18076
18:20:47,299 --> 18:20:53,029
can give our browser access to
actually rendering IPFS URLs. If

18077
18:20:53,029 --> 18:20:57,049
using brave, you can just do use
a brave local IPFS node or let's

18078
18:20:57,049 --> 18:21:00,679
go ahead and download this IPFS
companion. So we'll get IPFS

18079
18:21:00,679 --> 18:21:04,549
companion, there's a Firefox
install for Chrome brave, blah,

18080
18:21:04,549 --> 18:21:07,669
blah, blah. So I'm gonna go to
the Chrome store to get it for

18081
18:21:07,669 --> 18:21:11,149
brave, we're just going to hit
Add to brave add extension. But

18082
18:21:11,179 --> 18:21:13,639
once you download it, you'll get
something that looks like this.

18083
18:21:13,849 --> 18:21:16,249
Even on a little browser
companion, we can see like

18084
18:21:16,249 --> 18:21:19,219
import, we can see stuff about
our node, if we click our node,

18085
18:21:19,249 --> 18:21:22,519
we will see a very similar
setup. But now that we have the

18086
18:21:22,519 --> 18:21:27,409
companion in our browser, we can
copy that Cid that hash. Now

18087
18:21:27,409 --> 18:21:30,919
brave, we can just do use brave
local IPFS node, and will

18088
18:21:30,979 --> 18:21:35,029
automatically get dropped into
the file. Now, if IPFS companion

18089
18:21:35,029 --> 18:21:38,569
doesn't work for you, and you
can't see the URL inside of

18090
18:21:38,569 --> 18:21:42,049
something like Google Chrome or
some other browser, what you can

18091
18:21:42,049 --> 18:21:45,739
do is you can use something
called the IPFS gateway. Now

18092
18:21:45,739 --> 18:21:49,279
using a gateway, you're not
actually directly requesting the

18093
18:21:49,279 --> 18:21:53,449
data through IPFS requesting the
data through another server,

18094
18:21:53,449 --> 18:21:56,479
which is requesting it through
IPFS. But if you are having some

18095
18:21:56,479 --> 18:22:00,049
trouble accessing these files,
you can use the gateway. So what

18096
18:22:00,049 --> 18:22:02,869
you'll do is we'll do HTTPS,

18097
18:22:05,900 --> 18:22:11,270
slash IPFS, slash and then paste
the hash code there. And you'll

18098
18:22:11,270 --> 18:22:14,030
be able to see your file. Now if
you do it like this, you won't

18099
18:22:14,030 --> 18:22:17,720
even need IPFS companion at all.
So we're going to deploy our

18100
18:22:17,720 --> 18:22:22,070
website to IPFS. So that anybody
else who wants to pin this can,

18101
18:22:22,250 --> 18:22:26,120
and we will now have the ability
to have an incorruptible, in

18102
18:22:26,150 --> 18:22:29,990
unputdownable website, which is
just awesome. We're going to

18103
18:22:29,990 --> 18:22:32,540
learn how to do this the wrong
way first, and then we're going

18104
18:22:32,540 --> 18:22:34,910
to use a tool that's going to
make it a lot easier for us.

18105
18:22:34,910 --> 18:22:39,140
Okay, so first, let's go to our
website here. And, and if you

18106
18:22:39,140 --> 18:22:41,930
want to deploy to rink B, go
ahead and feel free. Just

18107
18:22:41,930 --> 18:22:46,670
remember to make sure that your
contract addresses file updates

18108
18:22:46,700 --> 18:22:50,480
accordingly. Okay. Now, next,
Jas has the ability to create

18109
18:22:50,480 --> 18:22:54,410
static websites. And that's
going to be an important term to

18110
18:22:54,410 --> 18:22:57,770
know we're going to make a
static website. At the moment,

18111
18:22:57,770 --> 18:23:02,720
we don't want our website to be
tangled with any server stuff.

18112
18:23:02,780 --> 18:23:05,000
And the reason we we don't want
it to be tangled with any server

18113
18:23:05,000 --> 18:23:07,430
stuff is because if our website
runs with server stuff, and we

18114
18:23:07,430 --> 18:23:11,090
deploy it to IPFS, will IPFS
doesn't have the ability to run

18115
18:23:11,090 --> 18:23:14,840
any code, it just hosts code. If
our front end has any server

18116
18:23:14,840 --> 18:23:18,920
stuff, it won't work. Now, in
its current state IPFS can't

18117
18:23:18,920 --> 18:23:21,320
come to our project and know
what to do, right, it doesn't

18118
18:23:21,320 --> 18:23:24,980
know how to do yarn dev can't do
yarn Dev. So we need to put all

18119
18:23:24,980 --> 18:23:28,910
of our code into its static
equivalents. So to do that,

18120
18:23:28,940 --> 18:23:32,300
we're gonna do yarn build. And
if again, if we look at our

18121
18:23:32,300 --> 18:23:36,230
package dot JSON, it comes with
this build, which just runs next

18122
18:23:36,230 --> 18:23:39,860
build. And running this build
command is going to build our

18123
18:23:39,860 --> 18:23:42,590
code, what's called like a
production build, creating an

18124
18:23:42,620 --> 18:23:46,310
optimized production build here.
And we'll get something that

18125
18:23:46,310 --> 18:23:49,880
looks like this. And we can see
this point down here. Static,

18126
18:23:49,910 --> 18:23:53,780
automatically rendered as static
HTML uses no initial props.

18127
18:23:53,930 --> 18:23:57,110
There's some server based
applications that next Jas comes

18128
18:23:57,110 --> 18:24:00,620
with that if we use them. Our
static build won't work. And

18129
18:24:00,620 --> 18:24:05,000
actually, you'll see when we run
yarn, next export, it'll fail if

18130
18:24:05,000 --> 18:24:08,030
you have any that non static
stuff. So let's Go ahead and try

18131
18:24:08,030 --> 18:24:11,750
yarn next export. And let's see
if it fails, it didn't fail, we

18132
18:24:11,750 --> 18:24:15,620
now have a new folder called
out. And this is our folder,

18133
18:24:15,680 --> 18:24:19,700
that's just pure static code and
that we can use on IPFS. In a

18134
18:24:19,700 --> 18:24:22,100
later section, I'll show you
what it looks like when you

18135
18:24:22,100 --> 18:24:25,250
don't use some of those static
things. Both Morales and next

18136
18:24:25,250 --> 18:24:28,880
Jas have the optionality to not
have static code. So we'll just

18137
18:24:28,880 --> 18:24:31,220
want to keep that in mind. So
now that we have this out

18138
18:24:31,220 --> 18:24:35,960
folder, we can go back to IPFS.
And we can import a folder,

18139
18:24:35,990 --> 18:24:39,050
we're going to import that whole
folder in here. So hit that hit

18140
18:24:39,050 --> 18:24:43,430
that import button and go to the
folder. Where that is mine is in

18141
18:24:43,910 --> 18:24:47,120
next year smart contract lottery
out. So now we're going to

18142
18:24:47,180 --> 18:24:50,450
upload this to our IPFS node.
Once it's done, we'll get this

18143
18:24:50,450 --> 18:24:54,500
little checkmark. And we can go
through IPFS files and see our

18144
18:24:54,530 --> 18:24:58,160
output here. What we can do,
let's go ahead and pin this to

18145
18:24:58,160 --> 18:25:01,760
our node, we'll pin it to our
local node here. And now once

18146
18:25:01,760 --> 18:25:05,900
it's up, we can copy the CID and
go back to brave or chrome or

18147
18:25:05,900 --> 18:25:11,000
whatever. You type in IPFS colon
slash slash, paste that in

18148
18:25:11,000 --> 18:25:15,110
there. And we immediately get
dropped into our smart contract

18149
18:25:15,110 --> 18:25:19,070
lottery in a browser. And we see
hi from lottery, no raffle

18150
18:25:19,100 --> 18:25:22,850
address detected, because right
now the way I set mine up Was it

18151
18:25:22,850 --> 18:25:25,850
only works with, you know, our
local hard hats, let's connect

18152
18:25:25,850 --> 18:25:29,240
our Metamask we'll hit the
connect button, connect, and

18153
18:25:29,240 --> 18:25:33,620
voila, we are right back where
we were. But with our data

18154
18:25:33,620 --> 18:25:37,040
stored in IPFS, we can enter
raffle as long as our node is

18155
18:25:37,040 --> 18:25:41,420
running a confirm. And we see
exactly what we get in our local

18156
18:25:41,420 --> 18:25:44,210
browsers. So this is phenomenal.

18157
18:25:46,940 --> 18:25:49,610
Now that I've shown you how to
do this, this is the manual way

18158
18:25:49,610 --> 18:25:54,680
of adding our code to IPFS. Let
me show you the easier way of

18159
18:25:54,680 --> 18:25:57,620
adding your code to IPFS we're
gonna go to this site called

18160
18:25:57,650 --> 18:26:03,350
fleek HQ. Go to fleek.co. And to
get to it, I'm going to turn my

18161
18:26:03,380 --> 18:26:06,650
my IPFS companion note off
because of some of the oddities

18162
18:26:06,650 --> 18:26:10,460
with working with brave but now
we're here@flickr.co fleek.co

18163
18:26:10,490 --> 18:26:13,190
makes it easy to to deploy
websites and apps to the new

18164
18:26:13,190 --> 18:26:16,130
open web permissionless,
trustless, censorship resistant,

18165
18:26:16,160 --> 18:26:19,610
etc. I like to think about it as
kind of like an auto deployment

18166
18:26:19,790 --> 18:26:22,460
for our websites. And
additionally, it does some

18167
18:26:22,460 --> 18:26:25,370
things to help out with that
problem. I was talking about how

18168
18:26:25,580 --> 18:26:29,450
we want to get other nodes to
pin our data. So it helps us out

18169
18:26:29,450 --> 18:26:32,150
with that. So let me show you
what it does. So let's go ahead,

18170
18:26:32,270 --> 18:26:35,630
we'll sign up. And why don't you
know, you can sign in with

18171
18:26:35,630 --> 18:26:38,510
GitHub. So if you have your
GitHub, definitely want to sign

18172
18:26:38,510 --> 18:26:42,350
in with GitHub here. Because
we're going to use GitHub to

18173
18:26:42,350 --> 18:26:46,310
actually help us automatically
deploy. So we'll authorize fleet

18174
18:26:46,310 --> 18:26:49,340
to work with our GitHub. You've
authorized your GitHub, let's go

18175
18:26:49,340 --> 18:26:52,850
ahead and add a new site or add
new site. Now we can use fleet

18176
18:26:52,850 --> 18:26:55,880
to just automatically deploy
websites, once we push them to

18177
18:26:55,880 --> 18:27:00,440
our GitHub. So we can come to
our GitHub once again. And click

18178
18:27:00,440 --> 18:27:03,260
the little plus button, we'll do
a new repository. We'll call

18179
18:27:03,260 --> 18:27:09,110
this next Jas smart contract,
lottery Free Code Camp. We'll

18180
18:27:09,110 --> 18:27:15,290
make it public create the
repository. Let's push all this

18181
18:27:15,290 --> 18:27:18,230
code to GitHub. We did it once
before, let's do it again. We'll

18182
18:27:18,230 --> 18:27:22,760
do git add, we'll do a little
dot, then we'll do git commit

18183
18:27:22,880 --> 18:27:30,800
minus m, say like initial commit
or whatever. We'll do git

18184
18:27:31,040 --> 18:27:39,680
remote, add origin, and then
we'll grab that URL, paste it

18185
18:27:39,680 --> 18:27:45,320
right here. And then we'll just
do git push origin, main. Now we

18186
18:27:45,320 --> 18:27:48,530
go back to our application we
see it in here we can do is back

18187
18:27:48,530 --> 18:27:52,400
in our fleek. We can connect
with GitHub, we're going to say

18188
18:27:52,430 --> 18:27:56,480
only select repositories, we're
only going to do this next js

18189
18:27:56,480 --> 18:27:59,630
application, this next JS get
we're going to install an

18190
18:27:59,630 --> 18:28:04,550
Authorize. Authorize Great. So
now we're going to pick a repo

18191
18:28:04,550 --> 18:28:08,180
we've picked a repo, we're going
to choose this application. And

18192
18:28:08,180 --> 18:28:11,690
we're going to use IPFS as our
hosting service. And now we're

18193
18:28:11,690 --> 18:28:14,390
going to add our information in
here. So we're going to use the

18194
18:28:14,390 --> 18:28:18,110
main branch. Here's the repo.
There's gonna be our framework

18195
18:28:18,110 --> 18:28:23,180
is gonna be next Jas. So we're
do fleek next. Jas, we're using

18196
18:28:23,180 --> 18:28:28,310
yarn. So we're gonna do yarn
install, and yarn, run build,

18197
18:28:28,640 --> 18:28:32,570
and then yarn run export. If you
want you could also just do

18198
18:28:32,570 --> 18:28:35,600
yarn, yarn build and yarn run
export, those are gonna be the

18199
18:28:35,600 --> 18:28:38,720
same thing. Publish directory is
going to be out and then we just

18200
18:28:38,720 --> 18:28:43,430
hit Deploy site, yarn, next
export as the last command, not

18201
18:28:43,460 --> 18:28:47,030
yarn, run, export. The accident
did the wrong one, you go over

18202
18:28:47,030 --> 18:28:51,710
deploys. Click on this, go to
deploy settings and then Edit

18203
18:28:51,710 --> 18:28:57,260
Settings and then just change it
to yarn. Next, export save. Then

18204
18:28:57,260 --> 18:28:59,900
we'll go back to deploys and
trigger deploy, if you did the

18205
18:28:59,900 --> 18:29:02,180
wrong one that was just a
learning opportunity for you to

18206
18:29:02,210 --> 18:29:05,540
learn where the settings are
after you deploy. And what this

18207
18:29:05,540 --> 18:29:08,690
is going to do is we're going to
do to deploy, it's going to run

18208
18:29:08,690 --> 18:29:11,780
those three commands yarn build,
yarn export, it's going to run

18209
18:29:11,810 --> 18:29:14,930
everything. And then it's going
to deploy a site for us both on

18210
18:29:14,930 --> 18:29:19,790
IPFS. And it's going to give a
regular URL that we can use for

18211
18:29:20,030 --> 18:29:24,290
normies, if you will. And while
this deploys, you'll actually

18212
18:29:24,290 --> 18:29:28,100
see down here we have this thing
called file coin di D in deal

18213
18:29:28,100 --> 18:29:32,720
proposal, Cid IPFS. Like I said,
we need other people to host our

18214
18:29:32,720 --> 18:29:36,860
node. File coin is actually a
blockchain that helps you pin

18215
18:29:36,860 --> 18:29:40,760
your data and uses decentralized
storage to do so. And fleek

18216
18:29:40,790 --> 18:29:44,090
helps you create those deals and
helps you pin your data with

18217
18:29:44,090 --> 18:29:46,880
this filecoin Blockchain
filecoin is one definitely to

18218
18:29:46,880 --> 18:29:49,820
take a look at. And then after a
while, you might have to wait a

18219
18:29:49,820 --> 18:29:53,840
little bit. And once it's done,
get a little deployed website,

18220
18:29:53,870 --> 18:29:58,520
we go back to hosting, we click
on our thing we can see we have

18221
18:29:58,520 --> 18:30:02,150
like a little website here. And
if we click it, we get a normal

18222
18:30:02,360 --> 18:30:06,320
URL for connecting and
interacting with our website,

18223
18:30:06,830 --> 18:30:09,260
you might even see this little
IPFS thing which will connect to

18224
18:30:09,260 --> 18:30:12,500
your IPFS node. And
additionally, we scroll down in

18225
18:30:12,500 --> 18:30:16,340
here we can see current IPFS
hash, so we can just stick that

18226
18:30:16,340 --> 18:30:22,580
in, um, and Bada bing, we have
an IP Fs deployed application.

18227
18:30:22,580 --> 18:30:25,790
Now what's cool is let's say I
make some changes, you know,

18228
18:30:25,790 --> 18:30:29,690
I'll go to lottery entrance. And
I'll do, I'll scroll on the

18229
18:30:29,690 --> 18:30:35,420
bottom to recent winner, I'll
make a new div. What a close the

18230
18:30:35,420 --> 18:30:41,990
div off, we'll save git add dot
Git commit minus m, add a dot

18231
18:30:42,590 --> 18:30:44,450
git push origin mean.

18232
18:30:46,700 --> 18:30:50,510
In our GitHub, we'll do a little
refresh, add a.as, the most

18233
18:30:50,510 --> 18:30:54,920
recently added one, go back over
to fleek. Go back to hosting

18234
18:30:54,920 --> 18:30:58,940
click on the section that we
just made go to deploys, and

18235
18:30:58,940 --> 18:31:02,120
you'll see there's a new deploy
going through. So it

18236
18:31:02,180 --> 18:31:05,090
automatically deploys your new
site, it'll automatically create

18237
18:31:05,090 --> 18:31:08,810
a new IPFS hash for your new
data. However, it'll still be on

18238
18:31:08,810 --> 18:31:12,680
this holy bird, you know, or
whatever your URL is here. And

18239
18:31:12,680 --> 18:31:16,730
this is kind of just a router
for IPSs. So that people without

18240
18:31:16,730 --> 18:31:20,150
IPFS connected can also connect
to this still. And now that my

18241
18:31:20,150 --> 18:31:23,330
application is done, pushing
automatically, with fleek, we

18242
18:31:23,330 --> 18:31:29,780
can see what's up being post in
my application here. Now, like I

18243
18:31:29,780 --> 18:31:32,690
said, filecoin isn't going to be
a technology, we're gonna go too

18244
18:31:32,690 --> 18:31:36,890
deep into introduce ourselves.
But like I was just saying IPFS

18245
18:31:36,920 --> 18:31:41,360
does have this limitation. It
doesn't have data persistence,

18246
18:31:41,450 --> 18:31:44,720
you have to have people pin your
data, in order for it to stay

18247
18:31:44,720 --> 18:31:48,200
distributed, and stay
decentralized. File coin is a

18248
18:31:48,200 --> 18:31:52,250
blockchain dedicated to keeping
this data, both decentralized

18249
18:31:52,280 --> 18:31:55,250
and persistent. And to give us a
better understanding of

18250
18:31:55,250 --> 18:31:58,610
filecoin. We actually have Ali
here to give us an overview.

18251
18:31:58,640 --> 18:32:00,830
Take it away, Ali. Hello, I'm

18252
18:32:00,830 --> 18:32:03,440
Ali, and I'm a developer
advocate here at the filecoin

18253
18:32:03,440 --> 18:32:07,400
Foundation, which works closely
with protocol labs and IPFS.

18254
18:32:07,580 --> 18:32:12,560
Just a quick note, protocol Labs
is our r&d arm. So it works on

18255
18:32:13,640 --> 18:32:17,270
creating tooling and technology
for a truly open and democratic

18256
18:32:17,270 --> 18:32:20,300
internet and web. And it's
building out some of the

18257
18:32:20,300 --> 18:32:23,720
foundational tooling like IPFS,
and filecoin, which are two

18258
18:32:23,720 --> 18:32:27,710
separate projects to enable
that. And hopefully, today,

18259
18:32:27,710 --> 18:32:30,080
because you're here to build, I
want to impart on you the

18260
18:32:30,080 --> 18:32:32,810
knowledge and tools you need to
get started with both of those

18261
18:32:32,810 --> 18:32:36,320
projects. So as anyone that's
kind of played around in this

18262
18:32:36,320 --> 18:32:39,320
ecosystem, or tech, in general
would know, data is an

18263
18:32:39,320 --> 18:32:42,380
absolutely essential part of our
daily lives. And not

18264
18:32:42,380 --> 18:32:45,770
surprisingly, it's also a super
fast growing field in web three,

18265
18:32:46,040 --> 18:32:49,160
and one, that's fundamental one,
and it's one of the fundamental

18266
18:32:49,160 --> 18:32:52,910
necessities of the decentralized
web stack as well. So the

18267
18:32:52,910 --> 18:32:56,150
current model of centralization
that's grown up, and basically

18268
18:32:56,150 --> 18:32:59,330
out of a lack of an identity
layer on the internet, is one

18269
18:32:59,330 --> 18:33:02,540
where only a few big companies
offer storage, and only a few

18270
18:33:02,540 --> 18:33:05,720
entities hold our data for
authorization purposes. And this

18271
18:33:05,720 --> 18:33:08,900
is an obvious problem, both in
terms of being an attack vector

18272
18:33:08,900 --> 18:33:12,320
for data mining, so without
data, getting leaked through

18273
18:33:12,620 --> 18:33:17,060
insecure service to third
parties, and also creating a

18274
18:33:17,060 --> 18:33:20,540
data resilience problem. So
whole services go down every

18275
18:33:20,540 --> 18:33:22,820
time one of these companies
servers does and we've

18276
18:33:22,820 --> 18:33:26,120
definitely seen that. So it
really leads to the question,

18277
18:33:26,150 --> 18:33:29,090
why aren't we designing the web
for the autonomy and resilience

18278
18:33:29,090 --> 18:33:31,910
we need in the first place? And
how do we store data in a way

18279
18:33:31,910 --> 18:33:35,180
that aligns with both the
original vision of the internet

18280
18:33:35,180 --> 18:33:38,570
as an open place for knowledge
sharing and collaboration, and,

18281
18:33:38,630 --> 18:33:43,580
and, and in a way that agrees
with the web three mission as

18282
18:33:43,580 --> 18:33:46,310
well. So these are the core
problems we're solving with IPFS

18283
18:33:46,310 --> 18:33:50,210
and file coin. Firstly, IPFS is
a distributed system for storing

18284
18:33:50,210 --> 18:33:54,350
and accessing files, folders,
websites, applications and data.

18285
18:33:54,560 --> 18:33:56,960
And it's designed to be able to
work even when the networks

18286
18:33:56,960 --> 18:34:00,200
between planets, so it's a
distributed by design, it has no

18287
18:34:00,200 --> 18:34:03,110
central authority servers, and
it's designed to be offline

18288
18:34:03,110 --> 18:34:05,840
first for resilience. And it's
not just a fancy name for

18289
18:34:05,840 --> 18:34:08,360
another peer to peer network
either. Because the nice thing

18290
18:34:08,360 --> 18:34:12,770
about the IPFS protocol is the
standard it uses for addressing

18291
18:34:12,770 --> 18:34:16,820
content on the network. IPFS is
unique because rather than using

18292
18:34:16,820 --> 18:34:20,270
traditional methods we might be
with familiar with from the web,

18293
18:34:20,600 --> 18:34:24,290
like those are location parts
that point to a particular HTTP

18294
18:34:24,290 --> 18:34:28,160
address where your content may
or may not be available and

18295
18:34:28,160 --> 18:34:32,420
stored. IPFS uses content
addressing so content addressing

18296
18:34:32,420 --> 18:34:36,110
means that each piece of data,
each meme or even full file

18297
18:34:36,110 --> 18:34:39,800
system has its own unique
cryptographically verifiable

18298
18:34:39,830 --> 18:34:43,580
fingerprint, you might call it.
So if you change even one pixel

18299
18:34:43,580 --> 18:34:47,480
of your main image, for example,
then the content ID or Cid

18300
18:34:47,510 --> 18:34:52,160
associated with it also changes.
So importantly, this hash

18301
18:34:52,160 --> 18:34:55,370
function is also upgradeable. So
let's say quantum computing

18302
18:34:55,370 --> 18:34:58,910
breaks out current secure hash
algorithms, we can upgrade the

18303
18:34:58,910 --> 18:35:02,960
standard we use. And it means
you will always get the same

18304
18:35:02,960 --> 18:35:07,520
content returned by an IPFS. Cid
as what you expect. So this is

18305
18:35:07,520 --> 18:35:10,730
fundamentally important, because
when you don't have to care

18306
18:35:10,730 --> 18:35:14,600
where the data comes from, you
open up the web to massively

18307
18:35:14,600 --> 18:35:18,920
distributed storage systems.
Hello, decentralization. So now

18308
18:35:18,920 --> 18:35:21,680
we have a really important and
valuable protocol that enables

18309
18:35:21,680 --> 18:35:25,100
distribution at scale. And it
provides verifiability of data

18310
18:35:25,520 --> 18:35:28,280
to serve and retrieve content on
the web. And not just for web

18311
18:35:28,280 --> 18:35:33,650
three, either, but also for all
web, or tech use cases. The

18312
18:35:33,650 --> 18:35:36,680
problem is, and it's one that
the early internet also faced,

18313
18:35:36,770 --> 18:35:39,140
who's going to ensure the
persistence and permanence of

18314
18:35:39,140 --> 18:35:42,290
all this data on the network. So
unless you're running your own

18315
18:35:42,290 --> 18:35:46,340
nodes 24/7, or your content is
really popular or other nodes

18316
18:35:46,340 --> 18:35:49,520
decide to altruistically store
your data. Because I think it's

18317
18:35:49,520 --> 18:35:53,000
important, then this data can
become unreliable because

18318
18:35:53,000 --> 18:35:55,580
they're no longer actively
hosted on any nodes on the

18319
18:35:55,580 --> 18:35:58,760
network's. So to avoid this, you
could also turn to a pinning

18320
18:35:58,760 --> 18:36:01,910
service that you pay to keep a
copy of your content around.

18321
18:36:02,870 --> 18:36:04,970
Unfortunately, the problem with
this though, is that we're

18322
18:36:04,970 --> 18:36:07,340
heading back towards
centralization of data. And

18323
18:36:07,340 --> 18:36:11,330
we're creating new data silos
with this solution and losing

18324
18:36:11,330 --> 18:36:13,610
the trust lessness and
resilience we're looking for.

18325
18:36:13,850 --> 18:36:18,650
And these one a bad solution
prior to file coin, and it's why

18326
18:36:18,650 --> 18:36:22,490
they sprung up initially, but we
want a better solution. So this

18327
18:36:22,490 --> 18:36:26,810
is where file coin comes in. So
far coins architecture, then

18328
18:36:26,810 --> 18:36:29,990
designed to leverage a crypto
economic incentive model

18329
18:36:29,990 --> 18:36:33,320
together with cryptographic
proofs in order to ensure data

18330
18:36:33,320 --> 18:36:38,390
is stored persistently, highly
reliably and verifiably. It uses

18331
18:36:38,390 --> 18:36:41,960
these cryptographic proofs to
also enable smart contract based

18332
18:36:41,960 --> 18:36:45,080
permanence. And that means that
it's designed to be as permanent

18333
18:36:45,080 --> 18:36:48,770
as you, the data owner want it
to be. It's your data, so it's

18334
18:36:48,770 --> 18:36:52,250
your choice. It's also designed
to enable internet scale

18335
18:36:52,250 --> 18:36:55,550
capacity. It's currently the
largest distributed storage

18336
18:36:55,550 --> 18:37:00,020
network in the world with over
18 million terabytes of capacity

18337
18:37:00,020 --> 18:37:05,120
available, which is apparently
about 135 copies of the European

18338
18:37:05,120 --> 18:37:09,620
Union's nuclear program, CERN's
data which, which is kind of a

18339
18:37:09,620 --> 18:37:14,240
fun fact. It's also file coins
also designed to be and stay

18340
18:37:14,240 --> 18:37:19,460
hyper competitive on pricing due
to its market economics. And

18341
18:37:19,460 --> 18:37:23,780
this comes down to storage
deals. So to make this network

18342
18:37:23,780 --> 18:37:27,170
feasible, filecoin uses storage
deals. And these include two

18343
18:37:27,170 --> 18:37:30,530
main consensus mechanisms that
ensure both rewards for good

18344
18:37:30,530 --> 18:37:33,440
actors in the system, and
penalties for bad actors. So

18345
18:37:33,440 --> 18:37:36,950
when you make a deal with one or
more storage providers to store

18346
18:37:36,980 --> 18:37:39,980
your important data, the
provider generates a proof of

18347
18:37:39,980 --> 18:37:43,490
replication. So this proves that
the storage provider is storing

18348
18:37:43,520 --> 18:37:48,680
a unique copy of your original
data over time to make sure that

18349
18:37:48,680 --> 18:37:53,090
this data is persisted. These
storage providers must prove

18350
18:37:53,090 --> 18:37:56,120
that they still have random
subsets of this client data and

18351
18:37:56,150 --> 18:37:59,930
they create proof of space
times. And these proof this

18352
18:37:59,930 --> 18:38:04,220
proof of space time is something
that is stored on the

18353
18:38:04,220 --> 18:38:07,730
blockchain. So anyone at any
time can also check that this is

18354
18:38:07,730 --> 18:38:11,690
true. And it also makes up the
mechanism by which miners are

18355
18:38:11,720 --> 18:38:15,050
rewarded or penalized because
you have to stake Phil on the

18356
18:38:15,050 --> 18:38:19,910
network in order to become a
storage provider. So when a

18357
18:38:19,910 --> 18:38:24,860
storage deal comes to an end, or
user can you can opt to let it

18358
18:38:24,860 --> 18:38:27,590
expire or renew the deal. If you
opt for renewal, then the

18359
18:38:27,590 --> 18:38:31,190
providers again bid to host this
content. So this creates an

18360
18:38:31,190 --> 18:38:34,310
efficient market for pricing a
continual efficient market for

18361
18:38:34,310 --> 18:38:38,030
pricing as well. It can even go
negative. So the storage

18362
18:38:38,030 --> 18:38:40,760
provider can even pay you to
store your data if it's an

18363
18:38:40,760 --> 18:38:43,670
important data set due to some
of the block rewards that are

18364
18:38:43,670 --> 18:38:48,320
being offered by the filecoin
Foundation as well. So these

18365
18:38:48,320 --> 18:38:52,490
mechanisms are what built in not
just data permanence, but data

18366
18:38:52,490 --> 18:38:55,460
timeframes, sovereignty, too so
it's your data, it's your

18367
18:38:55,460 --> 18:38:57,800
choice. You can decide you want
to store your data for five

18368
18:38:57,800 --> 18:39:01,700
minutes or 500 years. It's also
your choice over how much

18369
18:39:01,700 --> 18:39:05,270
resilience you want to have that
data so or how many copies of

18370
18:39:05,270 --> 18:39:08,360
that data you want to have and
with what store to providers. So

18371
18:39:08,600 --> 18:39:13,190
this allows you to comply with
regulations like GDPR. And

18372
18:39:13,190 --> 18:39:15,380
there's a growing number of
tools in the ecosystem like

18373
18:39:15,380 --> 18:39:19,340
murmurations bit screen that are
allowing for you to do this

18374
18:39:19,340 --> 18:39:23,990
filtering. But it also gives you
some guarantees that your data,

18375
18:39:24,020 --> 18:39:27,080
you know, if one storage
provided goes down, you know,

18376
18:39:27,080 --> 18:39:30,080
surely not 10 of them are going
to go down. So that's a

18377
18:39:30,080 --> 18:39:32,690
guarantee for your resilience
there as well.

18378
18:39:34,130 --> 18:39:36,890
And this is why IPFS and
filecoin are great complements

18379
18:39:36,890 --> 18:39:40,010
of each other. So IPF s gives
you that benefit of content

18380
18:39:40,010 --> 18:39:43,130
addressing file coin gives you
persistent guarantees that even

18381
18:39:43,130 --> 18:39:45,710
if your computer or your
favorite IPFS pinning service

18382
18:39:45,710 --> 18:39:50,990
where to go away, the content
persists. Just as a quick final

18383
18:39:50,990 --> 18:39:53,990
note on these concepts as well,
IPFS and file coin is separate

18384
18:39:53,990 --> 18:39:57,590
projects, as I mentioned. So
IPFS is a protocol much like

18385
18:39:57,590 --> 18:40:02,960
HTTP, whereas file coin is a
blockchain. So IPFS is also

18386
18:40:02,960 --> 18:40:05,930
storage layer agnostic, you can
combine it with the storage

18387
18:40:05,930 --> 18:40:08,630
layer of your choice. And while
file coin was specifically

18388
18:40:08,630 --> 18:40:11,810
designed to complement it, and
we think is a great choice, you

18389
18:40:11,810 --> 18:40:15,080
can also store your IPFS data in
the cloud or an other storage

18390
18:40:15,080 --> 18:40:19,310
solutions as well. So hopefully,
you've got a good baseline for

18391
18:40:19,310 --> 18:40:22,520
why you'd want to use IPFS, and
filecoin. And for those

18392
18:40:22,520 --> 18:40:25,790
engineers out there that like a
challenge, and are interested in

18393
18:40:25,790 --> 18:40:30,440
working on the base protocols
and code of IPFS, and file coin,

18394
18:40:30,440 --> 18:40:33,770
which isn't always easy for the
average user, I'd encourage you

18395
18:40:33,770 --> 18:40:36,260
to go and take a look at the
project docs and get hubs and

18396
18:40:36,260 --> 18:40:39,290
some of the associated grants
available for extensions to

18397
18:40:39,290 --> 18:40:42,170
these open source projects. And
this is a great site here if you

18398
18:40:42,170 --> 18:40:45,800
want to get more information
into the nitty gritty and really

18399
18:40:45,800 --> 18:40:49,940
dig into the code behind IPFS
and filecoin. And extend some of

18400
18:40:49,940 --> 18:40:52,610
that. For those of you that just
want to build out of the box

18401
18:40:52,610 --> 18:40:55,580
though. And this is definitely a
camp that I often fall into. I

18402
18:40:55,580 --> 18:40:57,980
want to talk about some of the
dev tooling and storage helpers

18403
18:40:57,980 --> 18:41:01,700
that make it easy for you to get
started. So firstly, Flake Flake

18404
18:41:01,700 --> 18:41:04,970
is one of my favorite IPFS dev
tools. And projects Flake is a

18405
18:41:04,970 --> 18:41:09,320
CI CD tool that you can use to
deploy your apps for free as

18406
18:41:09,320 --> 18:41:12,500
simply as easy as you would with
some of the web tools you might

18407
18:41:12,620 --> 18:41:15,860
web to tools you might be
familiar with like Netlify

18408
18:41:16,100 --> 18:41:20,300
oversell. The big difference,
though, is fleek uses IPFS to

18409
18:41:20,300 --> 18:41:23,330
host your site or app. And it
even offers an AES domain

18410
18:41:23,330 --> 18:41:26,960
routing on their platform. So if
you're deploying a front end

18411
18:41:26,960 --> 18:41:29,750
app, I would encourage you to
use fleek to make it more

18412
18:41:29,750 --> 18:41:33,080
distributed instead of some of
the traditional web two tools.

18413
18:41:33,110 --> 18:41:37,340
It's just as easy, I promise. So
another one of my favorite tools

18414
18:41:37,340 --> 18:41:41,540
is NFT storage, storing your NFT
metadata immutably and

18415
18:41:41,540 --> 18:41:45,200
persistently, as you already
probably know, is integral to

18416
18:41:45,200 --> 18:41:48,260
keeping the main value
proposition of NF Ts, then on

18417
18:41:48,260 --> 18:41:53,750
fungibility. So if you're not
storing this data on chain,

18418
18:41:53,780 --> 18:41:57,170
which obviously can become
pretty financially unviable for

18419
18:41:57,170 --> 18:42:00,680
large files, then this is
exactly where NF T storage comes

18420
18:42:00,680 --> 18:42:03,680
in. So it was specifically
created as a public good to

18421
18:42:03,710 --> 18:42:07,940
archive and persist NF T data.
So it's free. And it takes care

18422
18:42:07,940 --> 18:42:11,540
of the complexity around firstly
creating an IPFS Cid for this

18423
18:42:11,540 --> 18:42:15,110
metadata, and then making
automatic deals with filecoin

18424
18:42:15,110 --> 18:42:19,190
storage providers. So it does
this with at least eight storage

18425
18:42:19,190 --> 18:42:21,770
providers. So eight times
redundancy and it does it with a

18426
18:42:21,770 --> 18:42:25,160
multigenerational timeframe. So
it automatically renews those

18427
18:42:25,160 --> 18:42:28,640
deals. Because it's a public
good, it's all free as well. And

18428
18:42:28,640 --> 18:42:31,790
it's also super easy to use,
because you just need because

18429
18:42:31,790 --> 18:42:36,290
it's a JavaScript service. So
you just need to say import that

18430
18:42:36,290 --> 18:42:39,950
as an NPM package or JavaScript
library and then call the API

18431
18:42:39,950 --> 18:42:45,140
and NFT dot storage takes care
of the rest. For data that isn't

18432
18:42:45,140 --> 18:42:48,890
NF T metadata as well, we built
web three dot storage, web three

18433
18:42:48,890 --> 18:42:53,450
storage is designed to give you
those same web two benefits. So

18434
18:42:53,450 --> 18:42:56,840
similar to NF T dot storage,
make it super easy for you to

18435
18:42:56,840 --> 18:43:00,890
use. And it's got JavaScript and
go client libraries.

18436
18:43:02,300 --> 18:43:05,990
While giving you you know the
power of IPFS and filecoin of

18437
18:43:05,990 --> 18:43:09,830
decentralized storage and IPFS
content addressing so it's got

18438
18:43:09,830 --> 18:43:12,710
one terabyte after terabyte, one
terabyte of free storage with

18439
18:43:12,710 --> 18:43:15,440
that. So try that out if you're
not just like trying to store

18440
18:43:15,440 --> 18:43:19,760
and obtain metadata. The next
tool is a bit more advanced.

18441
18:43:20,000 --> 18:43:23,390
It's called textil Palghat gate,
and it's for you know, more

18442
18:43:23,390 --> 18:43:27,080
advanced developers or those
looking for more flexibility to

18443
18:43:27,080 --> 18:43:31,970
interact with IPFS live peer to
peer and filecoin. It's a Docker

18444
18:43:31,970 --> 18:43:35,180
container wrapped around
filecoin and IPFS nodes. And it

18445
18:43:35,180 --> 18:43:37,190
gives you a lot of options to
configure it's a minor

18446
18:43:37,190 --> 18:43:40,760
selections and extend
functionality. It also offers

18447
18:43:40,760 --> 18:43:43,880
some bridges to several layer
ones which might be of interest

18448
18:43:43,880 --> 18:43:49,070
to developers out there. Another
one here and I'll preface this

18449
18:43:49,070 --> 18:43:52,760
by saying you need an invite to
this is ESRI tech. So it's for

18450
18:43:52,760 --> 18:43:56,240
people looking to store really
meaningful public data. It's

18451
18:43:56,240 --> 18:44:00,410
currently in alpha mode and like
I said, it requires an invite

18452
18:44:00,410 --> 18:44:03,350
because it's been built as a
public goods specifically to

18453
18:44:03,350 --> 18:44:07,940
store important information. If
you are I do have Use case

18454
18:44:07,940 --> 18:44:11,120
around this slide, please feel
free to reach out to us on this

18455
18:44:11,120 --> 18:44:16,130
project. Other final tool I'll
mention is orbit dB. So many

18456
18:44:16,130 --> 18:44:19,100
people coming to the web three
space from web two are often

18457
18:44:19,100 --> 18:44:22,640
looking for the same sort of
relational databases that we're

18458
18:44:22,640 --> 18:44:25,910
so used to in traditional
computing except in a

18459
18:44:25,910 --> 18:44:30,230
decentralized or distributed
format. And this isn't an easy

18460
18:44:30,230 --> 18:44:33,710
problem. So Oba to me is
currently in active development.

18461
18:44:33,710 --> 18:44:37,850
And because this isn't an easy
problem to solve, this isn't an

18462
18:44:37,850 --> 18:44:40,130
ideal solution for those of you
looking for an out of the box

18463
18:44:40,130 --> 18:44:43,970
experience. But if you are
looking for something like that,

18464
18:44:44,120 --> 18:44:47,960
try out orbit dB. And there's
also several other tools in the

18465
18:44:47,960 --> 18:44:51,980
ecosystem leveraging IPFS and
filecoin, including ceramic,

18466
18:44:51,980 --> 18:44:55,100
which is similar to textil power
gate, except it uses

18467
18:44:55,100 --> 18:44:58,730
decentralized identities.
Lighthouse is file drive, and

18468
18:44:58,730 --> 18:45:03,110
there's even Morales has an IPFS
API, so check those out as well.

18469
18:45:04,370 --> 18:45:07,670
So storage is really a
fundamental component on one

18470
18:45:07,670 --> 18:45:10,160
technology system. So and
there's so many use cases you

18471
18:45:10,160 --> 18:45:13,190
could dive into here. And so
hopefully, I've provided you

18472
18:45:13,190 --> 18:45:15,500
with some of the knowledge and
tools you need to get started

18473
18:45:15,500 --> 18:45:19,640
with IPFS and file Goyt. Coin
and really make powerful

18474
18:45:19,640 --> 18:45:23,270
distributed applications. And
there's just one more tool

18475
18:45:23,270 --> 18:45:26,270
that's also in active
development now. So if you look

18476
18:45:26,270 --> 18:45:29,660
closely at this diagram, you'll
notice probably unfamiliar logo

18477
18:45:29,660 --> 18:45:32,690
right at the end of the logic
layer. And that's the logo for

18478
18:45:32,690 --> 18:45:36,980
the filecoin virtual machine. So
FBM will be launching at the end

18479
18:45:36,980 --> 18:45:40,310
of this year. And we're super
excited about it. And it's going

18480
18:45:40,310 --> 18:45:44,240
to allow smart contracts,
contract use combined with like

18481
18:45:44,240 --> 18:45:48,290
colocation of storage data,
loads, so computing capabilities

18482
18:45:48,320 --> 18:45:51,950
with storage capabilities, and
will also be EVM compatible. So

18483
18:45:51,950 --> 18:45:54,770
as I said, we're super excited
for the kinds of use cases that

18484
18:45:54,770 --> 18:45:58,790
we're going to see come out of
this project as well. And you

18485
18:45:58,790 --> 18:46:02,300
can follow along here on the
website here as well. So

18486
18:46:02,300 --> 18:46:04,430
hopefully, I've given you all
the tools you need to get

18487
18:46:04,430 --> 18:46:08,030
started with IPFS. And file
coin. If you do need more

18488
18:46:08,030 --> 18:46:11,180
resources or want to get
involved, we have proto School,

18489
18:46:11,180 --> 18:46:14,360
which is interactive tutorials
on decentralized web protocols.

18490
18:46:14,600 --> 18:46:19,130
There's also NFT, school dot
Dev, or join a hackathon, check

18491
18:46:19,130 --> 18:46:22,670
out our hackathons.filecoin.io
page for all the latest

18492
18:46:22,670 --> 18:46:25,970
hackathons we're involved in.
And if you do really want to dig

18493
18:46:25,970 --> 18:46:30,080
deep and build tooling in IPFS,
and file coin or build a cool

18494
18:46:30,080 --> 18:46:34,220
project, check out our grants
options as well for that, in the

18495
18:46:34,220 --> 18:46:39,260
meantime, all please learn long
build and prosper.

18496
18:46:42,320 --> 18:46:46,310
So we've learned a ton in this
section. And that is it. So

18497
18:46:46,310 --> 18:46:49,430
let's do a summary of all the
amazing things that we've

18498
18:46:49,430 --> 18:46:52,550
learned. And then we'll go into
the TypeScript edition of this

18499
18:46:52,550 --> 18:46:55,130
because the TypeScript edition
is definitely a little bit

18500
18:46:55,130 --> 18:46:58,340
different. So let's talk.
Alright, so first, we learned

18501
18:46:58,340 --> 18:47:00,800
more about next Jas. And we
learned we can have an

18502
18:47:00,800 --> 18:47:04,010
application using next Jas. And
it's a framework that's gonna

18503
18:47:04,010 --> 18:47:06,950
allow us to build really
powerful front ends and full

18504
18:47:06,950 --> 18:47:10,340
stack applications really
easily. We learned about the

18505
18:47:10,340 --> 18:47:13,640
layout of our next JS project,
we add components in a

18506
18:47:13,640 --> 18:47:17,270
components folder, which are
basically minimalistic blocks of

18507
18:47:17,270 --> 18:47:21,590
JavaScript and HTML that we can
use to modularize and create our

18508
18:47:21,590 --> 18:47:24,920
website out of these components.
Constants is a folder that we

18509
18:47:24,920 --> 18:47:29,390
can put constant variables, Node
modules is node modules. And out

18510
18:47:29,390 --> 18:47:32,210
folders. What happens when we
export all of our code to a

18511
18:47:32,210 --> 18:47:35,960
static example, pages are going
to be basically the routes or

18512
18:47:35,960 --> 18:47:38,780
the different pages of our
website, everything goes through

18513
18:47:38,810 --> 18:47:43,760
app.js. Public is just some
public stuff styles is for any

18514
18:47:43,760 --> 18:47:47,240
CSS or styling of our
application. And then we have

18515
18:47:47,270 --> 18:47:52,010
our basic files here. In our
pages section, we have our app,

18516
18:47:52,130 --> 18:47:55,520
which is surrounded by both this
notification provider and our

18517
18:47:55,520 --> 18:47:59,480
Morales provider, all of our
components run through this app

18518
18:47:59,600 --> 18:48:03,440
on all of our pages run through
this app. So this is kind of

18519
18:48:03,440 --> 18:48:07,460
considered the entry point for
our entire application. Having

18520
18:48:07,460 --> 18:48:10,760
this Morales provider wrapped
around our notifications in

18521
18:48:10,760 --> 18:48:15,080
component means that we don't
have to pass parameters between

18522
18:48:15,080 --> 18:48:18,680
our components. And our lottery
will just know what chain ID

18523
18:48:18,680 --> 18:48:21,290
that we're on, because our
header is going to pass it up to

18524
18:48:21,290 --> 18:48:23,780
Morales provider and the Morales
provider is going to pass it

18525
18:48:23,780 --> 18:48:27,650
back down to our lottery
entrance. And we saw with our

18526
18:48:27,650 --> 18:48:30,380
manual header, the way that that
connect button works behind the

18527
18:48:30,380 --> 18:48:33,260
scenes. So it's doing some local
storage, where we're storing

18528
18:48:33,260 --> 18:48:35,990
whether or not we're actually
connected, we learned about use

18529
18:48:35,990 --> 18:48:39,170
effect, and you state and these
different hooks in our front

18530
18:48:39,170 --> 18:48:42,020
ends were one of the main
reasons we want hooks is we want

18531
18:48:42,050 --> 18:48:45,560
we want our websites to
rerender. When stuff changes, we

18532
18:48:45,560 --> 18:48:49,040
want our components to be able
to talk about the state of the

18533
18:48:49,040 --> 18:48:52,250
blockchain with each other. And
they're incredibly powerful for

18534
18:48:52,250 --> 18:48:55,460
building our React applications.
Use effect is one of the most

18535
18:48:55,460 --> 18:48:58,910
popular ones where if we don't
have a dependency array, our

18536
18:48:58,910 --> 18:49:02,210
function inside of our use
effect will run anytime

18537
18:49:02,210 --> 18:49:06,050
something re renders a blank
dependency array means it'll

18538
18:49:06,050 --> 18:49:09,950
just run once on load. And if
there are dependencies in the

18539
18:49:09,950 --> 18:49:14,360
array, it'll run any time any of
the variables in those change.

18540
18:49:14,420 --> 18:49:18,020
We also learned about the use
state hook, which is really

18541
18:49:18,020 --> 18:49:21,200
similar to saying like, let
variable equals x. But it also

18542
18:49:21,200 --> 18:49:24,500
comes with the RE rendering
ability. And it comes with some

18543
18:49:24,500 --> 18:49:26,870
other nice abilities that we
didn't really discuss here, we

18544
18:49:26,870 --> 18:49:29,420
learned how to call different
contract functions with

18545
18:49:29,450 --> 18:49:33,680
mirallas. Not only sending
transactions, but also calling

18546
18:49:33,680 --> 18:49:36,560
data. Morales is smart enough to
know that when it sees get

18547
18:49:36,560 --> 18:49:40,160
entrance fee that this is going
to be a view function. And this

18548
18:49:40,190 --> 18:49:42,470
is going to be a transaction, it
can tell the difference between

18549
18:49:42,470 --> 18:49:45,770
the two. So this one's going to
populate Metamask to pop up. And

18550
18:49:45,770 --> 18:49:48,470
this one just going to return
kind of normally like a view

18551
18:49:48,470 --> 18:49:51,560
function, what we can actually
use the same syntax between

18552
18:49:51,590 --> 18:49:54,380
sending transactions and then
calling view functions on our

18553
18:49:54,380 --> 18:49:57,680
contract, we added a button,
calling one of these Morales

18554
18:49:57,680 --> 18:50:01,880
pieces and then had an onsuccess
section where when our

18555
18:50:01,880 --> 18:50:05,420
transaction completed, we update
the UI and we add a little pop

18556
18:50:05,420 --> 18:50:08,750
up for notifications, we learned
how to deploy our code directly

18557
18:50:08,750 --> 18:50:14,900
to IPFS. And use that IPFS hash
to interact and see our code, we

18558
18:50:14,900 --> 18:50:18,170
also learned about fleek and how
fleek automatically deploys to

18559
18:50:18,170 --> 18:50:22,130
IPFS. Whenever we do a git push
to our GitHub repository, and it

18560
18:50:22,130 --> 18:50:26,270
makes continuously updating our
websites much easier. It also

18561
18:50:26,270 --> 18:50:30,290
gives us a regular canonical URL
as well. And then finally, we

18562
18:50:30,290 --> 18:50:33,680
learned about IPFS and
decentralized database storage.

18563
18:50:33,890 --> 18:50:36,110
Now you might be asking, Okay,
well, why don't we just store

18564
18:50:36,110 --> 18:50:39,050
all the data for this website on
Aetherium, or polygon or

18565
18:50:39,050 --> 18:50:41,810
avalanche, etc? And the answer
to that is that can get

18566
18:50:41,810 --> 18:50:45,800
incredibly expensive storing
data, storing a ton of data on

18567
18:50:45,800 --> 18:50:50,060
the blockchain costs a ton of
gas, whereas this is a much

18568
18:50:50,090 --> 18:50:53,840
cheaper alternative. Aetherium
avalanche and the smart contract

18569
18:50:53,900 --> 18:50:57,230
platforms aren't really meant to
be data storage layers, they're

18570
18:50:57,230 --> 18:51:00,050
meant to be logic layers, right?
Decentralized logic,

18571
18:51:00,050 --> 18:51:03,260
decentralized smart contracts,
oftentimes, yes, we're gonna

18572
18:51:03,260 --> 18:51:06,410
have to store data in them. But
when it's a ton of data, there

18573
18:51:06,410 --> 18:51:08,630
are better solutions. And there
are different solutions out

18574
18:51:08,630 --> 18:51:12,410
there for storing our data, like
IPFS and filecoin, you should be

18575
18:51:12,440 --> 18:51:15,080
incredibly proud of yourself, if
you've made it this far, because

18576
18:51:15,080 --> 18:51:18,680
you've just made a really solid
app, a really solid front end

18577
18:51:18,680 --> 18:51:21,770
application. And you've learned
how to really easily add

18578
18:51:21,770 --> 18:51:24,650
functionality for interacting
with your smart contracts. So

18579
18:51:24,680 --> 18:51:27,800
give yourself a pat on the back,
maybe even tweet this out, share

18580
18:51:27,800 --> 18:51:30,320
this really cool application
with your friends and family.

18581
18:51:30,380 --> 18:51:33,290
Take a break. And I'll see you
in the next lesson.

18582
18:51:38,840 --> 18:51:41,360
All right, welcome to one of the
fastest lessons that we're going

18583
18:51:41,360 --> 18:51:43,520
to have here. And in this
lesson, we're going to talk

18584
18:51:43,520 --> 18:51:46,460
about the hardhat starter kit.
Really quickly, I'm going to

18585
18:51:46,460 --> 18:51:49,130
walk you through it and show you
how to use it. Now we've learned

18586
18:51:49,130 --> 18:51:51,290
a lot about projects, we've
learned a lot about different

18587
18:51:51,290 --> 18:51:54,290
repos, learnt the basics of
smart contracts. And we've

18588
18:51:54,290 --> 18:51:57,500
learned a lot about front end as
well and building front ends for

18589
18:51:57,500 --> 18:52:01,700
applications. So this smart
contract kit repo comes packed

18590
18:52:01,700 --> 18:52:06,410
with a ton of starter kits that
you can use to start deploying

18591
18:52:06,410 --> 18:52:09,530
your projects right away. And as
you can see, that hard hat

18592
18:52:09,530 --> 18:52:12,650
starter kit is easily one of the
most popular ones with the most

18593
18:52:12,650 --> 18:52:15,830
stars the most forks out there.
The smart contract kit repo

18594
18:52:15,830 --> 18:52:18,170
actually comes with a ton of
frameworks, like if you want to

18595
18:52:18,170 --> 18:52:21,080
work with SWANA, if you want to
work with Python and Brownie, if

18596
18:52:21,080 --> 18:52:25,040
you want to work with foundry,
truffle, really any other

18597
18:52:25,040 --> 18:52:27,590
framework out there, you can get
started, clone one of these

18598
18:52:27,590 --> 18:52:30,560
repos, work with one of these
repos and build your project and

18599
18:52:30,560 --> 18:52:32,960
get started right away, we're
going to show you how to use the

18600
18:52:32,960 --> 18:52:37,130
hard hat starter kit. So you can
just grab the repo and go and

18601
18:52:37,160 --> 18:52:40,400
already have some boilerplate
code and a boilerplate really

18602
18:52:40,400 --> 18:52:43,190
good looking repo to start your
projects with, we come to the

18603
18:52:43,190 --> 18:52:46,010
smart contract kit, hard hat
starter kit repo here. And if

18604
18:52:46,010 --> 18:52:48,140
you're working with GitHub, you
can just go ahead and use this

18605
18:52:48,140 --> 18:52:51,470
template and it will
automatically generate you a new

18606
18:52:51,470 --> 18:52:54,320
GitHub repo with the hardest
starter kit. So let's go ahead,

18607
18:52:54,320 --> 18:52:57,320
we'll click use this template,
we come up with our own name

18608
18:52:57,320 --> 18:53:02,450
here, we'll call it make it
public create repository from

18609
18:53:02,450 --> 18:53:06,860
Template. it'll generate our
repository. And now we

18610
18:53:06,860 --> 18:53:10,190
automatically have it in our own
repo here. And we can get

18611
18:53:10,190 --> 18:53:12,620
started working with it. And we
can get started working with it.

18612
18:53:12,680 --> 18:53:15,260
If you don't want to click the
use that template button, we can

18613
18:53:15,260 --> 18:53:18,740
also just copy the URL. And in
our code editor, we can just do

18614
18:53:18,740 --> 18:53:21,740
git clone and paste that in
there. So for now, I am going to

18615
18:53:21,740 --> 18:53:24,500
get clone, but I'm going to get
clone with this repo that we

18616
18:53:24,500 --> 18:53:30,080
just created. Come back in with
the git clone, hard hat play FCC

18617
18:53:30,110 --> 18:53:34,310
or hard hat starter kit. We're
going to cd into our head play

18618
18:53:34,310 --> 18:53:38,720
FCC, and then open that up in a
new code editor. And awesome.

18619
18:53:38,960 --> 18:53:41,150
Now you'll see in this repo, it
comes packed with a ton of

18620
18:53:41,150 --> 18:53:45,770
contracts, deployments, scripts,
tasks, test, everything, you

18621
18:53:45,770 --> 18:53:48,800
name it to really get started in
a professional environment. We

18622
18:53:48,800 --> 18:53:52,430
look in the contract section, we
can see we have a couple of

18623
18:53:52,460 --> 18:53:56,120
sample contracts. We have a
contract for making an API call

18624
18:53:56,120 --> 18:54:00,080
to a chain link node, working
with keepers working with price

18625
18:54:00,080 --> 18:54:03,350
feeds, and then working with
chain link Vir Fe two. We've got

18626
18:54:03,350 --> 18:54:06,140
some test contracts and we
additionally have this fuzzing

18627
18:54:06,140 --> 18:54:09,620
folder, which we'll talk talk
about in a much later section of

18628
18:54:09,620 --> 18:54:11,750
this course, we have deployed
scripts where we start with

18629
18:54:11,750 --> 18:54:14,780
deploying mocks, then we deploy
each one of those contracts, we

18630
18:54:14,780 --> 18:54:17,660
have a sample script to read the
price from one of these

18631
18:54:17,660 --> 18:54:21,260
contracts. And we have a whole
bunch of sample tasks. Now at

18632
18:54:21,260 --> 18:54:23,960
the time of recording, instead
of scripts, this repo uses

18633
18:54:23,960 --> 18:54:26,840
tasks. But again, they're a
little bit interchangeable. And

18634
18:54:26,840 --> 18:54:29,570
of course, we have some unit
tests and some staging tests as

18635
18:54:29,570 --> 18:54:32,420
well, that you can go through
and take a look at, once we're

18636
18:54:32,420 --> 18:54:35,930
in this repo, we can run some
familiar commands here, we'll do

18637
18:54:35,930 --> 18:54:39,560
yarn, of course, to install our
all of our packages. And then

18638
18:54:39,590 --> 18:54:42,140
everything that we're going to
do, if you get lost, you can

18639
18:54:42,140 --> 18:54:45,590
always come back to this repo.
And you can follow along with

18640
18:54:45,590 --> 18:54:47,810
getting started and the
Quickstart. So we just did the

18641
18:54:47,810 --> 18:54:51,050
git clone. Now we're doing the
yarn, and then we're gonna go

18642
18:54:51,050 --> 18:54:53,930
ahead and run yarn hard hat
test. This hard hat starter kit

18643
18:54:53,930 --> 18:54:57,710
repo is very consistently up to
date, we did the last push being

18644
18:54:57,740 --> 18:55:00,590
just a few days ago, and will
constantly have some best

18645
18:55:00,590 --> 18:55:03,590
practices for building our smart
contracts and having a really

18646
18:55:03,590 --> 18:55:06,230
professional coding environment.
And it's got this really cute

18647
18:55:06,230 --> 18:55:09,170
logo. Once we've installed all
the dependencies, we can run

18648
18:55:09,170 --> 18:55:14,360
yarn, art hath test, we can run
all of the tests in the test

18649
18:55:14,360 --> 18:55:17,660
folder, which also will show us
how to interact and how to use

18650
18:55:17,660 --> 18:55:20,930
all these different contracts in
here. And they each have some

18651
18:55:20,930 --> 18:55:23,780
console dot log, so you can see
more about what's actually going

18652
18:55:23,780 --> 18:55:28,070
on when these tests actually
run. If we look in the Hardhead

18653
18:55:28,070 --> 18:55:31,700
config.js, it's got some really
familiar code in here, we have

18654
18:55:31,700 --> 18:55:35,000
all our imports at the top, we
grab a whole bunch of

18655
18:55:35,000 --> 18:55:38,720
environment variables, we've got
the ether scan plugin, we've got

18656
18:55:38,720 --> 18:55:42,230
the gas reporter, the contract
sizer, which is a plugin that

18657
18:55:42,230 --> 18:55:45,650
tells you how big your contracts
are. So named accounts,

18658
18:55:45,650 --> 18:55:48,830
different solidity versions, and
then mocha timeout as well. We

18659
18:55:48,830 --> 18:55:53,270
can of course, do yarn hard hat
node, which will run through our

18660
18:55:53,270 --> 18:55:57,770
deploy scripts, and then spin up
a new note for us, which has

18661
18:55:57,860 --> 18:56:01,550
mock chainlink tokens, mock
Oracle's mock aggregators, and

18662
18:56:01,550 --> 18:56:04,760
mock up VRF for us to go ahead
and interact with once that's

18663
18:56:04,760 --> 18:56:09,050
up, we can then of course, to
hard hat, console, dash dash

18664
18:56:09,050 --> 18:56:13,760
network localhost, and begin
interacting with contracts on

18665
18:56:13,790 --> 18:56:16,550
localhost. So we can kind of
follow along with price feed,

18666
18:56:16,550 --> 18:56:22,310
for example, and do const price
consumer B three equals await

18667
18:56:22,850 --> 18:56:27,950
ethers dot get contract, price,
consumer V three.

18668
18:56:29,270 --> 18:56:34,490
And then we can do await price
consumer B three dot get latest

18669
18:56:34,490 --> 18:56:40,640
price. Let's wrap that in a to
string. And we can see a mock

18670
18:56:40,640 --> 18:56:43,940
latest price from a contract
that uses channeling price

18671
18:56:43,940 --> 18:56:47,000
feeds. And we can interact with
any of our contracts and work

18672
18:56:47,000 --> 18:56:50,360
with any of the mocks as well in
here. If we want to deploy this

18673
18:56:50,360 --> 18:56:53,750
to an actual test net like
Rinckey, or main net will just

18674
18:56:53,750 --> 18:56:57,950
pop in our dot env file, we'll
close our node terminal, and we

18675
18:56:57,950 --> 18:57:03,080
can run yarn hardhat or just hh
deploy. And then we'll add

18676
18:57:03,080 --> 18:57:05,510
whatever tags we want to do
here. So let's just deploy our

18677
18:57:05,510 --> 18:57:08,930
price feed contract. If we go to
the price feed deploy, we scroll

18678
18:57:08,930 --> 18:57:12,890
down, we'll get the tags. Okay,
great, we'll use the feed tag,

18679
18:57:13,070 --> 18:57:17,900
dash tags feeds dash to or feed
dash dash network brings beam.

18680
18:57:18,200 --> 18:57:21,020
And while we're waiting for this
to deploy, we can go back to the

18681
18:57:21,020 --> 18:57:24,230
actual repo. And just make sure
to follow along with the

18682
18:57:24,230 --> 18:57:26,840
documentation here and the
Quickstart in all the usage and

18683
18:57:26,840 --> 18:57:29,210
everything so that you make sure
that you're working with the

18684
18:57:29,210 --> 18:57:32,420
most up to date version. There's
even documentation on running a

18685
18:57:32,420 --> 18:57:36,230
local network using a test net
or live network working with

18686
18:57:36,230 --> 18:57:39,560
Aetherium. Rigby adding your
private keys and dotting envies

18687
18:57:39,590 --> 18:57:42,560
all this stuff that you already
know, forking, which we'll learn

18688
18:57:42,560 --> 18:57:45,590
a little bit later, auto funding
your contracts for working with

18689
18:57:45,830 --> 18:57:49,400
chain link API running tests,
you can additionally run your

18690
18:57:49,400 --> 18:57:53,180
tests in parallel by adding the
dash dash parallel flag to our

18691
18:57:53,180 --> 18:57:56,390
tests. We can interact with our
deployed contracts with those

18692
18:57:56,390 --> 18:57:59,480
different tasks that we've
created linting code formatting,

18693
18:57:59,510 --> 18:58:02,450
estimated gas code coverage
fuzzing, we'll talk about later.

18694
18:58:02,750 --> 18:58:06,650
And then contributions. PRs
issues are always welcome here.

18695
18:58:06,770 --> 18:58:09,320
And once it's outputted, and
even verified, if you have

18696
18:58:09,320 --> 18:58:12,110
verification turned on, you'll
get a little task that we can

18697
18:58:12,110 --> 18:58:15,050
run to just go ahead and read
the price feed or interact with

18698
18:58:15,050 --> 18:58:18,800
the contract. So we can copy
that task out. Yarn hardhat.

18699
18:58:18,830 --> 18:58:22,520
Read price feed since it's a
task here, contract the contract

18700
18:58:22,520 --> 18:58:25,640
data which we just deployed
network Rigby. And we'll get

18701
18:58:25,700 --> 18:58:28,610
reading data price feed from
consumer contract on network,

18702
18:58:28,610 --> 18:58:31,910
Rigby price is here, which of
course, we're saying the price

18703
18:58:31,910 --> 18:58:36,830
of Aetherium is $3,033, because
it has eight decimal places. So

18704
18:58:36,830 --> 18:58:39,500
if you're ever looking to start
a new project, and you want some

18705
18:58:39,500 --> 18:58:42,920
boilerplate code, this hard hat
Starter Kit is a great place to

18706
18:58:42,920 --> 18:58:46,100
get started. And of course, you
can open it and get pod if you

18707
18:58:46,100 --> 18:58:49,460
want to just test it out and try
it and get pot in a Cloud Shell.

18708
18:58:49,520 --> 18:58:52,430
So that's it for this lesson.
Wasn't that fast. This was the

18709
18:58:52,430 --> 18:58:55,280
fastest lesson ever. So if you
want to do a little extra

18710
18:58:55,280 --> 18:58:58,010
learnings here, I would fork
this I would clone this I would

18711
18:58:58,010 --> 18:59:00,710
use this template, try to play
around with the repo a little

18712
18:59:00,710 --> 18:59:03,620
bit yourself and see what you
recognize, see what you don't

18713
18:59:03,620 --> 18:59:07,400
recognize and keep that prepped
in your mind for later so

18714
18:59:07,430 --> 18:59:09,560
Questions in the course. And
then for everyone here who is

18715
18:59:09,560 --> 18:59:13,010
TypeScript, there is, of course,
a TypeScript version of this as

18716
18:59:13,010 --> 18:59:17,330
well that you can get cloned.
And it has a nice blue logo here

18717
18:59:17,510 --> 18:59:20,330
to show that it's a little bit
different. So, that being said,

18718
18:59:20,570 --> 18:59:24,290
use the repo, have fun. Let's
get to lesson 12.

18719
18:59:29,750 --> 18:59:33,560
Alright, now we're moving on to
the hard hat ERC. 20s are the

18720
18:59:33,560 --> 18:59:36,470
section where we're going to
learn how to create our own ERC

18721
18:59:36,470 --> 18:59:42,620
20 or EIP 20 Or B E P 20 or AEP
20 any of these tokens on the

18722
18:59:42,620 --> 18:59:45,770
blockchain before we can
understand what an ERC 20 is, or

18723
18:59:45,770 --> 18:59:48,650
even what one of these tokens
are, we first need to understand

18724
18:59:48,650 --> 18:59:53,330
what is an ERC. And then also
what is an EIP in Aetherium, and

18725
18:59:53,330 --> 18:59:56,480
avalanche and finance and
polygon. All these blockchains

18726
18:59:56,480 --> 18:59:59,630
have what's called improvement
proposals. And for Aetherium,

18727
18:59:59,870 --> 19:00:03,410
they're called Aetherium
improvement proposals, or E IPs.

18728
19:00:03,500 --> 19:00:07,160
And what people would do is they
come up with these ideas to

18729
19:00:07,160 --> 19:00:10,880
improve Aetherium or improve
these layer ones like polygon,

18730
19:00:11,090 --> 19:00:15,140
Matic avalanche, etc. And on
some GitHub or some open source

18731
19:00:15,140 --> 19:00:18,770
repository, they'll add these
new EIP is they'll add these new

18732
19:00:18,770 --> 19:00:21,890
improvement ideas to make these
protocols better. Now, these

18733
19:00:21,890 --> 19:00:23,990
improvements can really be
anything, they can be anything

18734
19:00:23,990 --> 19:00:27,980
from a core blockchain update to
some standard, that is going to

18735
19:00:27,980 --> 19:00:31,340
be a best practice for the
entire community to adopt. Once

18736
19:00:31,340 --> 19:00:35,780
an EIP gets enough insight, they
also create an E RC, which

18737
19:00:35,780 --> 19:00:39,650
stands for Aetherium request for
comments. So EIP a theory and

18738
19:00:39,830 --> 19:00:43,130
improvement proposals ERC a
theory and request for comments.

18739
19:00:43,160 --> 19:00:48,740
And again, these can be like BP,
Pep, you know, etc. For all

18740
19:00:48,740 --> 19:00:51,170
these different blockchains.
Both the improvement proposals

18741
19:00:51,170 --> 19:00:54,110
and the Request for Comments,
all have these different tags,

18742
19:00:54,110 --> 19:00:56,900
now they're numbered
chronologically, so something

18743
19:00:56,900 --> 19:01:03,020
like an ERC 20 is going to be
the 20th ERC slash EIP, the ERC

18744
19:01:03,020 --> 19:01:06,440
is and the EFPs share that same
number. And there are websites

18745
19:01:06,440 --> 19:01:10,130
like EIP is that aetherium.org
That keep track of all of these

18746
19:01:10,160 --> 19:01:12,680
new Aetherium improvement
proposals, and you can actually

18747
19:01:12,680 --> 19:01:15,530
see them real time go through
the process of being adopted by

18748
19:01:15,530 --> 19:01:20,300
the community. Now, one of these
e IPs or ERC is, is going to be

18749
19:01:20,300 --> 19:01:24,410
the ERC 20 or the token standard
for smart contracts. This is an

18750
19:01:24,410 --> 19:01:28,280
improvement proposal that talks
about how to actually create

18751
19:01:28,280 --> 19:01:31,040
tokens and create these smart
contract tokens. I made a video

18752
19:01:31,040 --> 19:01:33,890
about this recently. So in the
GitHub repo associated with this

18753
19:01:33,890 --> 19:01:35,990
course, we're going to have a
sub lesson, and we're going to

18754
19:01:35,990 --> 19:01:38,720
watch a quick video that
explains more about these

18755
19:01:38,720 --> 19:01:44,780
different tokens. Now first,
let's define even what are ERC

18756
19:01:44,780 --> 19:01:49,040
20s So ERC 20s are tokens that
are deployed on a chain using

18757
19:01:49,040 --> 19:01:52,040
what's called the ERC 20 token
standard, you can read more

18758
19:01:52,040 --> 19:01:54,620
about it in the year 20 token
standard here link in the

18759
19:01:54,620 --> 19:01:56,960
description as well. But
basically, it's a smart contract

18760
19:01:56,990 --> 19:02:00,050
that actually represents a
token. So it's token or the

18761
19:02:00,050 --> 19:02:03,230
smart contract. It's both it's
really cool tether chainlink

18762
19:02:03,320 --> 19:02:07,640
unique token and dye are all
examples of ERC 20s Technically,

18763
19:02:07,730 --> 19:02:11,990
chain link is in the ERC. 677 as
there are upgrades to the ERC 20

18764
19:02:11,990 --> 19:02:15,530
that some tokens take that are
still backwards compatible with

18765
19:02:15,560 --> 19:02:18,770
ERC. 20s And so basically, you
can think of them as ERC 20s

18766
19:02:18,800 --> 19:02:21,410
with a little additional
functionality. Now why would I

18767
19:02:21,410 --> 19:02:23,930
even care to want to make an ERC
20 Well, you can do a lot of

18768
19:02:23,930 --> 19:02:26,450
really cool stuff with it. You
can make governance token, you

18769
19:02:26,450 --> 19:02:28,880
can secure an underlying
network, you can create some

18770
19:02:28,880 --> 19:02:32,570
type of synthetic acid, or
really anything else. In any

18771
19:02:32,570 --> 19:02:35,300
case, how do we build one of
these ERC? 20s How do we build

18772
19:02:35,300 --> 19:02:38,450
one of these tokens? Well, all
we have to do is build a smart

18773
19:02:38,450 --> 19:02:41,810
contract that follows the token
standard, all we have to do is

18774
19:02:41,960 --> 19:02:45,080
build a smart contract that has
these functions that has a name

18775
19:02:45,080 --> 19:02:48,410
function, symbol function,
decimals function, etc. All

18776
19:02:48,410 --> 19:02:50,990
these functions we need to be
able to transfer it, we need to

18777
19:02:50,990 --> 19:02:53,570
be able to get the balance of it
etc. And again, if you want to

18778
19:02:53,570 --> 19:02:56,240
check out some of the
improvements that are still ERC

18779
19:02:56,240 --> 19:03:01,730
20 compatible, like the ERC 677
or the ERC 777. Definitely go

18780
19:03:01,730 --> 19:03:06,740
check those out and build one of
those instead. All right,

18781
19:03:06,740 --> 19:03:10,370
awesome. Now that we know what
one of these ERC 20s is, we can

18782
19:03:10,370 --> 19:03:14,120
go ahead and create our own per
usual in the GitHub repo

18783
19:03:14,180 --> 19:03:16,850
associated with this course. We
have all the code available

18784
19:03:16,850 --> 19:03:20,060
here. If you want to just get
clone. This is going to be again

18785
19:03:20,090 --> 19:03:22,610
another one of our quicker
lessons here. So we're in our

18786
19:03:22,610 --> 19:03:25,250
terminal. We're in our VS code
here. We're going to make a new

18787
19:03:25,250 --> 19:03:31,760
directory. I'm going to call it
hard hat ERC 20 FCC will cd into

18788
19:03:31,760 --> 19:03:35,630
hard hat, your C 20 sec. And
we're going to create a new hard

18789
19:03:35,630 --> 19:03:38,510
hat project the exact same way
we've been doing it yarn add

18790
19:03:38,510 --> 19:03:43,970
dash dash dev or tab. Let's
actually open it in its own VS

18791
19:03:43,970 --> 19:03:49,280
code will do code.or file open
this folder. And okay, we're in

18792
19:03:49,280 --> 19:03:52,130
our project now. Let's create a
new hard hat project. We'll do

18793
19:03:52,130 --> 19:03:53,990
yarn, art hats.

18794
19:03:55,460 --> 19:03:59,150
We'll do create an empty hard
hat dot config dot j s here and

18795
19:03:59,150 --> 19:04:02,540
great. We've now got an empty
hard hat dot config dot j s. If

18796
19:04:02,540 --> 19:04:05,720
you want to copy paste your hard
hat dot config from a previous

18797
19:04:05,720 --> 19:04:08,780
projects you want to copy paste
your heart Have dot config or

18798
19:04:08,780 --> 19:04:11,300
your dot EMV file, because you
know we're going to need those

18799
19:04:11,480 --> 19:04:15,200
feel free to do so now, I'm just
going to update this to 8.7.

18800
19:04:15,380 --> 19:04:19,340
I'll add the rest of my stuff
later. So as we've heard this

18801
19:04:19,370 --> 19:04:23,330
EIP 20, or this ERC 20. All it
needs is to have these functions

18802
19:04:23,360 --> 19:04:26,330
in its token standard so that we
can transfer tokens, we can do

18803
19:04:26,330 --> 19:04:29,540
all the stuff in the ERC 20
contract itself, it really is

18804
19:04:29,540 --> 19:04:33,230
just keeping track of how much
of each token people have. So

18805
19:04:33,230 --> 19:04:36,200
the smart contract, kind of in a
weird way it keeps track of

18806
19:04:36,200 --> 19:04:38,750
itself. To get started, we're
going to do this kind of the

18807
19:04:38,750 --> 19:04:42,140
manual way. First, we're going
to create our own manual token

18808
19:04:42,140 --> 19:04:45,800
here, or a really minimalistic
one anyways, so let's create a

18809
19:04:45,800 --> 19:04:52,280
new folder. contracts will
create a new file called manual

18810
19:04:52,280 --> 19:04:56,690
token dot soul. Yes, I'm going
to show you kind of the hard way

18811
19:04:56,690 --> 19:04:59,330
to make it and then I'll show
you a much easier way to make

18812
19:04:59,330 --> 19:05:04,310
it. So to get started here are
usual we can do pragma, solidity

18813
19:05:05,060 --> 19:05:11,570
to carrot zero, point 8.7. And
then we'll even do spdx, license

18814
19:05:11,840 --> 19:05:18,770
identifier, MIT do contract,
manual token, and boom, let's

18815
19:05:18,770 --> 19:05:22,370
get started. The main reason
this token smart contract works

18816
19:05:22,640 --> 19:05:28,010
is that there's some balances
mapping. So we have a mapping of

18817
19:05:28,010 --> 19:05:33,740
addresses to you in 256. And
it's usually public called

18818
19:05:34,550 --> 19:05:38,840
balance of and all this does is
this mapping is obviously the

18819
19:05:38,840 --> 19:05:42,170
key is going to be every single
address on the planet, and then

18820
19:05:42,170 --> 19:05:45,230
how much they have. And
basically, when we transfer

18821
19:05:45,230 --> 19:05:50,720
tokens, transfer tokens, we're
basically just subtract from

18822
19:05:50,750 --> 19:05:56,960
address, amount, and add to to
address. So a really

18823
19:05:56,960 --> 19:05:59,840
minimalistic way to implement
this would be to create this

18824
19:05:59,840 --> 19:06:02,990
transfer function first. So
we'll create this function, I'm

18825
19:06:02,990 --> 19:06:05,600
going to call it underscore
transfer, we can do an address

18826
19:06:05,600 --> 19:06:12,170
from address to you into fifth
sixth mount. And now we'd

18827
19:06:12,170 --> 19:06:14,960
probably put some requirements,
we probably omit some events,

18828
19:06:15,290 --> 19:06:17,870
and let's make this public as
well. And really, at the end of

18829
19:06:17,870 --> 19:06:25,670
the day, is we're gonna say
balance of from minus equals

18830
19:06:27,350 --> 19:06:31,730
value, which is the same as
saying bounce of from equals

18831
19:06:31,760 --> 19:06:35,420
bounce from minus value, or
excuse me, amount, and then

18832
19:06:35,420 --> 19:06:40,490
we're gonna say balance of two,
excuse me, plus equals, which is

18833
19:06:40,490 --> 19:06:43,820
the same as saying, you know,
balance of two plus. And

18834
19:06:43,820 --> 19:06:46,970
technically, that's really all
we need, right, we probably want

18835
19:06:46,970 --> 19:06:49,640
to do some asserts ins here,
some requires to make sure all

18836
19:06:49,640 --> 19:06:52,610
of our numbers make sense. But
really, at the end of the day,

18837
19:06:52,640 --> 19:06:56,060
this is all that this function
is doing. Transfer works when

18838
19:06:56,060 --> 19:06:59,930
the caller is sending money
directly into another address.

18839
19:07:00,230 --> 19:07:03,710
But what happens if we want to
allow some smart contract to

18840
19:07:03,710 --> 19:07:06,890
work with our token, or we want
to allow somebody else to work

18841
19:07:06,890 --> 19:07:09,920
with our token, you know, maybe
to deposit it into a protocol,

18842
19:07:10,100 --> 19:07:13,010
or do some more functionality
with it, there will be some

18843
19:07:13,010 --> 19:07:15,380
approved function that will
approve that contract to do

18844
19:07:15,380 --> 19:07:21,740
that. And then we'll have a
function transfer from and this

18845
19:07:21,740 --> 19:07:24,050
function will, you know, it'll
just implement taking funds from

18846
19:07:24,050 --> 19:07:27,440
user and this will be public as
well. And then at the top will

18847
19:07:27,440 --> 19:07:31,430
be some type of allowances
mapping that will tell who's

18848
19:07:31,430 --> 19:07:35,000
allowed which address to take
how much token, which sounds a

18849
19:07:35,000 --> 19:07:36,860
little confusing, but let me
just add the mapping. So it'll

18850
19:07:36,860 --> 19:07:42,530
be a mapping of addresses to a
mapping of addresses to an

18851
19:07:42,530 --> 19:07:47,240
amount to a unit tivity sex and
this will be public allowance,

18852
19:07:47,480 --> 19:07:52,340
we're gonna say address, Patrick
is going to allow address of

18853
19:07:52,340 --> 19:07:56,120
Patrick's brother to use 25
tokens. And that's how this

18854
19:07:56,150 --> 19:08:00,560
allowance works. And in our
transfer from transfer from will

18855
19:08:00,560 --> 19:08:04,640
check this allowance mapping and
save Hmm. Did Patrick give you

18856
19:08:04,820 --> 19:08:08,180
authorization to borrow those
tokens? Oh, yes, you did. Okay,

18857
19:08:08,180 --> 19:08:11,330
we'll let you transfer from. And
I'm just, I'm just going to copy

18858
19:08:11,330 --> 19:08:13,820
paste an implementation of it,
you can check out the GitHub

18859
19:08:13,820 --> 19:08:16,940
repo as well. And it would look
something like this is we check

18860
19:08:16,940 --> 19:08:20,300
the allowed amounts, update the
allowance, and then transfer the

18861
19:08:20,300 --> 19:08:22,730
tokens. So those are some of the
main functions. So we need an

18862
19:08:22,730 --> 19:08:26,120
approved function, obviously, to
update the allowances here. And

18863
19:08:26,120 --> 19:08:33,830
usually, you'll have like a un
256 initial supply. And this

18864
19:08:33,830 --> 19:08:37,010
will be like how many tokens
there are starting with how many

18865
19:08:37,010 --> 19:08:39,230
tokens there are total,
sometimes you'll add a mint

18866
19:08:39,230 --> 19:08:42,110
function to add more functions.
But you can basically start to

18867
19:08:42,110 --> 19:08:45,170
see this contract ramping up.
One thing we could do is we

18868
19:08:45,170 --> 19:08:49,430
could go ahead go through this
spec and just line by line, you

18869
19:08:49,430 --> 19:08:52,520
know, build our token ourself.
And after we do that, it might

18870
19:08:52,520 --> 19:08:56,270
look something like this. So I'm
just copy pasted the code from

18871
19:08:56,270 --> 19:08:59,720
the GitHub repo. If you go to
contracts, manual token, I just

18872
19:08:59,720 --> 19:09:03,500
copy paste this code in here.
This is what a contract a token

18873
19:09:03,500 --> 19:09:06,320
contract might look like. Okay.
So we have all these functions,

18874
19:09:06,320 --> 19:09:09,320
we have all these arrays. We
have all this stuff. And you can

18875
19:09:09,320 --> 19:09:12,680
see in the constructor, we're
taking initial supply, and then

18876
19:09:12,680 --> 19:09:16,010
a token name and a token symbol.
The name, you know, might be

18877
19:09:16,010 --> 19:09:18,890
something like dy token. And
then the symbol might be

18878
19:09:18,890 --> 19:09:22,130
something like dy, just so that
it's easily recognizable just by

18879
19:09:22,130 --> 19:09:23,090
its name and its token.

18880
19:09:25,850 --> 19:09:28,520
coding it all from scratch, like
that is definitely something

18881
19:09:28,520 --> 19:09:31,340
that we can do. But as
engineers, we know that that's

18882
19:09:31,370 --> 19:09:33,770
probably really annoying. And we
don't actually want to do that.

18883
19:09:33,800 --> 19:09:37,370
So what can we do instead? Well,
we can use an open source

18884
19:09:37,400 --> 19:09:42,080
library, like open Zeppelin, to
actually get some boilerplate

18885
19:09:42,080 --> 19:09:45,440
code work with open Zeppelin is
almost considered kind of the

18886
19:09:45,440 --> 19:09:48,950
standard library of solidity.
They have a list of open source

18887
19:09:48,950 --> 19:09:52,190
contracts that anybody can use
and import into their contracts

18888
19:09:52,190 --> 19:09:55,010
that have a ton of boilerplate,
so that you don't have to

18889
19:09:55,010 --> 19:09:58,070
manually write everything out,
we can see all their code in

18890
19:09:58,070 --> 19:10:00,860
their GitHub repository, open
Zeppelin slash open Zeppelin

18891
19:10:00,860 --> 19:10:03,950
contracts, and we're going to be
using them a lot moving forward.

18892
19:10:03,980 --> 19:10:06,320
So for example, you can see kind
of on the left side of their

18893
19:10:06,320 --> 19:10:09,860
documentation, they have this
tokens section, and they have an

18894
19:10:09,890 --> 19:10:13,130
ERC 20, which is one of those
tokens standards. If you scroll

18895
19:10:13,130 --> 19:10:17,330
on here, they even have some
minimalistic examples of how to

18896
19:10:17,330 --> 19:10:20,510
create your own ERC 20 token.
And that's what we're going to

18897
19:10:20,510 --> 19:10:23,330
be using to build our token.
Because you see how much smaller

18898
19:10:23,330 --> 19:10:26,150
this is how much less code this
is to maintain. Let's go ahead

18899
19:10:26,150 --> 19:10:29,240
and let's use open Zeppelin for
us to create our token. So let's

18900
19:10:29,240 --> 19:10:33,500
create a new file. We'll call
our token dot soul. I'm going to

18901
19:10:33,500 --> 19:10:38,750
create our own token here. So
let's do spdx. License

18902
19:10:38,930 --> 19:10:44,630
identifier, MIT, we'll do
pragma, solidity carrot zero,

18903
19:10:45,050 --> 19:10:50,600
point 8.7, we'll do contract our
token. Now, what we're going to

18904
19:10:50,600 --> 19:10:53,930
do, we're going to import
openzeppelin contracts into our

18905
19:10:53,930 --> 19:10:56,060
hard hat project. And we're
going to do it the same way we

18906
19:10:56,060 --> 19:10:58,910
did with chain link and any
other packages in the future. So

18907
19:10:58,910 --> 19:11:04,280
we'll do yarn, add dash dash
Dev, at open Zeppelin slash

18908
19:11:04,280 --> 19:11:07,670
contracts. And this is going to
add the open Zeppelin slash

18909
19:11:07,670 --> 19:11:10,850
contracts NPM package to our
project. And one of the code

18910
19:11:10,850 --> 19:11:14,450
pieces that they have is this
ERC 20 contract that we can use

18911
19:11:14,450 --> 19:11:17,960
and we can have our token
inherit all the functions. So

18912
19:11:17,960 --> 19:11:21,920
we'll go ahead and import it
with import at openzeppelin.

18913
19:11:22,490 --> 19:11:27,440
Slash contracts slash tokens
slash ERC 20 slash ERC 20

18914
19:11:27,440 --> 19:11:31,160
ditzel. And just by importing it
like this, all we have to do is

18915
19:11:31,160 --> 19:11:34,880
have our token inherited now. So
we'll say contract. Our token is

18916
19:11:35,240 --> 19:11:39,650
ERC 20. Boom. And just like that
our token is almost done. Now

18917
19:11:39,650 --> 19:11:42,410
you might get this little wiggle
this little red line here saying

18918
19:11:42,530 --> 19:11:45,860
our token should be marked
abstract. And that's because if

18919
19:11:45,860 --> 19:11:50,330
we look into the ERC 20 dot soul
of openzeppelin We'll see that

18920
19:11:50,330 --> 19:11:53,840
it has a constructor. So in
order for us to inherit your C

18921
19:11:53,840 --> 19:11:58,400
20 token, we have to use the ERC
20 constructor and we just need

18922
19:11:58,400 --> 19:12:01,880
to give our token a name and a
symbol. But we can say in our

18923
19:12:01,880 --> 19:12:05,480
constructor, we can leave it
blank. And then right next to

18924
19:12:05,480 --> 19:12:09,830
our constructor, we'll add the
ERC 20 constructor and our name

18925
19:12:09,830 --> 19:12:14,000
will be our token. And then our
symbol will just be OT and then

18926
19:12:14,000 --> 19:12:18,140
this ERC. 20 token also comes
with something called a mint

18927
19:12:18,140 --> 19:12:21,350
functionality, which is
essentially a function that

18928
19:12:21,350 --> 19:12:24,200
allows us to create tokens,
right because right now we

18929
19:12:24,230 --> 19:12:27,740
actually get initialized with
zero tokens, right. So nobody's

18930
19:12:27,740 --> 19:12:31,310
actually allowed to have any
tokens. So we want to mint the

18931
19:12:31,310 --> 19:12:35,090
initial amount of tokens and
then who owns all those tokens

18932
19:12:35,090 --> 19:12:37,970
to start with. So usually what
you'll see is you'll see a mint

18933
19:12:37,970 --> 19:12:41,150
function like this, it'll be
passed in message that sender,

18934
19:12:41,180 --> 19:12:44,420
so whoever deploys this contract
will own all the tokens to

18935
19:12:44,420 --> 19:12:48,470
start. And then we'll give it
like an in their soul supply.

18936
19:12:49,010 --> 19:12:52,430
And then we could do like, you
went to 56 initial supply equals

18937
19:12:52,430 --> 19:12:56,630
like seven, or whatever. But
instead, a common practice is

18938
19:12:56,630 --> 19:12:59,210
just to add it to the
constructor. So you and 256

18939
19:12:59,570 --> 19:13:02,840
initial supply like that, as we
know about solidity decimals

18940
19:13:02,840 --> 19:13:09,170
don't work so great. So if I say
my initial supply is 50, that 50

18941
19:13:09,200 --> 19:13:13,130
is going to be like 50 way, and
there's all these ERC 20s come

18942
19:13:13,130 --> 19:13:16,970
with a decimals and decimals
function, which tells us how

18943
19:13:16,970 --> 19:13:21,530
many decimals we should expect
with our ERC 20. The default is

18944
19:13:21,830 --> 19:13:24,980
18. And we can override this
function if we want a different

18945
19:13:24,980 --> 19:13:28,370
amount of decimals. And if we
know the default is 18. And we

18946
19:13:28,370 --> 19:13:32,690
want to deploy 50, we might want
to do our initial supply of 50 e

18947
19:13:32,690 --> 19:13:38,390
18. Or you can also say like 50
times 10, raise the 18th or

18948
19:13:38,390 --> 19:13:41,720
whatever you want there. And in
our code when we deploy this

18949
19:13:41,750 --> 19:13:43,580
now, this is actually where
we're going to finish the

18950
19:13:43,580 --> 19:13:46,790
project. Because everything else
that we would do here, we've

18951
19:13:46,790 --> 19:13:50,030
already done, all we need to do
is make a deploy script and

18952
19:13:50,030 --> 19:13:52,850
write some tests. That's really
it. Because right now you have

18953
19:13:52,850 --> 19:13:55,940
all the skills that you need to
write a deploy script and then

18954
19:13:55,940 --> 19:13:59,330
optionally write some tests for
this project. So I highly

18955
19:13:59,330 --> 19:14:01,970
encourage you to pause the video
here and try to write your own

18956
19:14:01,970 --> 19:14:05,360
deploy script. And even if you
want to write your own tests,

18957
19:14:05,690 --> 19:14:09,170
you can always refer back To the
GitHub repo associated with this

18958
19:14:09,170 --> 19:14:13,580
lesson, as we do have a deploy
script in here, we also have a

18959
19:14:13,580 --> 19:14:16,400
TypeScript edition in here as
well that we're additionally not

18960
19:14:16,400 --> 19:14:19,460
going to go over. And of course,
if you get totally lost, there's

18961
19:14:19,460 --> 19:14:22,940
a ton of instructions in here to
help you learn more and help you

18962
19:14:22,940 --> 19:14:25,190
work with this specific
repository.

18963
19:14:27,950 --> 19:14:31,760
So let's do a quick review of
what we just learned. So ERC 20

18964
19:14:31,760 --> 19:14:37,160
tokens, or EIP 20 tokens or or b
p or p p, or any of these dash

18965
19:14:37,160 --> 19:14:41,960
20. Improvement proposals are
what's known as the token

18966
19:14:41,990 --> 19:14:45,050
standard. And the token
standard, these tokens on chain

18967
19:14:45,080 --> 19:14:48,380
actually just tokens that are
smart contracts. Now, these

18968
19:14:48,380 --> 19:14:51,350
tokens are obviously different
than the layer one tokens like

18969
19:14:51,380 --> 19:14:55,280
Aetherium, or polygon or
Avalanche or arbitration, those

18970
19:14:55,280 --> 19:14:57,200
are not going to be smart
contracts, those are going to be

18971
19:14:57,200 --> 19:15:00,350
blockchain native tokens, and
you'll hear me refer to it as

18972
19:15:00,350 --> 19:15:04,550
blockchain native tokens a lot.
versus these tokens, these ERC

18973
19:15:04,550 --> 19:15:08,240
20, these smart contract tokens,
which are just smart contracts.

18974
19:15:08,300 --> 19:15:10,310
And they're just kind of a
combination of these functions

18975
19:15:10,310 --> 19:15:14,810
that represent how many tokens
each address has, we can create

18976
19:15:14,840 --> 19:15:19,070
our own token with all the
specifications added. Or we can

18977
19:15:19,070 --> 19:15:22,430
just use openzeppelin to import
a token in now another popular

18978
19:15:22,430 --> 19:15:25,730
repo like open Zeppelin is going
to be this one from Rory capital

18979
19:15:25,730 --> 19:15:29,150
called soulmate. And they're
both aimed to be standard

18980
19:15:29,150 --> 19:15:32,060
libraries for solidity. And one
of the important things to keep

18981
19:15:32,060 --> 19:15:35,660
in mind is that these tokens
have this allowance mapping. And

18982
19:15:35,660 --> 19:15:39,170
you can allow other addresses to
have access to your tokens and

18983
19:15:39,170 --> 19:15:42,290
move your tokens around. This is
important, especially when we

18984
19:15:42,290 --> 19:15:45,590
get to later on when working
with defy when we want to give

18985
19:15:45,590 --> 19:15:48,410
some smart contract access to
our tokens so that they can

18986
19:15:48,440 --> 19:15:51,140
input it into their defy
protocol. It's also a little bit

18987
19:15:51,140 --> 19:15:54,350
tricky. And you want to make
sure you're not allowing

18988
19:15:54,410 --> 19:15:58,040
malicious contracts to interact
with your tokens. And we'll also

18989
19:15:58,040 --> 19:16:01,220
see that when we start to
interact with these tokens more

18990
19:16:01,400 --> 19:16:04,550
before any contract can interact
with our tokens, we need to

18991
19:16:04,580 --> 19:16:07,760
approve them to interact with
our tokens. And that's it. Now

18992
19:16:07,760 --> 19:16:10,550
you're a token wizard, and you
can deploy your own tokens. Take

18993
19:16:10,550 --> 19:16:13,220
a break, get that coffee, and
I'll see you in the next one.

18994
19:16:18,770 --> 19:16:22,430
All right, welcome to the next
session, we are going to be

18995
19:16:22,430 --> 19:16:24,890
learning about defy in this
session and going to be

18996
19:16:24,890 --> 19:16:28,370
programmatic, and going to be
programmatically interacting

18997
19:16:28,370 --> 19:16:31,700
with the defy protocol. I am
incredibly excited for you for

18998
19:16:31,700 --> 19:16:35,450
this session, because defi is
one of the best use cases for

18999
19:16:35,450 --> 19:16:38,960
smart contracts. And one of the
use cases that I am specifically

19000
19:16:39,170 --> 19:16:43,010
most excited for now, as I've
mentioned, the past defy stands

19001
19:16:43,010 --> 19:16:46,760
for decentralized finance, we've
left some links in the GitHub

19002
19:16:46,760 --> 19:16:50,360
repository for you to learn more
about Defy. One of the main

19003
19:16:50,360 --> 19:16:53,630
reasons we're so excited about
defy is because we move away

19004
19:16:53,630 --> 19:16:56,000
from this area of traditional
agreement. And that's what smart

19005
19:16:56,000 --> 19:16:59,510
contracts are all about. They're
about removing this centralized

19006
19:16:59,510 --> 19:17:03,590
entity, from our financial
world, and especially from these

19007
19:17:03,590 --> 19:17:06,290
financial institutions that have
a conflict of interest. They're

19008
19:17:06,290 --> 19:17:08,870
in business to make money not to
keep our money safe not to make

19009
19:17:08,900 --> 19:17:12,620
us money. And we want to work
with a system where everything

19010
19:17:12,620 --> 19:17:15,800
is transparent, especially when
it comes to our financial

19011
19:17:15,800 --> 19:17:19,640
services. So we want to move to
this world of smart contracts,

19012
19:17:19,670 --> 19:17:22,550
especially when it comes to our
money. And in my mind, defi is

19013
19:17:22,550 --> 19:17:26,840
going to be the industry that
affects the masses, the quickest

19014
19:17:26,930 --> 19:17:29,690
because of how much fair how
much better decentralized

19015
19:17:29,690 --> 19:17:33,230
finance is than centralized
finance. And at the moment, the

19016
19:17:33,230 --> 19:17:36,200
rates and the yields and the
interest that you gain in defy

19017
19:17:36,200 --> 19:17:39,260
is much better than centralized
finance, because remember, will

19018
19:17:39,260 --> 19:17:41,930
go away from these centralized
protocols, saying, hey, trust

19019
19:17:41,930 --> 19:17:45,620
us, we'll give you access to the
markets or hate trust us put

19020
19:17:45,620 --> 19:17:49,310
your money in us will keep your
money safe to this cryptographic

19021
19:17:49,310 --> 19:17:52,700
math base guarantees instead of
having to trust these companies

19022
19:17:52,700 --> 19:17:55,490
and these entities, which is
what we want. And additionally,

19023
19:17:55,520 --> 19:17:58,610
the more our Oracle networks get
better, and the more Oracle's

19024
19:17:58,610 --> 19:18:00,740
networks work with these smart
contract platforms like

19025
19:18:00,740 --> 19:18:03,830
Aetherium, like polygon, like
arbitrage them, the more data

19026
19:18:03,830 --> 19:18:06,770
and the more complex financial
products that we can do. Now,

19027
19:18:06,770 --> 19:18:10,910
one of the other reasons I'm so
crazy excited about defy is if

19028
19:18:10,910 --> 19:18:13,310
you look at this little chart
right here, it shows the

19029
19:18:13,310 --> 19:18:16,910
different markets by size. Now
this this image is a little bit

19030
19:18:16,910 --> 19:18:19,640
outdated, but it still shows you
the relative sizes of all these

19031
19:18:19,640 --> 19:18:24,710
different industries defy right
now is a $200 billion market,

19032
19:18:24,770 --> 19:18:27,770
there's about $200 billion
locked in the defy industry. And

19033
19:18:27,770 --> 19:18:30,620
I'll show you that in a minute.
Cryptocurrency actually, at the

19034
19:18:30,620 --> 19:18:34,940
time of recording isn't 360
billion. It's actually like 1.8

19035
19:18:35,270 --> 19:18:38,120
trillion. So it's a lot more
than this. But still, it's a

19036
19:18:38,120 --> 19:18:42,290
massive subset of all these
other areas like gold is a $10

19037
19:18:42,290 --> 19:18:45,890
trillion market. The stock
market is almost $100 trillion

19038
19:18:46,640 --> 19:18:50,090
global real estate, almost $300
trillion derivatives as

19039
19:18:50,300 --> 19:18:55,490
quadrillion dollars. So the FBI
is a super tiny, tiny, tiny,

19040
19:18:55,490 --> 19:18:59,810
tiny subset right now and in my
mind, all of these areas can be

19041
19:18:59,810 --> 19:19:03,800
re landscaped with Defy. So
we're ramping up, we're getting

19042
19:19:03,800 --> 19:19:06,680
there. So it's gonna be up to us
to make some of these protocols

19043
19:19:06,710 --> 19:19:09,440
and make it Much easier for
people to get into the space

19044
19:19:09,440 --> 19:19:12,470
where their finances are going
to be more fair, more

19045
19:19:12,470 --> 19:19:15,800
accountable and more
transparent. And with better

19046
19:19:15,800 --> 19:19:19,370
yield rates, we can actually see
a pretty good summary of what's

19047
19:19:19,370 --> 19:19:23,390
going on in defy this site
called defy llama. It shows

19048
19:19:23,630 --> 19:19:27,710
total value locked in all these
different decentralized

19049
19:19:27,710 --> 19:19:31,760
protocols. And we can see a lot
of these are across multiple

19050
19:19:31,760 --> 19:19:34,520
chains, right. And a lot of
these are EVM compatible chains,

19051
19:19:34,940 --> 19:19:39,440
Aetherium, Biden, smart chain,
avalanche, Fanta, drawn polygon,

19052
19:19:39,740 --> 19:19:43,370
all these are EVM, compatible
blockchains, where we can see

19053
19:19:43,520 --> 19:19:46,760
exactly how much money
independent users have put into

19054
19:19:46,760 --> 19:19:50,090
these protocols. The time of
recording Ave is the number one

19055
19:19:50,090 --> 19:19:54,830
protocol for total value locked.
So there's $22 billion locked in

19056
19:19:54,860 --> 19:19:57,470
Ave, which is the protocol that
we're going to be going over

19057
19:19:57,470 --> 19:19:57,830
today.

19058
19:20:00,560 --> 19:20:04,550
So what is Ave So are they is a
borrowing and lending protocol,

19059
19:20:04,580 --> 19:20:07,580
it allows us to borrow and lend
cryptocurrencies. So we can

19060
19:20:07,580 --> 19:20:10,430
actually put down a token as
collateral, it's kind of similar

19061
19:20:10,430 --> 19:20:14,210
to like putting money in a bank,
and earn yields on other people

19062
19:20:14,210 --> 19:20:17,540
borrowing that collateral from
us almost exactly what a bank

19063
19:20:17,540 --> 19:20:21,410
does, except for the fact it's
what's called noncustodial. To

19064
19:20:21,410 --> 19:20:24,140
the Ave team never touches our
money. Nobody ever touches the

19065
19:20:24,140 --> 19:20:27,170
money. It's all just a smart
contract. It's all just this

19066
19:20:27,170 --> 19:20:30,200
programmatic code. So we can be
rest assured, no one's going to

19067
19:20:30,200 --> 19:20:33,020
run off with our money, no one's
going to do anything bad. And we

19068
19:20:33,020 --> 19:20:35,870
also gain these higher yields.
borrowing and lending is a

19069
19:20:35,870 --> 19:20:39,410
critical piece for creating
really any interesting financial

19070
19:20:39,410 --> 19:20:42,140
applications. If you want to
short sell something, if you

19071
19:20:42,140 --> 19:20:44,900
want to leverage up on some
asset if you want to. If you

19072
19:20:44,900 --> 19:20:48,200
want to do more complex
financial products, you need

19073
19:20:48,200 --> 19:20:51,200
borrowing and lending. Now a lot
of the typical FinTech or

19074
19:20:51,200 --> 19:20:55,070
financial technology or finance
terms do apply here. And this

19075
19:20:55,070 --> 19:20:58,100
course isn't going to be a deep
dive into exactly how these

19076
19:20:58,100 --> 19:21:00,980
financial products work. And
it's also not going to be a

19077
19:21:00,980 --> 19:21:03,590
course on finance. If you want
to learn more about finance,

19078
19:21:03,620 --> 19:21:06,410
we'll leave a number of links in
our GitHub repo associated with

19079
19:21:06,410 --> 19:21:09,200
this course. So you can learn
more about finance and become

19080
19:21:09,230 --> 19:21:12,680
what I like to call a defy
quant, quantitative defy

19081
19:21:12,680 --> 19:21:15,650
engineer. And I am so excited
for more defi quants to get into

19082
19:21:15,650 --> 19:21:19,670
this space. Alright, so here we
are in the Ave application. It's

19083
19:21:19,670 --> 19:21:22,340
at testament dot Ave dot
markets, we are in the testament

19084
19:21:22,370 --> 19:21:24,380
of Avi now, everything that
we're going to do here is going

19085
19:21:24,380 --> 19:21:27,050
to work on Main net as well, but
we're going to use it on their

19086
19:21:27,050 --> 19:21:30,500
test net. Now this is actually
obvious older UI, and they have

19087
19:21:30,500 --> 19:21:33,440
a new website that looks even
better than this. But we're

19088
19:21:33,440 --> 19:21:35,570
going to be going through a lot
of the basic functionality

19089
19:21:35,630 --> 19:21:38,570
depositing taking out a loan,
potentially even shorting an

19090
19:21:38,570 --> 19:21:41,240
asset, if we want, I don't
recommend going to the site

19091
19:21:41,240 --> 19:21:43,640
because it might not work and
COVID the way you'd expect it

19092
19:21:43,640 --> 19:21:46,700
to. So for this, just sit back,
relax and watch. In order for us

19093
19:21:46,700 --> 19:21:49,490
to actually short sell or margin
trade. The first thing that

19094
19:21:49,490 --> 19:21:51,740
we're going to need to do is
actually deposit some

19095
19:21:51,740 --> 19:21:54,290
collateral, we need to deposit
some collateral in order to

19096
19:21:54,290 --> 19:21:57,320
borrow this way. If we never
repay back the loan that we took

19097
19:21:57,320 --> 19:21:59,990
out or the the amount that we
borrowed, Ave, we'll just go

19098
19:21:59,990 --> 19:22:02,240
ahead and take the collateral
that we put in here, we'll do

19099
19:22:02,240 --> 19:22:04,370
what's called a liquidation
call. And that's why this is

19100
19:22:04,370 --> 19:22:06,740
actually a little bit safer than
short selling in traditional

19101
19:22:06,740 --> 19:22:10,220
markets. Because if your
collateral is less than how much

19102
19:22:10,220 --> 19:22:12,410
you have borrowed, you'll just
immediately get liquidated, but

19103
19:22:12,410 --> 19:22:15,320
you still lose a bunch of money
so like don't get liquidated. So

19104
19:22:15,320 --> 19:22:17,990
what we want to do now is we're
gonna scroll to Aetherium, we're

19105
19:22:17,990 --> 19:22:21,110
going to connect our wallet
here, we're going to move to

19106
19:22:21,230 --> 19:22:26,120
COVID test network browser here.
And we're gonna go to this

19107
19:22:26,120 --> 19:22:29,420
deposit piece. So it already
shows our balance here we have

19108
19:22:29,420 --> 19:22:32,720
point two COVID eath. Let's
deposit 0.1.

19109
19:22:34,940 --> 19:22:39,170
We're gonna hit deposit Metamask
can pop up, confirm. But once

19110
19:22:39,170 --> 19:22:41,870
this goes through, this means
that we've have it deposited and

19111
19:22:41,870 --> 19:22:45,320
we go to our dashboard, we can
see we have some eath here,

19112
19:22:45,350 --> 19:22:49,040
point one eath got some API,
this is kind of like that

19113
19:22:49,040 --> 19:22:51,680
percentage return that we're
gonna get back for, for

19114
19:22:51,680 --> 19:22:55,880
depositing into Ave. And yes, we
can use it as collateral here,

19115
19:22:55,970 --> 19:22:59,090
we have this, this marked as yes
here. So that's exactly what

19116
19:22:59,090 --> 19:23:02,030
we're going to do. And it says
nothing borrowed. Yep, we can go

19117
19:23:02,030 --> 19:23:04,730
ahead and hit this borrow now
button. And we're gonna get

19118
19:23:04,730 --> 19:23:07,340
brought to the borrower screen,
and we're going to choose which

19119
19:23:07,340 --> 19:23:10,940
asset we want to borrow. Now,
whenever we borrow one of these,

19120
19:23:11,180 --> 19:23:15,590
there are these API's, right?
This is the percentage that over

19121
19:23:15,620 --> 19:23:17,960
the course of a year that we're
gonna have to pay, in order to

19122
19:23:17,960 --> 19:23:20,690
actually borrow this asset. The
stable one means it'll always be

19123
19:23:20,690 --> 19:23:23,900
for or variable means it
actually changes depending on

19124
19:23:23,900 --> 19:23:27,950
kind of how much liquidity the
protocol has, you can kind of

19125
19:23:27,980 --> 19:23:30,830
pick which one you want to do
stable is you're always gonna be

19126
19:23:30,830 --> 19:23:33,920
a 4% variable is going to be a
little bit riskier, but you

19127
19:23:33,920 --> 19:23:36,650
might get a lower fee. So we're
actually going to borrow some

19128
19:23:36,650 --> 19:23:40,640
dye right, because dye is a
stable coin. It's worth $1. In a

19129
19:23:40,640 --> 19:23:43,550
way, you could call this taking
out on margin because we're

19130
19:23:43,550 --> 19:23:46,820
taking out dye to borrow and
another way we could say we're

19131
19:23:46,820 --> 19:23:49,880
shorting dye which is kind of
funny to think about, but you

19132
19:23:49,880 --> 19:23:52,460
get to choose how much you want
to borrow here and you'll see

19133
19:23:52,460 --> 19:23:54,350
this this thing called Health
factor I'm going to zoom in a

19134
19:23:54,350 --> 19:23:56,990
little bit this thing called
Health factor here as we as we

19135
19:23:56,990 --> 19:24:00,740
scroll this thing. So this
health factor is how close to

19136
19:24:00,740 --> 19:24:03,260
being liquidated you are
remember how I said you can get

19137
19:24:03,260 --> 19:24:06,380
liquidated this health factor
represents how close we are to

19138
19:24:06,380 --> 19:24:08,660
getting liquidated. This means
means how close we are to always

19139
19:24:08,660 --> 19:24:12,140
saying, You know what fu we're
taking your funds. If it goes

19140
19:24:12,140 --> 19:24:15,500
below one at any time, somebody
can liquidate you and take a lot

19141
19:24:15,500 --> 19:24:18,080
of that deposit that we put in,
there's some math behind

19142
19:24:18,110 --> 19:24:21,350
actually what the health factor
actually is, you can head over

19143
19:24:21,350 --> 19:24:24,860
to the Ave documentation, which
I will leave a link in the

19144
19:24:24,860 --> 19:24:27,050
description to kind of read more
about the health factor. So

19145
19:24:27,050 --> 19:24:30,170
we're going to borrow 29 die
we're buying, we're borrowing

19146
19:24:30,170 --> 19:24:33,980
basically 30 bucks. Gonna hit
continue, I'm gonna do a

19147
19:24:33,980 --> 19:24:37,370
variable, zoom back out,
continue, we're gonna borrow

19148
19:24:37,760 --> 19:24:41,540
metamath pops up, confirm
transaction that's pending. And

19149
19:24:41,540 --> 19:24:44,000
we're gonna go to the dashboard.
And now we can see kind of our

19150
19:24:44,000 --> 19:24:47,630
new balance here, right, we can
see the point one eath,

19151
19:24:48,200 --> 19:24:52,970
deposited and 29 die. And we can
see our health factor up here,

19152
19:24:53,000 --> 19:24:55,310
you can even click this little
button, saying, hey, it

19153
19:24:55,310 --> 19:24:59,390
represents how close you are to
being liquidated, we can see the

19154
19:24:59,390 --> 19:25:03,200
value here, our eath is worth
like $200, or die is worth 30

19155
19:25:03,200 --> 19:25:05,930
bucks. So we're good. We're
pretty healthy here. In order

19156
19:25:05,930 --> 19:25:09,200
for Avi to understand and under
to price the underlying

19157
19:25:09,200 --> 19:25:12,110
collateral, so it knows how much
it can lend out. Obviously

19158
19:25:12,140 --> 19:25:15,170
another one of these protocols
that uses changing price feeds

19159
19:25:15,260 --> 19:25:17,870
to price, the underlying
collateral, many of these

19160
19:25:17,870 --> 19:25:21,170
billion dollar defy protocols
use chain link on the back end

19161
19:25:21,380 --> 19:25:24,200
to do all their pricing
mechanisms. And that's

19162
19:25:24,230 --> 19:25:27,560
essentially it, we could then
repay our debts, we could borrow

19163
19:25:27,560 --> 19:25:30,860
more assets, we could swap
assets around. And the interest

19164
19:25:30,860 --> 19:25:35,210
return, we get onto pausing our
assets is amazing. So now that

19165
19:25:35,210 --> 19:25:38,330
we learned a little bit about
how to use their UI, which is

19166
19:25:38,330 --> 19:25:41,750
hosted on IPFS, by the way,
let's go ahead and let's learn

19167
19:25:41,750 --> 19:25:45,200
how to do all this and do even
more programmatically so we can

19168
19:25:45,200 --> 19:25:47,510
become defy quanta engineers.

19169
19:25:50,210 --> 19:25:53,090
Now, like I said, we're going to
be working with the Ave v two

19170
19:25:53,090 --> 19:25:56,840
protocol, if you want to try out
the v3, you absolutely can, if

19171
19:25:56,840 --> 19:25:59,090
you can go there and play with
it right now, it still has more

19172
19:25:59,090 --> 19:26:01,760
money locked in it, which is
great. But the v3 protocol is

19173
19:26:01,760 --> 19:26:04,310
obviously the latest addition.
So we're gonna be flipping back

19174
19:26:04,310 --> 19:26:06,410
and forth between the
documentation and our code base.

19175
19:26:06,440 --> 19:26:09,170
So I recommend that you have the
documentation up as well. And

19176
19:26:09,170 --> 19:26:11,630
per usual, all of the code that
we're going to be working with

19177
19:26:11,660 --> 19:26:15,980
is in this hard hat defi Free
Code Camp repository. So let's

19178
19:26:15,980 --> 19:26:19,850
jump in. I'm in by VS code, I'm
in my folder with this course,

19179
19:26:19,880 --> 19:26:21,770
we're going to make a new
folder, we're going to call it

19180
19:26:21,770 --> 19:26:26,480
hard hat, defy FCC, we're going
to cd into it. And then we're

19181
19:26:26,480 --> 19:26:30,170
going to open it up with code
period. Or you can also do per

19182
19:26:30,170 --> 19:26:34,370
usual, File Open and then open
that folder. Now we're in a new

19183
19:26:34,370 --> 19:26:38,450
project, we're going to do yarn,
add dash dash Dev, aren't hat.

19184
19:26:38,690 --> 19:26:41,540
And we're going to add hard hat
and start up our minimalistic

19185
19:26:41,540 --> 19:26:43,490
hard hat project. Once again,
for starting up your

19186
19:26:43,490 --> 19:26:45,860
minimalistic hard hat projects,
I usually just copy paste from

19187
19:26:45,860 --> 19:26:48,890
another folder, or I just used
that hard hat starter kit that

19188
19:26:48,890 --> 19:26:51,860
we saw in the smart contract
code repo. But whatever works

19189
19:26:51,860 --> 19:26:54,260
best for you to get your project
started, you can use now that

19190
19:26:54,260 --> 19:26:58,010
we've got this, we can run yarn
hardhat. And we'll just create

19191
19:26:58,010 --> 19:27:01,190
an empty hardhat.config.js. Now
to save us some boilerplate

19192
19:27:01,190 --> 19:27:05,180
time, I am going to copy paste
my hard hat.config.js from a

19193
19:27:05,180 --> 19:27:07,880
past project into this one, just
to make it so we don't have to

19194
19:27:07,880 --> 19:27:10,310
go through that boilerplate
setup again. And I'm also going

19195
19:27:10,310 --> 19:27:13,010
to copy paste this line from our
heart at smart contract lottery.

19196
19:27:13,010 --> 19:27:15,590
Again, if you want to use your
package JSON or your yarn dot

19197
19:27:15,590 --> 19:27:18,890
lock to install dependencies,
you absolutely can. But I'm just

19198
19:27:18,890 --> 19:27:22,250
going to paste that in here and
run it. And then I'm going to

19199
19:27:22,250 --> 19:27:26,030
copy paste over my prettier
files, so that all my JavaScript

19200
19:27:26,030 --> 19:27:28,790
can be formatted the way I want
it to be. Okay, great. Now we

19201
19:27:28,790 --> 19:27:31,190
have a minimalistic project spun
up, let's go ahead and get

19202
19:27:31,190 --> 19:27:33,980
started learning how to interact
with the AVI protocol here. So

19203
19:27:33,980 --> 19:27:36,200
let's make a quick readme and
talk about what we want to be

19204
19:27:36,200 --> 19:27:38,540
able to do. So first, we're
going to want to be able to

19205
19:27:38,540 --> 19:27:42,350
learn how to programmatically
deposit collateral. And if we

19206
19:27:42,350 --> 19:27:44,810
stopped right there, that might
be enough, we'd be able to

19207
19:27:44,810 --> 19:27:47,870
programmatically deposit
collateral, and in doing so we

19208
19:27:47,900 --> 19:27:51,230
earn yield, we'd earn that
percentage return just on our

19209
19:27:51,230 --> 19:27:54,770
deposited collateral. So
accomplishing this by itself is

19210
19:27:54,770 --> 19:27:57,650
already a feat. But let's say we
want to go one step further, we

19211
19:27:57,650 --> 19:28:00,590
want to get into these more
interesting financial products.

19212
19:28:00,770 --> 19:28:03,590
So after we deposit some
collateral, we're going to learn

19213
19:28:03,590 --> 19:28:07,040
how to programmatically borrow
and other asset, the deposited

19214
19:28:07,040 --> 19:28:10,340
collateral is going to be eath,
slash wrapped eath, which we'll

19215
19:28:10,340 --> 19:28:12,890
talk about in a little bit,
we're going to borrow another

19216
19:28:12,890 --> 19:28:16,310
asset, which for this demo is
going to be dye. And the reason

19217
19:28:16,310 --> 19:28:19,460
that we're using dye is because
dye is what's known as a stable

19218
19:28:19,460 --> 19:28:23,000
coin. So dye is actually a token
on the blockchain created by

19219
19:28:23,000 --> 19:28:26,600
this maker Dow where the price
of the dye token is always

19220
19:28:26,600 --> 19:28:30,290
pegged to $1. So we're putting
down eath as collateral and

19221
19:28:30,290 --> 19:28:33,680
we're borrowing cryptocurrency,
US dollars, sort of, we're

19222
19:28:33,680 --> 19:28:36,740
borrowing this token, which
represents a US dollar and then

19223
19:28:36,740 --> 19:28:40,100
we'll just repay that I will
repay almost everything back and

19224
19:28:40,100 --> 19:28:43,130
you'll see why we don't repay
everything back in a minute. One

19225
19:28:43,130 --> 19:28:45,440
other protocol that I want to
talk about quickly is the

19226
19:28:45,440 --> 19:28:48,680
uniswap protocol. And the
uniswap protocol has become this

19227
19:28:48,710 --> 19:28:52,760
haven for trading. It's a
decentralized application that

19228
19:28:52,760 --> 19:28:56,660
allows us to trade assets and
tokens with each other on

19229
19:28:56,660 --> 19:29:00,020
something called an automated
market maker. It ends basically

19230
19:29:00,020 --> 19:29:02,960
a decentralized Stock Exchange,
but with tokens and again,

19231
19:29:02,990 --> 19:29:05,900
tokens aren't exactly stocks,
they're very different. So when

19232
19:29:05,900 --> 19:29:08,540
looking to get some of these
assets It's like wrapped

19233
19:29:08,540 --> 19:29:12,830
Aetherium or dye or link token.
On a main net, oftentimes,

19234
19:29:12,830 --> 19:29:15,680
you're going to use one of these
decentralized exchanges. And

19235
19:29:15,680 --> 19:29:18,260
obviously, these decentralized
exchanges are much fairer,

19236
19:29:18,410 --> 19:29:21,590
because everything that happens
on them is transparent, much

19237
19:29:21,590 --> 19:29:24,590
fairer than centralized finance,
everything that happens on them

19238
19:29:24,590 --> 19:29:27,920
is transparent. You can see
everything that's going on on

19239
19:29:27,920 --> 19:29:31,100
chain, which is absolutely
phenomenal. So let's go ahead

19240
19:29:31,100 --> 19:29:34,160
and get started here. And let's
just create our scripts folder.

19241
19:29:34,190 --> 19:29:36,590
Because in this project, we're
actually not going to create any

19242
19:29:36,590 --> 19:29:39,410
contracts ourselves, we're just
going to learn how to interact

19243
19:29:39,410 --> 19:29:41,990
with these protocols. If you do
want to learn how to build some

19244
19:29:41,990 --> 19:29:45,230
of these protocols, at the end
of this session, we will give

19245
19:29:45,230 --> 19:29:48,620
you a ton of links. And we'll
have a special guest explain a

19246
19:29:48,650 --> 19:29:50,660
few different ways to learn how
to build more of these

19247
19:29:50,660 --> 19:29:53,390
decentralized protocols.
Although we've already built one

19248
19:29:53,420 --> 19:29:56,210
with our decentralized lottery,
which is fantastic. Let's create

19249
19:29:56,210 --> 19:29:59,030
some scripts here. And for all
of these things, deposit

19250
19:29:59,030 --> 19:30:02,210
collateral, borrow and repay.
We'll just put this all in a new

19251
19:30:02,210 --> 19:30:06,170
script called Ave borrow dot
Jas. So we're gonna do

19252
19:30:06,200 --> 19:30:09,500
everything in here. And since
this is a script, it's going to

19253
19:30:09,500 --> 19:30:12,290
have the same setup, as we've
seen before, right, so we're

19254
19:30:12,290 --> 19:30:17,660
gonna have this main thing
around an async function. Main,

19255
19:30:17,900 --> 19:30:20,690
and then we'll have our imports,
of course at the top. Now

19256
19:30:20,690 --> 19:30:23,360
something that's important to
note, go to avi, we go to the

19257
19:30:23,360 --> 19:30:26,180
protocol, we kind of read
through the docs, and eventually

19258
19:30:26,180 --> 19:30:32,180
we would find out the protocol
treats everything as an ERC 20

19259
19:30:32,180 --> 19:30:35,900
token. And but we know that
Aetherium or the native

19260
19:30:35,900 --> 19:30:39,890
blockchain token that you're
using, isn't an ERC 20 token.

19261
19:30:40,190 --> 19:30:42,440
And the reason that treats
everything like an ERC 20 token

19262
19:30:42,440 --> 19:30:45,110
is that it's just much easier,
right? If everything's using

19263
19:30:45,110 --> 19:30:48,440
this ERC 20 token standard, it's
much easier to send in and

19264
19:30:48,440 --> 19:30:49,340
interact with stuff.

19265
19:30:52,100 --> 19:30:55,220
On a lot of these protocols,
when we go to deposit Aetherium,

19266
19:30:55,220 --> 19:30:58,880
or polygon, or arbitrary marks
cetera, what actually happens is

19267
19:30:58,880 --> 19:31:01,820
they send your Aetherium through
like what's called a web

19268
19:31:01,850 --> 19:31:07,370
gateway, and swaps it for weath,
which stands for rapt ether. And

19269
19:31:07,370 --> 19:31:12,080
it's basically Aetherium. But in
an ERC 20 token contract, so

19270
19:31:12,080 --> 19:31:14,780
what we want to do is going to
do that same thing, we're gonna

19271
19:31:14,780 --> 19:31:18,020
skip kind of using this web
gateway. And we'll just get the

19272
19:31:18,020 --> 19:31:21,410
Web Token ourselves, and we'll
use that as collateral. So in

19273
19:31:21,410 --> 19:31:25,700
our script tag, I'm going to
make another file called Get

19274
19:31:25,700 --> 19:31:29,960
weath.js. And in here, we're
actually going to go ahead, and

19275
19:31:29,960 --> 19:31:34,490
we're going to build a script
that will deposit our token for

19276
19:31:34,490 --> 19:31:37,430
web token. Okay, so let's create
the script. And there's a link

19277
19:31:37,430 --> 19:31:40,640
to the web token on ether scan,
and on Main net in the GitHub

19278
19:31:40,640 --> 19:31:44,360
repo. And the way it works, is
you actually deposit Aetherium.

19279
19:31:44,570 --> 19:31:47,900
And in return, it'll give you
the web token on Rigby right

19280
19:31:47,900 --> 19:31:53,270
now, by deposit 0.05. Go ahead
and write I'm connected to ether

19281
19:31:53,270 --> 19:31:55,550
scan, I'll go ahead and write
this transaction, I'm gonna

19282
19:31:55,550 --> 19:31:58,340
drink pee. So I don't really
care if it's if it's the actual

19283
19:31:58,340 --> 19:32:01,130
contract or not, because it's
not real money. But I'm going to

19284
19:32:01,130 --> 19:32:05,210
deposit 0.05 eath. And after our
transaction goes through, we

19285
19:32:05,210 --> 19:32:08,570
copy the contract address, we
add this token to our Metamask

19286
19:32:08,600 --> 19:32:12,020
the same way we added link will
import tokens, paste the address

19287
19:32:12,020 --> 19:32:16,340
in here, add custom token,
import tokens will now see we

19288
19:32:16,340 --> 19:32:21,710
have some wet token in here, I
deposited 0.1 before so 0.1 plus

19289
19:32:21,740 --> 19:32:26,420
0.05, which is why it shows 0.15
Because I did it twice, well,

19290
19:32:26,450 --> 19:32:29,450
while I wasn't recording. So um,
but this is how you can get this

19291
19:32:29,450 --> 19:32:32,990
wet token into your contract.
And then anytime you want, you

19292
19:32:32,990 --> 19:32:35,540
can call this withdrawal
function. And you can withdraw

19293
19:32:35,570 --> 19:32:38,750
your Aetherium out of this and
do what's called Burn your wet

19294
19:32:38,750 --> 19:32:42,620
token. So when you swap back
from weath to Aetherium, you hit

19295
19:32:42,620 --> 19:32:45,290
this withdraw and boom, you
basically swap them back because

19296
19:32:45,290 --> 19:32:49,100
this contract itself right now
is holding your Aetherium token.

19297
19:32:49,160 --> 19:32:52,010
Pretty cool, right? So in our
get wet function, we're not

19298
19:32:52,010 --> 19:32:54,620
going to add this main thing
here, we're going to create get

19299
19:32:54,620 --> 19:32:57,140
West here just as kind of a
module and we're going to import

19300
19:32:57,140 --> 19:33:00,800
it into our Ave borrow. So we're
not going to do this this main

19301
19:33:00,800 --> 19:33:03,170
thing that you see here.
Instead, we're going to create

19302
19:33:03,170 --> 19:33:08,270
an async function called Get
Wes. And then below, we're going

19303
19:33:08,270 --> 19:33:13,940
to export it. So we'll do module
dot exports equals get weath.

19304
19:33:14,240 --> 19:33:18,290
And we're going to export it so
our Avi borrow can use this get

19305
19:33:18,290 --> 19:33:21,410
West script that we're creating
right now, let's add let's go

19306
19:33:21,410 --> 19:33:23,990
ahead and do this. Well, in
order to interact with a

19307
19:33:23,990 --> 19:33:27,170
contract, we're going to need an
account. So we can do const

19308
19:33:27,740 --> 19:33:34,400
deployer equals await get named
accounts, per usual. We'll do

19309
19:33:34,400 --> 19:33:37,220
const get name accounts equals
require hardhat. My VS code

19310
19:33:37,220 --> 19:33:39,920
automatically imported that
thank you VS code now. And now

19311
19:33:39,920 --> 19:33:45,590
we want to call the deposit
function on the west contract.

19312
19:33:46,010 --> 19:33:49,550
How do we call this deposit
function on the west contract?

19313
19:33:49,610 --> 19:33:52,340
Well, how do you call any
contract? Well, what do you

19314
19:33:52,340 --> 19:33:56,210
need? You need the ABI and then
you need the contract address.

19315
19:33:56,300 --> 19:33:59,300
Drill this in. You're always
going to be the API and the

19316
19:33:59,300 --> 19:34:02,180
contract address to interact
with the contract. We know that

19317
19:34:02,180 --> 19:34:04,760
if we give we know that if we
give our project the whole

19318
19:34:04,760 --> 19:34:08,360
contract, it'll get the API but
we also know If we just do the

19319
19:34:08,390 --> 19:34:11,480
interface, that's just as good,
it won't give us all the

19320
19:34:11,480 --> 19:34:14,450
functionality, but it will tell
it will give us the API, it will

19321
19:34:14,450 --> 19:34:18,620
tell our ethers, what functions
it can use. So we're going to

19322
19:34:18,620 --> 19:34:22,130
create a new folder, create our
contracts folder. And in here,

19323
19:34:22,130 --> 19:34:24,170
we're going to create a new
folder inside of that called

19324
19:34:24,200 --> 19:34:27,230
interfaces. And this is where
we're going to create our web

19325
19:34:27,260 --> 19:34:31,010
interface. Now a web interface
is going to be really similar to

19326
19:34:31,040 --> 19:34:34,640
an ERC 20 interface. So if you
want to go ahead and try to add

19327
19:34:34,640 --> 19:34:38,330
it yourself, feel free to do so.
Or what you can just do is you

19328
19:34:38,330 --> 19:34:40,670
can come to the GitHub repo
associated with this lesson,

19329
19:34:41,240 --> 19:34:45,020
come to iOS and just copy paste,
right, you'll see the functions

19330
19:34:45,020 --> 19:34:49,490
in here are exactly the same as
an ERC 20, allowance approved

19331
19:34:49,520 --> 19:34:53,300
balance of decimals named blah,
blah, with these additional

19332
19:34:53,300 --> 19:34:56,450
deposit and withdrawal
functions. So I'm going to copy

19333
19:34:56,450 --> 19:35:00,590
all this, move back over to my
hard hat project, we'll create a

19334
19:35:00,590 --> 19:35:05,570
new file, we'll call I left dot
soul. And just to note,

19335
19:35:05,630 --> 19:35:09,710
oftentimes, a good best practice
is to have interfaces, start

19336
19:35:09,710 --> 19:35:12,740
with eyes so that you know what
to interface and then we'll

19337
19:35:12,740 --> 19:35:16,130
paste it in here. Now in order
for this to compile, we'll need

19338
19:35:16,130 --> 19:35:21,170
to use 0.4 point 19 version of
solidity. So what we can do is

19339
19:35:21,170 --> 19:35:25,850
we can come over to our, our
head.config.js. We have solidity

19340
19:35:25,850 --> 19:35:29,750
compilers, version 0.07, or
whatever versions that you have

19341
19:35:29,750 --> 19:35:32,480
in here, we can add or just
replace. So I'm going to put a

19342
19:35:32,480 --> 19:35:40,400
comma here, version 0.4 point
19. Save. And now in order to

19343
19:35:40,400 --> 19:35:45,200
make sure we can get that API,
do yarn, hardhats compile, or hh

19344
19:35:45,200 --> 19:35:48,800
compiled, and great, we compile
this interface. So now we have

19345
19:35:48,800 --> 19:35:52,160
the ABI to interact with. Now
that we have the ABI, a little

19346
19:35:52,160 --> 19:35:55,250
check mark here, let's go ahead
and get the contract address.

19347
19:35:55,370 --> 19:35:58,250
But for reasons that we're going
to learn about very soon, we're

19348
19:35:58,250 --> 19:36:01,280
actually going to work just with
main net set of getting the

19349
19:36:01,280 --> 19:36:04,610
Rinkeby test and address, I'm
going to look up with main net,

19350
19:36:04,970 --> 19:36:08,900
we're going to find the web
token on Main net. So I'm going

19351
19:36:08,900 --> 19:36:11,900
to copy the address of main net.
And again, you can just grab

19352
19:36:11,900 --> 19:36:15,020
this address from the GitHub
repo associated with this lesson

19353
19:36:15,020 --> 19:36:18,500
as well. And for now, we're
gonna say check a little check

19354
19:36:18,500 --> 19:36:23,000
mark here, and paste the address
there. So now we're have the ABI

19355
19:36:23,000 --> 19:36:25,640
compiled from an interface, and
we have the contract address for

19356
19:36:25,640 --> 19:36:28,850
main net. But let's go ahead and
create this contract now. So we

19357
19:36:28,850 --> 19:36:34,250
can say const, iOS equals await
ethers dot and then we'll need

19358
19:36:34,250 --> 19:36:38,870
to import ethers from Hardhead
as well. Ethers dot get contract

19359
19:36:38,960 --> 19:36:43,130
at this is another one of these
functions on ethers, it allows

19360
19:36:43,130 --> 19:36:46,490
us to get a contract at a
specific address, we'll say get

19361
19:36:46,490 --> 19:36:51,530
contract app, we use the iOS ABI
for now, we'll just hard code

19362
19:36:51,530 --> 19:36:54,200
this address in here. And then
we'll connect it to the

19363
19:36:54,200 --> 19:36:57,950
Deployer. So we're saying let's
get this web contract with the

19364
19:36:57,950 --> 19:37:02,750
ABI of iOS at this address
connected to Deployer. So we

19365
19:37:02,750 --> 19:37:08,300
could go ahead and run await AI
with dot deposit. And we'll set

19366
19:37:08,300 --> 19:37:11,870
value which will be some
amounts. Let's go ahead and at

19367
19:37:11,870 --> 19:37:17,360
the top, we'll say const amount
equals let's do ethers dot utils

19368
19:37:17,360 --> 19:37:24,890
dot parse, ether, and then we'll
do 0.0 0.02. So we'll deposit

19369
19:37:24,920 --> 19:37:30,710
0.02 will say const TX equals
that will do await TX dot wait

19370
19:37:30,740 --> 19:37:33,620
one wait for one block to go
through. And then we'll just get

19371
19:37:33,620 --> 19:37:40,310
the balance will say const. With
balance equals await I with that

19372
19:37:40,340 --> 19:37:44,630
balance of employer. So we're
going to call the balance of

19373
19:37:44,630 --> 19:37:48,440
function on our iWeb ERC 20
token. And then we'll just do

19374
19:37:48,440 --> 19:37:54,980
console dot log got West
balance.to string.

19375
19:37:56,389 --> 19:37:59,209
So we're using the main net
address in here. And we're gonna

19376
19:37:59,209 --> 19:38:01,609
say okay, we're going to deposit
some amount, we're going to

19377
19:38:01,609 --> 19:38:04,459
wait. And then we're gonna go
ahead and get the balance right,

19378
19:38:04,459 --> 19:38:07,099
so we're just depositing our
Aetherium so that we can get

19379
19:38:07,099 --> 19:38:11,119
that ERC 20 version of
Aetherium, that West token here.

19380
19:38:13,760 --> 19:38:16,580
Now, you might be thinking,
Okay, why are you putting the

19381
19:38:16,580 --> 19:38:19,940
main address in here? Let's
Patrick, slow down. Let's go

19382
19:38:19,940 --> 19:38:23,120
ahead and let's create a mock
Web Token contract address.

19383
19:38:23,240 --> 19:38:27,050
Let's deploy the mocks first,
and then we'll go ahead and use

19384
19:38:27,050 --> 19:38:29,600
that same setup that we've been
doing this whole time, why you

19385
19:38:29,630 --> 19:38:32,630
why you directly hard coding
this in here. Well, I've been

19386
19:38:32,630 --> 19:38:36,110
alluding to this for some time.
But there's another way that we

19387
19:38:36,110 --> 19:38:39,080
can run tests in our smart
contracts. And this is with

19388
19:38:39,080 --> 19:38:42,050
something called main net
forking, we can actually do

19389
19:38:42,050 --> 19:38:46,550
something where we fork the main
net, and run a local hard hat

19390
19:38:46,550 --> 19:38:51,170
node. That's pretending to be a
main net node. And all we have

19391
19:38:51,170 --> 19:38:55,250
to do is update our hard head
config to do so. So let's talk

19392
19:38:55,250 --> 19:38:58,190
about forking for a minute. So
on the left here, we have a

19393
19:38:58,190 --> 19:39:00,770
blockchain an example of
blockchain it's going to be

19394
19:39:00,770 --> 19:39:05,300
something similar to a test net
or main net like Rinkeby, eath,

19395
19:39:05,300 --> 19:39:09,650
main net polygon etc. This is
going to be a blockchain that we

19396
19:39:09,650 --> 19:39:12,290
deploy to. Now there are a whole
bunch of blocks in here, right?

19397
19:39:12,500 --> 19:39:15,470
We have this huge chain that we
can work with. And all this

19398
19:39:15,470 --> 19:39:18,530
information on the blockchain is
public information, like this

19399
19:39:18,530 --> 19:39:21,710
block is going to have
transaction transaction

19400
19:39:22,130 --> 19:39:25,310
transaction, each one of these
blocks is going to have a whole

19401
19:39:25,310 --> 19:39:28,400
bunch of transactions. And all
this information is on this

19402
19:39:28,400 --> 19:39:31,670
public blockchain. In addition
to all these transactions, it's

19403
19:39:31,670 --> 19:39:34,310
going to have things like price
feed contracts, it's going to

19404
19:39:34,310 --> 19:39:37,730
have things like Ave contract,
the Web token, contract, etc.

19405
19:39:37,850 --> 19:39:42,380
All this contract information is
public. So hypothetically, if

19406
19:39:42,380 --> 19:39:46,910
it's already there, we should be
basically able to copy this to

19407
19:39:46,910 --> 19:39:50,720
our local environment and do
some simulations ourselves. And

19408
19:39:50,720 --> 19:39:54,320
that's exactly what forking
does. A fork blockchain

19409
19:39:54,500 --> 19:39:58,160
literally takes a copy of an
existing blockchain like on the

19410
19:39:58,160 --> 19:40:02,150
left here and brings it on our
local computer. We actually have

19411
19:40:02,150 --> 19:40:05,180
control over our blockchain
that's running locally, because

19412
19:40:05,180 --> 19:40:08,390
it's gonna run on a local
computer, similar to hard hat.

19413
19:40:08,480 --> 19:40:12,530
Now, everything we do on this
local forked blockchain is not

19414
19:40:12,530 --> 19:40:15,140
going to affect main them,
because it's a simulated

19415
19:40:15,140 --> 19:40:18,590
blockchain. It's just running in
our local environment. So we can

19416
19:40:18,590 --> 19:40:21,260
actually interact with this
forking this kind of local

19417
19:40:21,260 --> 19:40:24,650
blockchain that resembles that
mimics the actual blockchain.

19418
19:40:24,830 --> 19:40:27,080
And here's what forking doesn't
do, it doesn't download the

19419
19:40:27,080 --> 19:40:30,500
entire blockchain into our local
setup. Anytime we reference an

19420
19:40:30,500 --> 19:40:33,320
address. Anytime we reference,
hey, there's something at a

19421
19:40:33,320 --> 19:40:37,730
specific address, we make an API
call to our Aetherium node,

19422
19:40:37,760 --> 19:40:41,570
which again, we're using alchemy
and say, hey, oh, what's at this

19423
19:40:41,570 --> 19:40:45,200
address, and it'll return just
that specific contract for us.

19424
19:40:45,290 --> 19:40:47,270
This way, we don't have to
download the whole blockchain.

19425
19:40:47,270 --> 19:40:50,270
And it's a lot quicker. And we
can also do this forking to run

19426
19:40:50,270 --> 19:40:53,300
our tests to run our scripts to
do everything. And now you might

19427
19:40:53,300 --> 19:40:55,940
be thinking, wow, Patrick, this
sounds awesome. Well, why don't

19428
19:40:55,940 --> 19:40:58,550
we just do this for everything?
Well, there's some trade offs.

19429
19:40:58,610 --> 19:41:01,190
The pros are that it's quick,
it's easy, and a test will

19430
19:41:01,190 --> 19:41:04,640
resemble what's on Main net. Now
the cons are that we need an

19431
19:41:04,640 --> 19:41:08,450
API, and we can't do everything
locally. Some contracts, some

19432
19:41:08,450 --> 19:41:11,150
contracts are complex to work
with, and mocks might just be

19433
19:41:11,150 --> 19:41:14,030
better. But using a forked
network might be a good way to

19434
19:41:14,030 --> 19:41:16,400
run your tests, it might be a
good alternate to just using

19435
19:41:16,400 --> 19:41:19,370
mocks. So it really depends on
what's right for you and right

19436
19:41:19,370 --> 19:41:23,240
for your project. But it is a
fantastic tool, especially for

19437
19:41:23,240 --> 19:41:25,730
something like Avi, where we
want to quickly test some

19438
19:41:25,730 --> 19:41:29,030
things. Now the hard forking
also will give us a bunch of

19439
19:41:29,030 --> 19:41:32,030
fake accounts. So we'll still
get a bunch of fake accounts on

19440
19:41:32,030 --> 19:41:36,140
Main net that will be given a
theorem. So we'll get fake main

19441
19:41:36,140 --> 19:41:38,870
net accounts for this forking.
So for the rest of this, we're

19442
19:41:38,870 --> 19:41:41,930
going to be using this forking
to run our scripts and run our

19443
19:41:41,930 --> 19:41:45,590
tests. If you want to go back
after this and try this all out

19444
19:41:45,590 --> 19:41:48,140
on COVID. We've got a whole
bunch of different addresses for

19445
19:41:48,140 --> 19:41:50,540
the COVID network so that you
can run these scripts directly

19446
19:41:50,540 --> 19:41:53,450
on COVID. And you can see the
transactions yourself. Just note

19447
19:41:53,450 --> 19:41:56,060
that when using COVID, you'll
want to make sure that you're

19448
19:41:56,060 --> 19:41:59,930
using the same addresses, as are
in the AVI docs for the COVID

19449
19:41:59,930 --> 19:42:03,110
network, because they do change
sometimes. Great, let's go

19450
19:42:03,110 --> 19:42:06,860
ahead, we'll go to our RT head
dot config dot j s. And now

19451
19:42:06,860 --> 19:42:09,740
we'll go to our networks, which
right now, I don't have

19452
19:42:09,740 --> 19:42:14,600
anything, I only have ranking.
And we'll add hard hat in here,

19453
19:42:15,140 --> 19:42:18,200
we'll add a little comma down
here. And we'll say, you know,

19454
19:42:18,200 --> 19:42:22,670
the chain ID of course is going
to be 31337. We'll add this

19455
19:42:22,670 --> 19:42:26,420
forking keyword. And in here,
we'll say the URL for a Forking

19456
19:42:26,450 --> 19:42:30,860
is going to be our main net RPC
URL. And this is another reason

19457
19:42:30,860 --> 19:42:34,430
why we're using alchemy. Alchemy
is fantastic at these forked

19458
19:42:34,430 --> 19:42:37,730
blockchains, and has really good
pieces here. So what we can do

19459
19:42:37,730 --> 19:42:40,640
is we can come back to our
alchemy dashboard, we'll create

19460
19:42:40,640 --> 19:42:44,450
a new app. This one will be for
Aetherium main net, and we'll

19461
19:42:44,450 --> 19:42:50,990
say forking chain. We'll say for
forking, we'll go ahead and

19462
19:42:50,990 --> 19:42:53,900
create this on a theory and main
net. Now that we have this

19463
19:42:53,900 --> 19:42:57,710
forking chain, we can do the
same thing. We'll grab our API

19464
19:42:57,710 --> 19:43:02,570
key, we'll come back to our
project, create this new file,

19465
19:43:02,870 --> 19:43:07,550
we'll create our dot env. And
we'll do main net RPC URL equals

19466
19:43:07,610 --> 19:43:10,430
and paste that in there. In our
Hardhead config, we are now

19467
19:43:10,430 --> 19:43:14,900
going to be forking from mainnet
RPC URL whenever we work with

19468
19:43:14,900 --> 19:43:18,050
the heart at blockchain. So now
that we have this in here, let's

19469
19:43:18,050 --> 19:43:22,040
go ahead and try to run this get
wet function. Because since

19470
19:43:22,040 --> 19:43:26,060
we're forking the blockchain, we
should be able to go ahead and

19471
19:43:26,060 --> 19:43:29,810
simulate this. So backing off a
borrow, we'll go ahead we'll do

19472
19:43:29,810 --> 19:43:31,640
const, get weath

19473
19:43:33,139 --> 19:43:36,949
equals require and then we'll
pull this script that dot dot

19474
19:43:37,309 --> 19:43:43,459
scripts slash get weath. And
then, in our main function,

19475
19:43:43,459 --> 19:43:48,769
we'll just run await yet. So to
run our script here, we'll do

19476
19:43:48,799 --> 19:43:55,159
yarn hard hat, run scripts
avevamo.js. And our default

19477
19:43:55,159 --> 19:43:57,889
network is hard hat. So we could
either do dash dash network hard

19478
19:43:57,889 --> 19:44:01,549
hat or just run it. And
remember, since in our config,

19479
19:44:01,609 --> 19:44:04,819
we're saying, hey, when we run
the hard hat chain, use this

19480
19:44:04,819 --> 19:44:07,669
forking, we're going to be
forking, so let's go ahead Run

19481
19:44:07,669 --> 19:44:11,809
this ran to air main. Net RPC
URL is undefined. Well, that

19482
19:44:11,809 --> 19:44:15,529
makes sense. Let's go ahead and
add this consummated RPC rel

19483
19:44:15,559 --> 19:44:21,559
equals process study and v dot
made it RPC URL. Let's try this

19484
19:44:21,559 --> 19:44:26,059
again. And we now see we got,
you know, this much weath,

19485
19:44:26,089 --> 19:44:28,219
which, again, that much wealth
is gonna be

19486
19:44:28,219 --> 19:44:35,149
1-234-567-8910 1234567 0.02
wealth, which is exactly what we

19487
19:44:35,149 --> 19:44:39,799
want. So now we have a way to
interact with main net locally,

19488
19:44:39,859 --> 19:44:42,529
which sounds kind of crazy. But
he's incredibly powerful for

19489
19:44:42,529 --> 19:44:45,829
exactly what we're doing right
here. So we have a way to fork

19490
19:44:45,829 --> 19:44:48,589
main that eath and run our
scripts and kind of test to see

19491
19:44:48,739 --> 19:44:51,679
and simulate what it would be
like to actually run these

19492
19:44:51,679 --> 19:44:55,729
transactions. So we're gonna do
like that, our get with function

19493
19:44:55,759 --> 19:44:58,879
looks good. And obviously, we
would still modularize this, we

19494
19:44:58,879 --> 19:45:01,459
put this in our helper Hardhead
config, but we're going to skip

19495
19:45:01,459 --> 19:45:04,669
doing that for now. So let's go
head back to the AVI borrow. And

19496
19:45:04,669 --> 19:45:07,609
let's go ahead and flesh the
rest of this out. Now, let's go

19497
19:45:07,609 --> 19:45:09,919
ahead and set up the rest of the
boilerplate here. So we'll do

19498
19:45:09,919 --> 19:45:13,399
const Deployer, because we need
an account, obviously equals

19499
19:45:13,429 --> 19:45:17,959
await, get named accounts. And
then we'll do const get named

19500
19:45:17,959 --> 19:45:24,169
accounts equals require. Now we
want to start interacting with

19501
19:45:24,169 --> 19:45:26,599
the ABI protocol, well, what do
we need, we're gonna need the

19502
19:45:26,599 --> 19:45:30,079
ABI and the address, nothing
changes, we're gonna need these

19503
19:45:30,079 --> 19:45:33,979
two. So what we can do is we can
go to the Ave docs. And again,

19504
19:45:33,979 --> 19:45:37,909
we're going to be on V two. And
we can go ahead and find the

19505
19:45:37,939 --> 19:45:41,119
contract address in here. Now
the way it works is they

19506
19:45:41,119 --> 19:45:44,029
actually have a contract, which
will point us to the correct

19507
19:45:44,029 --> 19:45:46,729
contract. The contract that
we're going to be doing all the

19508
19:45:46,729 --> 19:45:50,749
lending with is this lending
pool. And there's actually a

19509
19:45:50,749 --> 19:45:55,129
contract to get that contract
address. And to get the lending

19510
19:45:55,129 --> 19:45:58,159
pool address, we have to go to
the lending pool address

19511
19:45:58,159 --> 19:46:00,709
provider. It's this contract
that will tell us what the

19512
19:46:00,709 --> 19:46:03,469
address of the lending pullets.
And we can actually see the

19513
19:46:03,469 --> 19:46:06,409
deployed contract section, we
can see the address of this

19514
19:46:06,409 --> 19:46:08,959
contract. And we can see the
address of all the main ones and

19515
19:46:08,959 --> 19:46:11,479
the COVID. Once again, if you
want to play with this on COVID.

19516
19:46:11,779 --> 19:46:14,659
But we can see lending pool
address provider is going to be

19517
19:46:14,689 --> 19:46:18,739
located right here, we can copy
this address. And we'll just

19518
19:46:18,739 --> 19:46:19,699
take notes of this.

19519
19:46:21,860 --> 19:46:24,830
And that lending pool, we're
going to get from the lending

19520
19:46:24,830 --> 19:46:28,070
pelagics provider. So let's
actually create a function that

19521
19:46:28,070 --> 19:46:30,770
will get us the lending pool
address from the lending pool

19522
19:46:30,770 --> 19:46:35,270
address provider. So down here,
we'll create async function, get

19523
19:46:35,300 --> 19:46:38,480
lending pool. Now in order to
interact with this lending pool

19524
19:46:38,480 --> 19:46:41,450
address provider. Same thing,
we're going to need its address

19525
19:46:41,480 --> 19:46:44,750
and its API, we have its
address. So let's go ahead and

19526
19:46:44,750 --> 19:46:48,380
get its API, you can go ahead to
the GitHub repo associated with

19527
19:46:48,380 --> 19:46:51,650
this lesson. And just copy paste
it from the interfaces section.

19528
19:46:51,770 --> 19:46:55,370
You could also look directly on
the blockchain to see what this

19529
19:46:55,370 --> 19:46:58,100
contract looks I can create your
own interface. Or we can go

19530
19:46:58,100 --> 19:47:00,980
ahead and use the interface
right in the documentation. So

19531
19:47:00,980 --> 19:47:03,470
we have islanding Palach.
Provider, I'm just going to copy

19532
19:47:03,470 --> 19:47:07,160
this from the ABI docs. But
again, you've got a number of

19533
19:47:07,160 --> 19:47:10,670
options. And so in our contracts
in our interfaces, let's let's

19534
19:47:10,670 --> 19:47:14,420
stick iwth in interfaces here.
Let's create a new file. And

19535
19:47:14,420 --> 19:47:20,540
we'll call it I lending pool
address provider, dot soul. And

19536
19:47:20,540 --> 19:47:24,440
we'll paste it in here, we just
see we're using 0.6 point 12. So

19537
19:47:24,440 --> 19:47:27,950
be sure to in our Hardhead
config to make sure we have that

19538
19:47:27,950 --> 19:47:33,440
we don't so we're just create a
new one 0.6 point 12 And then

19539
19:47:33,440 --> 19:47:38,060
we'll compile yarn Hardhead
compile and compiles so awesome.

19540
19:47:38,090 --> 19:47:42,410
We now have the ABI here, we'll
get this contract by saying

19541
19:47:42,410 --> 19:47:50,600
const lending pool address
provider equals await ethers dot

19542
19:47:50,630 --> 19:47:59,270
get contract at will say I
lending pool address oops

19543
19:47:59,270 --> 19:48:03,230
address as I lending pool
addresses excuse me, I'm going

19544
19:48:03,230 --> 19:48:06,950
to update the name I Lenny pull
addresses provider islanding

19545
19:48:06,950 --> 19:48:11,720
pool addresses provider, we're
going to pass in that contract

19546
19:48:11,720 --> 19:48:15,830
address that we got from the
Ovid docs here. Paste that in.

19547
19:48:16,040 --> 19:48:19,550
And then we're going to connect
it to our Deployer. So we're

19548
19:48:19,550 --> 19:48:22,250
going to have our get lending
pool, get past that account

19549
19:48:22,250 --> 19:48:25,730
variable and then we'll just use
the account here to connect it

19550
19:48:25,730 --> 19:48:28,160
and the account that we're going
to pass is of course going to be

19551
19:48:28,160 --> 19:48:32,120
our Deployer. In our lending
pool address provider. There's a

19552
19:48:32,120 --> 19:48:37,130
function called Get lending pool
which returns the address of the

19553
19:48:37,130 --> 19:48:39,200
lining pool and this is going to
be the function that we're going

19554
19:48:39,200 --> 19:48:44,450
to call so we're gonna say const
lending pool address equals a

19555
19:48:44,450 --> 19:48:51,560
weight lending pool address says
probes address any pool address

19556
19:48:51,560 --> 19:48:56,150
says provider dot get lending
pool and that's it we'll have

19557
19:48:56,150 --> 19:48:59,090
the lending pool address and
then we'll have this contract

19558
19:48:59,090 --> 19:49:03,500
give us the lending pool
contract by doing const lending

19559
19:49:03,500 --> 19:49:10,040
pool equals await ethers dot get
contract Add. And we need to do

19560
19:49:10,040 --> 19:49:13,880
the same thing, the interface,
the interface, the address, and

19561
19:49:13,880 --> 19:49:17,390
then the account. So back in the
docs, we can grab the I lending

19562
19:49:17,390 --> 19:49:22,340
pool by copying this like this.
We'll go back to our contracts

19563
19:49:22,340 --> 19:49:27,860
interfaces, new file, I lending
pool, that's all. And we'll

19564
19:49:27,860 --> 19:49:30,920
paste it in. Now with this one,
if we scroll to the top, we

19565
19:49:30,920 --> 19:49:34,880
noticed that we're importing
from some local places that we

19566
19:49:34,880 --> 19:49:38,480
actually don't have in our
contracts area, we can once

19567
19:49:38,480 --> 19:49:44,360
again go ahead and add the AVI
protocol v2 from NPM. And just

19568
19:49:44,360 --> 19:49:49,730
use this as our imports. So
we'll do yarn, add dash dash dev

19569
19:49:49,850 --> 19:49:55,220
apt have a slash proto call
hyphen V two. And now that we

19570
19:49:55,220 --> 19:50:00,350
have the Add Ave protocol in our
node modules, we can update

19571
19:50:00,410 --> 19:50:03,350
these imports to point to our
node modules instead of our

19572
19:50:03,350 --> 19:50:07,010
local files. So I'm just gonna
go ahead and tell you that the

19573
19:50:07,010 --> 19:50:12,080
islanding pledge provider is
that Ave slash protocol hyphen V

19574
19:50:12,080 --> 19:50:17,660
to slash contracts slash
interfaces. And then data types

19575
19:50:17,660 --> 19:50:22,550
dot soul is gonna be at of a
protocol hyphen v2 slash

19576
19:50:22,550 --> 19:50:28,610
contracts slash, proto call
slash libraries, slash types,

19577
19:50:28,640 --> 19:50:32,030
data types, that's all again to
make sure this is right, yarn,

19578
19:50:32,030 --> 19:50:36,350
Hardhead compile or hh, compile.
And Cool. Looks like I did that

19579
19:50:36,350 --> 19:50:41,090
right? Lending pool equals await
ethers dot get contract at,

19580
19:50:41,150 --> 19:50:44,510
we're going to be using lending
pool, I lend the pool here,

19581
19:50:44,660 --> 19:50:47,750
we're going to use this lending
pool address got from the

19582
19:50:47,750 --> 19:50:51,890
addresses provider. And then the
account, which is going to be

19583
19:50:51,890 --> 19:50:57,290
our Deployer. And now we can do
return lending pool. And if we

19584
19:50:57,290 --> 19:51:03,080
want, and now that we have this
function get lending pool backup

19585
19:51:03,080 --> 19:51:08,210
in our main function, we can say
const lending pool equals a

19586
19:51:08,210 --> 19:51:12,020
weight, get lending pool and
then pass the Deployer. And then

19587
19:51:12,020 --> 19:51:14,240
we can even do a little console
dot log,

19588
19:51:15,710 --> 19:51:22,640
lending pool address and then do
lending pool dot address. And

19589
19:51:22,640 --> 19:51:24,980
since we're making it forking,
we can kind of just keep running

19590
19:51:24,980 --> 19:51:30,890
this right. So we'll do yarn
hardhat run scripts. Ave Baroda

19591
19:51:30,890 --> 19:51:33,710
Jas, there are multiple
artifacts for contract II

19592
19:51:33,710 --> 19:51:37,430
lending pool addresses provider.
And this is because in our node

19593
19:51:37,430 --> 19:51:42,350
modules, import all this stuff
from contracts and in here, and

19594
19:51:42,380 --> 19:51:45,530
there's already in islanding,
pool addresses provider in those

19595
19:51:45,530 --> 19:51:48,470
add ons slash contracts. So
actually, we don't even need

19596
19:51:48,470 --> 19:51:51,350
this, I lending pool added
service provider, we can go

19597
19:51:51,350 --> 19:51:54,050
ahead and delete it. Our time
right now is getting confused.

19598
19:51:54,080 --> 19:51:56,960
It's saying Oh, are you
referring to the one that you

19599
19:51:57,350 --> 19:52:01,220
downloaded from NPM or the one
that you made, which which one

19600
19:52:01,220 --> 19:52:04,160
do you want to use. So we'll
just make it easier for hardhat.

19601
19:52:04,220 --> 19:52:07,460
And we'll say okay, well, we'll
delete the one that we created,

19602
19:52:07,460 --> 19:52:09,830
we'll use the one that we've
downloaded here. And now we

19603
19:52:09,830 --> 19:52:12,980
should be good to run this
again. Because now there's only

19604
19:52:12,980 --> 19:52:15,770
one for to pick from, which is
the one we downloaded from NPM.

19605
19:52:16,550 --> 19:52:20,060
And perfect, we get our get
weath printout here, and then we

19606
19:52:20,060 --> 19:52:22,850
get lending pool address is
here. And this is going to be

19607
19:52:22,850 --> 19:52:26,420
the actual lending pool address
on ether Aetherium main net. So

19608
19:52:26,420 --> 19:52:29,720
if we go back to ether scan,
copy that address and paste it

19609
19:52:29,720 --> 19:52:34,250
and ether scan, we can see it's
even labeled Ave v two, and we

19610
19:52:34,250 --> 19:52:38,060
can see a ton of transactions
going through all the time. And

19611
19:52:38,060 --> 19:52:39,770
ether scan is having a hard time
keeping up with all the

19612
19:52:39,770 --> 19:52:42,920
transactions. So we've got the
lending pool address, we've got

19613
19:52:42,920 --> 19:52:47,090
some web token, what do we need
to do? Now we want a deposit of

19614
19:52:47,090 --> 19:52:50,300
what do we need in order to
deposit the token? Well, if we

19615
19:52:50,300 --> 19:52:54,290
look at the deposit function in
the avec GitHub, we can scroll

19616
19:52:54,290 --> 19:52:58,640
in here and we see it eventually
we'll call this safe transfer

19617
19:52:58,640 --> 19:53:01,370
from which is basically going to
be this transfer from function,

19618
19:53:01,490 --> 19:53:04,640
since we're calling transfer
from it's going to be this

19619
19:53:04,640 --> 19:53:08,420
contract, that's actually going
to pull the money out of our

19620
19:53:08,420 --> 19:53:12,500
wallet. So in order to give the
Ave contract, the ability to

19621
19:53:12,500 --> 19:53:15,500
pull the money out of our
wallet, we need to do what we're

19622
19:53:15,500 --> 19:53:19,580
going to need to approve the
contract. So first, before we

19623
19:53:19,580 --> 19:53:22,130
can even deposit we're gonna
need to approve it to get our

19624
19:53:22,130 --> 19:53:25,370
web token, we're gonna have to
get the Web Token first. So

19625
19:53:25,370 --> 19:53:29,150
let's get the Web Token address
we'll say const Web Token

19626
19:53:29,180 --> 19:53:33,470
address, equals and this is
where we marginalize it and get

19627
19:53:33,470 --> 19:53:36,470
it from our hard head helper
config. But for now, we can just

19628
19:53:36,470 --> 19:53:39,170
hard code it, the Web Token
contract address is going to be

19629
19:53:39,170 --> 19:53:42,920
the exact same thing as what's
in get web and then want to

19630
19:53:42,920 --> 19:53:46,280
approve. So let's write an
approved function because we're

19631
19:53:46,280 --> 19:53:48,890
going to use this a couple
times. So we'll make an async

19632
19:53:48,890 --> 19:53:52,460
function and approve ERC 20

19633
19:53:54,080 --> 19:54:00,470
And we'll take a contract
address a spender address, which

19634
19:54:00,470 --> 19:54:03,440
is going to be the contract that
we're going to give the approval

19635
19:54:03,440 --> 19:54:08,630
to to spend our token and amount
to spend so exactly how much we

19636
19:54:08,630 --> 19:54:13,460
want to prove it. And then an
account to do all this on. So in

19637
19:54:13,460 --> 19:54:19,550
here we'll say const ERC 20
token equals await ethers dot

19638
19:54:19,580 --> 19:54:24,890
get contract at. And we could
say I WEF but maybe we just want

19639
19:54:24,890 --> 19:54:28,160
like a simple ERC 20 token
interface. And we're going to

19640
19:54:28,160 --> 19:54:31,820
grab that by cheating a little
bit coin to our hard head defy

19641
19:54:31,820 --> 19:54:34,700
FCC. We're going to go to
interfaces and grab this

19642
19:54:34,700 --> 19:54:37,640
interface from here. So we're
going to copy this, paste it in

19643
19:54:37,640 --> 19:54:43,580
here New File IO ERC 20 dot som
paste and now we have an ABI for

19644
19:54:43,580 --> 19:54:48,260
ERC. 20s So we'll do get
contract that ERC 20 Actually

19645
19:54:48,260 --> 19:54:51,770
let's change this name to ERC.
20 address so we're going to get

19646
19:54:51,770 --> 19:54:57,800
the contract with the ABI of IRC
ERC 20 at contract address ERC

19647
19:54:57,800 --> 19:55:01,760
20 address and then we'll
connect it to our account here.

19648
19:55:01,820 --> 19:55:06,560
So and once we have the ERC 20
We can do const TX, we're going

19649
19:55:06,560 --> 19:55:10,820
to do that approve transaction
we'll do a weight ERC 20 token

19650
19:55:11,300 --> 19:55:17,660
dot approve spender address, and
then amount amount to spend.

19651
19:55:18,290 --> 19:55:22,670
We'll do we'll do a wait TX dot
wait for one block. And we'll do

19652
19:55:22,670 --> 19:55:27,380
a little console dot log saying
approved. Now if you don't run

19653
19:55:27,380 --> 19:55:30,470
this function before you try to
deposit you'll just get an error

19654
19:55:30,470 --> 19:55:32,690
saying hey, token is not
approved, which is a pretty

19655
19:55:32,690 --> 19:55:36,470
common error. So if you ever see
that just know, I forgot to

19656
19:55:36,470 --> 19:55:39,830
approve my token. So backup in
our main script, we'll go ahead

19657
19:55:39,830 --> 19:55:44,630
and run this function. We'll say
await approve ERC 20 with the

19658
19:55:44,630 --> 19:55:48,530
Web Token address lending pool
dot address because we want to

19659
19:55:48,530 --> 19:55:53,840
give the len pool the approval
to pull our web token from our

19660
19:55:53,840 --> 19:55:57,440
account. And then we'll give it
some amount to actually will

19661
19:55:57,470 --> 19:56:01,640
import a mount from get weath as
well. Mount we gotta go back to

19662
19:56:01,640 --> 19:56:05,570
get with an export it so we can
actually import it. So get with

19663
19:56:05,600 --> 19:56:10,340
exporting that amount that 0.02.
So we'll prove the amount and

19664
19:56:10,340 --> 19:56:12,470
then we'll connect we'll have
our Deployer do it obviously

19665
19:56:12,470 --> 19:56:14,480
because we're doing everything
with the Deployer. So we'll

19666
19:56:14,480 --> 19:56:18,290
approve the ERC 20. And then
once we approve, we can go ahead

19667
19:56:18,290 --> 19:56:22,910
and deposit it. So we'll say
console dot log, depositing

19668
19:56:22,970 --> 19:56:28,850
that. And then we'll run await
lending pool dot deposit. If we

19669
19:56:28,850 --> 19:56:33,230
look at the deposit function, we
can see all the parameters that

19670
19:56:33,230 --> 19:56:37,340
the deposit function takes. We
can also see it in the Ave v2

19671
19:56:37,340 --> 19:56:40,640
documentation and we just look
forward the posit. And we can

19672
19:56:40,640 --> 19:56:42,710
see it takes the address of the
asset that we're going to

19673
19:56:42,710 --> 19:56:46,550
deposit how much of that asset
we're going to deposit address

19674
19:56:46,550 --> 19:56:49,670
on behalf of we're going to do
it on behalf of ourself and then

19675
19:56:49,670 --> 19:56:52,670
a referral code, which right now
is just always going to be zero

19676
19:56:52,700 --> 19:56:55,340
because the referral code has
been discontinued. So we're

19677
19:56:55,340 --> 19:56:58,670
going to deposit the wet token
address, we're going to deposit

19678
19:56:58,670 --> 19:57:04,250
our web token, we're going to
posit 0.02 of that web token.

19679
19:57:04,730 --> 19:57:07,610
And then we're going to use a
deployer ash and then referral

19680
19:57:07,610 --> 19:57:09,830
code is going to be zero. And
then we'll do a little console

19681
19:57:09,830 --> 19:57:14,510
dot log the positive. So let's
try this script. Let's see if it

19682
19:57:14,510 --> 19:57:18,050
works. I'm just going to hit up
to go ahead and rerun this

19683
19:57:18,080 --> 19:57:21,230
script to rerun this command I
just ran into doing a little

19684
19:57:21,230 --> 19:57:25,340
compiling that ERC 20. That song
was compiled one solidity file,

19685
19:57:25,700 --> 19:57:29,600
got a bunch of wrapped Aetherium
lending pool address. We

19686
19:57:29,600 --> 19:57:32,990
approved it, we deposit we were
depositing it and then we

19687
19:57:32,990 --> 19:57:37,400
deposited it. So if we're
looking at our little readme

19688
19:57:37,400 --> 19:57:39,650
here, we get a little checkmark.

19689
19:57:42,470 --> 19:57:45,740
We've done step one, we've
deposited our collateral.

19690
19:57:46,070 --> 19:57:49,130
Awesome. So now we have some
collateral to use to borrow

19691
19:57:49,160 --> 19:57:53,510
other assets. Great. So now
we've deposited let's go ahead

19692
19:57:53,510 --> 19:57:56,960
and learn how to borrow now
through a couple of new lines,

19693
19:57:56,960 --> 19:58:01,640
and we'll say borrowed time. So
in order for us to borrow, we

19694
19:58:01,640 --> 19:58:05,540
probably want to know how much
we can borrow. And we want to

19695
19:58:05,540 --> 19:58:09,110
know more about our account,
right? We want to know how much

19696
19:58:09,110 --> 19:58:14,600
we have borrowed, how much we
have in collateral and how much

19697
19:58:14,990 --> 19:58:18,590
we can borrow. So there's a
function that Avi comes with

19698
19:58:18,590 --> 19:58:21,710
called Get User account data,
which will return the user's

19699
19:58:21,740 --> 19:58:24,920
account data across all
reserves, how much collateral we

19700
19:58:24,920 --> 19:58:28,940
have down the total value it in
its eath price, we have the

19701
19:58:28,940 --> 19:58:32,000
available borrows and eath
current liquidation threshold,

19702
19:58:32,060 --> 19:58:36,140
loan to value etc. Now these are
really important metrics. If we

19703
19:58:36,140 --> 19:58:39,770
have one, eath and collateral
that doesn't mean we can borrow

19704
19:58:39,800 --> 19:58:43,520
one eath of assets. Each one of
these tokens have some different

19705
19:58:43,520 --> 19:58:48,140
values like loan to value. For
example, if you have one eath

19706
19:58:48,170 --> 19:58:53,720
you can only borrow zero point
75 for the dye token, this is to

19707
19:58:53,720 --> 19:58:57,320
reduce risk of the collateral
and reduce risk of people not

19708
19:58:57,320 --> 19:59:01,340
having enough collateral down as
prices fluctuate. There's a

19709
19:59:01,340 --> 19:59:06,650
liquidation threshold of 80% if
you have one eath as collateral

19710
19:59:06,680 --> 19:59:10,490
and point 81 eath borrowed,
you'll get what's called

19711
19:59:10,520 --> 19:59:14,060
liquidated. So what is
liquidation? When you put down

19712
19:59:14,060 --> 19:59:16,490
collateral and you borrow, if
the amount that you have

19713
19:59:16,490 --> 19:59:20,720
borrowed past this liquidation
threshold is passed that 80% Or,

19714
19:59:20,810 --> 19:59:23,270
or depending on different
assets, it's different people

19715
19:59:23,270 --> 19:59:26,540
can do what's called liquidate
you. This is when they pay back

19716
19:59:26,540 --> 19:59:31,820
some of your loan that you took
out. And they also get to buy

19717
19:59:31,850 --> 19:59:35,000
some of your collateral at a
cheaper price. This keeps the

19718
19:59:35,000 --> 19:59:39,590
Ave platform solvent, and it
makes it so that there's never

19719
19:59:39,590 --> 19:59:43,430
more borrows than there are
collateral in order to borrow

19720
19:59:43,430 --> 19:59:46,340
assets, we still need that
collateral down. So basically,

19721
19:59:46,340 --> 19:59:49,610
if you borrowed more money than
you've put up, other users can

19722
19:59:49,640 --> 19:59:52,760
can take the money that you've
put up in return for them paying

19723
19:59:52,760 --> 19:59:56,000
for your loans. So we obviously
don't want this to happen. And

19724
19:59:56,000 --> 19:59:58,340
the audit protocol
programmatically doesn't want to

19725
19:59:58,340 --> 20:00:01,040
have not enough money to do
this. So they incentivize users

19726
20:00:01,040 --> 20:00:04,790
to liquidate, in case of these
failures is the protocols come

19727
20:00:04,790 --> 20:00:08,810
with this thing called a health
factor, which if this health

19728
20:00:08,810 --> 20:00:11,660
factor is below one, you go
ahead and you get liquidated,

19729
20:00:11,810 --> 20:00:15,200
the actual function to liquidate
somebody is called liquidation

19730
20:00:15,200 --> 20:00:18,530
call. So you can actually build
a bot and you can liquidate

19731
20:00:18,530 --> 20:00:21,830
users who go insolvent and you
can make a fee, you can make a

19732
20:00:21,830 --> 20:00:25,310
reward for actually doing this.
These protocols need to stay

19733
20:00:25,310 --> 20:00:28,310
solvent, they need to have
enough money to lend out. And

19734
20:00:28,310 --> 20:00:30,710
they programmatically enforced
this, which is why it's so

19735
20:00:30,710 --> 20:00:33,890
great. You can learn more about
liquidations in the liquidation

19736
20:00:33,920 --> 20:00:37,220
documentation. So this get us
account data will tell us how

19737
20:00:37,220 --> 20:00:40,250
much we have collateral, how
much we have in debt, and how

19738
20:00:40,250 --> 20:00:43,550
much we have available to borrow
based on how much collateral we

19739
20:00:43,550 --> 20:00:46,520
have. We can see the current
liquidation threshold we can see

19740
20:00:46,520 --> 20:00:49,490
the loan to value and then we
can see our health factor, which

19741
20:00:49,490 --> 20:00:53,150
is obviously really important.
If our health factor ever falls

19742
20:00:53,150 --> 20:00:56,480
below one, we get liquidated. So
we never want this hell factor

19743
20:00:56,480 --> 20:00:59,420
to fall below one when we're
borrowing assets. So let's

19744
20:00:59,420 --> 20:01:01,970
create a function that can grab
that first. So let's create a

19745
20:01:01,970 --> 20:01:08,600
new function called async.
Function get it borrow user

19746
20:01:08,600 --> 20:01:12,200
data, and we'll pass in the
lending pool contract, we'll

19747
20:01:12,200 --> 20:01:15,230
pass in the lending pool
contract and the account that we

19748
20:01:15,230 --> 20:01:18,800
want to get the data for. So we
can say const. And actually, we

19749
20:01:18,800 --> 20:01:21,380
can pull out just the values
that we want, we could pull out

19750
20:01:21,380 --> 20:01:24,920
the total collateral eath total
debt eath and the available to

19751
20:01:24,920 --> 20:01:30,140
borrow. Let's just pull out the
total collateral eath the total

19752
20:01:31,400 --> 20:01:40,700
debt if and the available,
borrows. So this equals await,

19753
20:01:41,300 --> 20:01:49,340
lending pool dot get user
account data of account. And now

19754
20:01:49,340 --> 20:01:53,090
we'll even just kind of logged
us out we'll say console dot log

19755
20:01:54,560 --> 20:02:03,500
you have total collateral eath
worth of eath the positive

19756
20:02:04,850 --> 20:02:19,190
console. Log you have total debt
eath worth of eath borrowed and

19757
20:02:19,190 --> 20:02:22,970
then console dot log you can
borrow

19758
20:02:24,350 --> 20:02:32,240
available borrows eath worth of
eath. And then we'll just return

19759
20:02:32,540 --> 20:02:36,380
available to borrow will turn
available borrows eath. And

19760
20:02:36,380 --> 20:02:39,320
we'll return or total debt, we
don't really need to return

19761
20:02:39,320 --> 20:02:41,720
total collateral we could if we
want we really just want to

19762
20:02:41,720 --> 20:02:46,610
print it out here. So now back
in our function, we can do in

19763
20:02:46,610 --> 20:02:50,570
our main function, we can run
let, I'm going to do that

19764
20:02:50,570 --> 20:02:52,550
because we're going to be
calling this a few times

19765
20:02:53,270 --> 20:02:59,240
available borrows eath. And
total debt eath

19766
20:03:00,740 --> 20:03:05,810
equals await, get borrow user
data of lending pool and

19767
20:03:05,810 --> 20:03:08,780
Deployer. And if we run this,
we'll see how much we can

19768
20:03:08,780 --> 20:03:14,480
actually borrow yarn hard hat or
just h h run scripts on a

19769
20:03:14,480 --> 20:03:18,770
borrowed.js and work on our
forked blockchain here. And

19770
20:03:18,770 --> 20:03:20,990
remember, it is going to be a
little bit slower. And this is

19771
20:03:20,990 --> 20:03:23,210
kind of one of the disadvantages
too because it does have to make

19772
20:03:23,240 --> 20:03:26,840
API calls whenever we want to
interact with these chains. And

19773
20:03:26,840 --> 20:03:29,930
then we got total collateral
eath is not defined. And that's

19774
20:03:29,930 --> 20:03:34,250
because I spelt total wrong. So
let's spell total correctly. And

19775
20:03:34,250 --> 20:03:38,420
we'll run this again. But okay,
great. So you have this month's

19776
20:03:38,420 --> 20:03:42,350
worth of eath deposited, you
have zero worth of eath borrowed

19777
20:03:42,350 --> 20:03:44,510
because we haven't borrowed
anything, and you can borrow

19778
20:03:44,540 --> 20:03:47,810
this much worth of eath.
Remember, the amount that we can

19779
20:03:47,810 --> 20:03:50,840
borrow is always going to be
less than the total amount that

19780
20:03:50,840 --> 20:03:54,380
we have as deposited. That's why
we see this lower number here.

19781
20:03:54,590 --> 20:03:57,770
So cool. So that's how much we
can borrow. Let's use that to go

19782
20:03:57,770 --> 20:04:01,070
and borrow some time. So we have
this total amount we can borrow

19783
20:04:01,070 --> 20:04:04,700
an eighth and we're gonna get to
borrow time. I promise we're

19784
20:04:04,700 --> 20:04:07,670
gonna get to borrow time, but we
need to figure out What's the

19785
20:04:07,670 --> 20:04:10,970
conversion rate of diets? We're
gonna get how much we can borrow

19786
20:04:10,970 --> 20:04:14,660
in eath. But we want to borrow
dye. So how much of dye can we

19787
20:04:14,660 --> 20:04:17,810
borrow based off of the value of
eath? And to do that, we're

19788
20:04:17,810 --> 20:04:20,930
gonna have to get the dye price.
And how are we going to do that?

19789
20:04:20,930 --> 20:04:22,970
Well, you guessed it, we're
going to use chain link price

19790
20:04:22,970 --> 20:04:25,880
feeds. If you look in the AVI
documentation, you can find

19791
20:04:25,880 --> 20:04:28,400
price Oracle, which is a
contract that you could actually

19792
20:04:28,400 --> 20:04:32,390
use right directly from Avi. But
the first thing it does is check

19793
20:04:32,390 --> 20:04:34,820
from a chain link aggregator,
which we already know how to do.

19794
20:04:34,850 --> 20:04:37,310
So we're gonna go ahead and just
call directly from the chain

19795
20:04:37,310 --> 20:04:40,340
link aggregator. So let's create
a new function function, we'll

19796
20:04:40,340 --> 20:04:44,360
call it get dye price is first
we're going to need to get that

19797
20:04:44,360 --> 20:04:48,290
interface, same thing. So you
can either go right to Hardhead

19798
20:04:48,290 --> 20:04:52,460
defy and just grab the interface
right from here, we could swap

19799
20:04:52,460 --> 20:04:56,330
this out with just an import
from chainlink NPM, as well. But

19800
20:04:56,330 --> 20:04:59,390
I'm just going to go ahead and
copy paste a new file, this is

19801
20:04:59,390 --> 20:05:04,340
going to be the Ag reg gate, Tor
v3 interface. Dot saw that we've

19802
20:05:04,340 --> 20:05:07,220
worked with so many times. Now
that we have this interface,

19803
20:05:07,250 --> 20:05:10,790
this will compile, we're
obviously looking for latest

19804
20:05:10,790 --> 20:05:13,520
round data, which will give us
this answer here, which is going

19805
20:05:13,520 --> 20:05:15,470
to be the price. So let's go
ahead and grab that. So we'll

19806
20:05:15,470 --> 20:05:21,170
say const di eath price feed
equals await ethers dot get

19807
20:05:21,170 --> 20:05:27,500
contract at and we'll use the
air, Greg a Tor v3 interface

19808
20:05:27,680 --> 20:05:30,860
will get the dye eath price feed
right from the chain link Docs.

19809
20:05:30,890 --> 20:05:35,030
So we go to docs dot chain dot
link UVM chains will go to

19810
20:05:35,510 --> 20:05:39,920
contract addresses on Aetherium.
Or look for di eath on Main net.

19811
20:05:40,370 --> 20:05:43,370
And we see di eath is right
here. So we'll grab this and

19812
20:05:43,370 --> 20:05:46,100
again, we're just hard coding it
in the GitHub repo associated

19813
20:05:46,100 --> 20:05:50,240
with it. With this, we put it in
a little config file, but we can

19814
20:05:50,240 --> 20:05:53,420
just go ahead and hard coded in.
And for this one, we don't need

19815
20:05:53,420 --> 20:05:56,930
to connect this to the deployer
account. Since we're not going

19816
20:05:56,930 --> 20:05:59,930
to be sending any transactions,
we're just going to be reading

19817
20:05:59,930 --> 20:06:02,720
from this contract, right. So
reading don't need a signer

19818
20:06:02,840 --> 20:06:08,300
sending me to signer. Now we can
say const price equals a weight

19819
20:06:08,390 --> 20:06:15,470
dye eath price feed dot latest
round data. Now latest round

19820
20:06:15,470 --> 20:06:19,370
data, as we know is going to
return us this huge thing. And

19821
20:06:19,370 --> 20:06:23,270
we only want the answer at the
first index. So another way we

19822
20:06:23,270 --> 20:06:25,970
could do this, we could just
wrap this whole thing up. And

19823
20:06:25,970 --> 20:06:28,760
then once this returns, we're
gonna say okay, just grab that

19824
20:06:28,760 --> 20:06:31,760
first index here, which will be
that price. And then we could do

19825
20:06:31,760 --> 20:06:39,770
a little console dot log, the dy
eath. Price is in price dot two,

19826
20:06:40,580 --> 20:06:43,730
like that, and then return
price. So we can go ahead and

19827
20:06:43,730 --> 20:06:46,940
run this as well test this out,
just by hitting up and then

19828
20:06:46,940 --> 20:06:51,050
enter. Depositing we deposited
this is how much we can deposit.

19829
20:06:51,380 --> 20:06:54,620
Nothing Oh, and I forgot to call
it oh, excuse me, let's go up.

19830
20:06:54,920 --> 20:07:01,880
This, let's say const dye price
equals await get dye price. And

19831
20:07:01,880 --> 20:07:05,210
tada. The dye youth price is
this big number, which of course

19832
20:07:05,210 --> 20:07:09,320
we know is going to be $3,289
which is which of course is

19833
20:07:09,320 --> 20:07:15,050
gonna be 3289 di per eath. Now
that we have the dye price, we

19834
20:07:15,050 --> 20:07:18,620
can figure out how much dye we
want to borrow. So great, we

19835
20:07:18,620 --> 20:07:21,740
have the price. Now let's figure
out the amount that we can

19836
20:07:21,740 --> 20:07:25,010
borrow in dye, we have the
amount we can borrow eath, we

19837
20:07:25,010 --> 20:07:29,480
need to convert it to die. So
we'll say const amount die to

19838
20:07:29,480 --> 20:07:36,890
borrow equals available, be the
available borrows in eath.to

19839
20:07:36,890 --> 20:07:41,330
string. And then in JavaScript,
we can do this.to string but

19840
20:07:41,330 --> 20:07:47,240
still do math. So times 0.95
times and then we'll do the

19841
20:07:47,240 --> 20:07:53,300
reciprocal of that die. So one
divided by die price.to number.

19842
20:07:53,780 --> 20:07:58,280
So this will give us the amount
of die that we can borrow. And

19843
20:07:58,280 --> 20:08:01,430
then we'll want to get this in
way. So if we print this out

19844
20:08:01,430 --> 20:08:05,810
right now, console dot log, you
can borrow.

19845
20:08:08,150 --> 20:08:14,330
Run this now, you can borrow
amount die to borrow. Not in way

19846
20:08:14,330 --> 20:08:17,480
units, which we need in way
units, but you can borrow 48

19847
20:08:17,480 --> 20:08:21,020
Die, which based off the price
looks about right. So to get the

19848
20:08:21,020 --> 20:08:27,440
correct units, we'll say const
amount, di to borrow way. That's

19849
20:08:27,440 --> 20:08:33,320
going to equal ethers dot utils
dot parse ether, MT di to

19850
20:08:33,320 --> 20:08:37,850
borrow.to string. This is just
purely the amount of dye to

19851
20:08:37,850 --> 20:08:42,020
borrow right so we get 48.79
die. But again, we want that in

19852
20:08:42,020 --> 20:08:47,180
way the die token has 18 decimal
places similar to Aetherium. So

19853
20:08:47,180 --> 20:08:50,870
we need that amount in way and
then we can go ahead and start

19854
20:08:50,870 --> 20:08:53,390
actually borrowing now. So we'll
create a new function called

19855
20:08:53,390 --> 20:08:58,850
borrow die async function,
borrow die will take the die

19856
20:08:58,850 --> 20:09:05,390
address. Take the lending pool,
take the amount die to borrow

19857
20:09:05,630 --> 20:09:09,440
and weigh in Then of course,
we'll take the account. And all

19858
20:09:09,440 --> 20:09:13,190
we'll do is we'll do const.
Borrow TX is going to be a

19859
20:09:13,190 --> 20:09:20,330
weight, lending pool dot borrow,
die address, amount die to

19860
20:09:20,330 --> 20:09:25,250
borrow. And again, we can go
right to the documentation, if

19861
20:09:25,250 --> 20:09:28,310
we want, it takes the address of
the asset, the amount, we want

19862
20:09:28,310 --> 20:09:30,590
to borrow the interest rate
mode, which is going to be

19863
20:09:30,590 --> 20:09:34,280
variable or stable, the referral
code and then address on behalf

19864
20:09:34,280 --> 20:09:37,790
of, we're going to say one for
the interest rate mode, where

19865
20:09:37,790 --> 20:09:41,900
one is going to be stable. And
then we're going to do zero or

19866
20:09:41,900 --> 20:09:44,840
this referral code because
that's debunked now, and then

19867
20:09:44,840 --> 20:09:49,640
we'll do a count, then we'll do
a wait, borrow TX dot Wait, wait

19868
20:09:49,640 --> 20:09:54,470
one transaction, and then we'll
do console dot log you've

19869
20:09:56,150 --> 20:10:00,170
borrowed. Well, and that's it.
So we now have this borrowed I

19870
20:10:00,170 --> 20:10:04,550
function. So back up in our main
function, right, now, we can

19871
20:10:04,550 --> 20:10:09,020
finally do the borrow time. So
we'll do a wait, borrow die. And

19872
20:10:09,020 --> 20:10:12,380
we'll pass those parameters in
here. So we're going to do

19873
20:10:12,380 --> 20:10:16,730
const, die token address, equals
and we're just going to hard

19874
20:10:16,730 --> 20:10:20,870
code this from main net. So we
can look up die token address,

19875
20:10:21,110 --> 20:10:24,320
main net, we'll grab this
address here, this looks like

19876
20:10:24,320 --> 20:10:27,500
this is indeed the DI token, we
check right on the object get

19877
20:10:27,500 --> 20:10:30,380
up, we could check right on the
ABI of actual code, since we're

19878
20:10:30,380 --> 20:10:32,690
just testing, we're just gonna
go ahead and grab from ether

19879
20:10:32,690 --> 20:10:36,290
scan here. So for borrow dye,
we're gonna need the dye token

19880
20:10:36,290 --> 20:10:40,760
address, we're gonna need the
lending pool contract the amount

19881
20:10:41,720 --> 20:10:46,220
of dye to borrow in way, and
then our Deployer. And then

19882
20:10:46,220 --> 20:10:51,650
we'll await borrow dye. And then
we will run this get bar user

19883
20:10:51,650 --> 20:10:55,130
data again, just print out the
information about where we are

19884
20:10:55,220 --> 20:10:58,520
after we do that. So when we can
run this, again, we should see

19885
20:10:58,550 --> 20:11:02,000
the amount that we have
borrowed, updated, our first

19886
20:11:02,030 --> 20:11:05,660
call to that function is gonna
say, Hey, you have this much eat

19887
20:11:05,660 --> 20:11:08,150
the positive Do you have nothing
borrowed, you can borrow this

19888
20:11:08,150 --> 20:11:11,030
much eath, we get the price, we
get how much we borrowed, we

19889
20:11:11,030 --> 20:11:15,770
borrow. And now it says you have
this much where the eath

19890
20:11:15,770 --> 20:11:18,980
deposited and you have this much
worth of eath borrowed and you

19891
20:11:18,980 --> 20:11:23,000
can borrow this much eat. So we
actually now have bought a bunch

19892
20:11:23,000 --> 20:11:26,090
of this dye actually borrowed.
And the reason we're doing times

19893
20:11:26,090 --> 20:11:29,240
zero point 95, we don't want to
hit that cap of the maximum

19894
20:11:29,240 --> 20:11:32,840
amount that we can borrow. So
we're saying hey, let's get 95%

19895
20:11:33,290 --> 20:11:35,570
of the amount that we actually
can borrow. So we're not going

19896
20:11:35,570 --> 20:11:39,140
to borrow everything, we're just
gonna borrow 95%. And you can

19897
20:11:39,140 --> 20:11:41,840
see that the amount of eath we
have deposited is actually

19898
20:11:41,840 --> 20:11:46,070
higher. This is because we're
actually gaining interest just

19899
20:11:46,070 --> 20:11:50,330
by having this eath deposited.
And now that we have some dye

19900
20:11:50,330 --> 20:11:54,500
borrowed, we borrowed 48 dye,
which is equivalent to this much

19901
20:11:54,530 --> 20:11:56,960
Aetherium. And then we still
have a little bit more we can

19902
20:11:56,960 --> 20:12:00,830
borrow because we only borrowed
95%, which is great.

19903
20:12:03,440 --> 20:12:07,760
Awesome, we've taken out a
borrow programmatically, let's

19904
20:12:07,790 --> 20:12:10,730
repay at least some of it here.
So we're gonna have to create a

19905
20:12:10,730 --> 20:12:15,050
new function that's going to use
the repay function in the

19906
20:12:15,050 --> 20:12:19,160
contract. So we're gonna do
async function repay, and this

19907
20:12:19,160 --> 20:12:24,290
is going to take the amount that
we want to repay the dye address

19908
20:12:24,290 --> 20:12:27,410
that we're going to repay the
lending pool and then the

19909
20:12:27,410 --> 20:12:32,000
account now to repay once again,
we're going to have to approve

19910
20:12:32,030 --> 20:12:36,620
sending our dye back to Ave So
in here, the first thing we need

19911
20:12:36,620 --> 20:12:43,700
to do is we actually need to
call wait prove ERC 20 with the

19912
20:12:43,700 --> 20:12:49,670
dye address, lending pool dot
address, mount and then

19913
20:12:49,670 --> 20:12:53,630
accounts, right because approve
ERC 20. That's the input

19914
20:12:53,630 --> 20:12:56,900
parameters it takes, and we need
to approve sending the dye back

19915
20:12:56,900 --> 20:12:59,600
to the contract. So we borrowed
it, and we're gonna send it

19916
20:12:59,600 --> 20:13:02,600
back. Now we're actually going
to send it back. So let's say

19917
20:13:02,600 --> 20:13:08,420
const, repay TX equals await,
lending, cool that repay the

19918
20:13:08,420 --> 20:13:14,780
address, amount, one account.
And then we'll say await repay

19919
20:13:14,780 --> 20:13:21,230
TX dot Wait, that will do
console dot log repaid up in our

19920
20:13:21,230 --> 20:13:25,400
main function, we're going to do
a weight repay, and we're going

19921
20:13:25,400 --> 20:13:30,410
to give it the amount dye to
borrow in way. We're gonna give

19922
20:13:30,410 --> 20:13:34,610
it the dye token address, give
it lending pool, and then we'll

19923
20:13:34,610 --> 20:13:38,120
give it deployer get you borrow
user data one more time just so

19924
20:13:38,120 --> 20:13:41,930
we can print out the final
amounts. Now, you'll notice

19925
20:13:41,930 --> 20:13:45,410
something though, we're going to
give back all of the dye that we

19926
20:13:45,410 --> 20:13:48,650
borrowed. However, we're still
going to have a dye balance,

19927
20:13:48,680 --> 20:13:51,980
you'll see that when I run this
that we're still have a little

19928
20:13:51,980 --> 20:13:54,050
bit of Aetherium borrowed,
basically, we'll still have a

19929
20:13:54,050 --> 20:13:56,750
dye balance because we'll still
have a little bit of die borrow

19930
20:13:56,780 --> 20:14:01,040
and try to figure out why before
I answer it actually. So we have

19931
20:14:01,040 --> 20:14:05,090
this tiny, tiny tiny amount of
eath borrowed here and we have a

19932
20:14:05,090 --> 20:14:08,090
much larger amount of eath
deposited so Why do we still

19933
20:14:08,090 --> 20:14:12,170
have this tiny, tiny amount of
eath borrowed? Well, the reason

19934
20:14:12,200 --> 20:14:16,760
is because as we borrow dye, we
actually accrued interest. So we

19935
20:14:16,760 --> 20:14:20,120
still owe dye back. Now what we
can do is we can do something

19936
20:14:20,120 --> 20:14:25,130
like uniswap, to actually swap
our Aetherium, for dye to repay

19937
20:14:25,160 --> 20:14:27,830
the rest of our debt here. And
that's how we could actually

19938
20:14:27,860 --> 20:14:31,070
finish repaying all the debt is
to get a little bit more dye to

19939
20:14:31,070 --> 20:14:34,280
pay off that interest that we
had accrued. And if you want,

19940
20:14:34,310 --> 20:14:37,490
you can go back and you can do
the exact same thing we did here

19941
20:14:37,550 --> 20:14:41,360
to grab the uniswap code, place
it in here to programmatically

19942
20:14:41,360 --> 20:14:45,020
repay your debt as well. But at
this point, you have just gone

19943
20:14:45,020 --> 20:14:48,410
through the entire lifecycle
here. And that is absolutely

19944
20:14:48,500 --> 20:14:53,030
massive, huge congratulations.
You've just deposited borrowed

19945
20:14:53,300 --> 20:15:00,260
and repaid tokens from the AVI
protocol. Now I'm going to go

19946
20:15:00,260 --> 20:15:03,530
briefly show you what some of
these transactions are going to

19947
20:15:03,530 --> 20:15:08,390
look like on an actual test net,
on an ether scan, you'll see

19948
20:15:08,420 --> 20:15:12,050
that when we deposit our
collateral, we actually get back

19949
20:15:12,080 --> 20:15:16,280
what's called an A token, or an
interest bearing token, these

19950
20:15:16,280 --> 20:15:20,480
tokens keep track of how much
collateral or in our case how

19951
20:15:20,480 --> 20:15:25,550
much web token we have deposited
in the AVI protocol. And when we

19952
20:15:25,550 --> 20:15:29,510
want to withdraw our wealth
back, we burn these eight

19953
20:15:29,510 --> 20:15:32,330
tokens, we remove these eight
tokens, you can see that our

19954
20:15:32,330 --> 20:15:35,600
first transaction is going to be
deposit and I wanted to show you

19955
20:15:35,600 --> 20:15:37,610
what it looks like when you
actually deposit one of these

19956
20:15:37,610 --> 20:15:40,340
tokens, this transaction
associated with this lending

19957
20:15:40,340 --> 20:15:43,700
pool, that deposit right here,
if you look at tokens transfer

19958
20:15:43,700 --> 20:15:47,120
down here, you can see we
actually we deposited, you can

19959
20:15:47,120 --> 20:15:52,550
see that we actually sent rapt
ether to the ARB a contract. Now

19960
20:15:52,550 --> 20:15:56,390
you'll also see this a weath
stuff here. So what is this a

19961
20:15:56,390 --> 20:16:00,380
with stuff. So to keep track of
how much you've actually

19962
20:16:00,380 --> 20:16:05,270
deposited into Ave, Ave will
give you your own a wealth token

19963
20:16:05,300 --> 20:16:09,020
or a token to keep track. And
this is this interest bearing

19964
20:16:09,020 --> 20:16:11,720
token, you actually can see up
here a little bit of interest

19965
20:16:11,720 --> 20:16:15,560
already for actually depositing
these tokens into the protocol.

19966
20:16:15,650 --> 20:16:19,340
And it's this token, that will
keep going up, the more people

19967
20:16:19,340 --> 20:16:21,500
borrow and the more people use
the protocol. So you can

19968
20:16:21,500 --> 20:16:24,740
actually grab this token
address, interest bearing token

19969
20:16:24,740 --> 20:16:29,330
this a token, I can import it
into my meta mask. And I can see

19970
20:16:29,390 --> 20:16:32,720
that I have 0.1, which
represents my initial deposit

19971
20:16:32,960 --> 20:16:39,320
00517 dot that dot A with and if
you keep this up long enough,

19972
20:16:39,500 --> 20:16:44,210
this number will slowly go up as
you get more and more. Because

19973
20:16:44,480 --> 20:16:48,290
the interest keep out and you
can see just went went up right

19974
20:16:48,290 --> 20:16:51,350
there, the interest will keep
changing and keep going up.

19975
20:16:51,470 --> 20:16:53,930
Obviously, we have so little
deposited that the interest

19976
20:16:53,930 --> 20:16:56,750
isn't gonna go up very quickly,
but it will go up, the more

19977
20:16:56,750 --> 20:16:59,960
people use the protocol. And
since I'm using a test net, the

19978
20:16:59,990 --> 20:17:03,050
actual usage of the protocol
isn't very high, but you get the

19979
20:17:03,050 --> 20:17:03,470
picture.

19980
20:17:06,080 --> 20:17:09,470
Awesome, you've done phenomenal
to get this far. Let's do a

19981
20:17:09,470 --> 20:17:12,440
quick recap of everything that
we've learned. And then we'll

19982
20:17:12,440 --> 20:17:16,070
head on to the next section. So
first, we learned about the web

19983
20:17:16,070 --> 20:17:20,000
token or the wrapped Aetherium
token, it's a way to tokenize

19984
20:17:20,060 --> 20:17:24,200
our Aetherium or layer one
blockchain native token. Then we

19985
20:17:24,200 --> 20:17:27,770
learned a little bit about the
AVI protocol, and how it's this

19986
20:17:27,770 --> 20:17:30,980
defy primitive for borrowing and
lending assets. And we can

19987
20:17:30,980 --> 20:17:34,040
actually gain interest by
depositing our tokens and our

19988
20:17:34,040 --> 20:17:37,040
assets into Ave we learned a
little bit of also about

19989
20:17:37,250 --> 20:17:40,250
uniswap, which is another
incredibly important defy

19990
20:17:40,250 --> 20:17:43,340
protocol, which allows us to
swap tokens between each other

19991
20:17:43,610 --> 20:17:47,420
in the decentralized context,
then we learned that we can

19992
20:17:47,420 --> 20:17:51,260
actually deposit some of our
tokens into the AVI protocol,

19993
20:17:51,260 --> 20:17:53,960
which is a decentralized
borrowing and lending platform

19994
20:17:53,990 --> 20:17:57,260
and similar to a bank will
actually gain interest on our

19995
20:17:57,290 --> 20:18:00,950
deposited tokens. But first, we
have to approve them. Because

19996
20:18:00,980 --> 20:18:04,820
anytime you want a contract to
interact with your tokens, you

19997
20:18:04,820 --> 20:18:07,940
need to approve the contract to
do so. And then we go ahead and

19998
20:18:07,940 --> 20:18:12,110
deposit once we deposited we got
the dye price. And then we

19999
20:18:12,110 --> 20:18:16,130
learned that we can actually
borrow dye we can borrow an

20000
20:18:16,130 --> 20:18:19,460
asset based off of how much
collateral we put down. And then

20001
20:18:19,460 --> 20:18:22,910
we learned how to repay it back.
We learned about forking a

20002
20:18:22,910 --> 20:18:26,780
blockchain as opposed to using
our own main blockchain. Another

20003
20:18:26,780 --> 20:18:29,690
thing to know if you are using
an RPC URL like something from

20004
20:18:29,690 --> 20:18:32,780
alchemy so awesome you've
learned a ton about defy now

20005
20:18:32,780 --> 20:18:36,920
defi is an absolutely massive
powerhouse when it comes to the

20006
20:18:36,920 --> 20:18:39,260
blockchain. And it is one of the
most important things

20007
20:18:39,260 --> 20:18:42,410
blockchains can do. If you want
to learn more about defy and

20008
20:18:42,410 --> 20:18:46,760
read more on Defy. I've got some
more links in the GitHub here so

20009
20:18:46,760 --> 20:18:48,950
that you can learn more about
defy and one of them in

20010
20:18:48,950 --> 20:18:53,120
particular that I want to show
you is this one called speed run

20011
20:18:53,150 --> 20:18:56,930
Etherium. Not only does it give
you a ton of defy examples, but

20012
20:18:56,930 --> 20:18:59,870
it gives you a whole bunch of
other examples as well. And this

20013
20:18:59,870 --> 20:19:01,850
will be a good test of
everything that you've learned

20014
20:19:01,880 --> 20:19:04,970
after you pass this course. Or
even right now if you want to or

20015
20:19:04,970 --> 20:19:08,060
whenever you want and to talk
about it a little bit more, we

20016
20:19:08,060 --> 20:19:10,820
actually have Austin Griffiths
here to talk a little bit more

20017
20:19:10,820 --> 20:19:13,370
about speed run Aetherium
himself, I'll pass it over to

20018
20:19:13,370 --> 20:19:13,820
Austin.

20019
20:19:16,400 --> 20:19:18,830
Hey, what's up, I'm Austin
Griffith, I want to show you

20020
20:19:18,830 --> 20:19:21,800
speed run Aetherium. speed run
Aetherium is a great way to get

20021
20:19:21,800 --> 20:19:25,190
started in Aetherium. If you are
a developer, it's targeted at

20022
20:19:25,190 --> 20:19:28,700
web two developers becoming web
three developers speed run a

20023
20:19:28,700 --> 20:19:32,120
theory. m.com is the website. It
takes you through both getting

20024
20:19:32,120 --> 20:19:35,210
started and kind of getting
getting an idea for the language

20025
20:19:35,210 --> 20:19:39,080
and the syntax. But that's just
the start. Just understanding

20026
20:19:39,080 --> 20:19:42,020
the language is just the start,
you feel like you're you can do

20027
20:19:42,020 --> 20:19:44,420
anything. And you're on the top
of the world when you finally

20028
20:19:44,420 --> 20:19:46,610
get the syntax of solidity
together, and you can jam

20029
20:19:46,610 --> 20:19:49,580
through a smart contract. But
really getting context with the

20030
20:19:49,580 --> 20:19:52,370
space and figuring out what
works and what doesn't, that's a

20031
20:19:52,370 --> 20:19:55,670
whole nother battle. And that's
where speed run aetherium.com

20032
20:19:55,670 --> 20:20:01,220
comes in. So let's speed run the
speed run. First, you will get

20033
20:20:01,220 --> 20:20:05,210
scaffold e down speedrun
Aetherium kind of revolves

20034
20:20:05,210 --> 20:20:09,380
around scaffold eath and uses
scaffold eath as a base, you'll

20035
20:20:09,410 --> 20:20:12,620
want to tinker around with some
ideas within solidity. And let

20036
20:20:12,620 --> 20:20:16,160
me show you what I mean by that.
So with scaffold eath, you have

20037
20:20:16,190 --> 20:20:20,870
a front end and you have your
smart contract. So scaffold eath

20038
20:20:20,870 --> 20:20:24,500
comes with hard hat out of the
box. And you will use the

20039
20:20:24,500 --> 20:20:28,880
combination of hard hat and
react to build a DAP where

20040
20:20:28,880 --> 20:20:32,420
you'll deploy both the smart
contract and the front end. And

20041
20:20:32,420 --> 20:20:37,190
this, this ability to edit your
smart contract and have your

20042
20:20:37,370 --> 20:20:41,060
front end auto adapt to it is
kind of the key to scaffold

20043
20:20:41,060 --> 20:20:44,300
ease. I just added some extra
extra exclamation points. But

20044
20:20:44,300 --> 20:20:46,700
we'll see that show up over
here. Once this contract

20045
20:20:46,700 --> 20:20:50,210
deploys, there we go, there's
that. So just real quick, again,

20046
20:20:50,240 --> 20:20:55,610
if I create like a un 256 public
counter, and we set that equal

20047
20:20:55,610 --> 20:20:59,120
to five, and then I build a
function called increment,

20048
20:20:59,330 --> 20:21:04,640
that's public that does counter
public, there we go, that does

20049
20:21:04,640 --> 20:21:07,490
counter plus, plus, you can
imagine what's going to happen

20050
20:21:07,490 --> 20:21:11,450
here. So you, you edit a little
bit of solidity, you deploy your

20051
20:21:11,450 --> 20:21:14,870
contract, and then your front
end auto adjust to that. And it

20052
20:21:14,870 --> 20:21:19,400
gives you the ability as a
developer to call those

20053
20:21:19,400 --> 20:21:22,760
functions tinker with your smart
contract to play around, you can

20054
20:21:22,760 --> 20:21:26,930
even have a console log in
there, where it you know, sets

20055
20:21:27,020 --> 20:21:32,870
says the count now is there we
go something like this. And

20056
20:21:32,870 --> 20:21:35,720
let's go ahead and deploy that.
Notice I'm doing these quick

20057
20:21:35,720 --> 20:21:38,570
iterations, I'm making small
changes in solidity, and I'm

20058
20:21:38,570 --> 20:21:41,810
seeing those changes show up in
the front end. And I'm tinkering

20059
20:21:41,810 --> 20:21:45,110
with those in the front end and
testing my assumptions. Here, if

20060
20:21:45,110 --> 20:21:49,700
we go look at our hard hat node,
when I make this increment call,

20061
20:21:50,060 --> 20:21:53,780
we should see that nice console
log there, you know, this

20062
20:21:53,810 --> 20:21:58,280
address, set the count to eight,
right? Very, very cool. So this

20063
20:21:58,280 --> 20:22:01,100
is scaffold eath. This is what
speed run Aetherium is built on

20064
20:22:01,100 --> 20:22:04,310
top of, you'll get in here,
you'll edit your smart contract,

20065
20:22:04,430 --> 20:22:06,980
then you'll edit your front end,
you'll point your front end at

20066
20:22:06,980 --> 20:22:09,470
some particular network, you'll
deploy your smart contract,

20067
20:22:09,470 --> 20:22:12,680
you'll deploy your app, it just
gives you the ability to have a

20068
20:22:12,680 --> 20:22:16,220
front end along with your smart
contract. And you'll have that

20069
20:22:16,220 --> 20:22:19,910
as you're building your smart,
smart contract. So to have this

20070
20:22:19,910 --> 20:22:22,820
front end, to tinker with your
smart contract is going to help

20071
20:22:22,820 --> 20:22:25,520
you kind of figure out how you
want to write your solidity,

20072
20:22:25,520 --> 20:22:27,830
like, is this going to be a
mapping? Is this going to be an

20073
20:22:27,830 --> 20:22:31,520
array? How am I going to track
this struct, you can kind of do

20074
20:22:31,520 --> 20:22:34,730
this in an iterative process by
just throwing it in here into

20075
20:22:34,730 --> 20:22:36,980
your smart contract and
tinkering with it on the front

20076
20:22:36,980 --> 20:22:40,070
end and trying it out and seeing
what you need to build. So

20077
20:22:40,070 --> 20:22:43,220
that's scaffold eath. And that's
the base that you'll need to get

20078
20:22:43,220 --> 20:22:47,060
started with speed run Ethereum.
Once you've you're able to have

20079
20:22:47,060 --> 20:22:49,820
this all installed, you'll
you'll have your kind of react

20080
20:22:49,820 --> 20:22:52,340
front end here with yarn start,
you'll have yarn chain, which

20081
20:22:52,340 --> 20:22:54,890
will run your your hard hat
node, then you'll do yarn

20082
20:22:54,890 --> 20:22:59,330
deploy. Once you have that setup
locally, you're ready to go with

20083
20:22:59,330 --> 20:23:02,810
speed run Aetherium. And you can
also do this right here and

20084
20:23:02,810 --> 20:23:06,110
challenge zero. So challenge
zero, gotta go zero index,

20085
20:23:06,110 --> 20:23:09,890
right, we got to be nerdy
challenge zero sets you up with

20086
20:23:09,890 --> 20:23:13,220
just getting the environment
setup, you'll you'll quest on

20087
20:23:13,220 --> 20:23:17,630
building a simple NFT example.
It's going to come with an NFT

20088
20:23:17,630 --> 20:23:20,690
smart contract. And it's going
to come with an NFT front end a

20089
20:23:20,690 --> 20:23:24,800
little kind of like minting
view, it'll come with all of

20090
20:23:24,800 --> 20:23:27,440
this stuff to do that. And it'll
walk you through basically

20091
20:23:27,440 --> 20:23:29,900
challenge the row is going to
hold your hand, it's going to

20092
20:23:29,900 --> 20:23:32,930
take you through every step
you'll have to get get you have

20093
20:23:32,930 --> 20:23:37,070
to have a certain version of
node E, L some some correct

20094
20:23:37,070 --> 20:23:40,700
range of node and yarn
installed. Watch out yarn has an

20095
20:23:40,700 --> 20:23:44,030
executable on Linux, make sure
you have the yarn, the package

20096
20:23:44,030 --> 20:23:48,590
manager. But after you have get
your node and yarn, you'll run

20097
20:23:48,590 --> 20:23:53,090
through cloning down each
challenge. You'll do an install,

20098
20:23:53,180 --> 20:23:55,700
you'll fire up the chain and
you'll fire up your front end.

20099
20:23:55,880 --> 20:23:58,850
And you'll have a working app
that lets you interface with

20100
20:23:58,850 --> 20:24:02,210
your NFT smart contract. You'll
go through here and you'll learn

20101
20:24:02,210 --> 20:24:06,620
about wallets. Then you'll start
minting NF Ts and you'll send

20102
20:24:06,620 --> 20:24:09,860
those NF T's are Round. And
that's challenge zero, it's just

20103
20:24:09,860 --> 20:24:14,270
getting you started. Here even
in challenge zero, you'll deploy

20104
20:24:14,270 --> 20:24:18,470
this NFT to Rinkeby. And you'll
also deploy an app and allow

20105
20:24:18,470 --> 20:24:22,700
your friends to go to your app
and mint in FTS on Rinkeby. So

20106
20:24:22,700 --> 20:24:25,640
that's the first challenge, it
looks like we even like dive

20107
20:24:25,640 --> 20:24:28,160
into open see and play around
with some of those mechanics.

20108
20:24:28,700 --> 20:24:32,150
The second challenge challenge
number one challenge one of

20109
20:24:32,150 --> 20:24:36,170
speed runner theory is like
where it all really starts. This

20110
20:24:36,170 --> 20:24:40,010
really shows off the superpower
of Aetherium. It sets it up. So

20111
20:24:40,790 --> 20:24:44,750
you need to build an app where a
bunch of people that don't

20112
20:24:44,750 --> 20:24:49,340
necessarily trust each other,
can coordinate and stake into a

20113
20:24:49,340 --> 20:24:51,980
smart contract. And this is
like, this is the superpower of

20114
20:24:51,980 --> 20:24:55,130
Aetherium. The ability for you,
the developer to write a few

20115
20:24:55,130 --> 20:25:00,200
simple rules to allow jerks to
coordinate financially, and not

20116
20:25:00,200 --> 20:25:03,050
greet each other and steal each
other's money, right? You're

20117
20:25:03,080 --> 20:25:06,110
we're building these financial
systems, there's, you know, game

20118
20:25:06,110 --> 20:25:09,500
theory and economics and so many
other things going on here. But

20119
20:25:09,500 --> 20:25:12,620
you as the developer, you're
writing simple rules, and you're

20120
20:25:12,620 --> 20:25:15,650
building a system that allows
people to coordinate. So

20121
20:25:15,650 --> 20:25:19,220
challenge one, we'll take you
through how to get set up with

20122
20:25:19,220 --> 20:25:22,190
your steak or docile, smart
contract, you'll install

20123
20:25:22,190 --> 20:25:25,280
everything exactly the same way,
you'll fire everything up. And

20124
20:25:25,280 --> 20:25:27,590
then it's just going to walk you
through the kinds of things that

20125
20:25:27,590 --> 20:25:29,960
you will need in your smart
contract. But you'll have to

20126
20:25:29,960 --> 20:25:33,800
write the solidity yourself. So
this is this is not going to be

20127
20:25:33,830 --> 20:25:38,060
a handheld tutorial, hell thing,
you're going to have to write

20128
20:25:38,060 --> 20:25:41,300
the smart contract yourself. And
there's some guidelines and some

20129
20:25:41,300 --> 20:25:44,240
rails that kind of help you out,
but it's not going to do it for

20130
20:25:44,240 --> 20:25:47,780
you. Okay, so that's, that's
Quest One is or that's

20131
20:25:47,780 --> 20:25:51,980
challenge. One is building a
decentralized staking app. Then

20132
20:25:51,980 --> 20:25:55,850
challenge two is building a
token vendor this so in

20133
20:25:55,850 --> 20:25:58,250
challenge one, you'll learn
things like how to send money

20134
20:25:58,250 --> 20:26:01,070
into a contract, how to have a
contract, keep track of

20135
20:26:01,070 --> 20:26:04,850
mappings. In challenge two,
you're going to learn contract

20136
20:26:04,850 --> 20:26:08,660
to contract interaction, you're
going to learn about ERC 20s,

20137
20:26:08,810 --> 20:26:11,180
you're going to learn about
specifically the approved

20138
20:26:11,180 --> 20:26:14,600
pattern, which is kind of a
jerk, it's, it's hard, it's a

20139
20:26:14,600 --> 20:26:18,170
hard thing to deal with is the
approved pattern, you need to go

20140
20:26:18,170 --> 20:26:21,350
to your token contract and
approve the vendor to take some

20141
20:26:21,350 --> 20:26:23,990
money, then in a second
transaction, you need to go to

20142
20:26:23,990 --> 20:26:27,140
the vendor and have the vendor
grab the money from the token

20143
20:26:27,140 --> 20:26:31,100
contract and do something else.
So that's that's challenge two

20144
20:26:31,100 --> 20:26:35,540
is learning about tokens and
vendors, and is starting to

20145
20:26:35,540 --> 20:26:39,650
really like get you kind of
exposed to the idea of this like

20146
20:26:39,650 --> 20:26:43,430
massive multiplayer game that is
Aetherium. And also kind of like

20147
20:26:43,460 --> 20:26:46,100
how to build these vending
machines that anybody can get

20148
20:26:46,100 --> 20:26:49,880
to, then you'll build a Dex. Now
once you've once you're done

20149
20:26:49,880 --> 20:26:53,180
with 01. And two, you're really
kind of you have a license to

20150
20:26:53,180 --> 20:26:55,850
learn at this point, you're
you're ready to really like go

20151
20:26:55,850 --> 20:26:58,820
do some damage and build some
cool things, maybe go build a

20152
20:26:58,820 --> 20:27:01,880
couple other things, but come
back and come come hit challenge

20153
20:27:01,880 --> 20:27:04,910
three, challenge three is going
to be a little bit more open

20154
20:27:04,910 --> 20:27:08,570
ended, there's going to be a
cohort of other people that are

20155
20:27:08,570 --> 20:27:11,720
also building this. And you have
to get through the first three

20156
20:27:11,720 --> 20:27:14,360
challenges to even get to
challenge three to even get to

20157
20:27:14,360 --> 20:27:17,330
this chat room. But there's a
chat room where other developers

20158
20:27:17,420 --> 20:27:20,720
that are also building their own
decks are all there together,

20159
20:27:20,720 --> 20:27:23,300
and you can kind of learn with
them and chat with them. But

20160
20:27:23,300 --> 20:27:25,790
you're going to build an
exchange. And you're going to

20161
20:27:25,790 --> 20:27:28,550
build an exchange that works in
a smart contract in a

20162
20:27:28,550 --> 20:27:33,410
decentralized way with no
centralized breaking points. And

20163
20:27:33,410 --> 20:27:35,210
what that's going to mean is
you're going to have to have

20164
20:27:35,210 --> 20:27:37,730
reserves of both eath and tokens
and you're gonna have to have a

20165
20:27:37,730 --> 20:27:41,870
pricing function and LP tokens
and all sorts of other things

20166
20:27:41,870 --> 20:27:44,810
that you'll have to learn about
as you get to it. Then challenge

20167
20:27:44,810 --> 20:27:49,340
five is a multi SIG wallet. Such
a fundamental important thing

20168
20:27:49,340 --> 20:27:52,490
about how to store your eath
safely is going to be in a multi

20169
20:27:52,490 --> 20:27:55,340
SIG wallet and how you can have
multiple identities even even

20170
20:27:55,340 --> 20:27:59,630
like the the base of like what a
Dow is, is sort of like starting

20171
20:27:59,630 --> 20:28:02,060
with a multi SIG wallet. And
you'll need to build one of

20172
20:28:02,060 --> 20:28:05,690
those you'll need to understand
call data call data is super

20173
20:28:05,690 --> 20:28:08,480
weird and complex. And
everything's a transaction even

20174
20:28:08,480 --> 20:28:10,670
when you're just poking a
contract. It's a transaction,

20175
20:28:10,940 --> 20:28:15,140
and you have to craft that call
data correctly to say, I would

20176
20:28:15,140 --> 20:28:17,840
like to call this specific
function on this specific

20177
20:28:17,840 --> 20:28:21,620
contract. So that's multisig
wallets and then it kind of ends

20178
20:28:21,620 --> 20:28:23,870
up we've got more challenges in
the pipeline, but it kind of

20179
20:28:23,900 --> 20:28:28,520
ends on build an SVG NFT so much
fun to build an NF t that crafts

20180
20:28:28,520 --> 20:28:32,510
the actual drawing in the smart
contract and renders it. So

20181
20:28:32,510 --> 20:28:36,200
that's the speed run, go speed
run Aetherium checkout scaffold,

20182
20:28:36,200 --> 20:28:39,320
eat start building, build
something awesome on Aetherium.

20183
20:28:39,350 --> 20:28:41,540
hearts, hearts, hearts, go get
them.

20184
20:28:41,840 --> 20:28:45,350
Austin Griffith is one of the
OGS when it comes to helping

20185
20:28:45,350 --> 20:28:48,380
engineers get caught up and up
to speed in the blockchain world

20186
20:28:48,380 --> 20:28:51,380
so massive thank you to Austin
for all he's done so far.

20187
20:28:56,790 --> 20:29:01,350
All right now we're gonna get
into NF T's. Let's do this. Now,

20188
20:29:01,350 --> 20:29:04,290
I've already made a number of
videos on what NF T's are and

20189
20:29:04,440 --> 20:29:06,780
how to start working with NF
T's. So we're going to watch a

20190
20:29:06,780 --> 20:29:10,800
portion of the previous Python
edition of this course where I

20191
20:29:10,800 --> 20:29:13,260
explain and a piece from a high
level and then of course, we're

20192
20:29:13,260 --> 20:29:17,070
gonna get into the ultimate NFT
tutorial. So let's learn about

20193
20:29:17,070 --> 20:29:20,520
NF T's look, NF T's are hot
right now. Nf T's also known as

20194
20:29:20,550 --> 20:29:24,480
ERC 720 ones are a token
standard that was created on the

20195
20:29:24,480 --> 20:29:28,230
Ethereum platform. Nf T stands
for non fungible token is a

20196
20:29:28,230 --> 20:29:32,280
token standard similar to the
ERC 20. Again, ERC 20 is like

20197
20:29:32,460 --> 20:29:36,330
link of a maker, all those
goodies that are found on the

20198
20:29:36,330 --> 20:29:41,280
Etherium chain. An NF T or a non
fungible token is a token that

20199
20:29:41,280 --> 20:29:44,940
is non fungible, this means that
they are starkly unique from

20200
20:29:44,940 --> 20:29:48,240
each other. And one token isn't
interchangeable with any other

20201
20:29:48,240 --> 20:29:51,570
token of its class. A good way
to think about it is $1 is

20202
20:29:51,570 --> 20:29:54,330
interchangeable with any other
dollar $1 is going to have the

20203
20:29:54,330 --> 20:29:57,870
same value of another dollar.
Those are fungible tokens that's

20204
20:29:57,870 --> 20:30:01,620
like ERC 20s one link is always
going to be equivalent to one

20205
20:30:01,650 --> 20:30:05,040
other link, by contrast is going
to be NF T's those of you nerds

20206
20:30:05,040 --> 20:30:08,070
out there, we know like a
Pokemon would be a good example

20207
20:30:08,070 --> 20:30:11,400
of an NFT you're one Pokemon is
going to have different stats,

20208
20:30:11,400 --> 20:30:14,400
different moves, sets, and isn't
interchangeable with any other

20209
20:30:14,400 --> 20:30:16,770
Pokemon, or maybe a more
relatable one. It's like a

20210
20:30:16,770 --> 20:30:20,550
trading card, or unique piece of
art or the like. So that's what

20211
20:30:20,550 --> 20:30:24,600
these NF T's are there non
fungible, non interchangeable

20212
20:30:24,600 --> 20:30:28,050
tokens that for the moment are
best represented or thought

20213
20:30:28,050 --> 20:30:32,520
about as digital pieces of art
that are incorruptible and have

20214
20:30:32,520 --> 20:30:35,850
a permanent history of whose own
them who's deployed them, etc.

20215
20:30:35,880 --> 20:30:39,240
Now, like I said, NF T's are
just a token standard. So you

20216
20:30:39,240 --> 20:30:41,940
can actually make them do much
more than just be art. You can

20217
20:30:41,940 --> 20:30:44,490
give them stats, you can make
them battle, you can do really

20218
20:30:44,490 --> 20:30:47,010
unique things with them, you can
do pretty much whatever you want

20219
20:30:47,010 --> 20:30:49,170
with them. But right now, the
easiest way to think about it,

20220
20:30:49,200 --> 20:30:51,510
and the most popular way to
think about it is by calling

20221
20:30:51,510 --> 20:31:00,960
them ah, ah, ah it's odd, or
some type of collectible or just

20222
20:31:00,960 --> 20:31:03,450
anything that's unique. Now,
they've been getting a ton of

20223
20:31:03,450 --> 20:31:05,910
buzz recently, because we've
been seeing more and more of

20224
20:31:05,910 --> 20:31:09,780
these being sold at insane
prices, like we saw x infinity

20225
20:31:09,780 --> 20:31:13,080
sell nine plots of their land
nine plots of their unique land

20226
20:31:13,200 --> 20:31:18,600
for $1.5 million. We also saw
the original creator of the Nyan

20227
20:31:18,600 --> 20:31:19,650
Cat, you know, this cat

20228
20:31:22,980 --> 20:31:26,820
sold for like 300 eath. So
apparently people really value

20229
20:31:26,820 --> 20:31:29,250
these things. So like I said,
they're just tokens that are

20230
20:31:29,250 --> 20:31:32,220
deployed on a smart contract
platform, and you can view them

20231
20:31:32,250 --> 20:31:35,940
on different NFT platforms like
open sea or wearable. And these

20232
20:31:35,940 --> 20:31:38,730
are the NFT marketplaces that
let people buy and sell them.

20233
20:31:38,760 --> 20:31:41,040
You obviously can do that
without these marketplaces,

20234
20:31:41,040 --> 20:31:44,190
because it's a decentralized but
they're helping give a good user

20235
20:31:44,190 --> 20:31:46,620
interface. Now, like many of you
out there, my initial thought to

20236
20:31:46,620 --> 20:31:49,680
NF T's was okay, this sounds
pretty dumb. But I think that

20237
20:31:49,710 --> 20:31:52,530
that was dumb. I think art does
have a lot of value. And I think

20238
20:31:52,560 --> 20:31:55,800
that artists are not always paid
fairly for what they do. And

20239
20:31:55,800 --> 20:31:57,660
this is actually a huge issue
right now in the modern day

20240
20:31:57,660 --> 20:32:00,300
world where an artist can make
some type of art people just

20241
20:32:00,300 --> 20:32:03,060
copy paste it, you know,
everywhere and, and they never

20242
20:32:03,060 --> 20:32:06,690
get attribution for what they
make. So having a really easy

20243
20:32:06,720 --> 20:32:10,560
decentralized royalty mechanism,
or some type of mechanism where

20244
20:32:10,560 --> 20:32:13,200
these artists can get accurately
comped for what they're doing, I

20245
20:32:13,200 --> 20:32:16,260
think, is really important. I
love music. I love movies, those

20246
20:32:16,260 --> 20:32:19,680
are pieces of art that I digest.
And I really like and I think

20247
20:32:19,680 --> 20:32:22,170
it's fair for them to get comped
appropriately because they are

20248
20:32:22,170 --> 20:32:24,570
providing value to my life. I
think NF T's are a great way to

20249
20:32:24,570 --> 20:32:27,450
solve this issue as kind of
having these decentralized audit

20250
20:32:27,450 --> 20:32:30,660
trails and, and royalty trails
that we can set up and, and see

20251
20:32:30,660 --> 20:32:32,640
really transparently without
having to go through some

20252
20:32:32,640 --> 20:32:35,790
centralized service. So that's
the basic gist of it. Let's talk

20253
20:32:35,790 --> 20:32:40,230
some more about the standards
ERC 721 standard are the NFT

20254
20:32:40,230 --> 20:32:43,350
standard. This is the basis of
it all there is another standard

20255
20:32:43,350 --> 20:32:47,640
that's semi fungible tokens, the
1155 We're not going to talk

20256
20:32:47,640 --> 20:32:49,620
about that here. But you can
check it out the main

20257
20:32:49,620 --> 20:32:53,670
differences between a 721 and
the ERC 20 and ERC. 20 is they

20258
20:32:53,670 --> 20:32:56,580
have a really simple mapping
between an address and how much

20259
20:32:56,580 --> 20:33:00,420
that address holds. 720 ones
have unique token IDs, each

20260
20:33:00,420 --> 20:33:03,660
token ID has a unique owner. And
in addition, they have what's

20261
20:33:03,660 --> 20:33:06,750
called a token URI, which we'll
talk about in a minute. Each

20262
20:33:06,750 --> 20:33:11,130
token is unique. Each token ID
represents a unique asset. So

20263
20:33:11,130 --> 20:33:13,290
since these assets are unique,
and we want to be able to

20264
20:33:13,290 --> 20:33:15,660
visualize them and show what
they actually look like we need

20265
20:33:15,660 --> 20:33:18,480
to define those attributes of
the object. If it's a piece of

20266
20:33:18,480 --> 20:33:21,120
art, we needed a way to define
what that art looks like. If

20267
20:33:21,120 --> 20:33:24,000
it's some type of character in a
game, we need to wait define

20268
20:33:24,000 --> 20:33:28,080
that character stats in the NFT.
This is where metadata and token

20269
20:33:28,080 --> 20:33:30,720
URI has come in. So if you know
anything about Aetherium, you

20270
20:33:30,720 --> 20:33:33,420
know that sometimes gas prices
getting pretty high, especially

20271
20:33:33,420 --> 20:33:36,000
when it comes to storing a lot
of space, it can get really,

20272
20:33:36,000 --> 20:33:38,880
really expensive. So one of your
first questions might be Well,

20273
20:33:38,910 --> 20:33:42,540
are they storing these images?
And these are pieces on chain?

20274
20:33:42,570 --> 20:33:45,540
And the answer is sometimes back
when they were coming up with NF

20275
20:33:45,540 --> 20:33:48,300
T's and artists were deploying
stuff, the eath devs and the

20276
20:33:48,300 --> 20:33:50,940
artists were like yeah, art,
let's do that art. I'm just

20277
20:33:50,940 --> 20:33:54,150
gonna deploy This one megabyte
image onto the Etherium chain.

20278
20:33:54,450 --> 20:33:59,460
And Oh god, it's so much gas
expensive, delete button.

20279
20:34:00,390 --> 20:34:05,400
Otherwise, it's not, it's not
good. And they realized that if

20280
20:34:05,400 --> 20:34:07,350
they put all this art on chain,
it's going to be incredibly

20281
20:34:07,350 --> 20:34:10,080
expensive. So to get around
this, what they did is they put

20282
20:34:10,080 --> 20:34:12,810
in the standard, what's called
the token URI. This is a

20283
20:34:12,810 --> 20:34:16,710
universally unique indicator of
what that asset or what that

20284
20:34:16,710 --> 20:34:19,980
token looks like and what the
attributes of the token are, you

20285
20:34:19,980 --> 20:34:23,160
can use something like a
centralized API, or IPFS. To

20286
20:34:23,160 --> 20:34:26,550
actually get that token URI.
Typical token URI has to return

20287
20:34:26,550 --> 20:34:29,220
something in this format like
this, where it has the name, the

20288
20:34:29,220 --> 20:34:31,650
image, location, the
description, and then any

20289
20:34:31,650 --> 20:34:35,040
attributes below, there is often
this talk of on chain metadata

20290
20:34:35,040 --> 20:34:37,950
versus off chain metadata.
Because it is so much easier and

20291
20:34:37,950 --> 20:34:40,710
cheaper to store all your
metadata off chain, a lot of

20292
20:34:40,710 --> 20:34:44,130
people will use something like
IPFS that is decentralized, but

20293
20:34:44,280 --> 20:34:46,710
does take a little bit of
centrality to keep persisting,

20294
20:34:46,740 --> 20:34:49,440
but they can also use their own
centralized API. However,

20295
20:34:49,440 --> 20:34:52,080
obviously, if that goes down,
then you lose your image, you

20296
20:34:52,080 --> 20:34:54,690
lose everything associated with
your NFT. Because of this most

20297
20:34:54,690 --> 20:34:57,990
NFT marketplaces actually can't
and won't read off on chain

20298
20:34:57,990 --> 20:35:00,870
attributes or on chain metadata,
because they're so used to

20299
20:35:00,870 --> 20:35:03,930
looking for the token URI.
Obviously, if you do off chain

20300
20:35:03,930 --> 20:35:06,570
metadata, you can't do anything
really cool or really

20301
20:35:06,570 --> 20:35:09,180
interesting or have any gains
with your NF T's. For example,

20302
20:35:09,180 --> 20:35:11,880
if you wanted to create an on
chain Pokemon game, all your

20303
20:35:11,880 --> 20:35:14,760
attributes would need to be on
chain in order for your Pokemon

20304
20:35:14,760 --> 20:35:17,310
to interact with each other.
Because if it was off chain,

20305
20:35:17,370 --> 20:35:20,250
then that becomes a lot harder
to cryptographically prove. So

20306
20:35:20,280 --> 20:35:22,290
if you're new with NF T's and
you're like wait, this is kind

20307
20:35:22,290 --> 20:35:24,750
of a lot of information, I'll
make it easy for you. If you're

20308
20:35:24,750 --> 20:35:28,350
looking to render an image, I'm
an NFT, add your image to IPFS,

20309
20:35:28,380 --> 20:35:31,920
add a metadata file pointing to
that image file on IPFS. And

20310
20:35:31,920 --> 20:35:35,130
then grab that token URI and put
it and set it as your NFT. The

20311
20:35:35,130 --> 20:35:38,010
chain link DND article does a
great job of walking you through

20312
20:35:38,010 --> 20:35:40,500
this and showing you how to do
this. So be sure to read that if

20313
20:35:40,500 --> 20:35:42,540
you're looking to learn how to
do that we're not going to cover

20314
20:35:42,540 --> 20:35:45,390
that in this video, but we will
be deploying our first NFT with

20315
20:35:45,390 --> 20:35:48,810
some on chain attributes. Again,
having your attributes on chain

20316
20:35:48,840 --> 20:35:52,290
is really going to allow you to
build really creative NF T's

20317
20:35:52,470 --> 20:35:55,170
that build games or have
interesting properties and and

20318
20:35:55,170 --> 20:35:58,230
really makes the authenticity of
your NFT guaranteed because

20319
20:35:58,230 --> 20:36:00,240
those attributes are always
going to be on chain.

20320
20:36:02,970 --> 20:36:06,300
Alright, so now that we know the
basics of approximately what an

20321
20:36:06,300 --> 20:36:11,700
NF t is, and similar to the ERC
20 You can see the E IP 721 or

20322
20:36:11,700 --> 20:36:16,530
the ERC 721 non fungible token
standard on the Aetherium, ie

20323
20:36:16,530 --> 20:36:19,800
IPs. And once again, if you
scroll down, you can see all the

20324
20:36:19,800 --> 20:36:22,890
different events and the
different functions that come

20325
20:36:22,890 --> 20:36:26,010
with creating this token. And
now everything that we're going

20326
20:36:26,010 --> 20:36:30,000
to do is going to be available
at this GitHub repo. This hard

20327
20:36:30,000 --> 20:36:33,780
hat NFT FCC, we're going to
actually go through all the code

20328
20:36:33,780 --> 20:36:39,060
down to deploying and creating
our own customized NFT. And I've

20329
20:36:39,060 --> 20:36:42,720
labeled this the ultimate NFT
repo as part of this course,

20330
20:36:42,720 --> 20:36:45,600
because we're going to go
through a lot here, we're gonna

20331
20:36:45,600 --> 20:36:50,460
go through a basic NFT, a real
minimalistic NFT and then an

20332
20:36:50,460 --> 20:36:54,990
IPFS hosted NFT. That is
dynamic. And it uses randomness

20333
20:36:54,990 --> 20:36:59,430
to generate unique NF T's so
that we can have provably rare

20334
20:36:59,550 --> 20:37:03,660
and appease or provably rare
cards or provably rare tokens or

20335
20:37:03,660 --> 20:37:07,110
stats or whatever you want. And
then we're going to do what's

20336
20:37:07,110 --> 20:37:12,240
called an SVG NFT. These are
entities that are 100 percent hosted on

20337
20:37:12,240 --> 20:37:15,690
chain, so you don't need an off
chain. So you don't need IPFS,

20338
20:37:15,690 --> 20:37:18,630
you don't need an off chain
database. And this one's also

20339
20:37:18,630 --> 20:37:21,450
going to be dynamic, where it's
going to use price feeds in

20340
20:37:21,450 --> 20:37:24,780
order to fluctuate what the
image of the entity actually

20341
20:37:24,780 --> 20:37:27,690
looks like based off the price
of some asset. And here are the

20342
20:37:27,690 --> 20:37:30,030
images that we're going to be
using. And we obviously have

20343
20:37:30,030 --> 20:37:33,120
these three adorable doggies
here. If you want to follow

20344
20:37:33,120 --> 20:37:35,790
along with the Quickstart, you
absolutely can. And I'm going to

20345
20:37:35,790 --> 20:37:38,970
do a quick overview of just
running the code to show you

20346
20:37:38,970 --> 20:37:42,330
what it's going to look like at
the end. Basically, what we're

20347
20:37:42,330 --> 20:37:44,940
going to do is we're going to
have our code, we're going to

20348
20:37:44,940 --> 20:37:50,760
run hardhat deploy dash dash
network, rink B, dash dash tags

20349
20:37:50,760 --> 20:37:53,940
main. And this is going to
deploy all of our contracts and

20350
20:37:53,940 --> 20:37:57,990
everything. And then finally, if
we go to test nets dot open c.io

20351
20:37:58,200 --> 20:38:02,430
And we grab the address of one
of these NF T's we should be

20352
20:38:02,430 --> 20:38:06,420
able to put it in here see our
actual NFT as a collection with

20353
20:38:06,420 --> 20:38:10,410
an item. Or Additionally, we can
just go right to the contract.

20354
20:38:10,860 --> 20:38:14,550
We can read the contract, we can
get the token URI, and then we

20355
20:38:14,550 --> 20:38:18,750
can copy this token here, I
paste it into our browser or any

20356
20:38:18,750 --> 20:38:22,950
IPFS is into our browser, and
then grab the image attribute

20357
20:38:22,950 --> 20:38:26,190
and see what this actually looks
like on chain. So with all that

20358
20:38:26,190 --> 20:38:30,600
being said, let's learn how to
build this ultimate NFT repo and

20359
20:38:30,600 --> 20:38:34,290
build all of these different
customizable NF T's let's jump

20360
20:38:34,290 --> 20:38:39,450
in. So once again, we're in our
terminal I'm going to create a

20361
20:38:39,450 --> 20:38:43,800
new directory. We're gonna call
it hard hat and a T for FCC.

20362
20:38:44,400 --> 20:38:47,850
We're gonna cd into that. And if
T FCC and we're going to open

20363
20:38:47,850 --> 20:38:52,110
that up with code.or, you can
hit File, Open Folder At this

20364
20:38:52,110 --> 20:38:55,200
point, you'll have gotten pretty
familiar with the setup of our

20365
20:38:55,200 --> 20:38:58,320
code bases here, feel free to
copy over or do whatever you

20366
20:38:58,320 --> 20:39:02,040
want to do for our setup, we'll
do yarn, add dash dash dev hard

20367
20:39:02,040 --> 20:39:05,460
hat. And then while that's
loading, I'm going to copy over

20368
20:39:05,460 --> 20:39:08,370
my prettier files. Because I
want to use prettier, I'm going

20369
20:39:08,370 --> 20:39:12,900
to copy over my hard
hat.config.js. And I'm also

20370
20:39:12,900 --> 20:39:16,710
going to grab my package that
Jason copied over here, I'm

20371
20:39:16,710 --> 20:39:20,160
going to delete this old package
dot JSON. And I'm just going to

20372
20:39:20,280 --> 20:39:23,520
hit Enter on this and rename the
one I just copied over from

20373
20:39:23,520 --> 20:39:26,970
package copy to package json.
And the reason I'm doing this is

20374
20:39:26,970 --> 20:39:30,690
so that I can just go ahead and
run yarn and install all this

20375
20:39:30,690 --> 20:39:33,240
stuff for me. Or we can just
come back over here and just

20376
20:39:33,240 --> 20:39:36,540
grab this lesson nine hard hat,
smart contract lottery, all that

20377
20:39:36,540 --> 20:39:40,620
stuff, again, just run that
massive piece as well. Or you

20378
20:39:40,620 --> 20:39:43,590
can copy over your package json,
and then just run yarn that will

20379
20:39:43,590 --> 20:39:45,930
do the same thing. Now we don't
have to keep doing this

20380
20:39:45,930 --> 20:39:48,540
boilerplate over and over and
over again. And then while

20381
20:39:48,540 --> 20:39:51,030
that's loading, I'm also going
to grab my Dotty and v file that

20382
20:39:51,030 --> 20:39:53,100
we've been using on a past
couple of projects, the

20383
20:39:53,100 --> 20:39:56,310
readme.md. And we'll just do
what we're gonna be doing here.

20384
20:39:56,340 --> 20:39:58,740
So we're going to make three
different contracts. One is

20385
20:39:58,740 --> 20:40:03,720
going to be a basic NFT, using
that ERC 721 standard, then

20386
20:40:04,020 --> 20:40:08,850
we're gonna do a random IPFS
hosted NF t. And then finally,

20387
20:40:09,240 --> 20:40:15,840
we're going to do a dynamic S V
G NFT. So our random NF T is

20388
20:40:15,840 --> 20:40:18,450
going to be random at creation
time, this is going to give some

20389
20:40:18,450 --> 20:40:22,710
true scarcity and some true
randomness to our NF T. And it's

20390
20:40:22,710 --> 20:40:27,660
gonna be hosted on IPFS. Our
dynamic SVG NFT is going to be

20391
20:40:27,660 --> 20:40:32,430
hosted 100 percent on chain, and the
image of it's going to change

20392
20:40:32,580 --> 20:40:35,610
based off of some parameters.
That's what makes it a dynamic

20393
20:40:35,610 --> 20:40:36,720
SVG NFT.

20394
20:40:39,450 --> 20:40:41,760
Let's go ahead and we'll create
a new folder, we'll create our

20395
20:40:41,760 --> 20:40:45,900
contracts folder, and we will
create our first NF t this is

20396
20:40:45,900 --> 20:40:49,230
going to be our basic NFT. And
I'm going to go a little bit

20397
20:40:49,230 --> 20:40:52,380
quick here, because most of what
we're going to be doing is

20398
20:40:52,380 --> 20:40:55,170
actually things that we're
already familiar with. So we'll

20399
20:40:55,170 --> 20:40:59,730
do basic NF T dot soul in a new
file. And let's go ahead and

20400
20:40:59,730 --> 20:41:04,140
let's do it. Let's go ahead and
we'll do spdx license

20401
20:41:04,230 --> 20:41:09,750
identifier, it's gonna be MIT.
We'll do pragma, solidity,

20402
20:41:10,050 --> 20:41:15,090
carrot zero, point 8.7 pragma,
solidity, and then we'll do

20403
20:41:15,090 --> 20:41:21,870
contract, basic NF t. Let me
just basic, get a t.so, like

20404
20:41:21,870 --> 20:41:25,110
that. And we'll say contract
basic NF t. And then we'll just

20405
20:41:25,110 --> 20:41:28,290
run hard at compile or yarn
hard, hit compile, and it looks

20406
20:41:28,290 --> 20:41:31,500
like we're doing well here so
far. Okay, perfect. Based off of

20407
20:41:31,500 --> 20:41:35,700
that NFT token standard, we go
back that EIP, we're going to

20408
20:41:35,700 --> 20:41:38,040
need a whole bunch of different
functions here, we're going to

20409
20:41:38,040 --> 20:41:41,370
need transfer events, we're
going to need owner events

20410
20:41:41,370 --> 20:41:44,940
bounce up, we're going to all
these different functions. And

20411
20:41:44,940 --> 20:41:48,630
we could 100 percent implement these
and transfer them exactly like

20412
20:41:48,630 --> 20:41:53,400
the ERC 20 did, or once again,
so we can use, you guessed it,

20413
20:41:53,400 --> 20:41:56,160
we're gonna be using open
Zeppelin contracts for this as

20414
20:41:56,160 --> 20:41:58,620
well. So we come back over to
open Zeppelin, we go over to

20415
20:41:58,620 --> 20:42:01,920
contracts. And we're gonna go
ahead and add this with yarn,

20416
20:42:01,950 --> 20:42:07,380
add dash dash Dev. So yarn, add
dash dash dev at opens up on

20417
20:42:07,380 --> 20:42:11,070
contracts, like so. And while
that's going through, we can

20418
20:42:11,070 --> 20:42:16,110
look at the ERC 721 of this and
we can see what creating a

20419
20:42:16,110 --> 20:42:19,650
minimalist ERC 721 looks like.
Now there's a number of

20420
20:42:19,650 --> 20:42:23,700
extensions that come with its
ERC. 721 In this example that

20421
20:42:23,700 --> 20:42:28,200
they give us. They're using ERC
721 Uri storage, which we'll

20422
20:42:28,200 --> 20:42:31,170
talk about in a little bit. So
we've added it in here. And now

20423
20:42:31,170 --> 20:42:34,710
we can actually import that ERC
21 from opens up when in our

20424
20:42:34,710 --> 20:42:39,750
contract. So we'll do import at
open Zeppelin slash contracts

20425
20:42:39,750 --> 20:42:46,200
slash token slash your C 721
slash ERC. 721 does so they use

20426
20:42:46,200 --> 20:42:49,950
a different one in the demo, but
don't worry about that. And same

20427
20:42:49,950 --> 20:42:56,490
as the ERC. 20 we're gonna say
our basic NFT is ERC 721. So

20428
20:42:56,490 --> 20:43:00,000
we're doing this inheritance,
you find the constructor, we can

20429
20:43:00,000 --> 20:43:03,390
see this has a constructor,
where it takes a name and a

20430
20:43:03,390 --> 20:43:07,560
symbol. So we're gonna want to
use this constructor and our

20431
20:43:07,560 --> 20:43:11,340
contract. So we're gonna say,
construct door.

20432
20:43:12,630 --> 20:43:16,200
And our constructor is just
going to be blank. But we'll do

20433
20:43:16,350 --> 20:43:21,030
the ERC 721 constructor and
we'll call this a doggie. And

20434
20:43:21,030 --> 20:43:25,170
the symbol will be dog just like
that. Our basic NFT we're just

20435
20:43:25,170 --> 20:43:27,870
going to have it be this doggy
here, right so it's going to be

20436
20:43:27,870 --> 20:43:31,680
an NF T of just a purely this
dog here. The name is going to

20437
20:43:31,680 --> 20:43:34,830
be doggy and the symbol is going
to be dog. Now in order to

20438
20:43:34,830 --> 20:43:39,690
create new dogs. What we're
going to do is openzeppelin code

20439
20:43:39,690 --> 20:43:43,410
comes with something called a
mint function exactly the same

20440
20:43:43,770 --> 20:43:48,360
as the ERC 20 So we're going to
create a function called mint

20441
20:43:48,810 --> 20:43:53,220
NFT this will be a public file
function that's going to return

20442
20:43:53,310 --> 20:43:58,710
you activity six. And we'll use
the safe mint function of this

20443
20:43:58,710 --> 20:44:05,310
ERC 20 or underscore safe mint
message dot sender will mint the

20444
20:44:05,310 --> 20:44:09,810
token to whoever calls this mint
function. And then we need to

20445
20:44:09,810 --> 20:44:13,620
also give this a token ID, if
we're looking back at the code

20446
20:44:13,620 --> 20:44:17,010
for the ERC 721. And again, you
can see this on GitHub as well,

20447
20:44:17,100 --> 20:44:19,740
we're gonna look at this safe
mint function, it takes an

20448
20:44:19,740 --> 20:44:24,750
address to who is going to own
the NFT. And then a token ID,

20449
20:44:24,840 --> 20:44:28,950
what is the ID of the token
based off of this address. So if

20450
20:44:28,950 --> 20:44:32,280
you have a collection of tokens
on the same smart contract, each

20451
20:44:32,280 --> 20:44:35,370
one of them needs their own
unique token ID. So what we're

20452
20:44:35,370 --> 20:44:39,990
gonna do is we're gonna create a
un 256, private variable called

20453
20:44:39,990 --> 20:44:44,430
S underscore token counter, and
it's gonna get initialized in

20454
20:44:44,430 --> 20:44:47,400
our constructor to zero, but
we'll just be explicit and say

20455
20:44:47,400 --> 20:44:51,120
es token counter equals zero.
And then in here, we'll just

20456
20:44:51,120 --> 20:44:56,880
have the token ID of this new NF
t be that token counter. And

20457
20:44:56,880 --> 20:45:00,210
then of course, we'll say s
token counter equals s token

20458
20:45:00,210 --> 20:45:04,860
counter plus one. So every time
we meant a new NFT, we up the

20459
20:45:04,860 --> 20:45:08,550
token counter, and then we'll
just return, we'll just return

20460
20:45:08,550 --> 20:45:11,430
the new tab counter. Right. And
then obviously, at the bottom,

20461
20:45:11,430 --> 20:45:14,460
we could do like function, get
token counter, this would be a

20462
20:45:14,460 --> 20:45:19,110
public view returns you in 256.
And I'm gonna go a little quick

20463
20:45:19,110 --> 20:45:22,470
here, because you've seen this
before, return s underscore

20464
20:45:22,500 --> 20:45:26,220
token counter, right, since it's
a private variable up here, the

20465
20:45:26,220 --> 20:45:29,970
public function down here to get
that token counter. So this

20466
20:45:30,000 --> 20:45:33,510
technically, is it. This is
technically an NF T. But what

20467
20:45:33,510 --> 20:45:36,480
does this look like? Well, right
now, this NF T isn't going to

20468
20:45:36,480 --> 20:45:41,790
look like anything at all, in
this EIP token standard. It has

20469
20:45:41,790 --> 20:45:44,790
this thing called a token URI.
And this is the important

20470
20:45:44,790 --> 20:45:48,510
function that tells us exactly
what this token is going to look

20471
20:45:48,510 --> 20:45:52,260
like. Like what we said in the
mini lesson here. This token URI

20472
20:45:52,320 --> 20:45:56,400
returns some type of URL or
universal resource identifier

20473
20:45:56,790 --> 20:46:00,120
that returns some JSON that
looks like this. And in this

20474
20:46:00,120 --> 20:46:03,240
JSON, we're going to have this
image part. And this image is

20475
20:46:03,240 --> 20:46:07,050
going to be a URL that's going
to point to what this image

20476
20:46:07,050 --> 20:46:10,320
actually looks like. Now this
URL can be hosted on chain, it

20477
20:46:10,320 --> 20:46:13,740
can be hosted on IPFS, it can be
hosted really wherever. But

20478
20:46:13,740 --> 20:46:16,920
ideally, we're not going to use
a centralized server to host it.

20479
20:46:16,950 --> 20:46:19,710
If this is hosted on a Google
Cloud or a centralized server or

20480
20:46:19,710 --> 20:46:22,440
whatever, and our centralized
server goes down. Well guess

20481
20:46:22,440 --> 20:46:24,540
what this MC is gonna look like,
it's not gonna look like

20482
20:46:24,540 --> 20:46:27,960
anything. So we want to use some
type of decentralized storage,

20483
20:46:28,230 --> 20:46:32,430
to get a URL, or URI to store
what this looks like. To make

20484
20:46:32,430 --> 20:46:35,460
this section a little bit easier
for you, I've actually already

20485
20:46:35,460 --> 20:46:40,560
gone ahead and hosted an image
to IPFS. For you, it's going to

20486
20:46:40,560 --> 20:46:44,880
be at IPFS dot dot slash slash,
it's going to look like this,

20487
20:46:44,940 --> 20:46:47,490
this is going to be the image
that we're going to use for our

20488
20:46:47,490 --> 20:46:51,300
dog here. If you create just
this image, though, as the token

20489
20:46:51,300 --> 20:46:55,830
URI, that's not going to work,
we need a URI that returns this,

20490
20:46:56,220 --> 20:46:59,400
with the image inside of it. Now
for this first section, have

20491
20:46:59,400 --> 20:47:01,650
already gone ahead and done that
for you as well. And that's

20492
20:47:01,650 --> 20:47:05,040
going to be located here. This
is what our token URI function

20493
20:47:05,070 --> 20:47:07,740
needs to return. So it's going
to have the name, the

20494
20:47:07,740 --> 20:47:11,970
description, the image URI,
which then points to the dog,

20495
20:47:12,120 --> 20:47:15,690
and then some attributes, etc,
etc. Now, you'll notice that the

20496
20:47:15,690 --> 20:47:21,720
image here is pointing to HTTPS,
dot dot slash slash ipfs.io. The

20497
20:47:21,720 --> 20:47:24,360
reason I did this was again,
just in case you didn't have the

20498
20:47:24,360 --> 20:47:28,020
IPFS gateway, but this would be
a lot better if this was in its

20499
20:47:28,020 --> 20:47:33,330
IPFS form. Because if the
centralized server ipfs.io, goes

20500
20:47:33,360 --> 20:47:38,310
ever goes down, this NFT will
show what it'll show nothing. So

20501
20:47:38,340 --> 20:47:44,010
it would be much better. If it
was instead of ipfs.io. It was

20502
20:47:44,070 --> 20:47:49,680
IPFS, colon slash slash, like
that, instead of ipfs.io. But

20503
20:47:49,680 --> 20:47:51,840
for now, this is what we're
going to be using. And you can

20504
20:47:51,840 --> 20:47:56,250
just go to the GitHub for this,
just to grab this for this

20505
20:47:56,250 --> 20:48:00,870
section. Right? Just go to
contracts, basic NFT, you can

20506
20:48:00,870 --> 20:48:04,770
just grab this, this, this top
part, just copy it like that. So

20507
20:48:04,770 --> 20:48:09,120
we're going to paste that the
token URI up, up, up at the top,

20508
20:48:09,180 --> 20:48:14,700
like so. Oh, it should be
returns, return. There we go.

20509
20:48:14,760 --> 20:48:17,730
Okay, cool. So we're just going
to copy paste that in here like

20510
20:48:17,730 --> 20:48:22,080
this. Like I said, even though
the token URI here is pointing

20511
20:48:22,080 --> 20:48:26,220
directly to IPFS, which is good.
If you actually go to this file,

20512
20:48:26,370 --> 20:48:31,350
the file is actually pointing to
http.ipfs.io. Again, for your NF

20513
20:48:31,350 --> 20:48:35,730
T's don't do that for this NFT.
I just did that just in case,

20514
20:48:35,940 --> 20:48:38,220
but for your NF T's don't do
that. And we're going to make

20515
20:48:38,220 --> 20:48:42,240
this a public constant variable.
Why? Well, because this token

20516
20:48:42,240 --> 20:48:44,880
you write is never going to
change. We're going to make this

20517
20:48:44,880 --> 20:48:48,810
NFT so that everybody who meets
one will have this exact same

20518
20:48:48,870 --> 20:48:52,980
adorable little puck here. And
the way we do That now is we

20519
20:48:52,980 --> 20:48:56,850
need to identify the actual
token URI function. So I'm going

20520
20:48:56,850 --> 20:48:59,280
to do it above get token
counter, we're going to say

20521
20:48:59,280 --> 20:49:07,080
function, token URI. And these
always take a UNT 256 token ID,

20522
20:49:08,370 --> 20:49:14,010
we're going to make this a
public view, override returns

20523
20:49:14,670 --> 20:49:22,290
string memory. And this needs to
return the token URI. Now, this

20524
20:49:22,290 --> 20:49:26,040
is going to be the most basic
way to create this, right. And

20525
20:49:26,040 --> 20:49:29,160
if we wanted to make this
function a little nicer, we'd

20526
20:49:29,160 --> 20:49:32,700
comment out token ID as well,
since we're actually not using

20527
20:49:32,850 --> 20:49:38,610
token ID. But we're overriding
in our in the ERC 721 that we're

20528
20:49:38,610 --> 20:49:42,750
importing. This has a token ID
function or a token URI

20529
20:49:42,750 --> 20:49:46,410
function. And we're overriding
this, right, we're not using

20530
20:49:46,410 --> 20:49:48,960
this at all, we're saying, Hey,
we're just going to use our own

20531
20:49:48,960 --> 20:49:53,190
here. And that's all we need for
this to work. And now if you

20532
20:49:53,190 --> 20:49:55,830
were to deploy this to rink B,
if you were to jump over to open

20533
20:49:55,830 --> 20:49:59,460
C test net, and you would deploy
this, this dog, this adorable

20534
20:49:59,460 --> 20:50:03,960
little pop would be what shows
up for all the minutes. So let's

20535
20:50:03,960 --> 20:50:06,660
go ahead, and let's create a
little deploy function for this.

20536
20:50:06,840 --> 20:50:11,340
So we'll do a new folder, deploy
a new file, we'll call this a

20537
20:50:11,340 --> 20:50:17,400
one deploy basic NF T dot j s.
And this is going to look real

20538
20:50:17,400 --> 20:50:19,830
similar to everything that we've
done before. So I'm going to

20539
20:50:19,830 --> 20:50:25,860
move a little bit quicker here.
const network equals require

20540
20:50:25,980 --> 20:50:33,360
hard hats, const development
chains, equals require dot dot

20541
20:50:33,360 --> 20:50:38,250
slash helper, hard hats config.
And I don't think I added that.

20542
20:50:38,280 --> 20:50:42,150
So I'm going to copy paste my
helper Hardhead config from our

20543
20:50:42,150 --> 20:50:45,090
last project. And if you get
confused, you can always just

20544
20:50:45,090 --> 20:50:49,050
come to the GitHub here, and
just go to the helper Hardhead

20545
20:50:49,050 --> 20:50:52,590
config and grab it from here, we
have that const development

20546
20:50:52,590 --> 20:50:58,620
chains, or say const verify
equals require dot dot slash

20547
20:50:58,620 --> 20:51:03,090
utils. Slash verify. We're also
going to grab our utils, I'm

20548
20:51:03,090 --> 20:51:06,060
going to copy paste so utils
folder from alas project, once

20549
20:51:06,060 --> 20:51:09,330
again, you can copy paste from
your last project, or you can

20550
20:51:09,330 --> 20:51:12,600
just go straight to the repo,
grab the verified dot j s, we're

20551
20:51:12,600 --> 20:51:15,000
going to go over these two
functions a little bit later,

20552
20:51:15,000 --> 20:51:17,370
but at least grab the verified
for now. And then we're gonna

20553
20:51:17,370 --> 20:51:21,390
start the function. So we'll do
module that exports equals async

20554
20:51:21,390 --> 20:51:27,720
function. We're gonna get get
named accounts, and deployments.

20555
20:51:29,610 --> 20:51:34,620
And we're gonna say const.
Deploy, log equals deployments

20556
20:51:34,770 --> 20:51:41,610
against deployer equals await,
get named accounts. So we'll do

20557
20:51:41,610 --> 20:51:47,490
a little log here just to get
started to do our basic NFT

20558
20:51:47,610 --> 20:51:51,750
doesn't take any constructor
parameters. So we'll say const

20559
20:51:51,780 --> 20:51:58,140
args equals a little blank here.
Then we'll do const basic NFT

20560
20:51:58,170 --> 20:52:05,400
equals await, deploy basic NF T,
exactly what we've seen before a

20561
20:52:05,400 --> 20:52:10,350
number of times at this point,
we'll say from Deployer. args is

20562
20:52:10,350 --> 20:52:14,640
going to be args. And then log,
it's going to be true. And then

20563
20:52:14,640 --> 20:52:16,860
we'll also do weight
confirmations. It's going to be

20564
20:52:16,860 --> 20:52:25,620
network dot config dot block,
confirmations, or one. Then if

20565
20:52:25,620 --> 20:52:29,190
we want to verify this, we're
going to once again do if it's

20566
20:52:29,190 --> 20:52:37,320
not development chains, dot
includes network dot name, and

20567
20:52:37,470 --> 20:52:44,790
process that EMV dot ether scan
API key will say log verifying

20568
20:52:44,790 --> 20:52:51,930
dot the dot await, verify basic
NF T dot address arguments which

20569
20:52:51,930 --> 20:52:55,830
are going to be blank, grab this
little log here, stick it right

20570
20:52:55,830 --> 20:52:59,400
underneath. And then actually in
our basic NF T. This should be

20571
20:52:59,430 --> 20:53:03,180
args not arguments. Now we have
a deploy script. Now we have a

20572
20:53:03,180 --> 20:53:07,920
basic NFT here in test data
deploy script, or any hh deploy

20573
20:53:07,950 --> 20:53:12,450
or yarn Hardhead deploy. And
oops, let's go back to the basic

20574
20:53:12,450 --> 20:53:19,050
kind of tea or mint and have tea
needs to return a UNT 256. Try

20575
20:53:19,050 --> 20:53:23,820
again. Get token counter also
needs to return a UNT forget you

20576
20:53:23,820 --> 20:53:26,700
into anywhere else. Nope. Okay,
looking good. And looks like

20577
20:53:26,700 --> 20:53:30,930
we're compiling well compiled,
deploying Well, now if you want

20578
20:53:30,930 --> 20:53:35,100
to deploy this to rink B, you
can. I recommend holding off

20579
20:53:35,100 --> 20:53:37,530
though, because we're going to
do that at the end. Now that

20580
20:53:37,530 --> 20:53:40,350
we've written a deploy script.
We've written the contract, you

20581
20:53:40,350 --> 20:53:44,280
already know what's coming next.
Yes, neat. What's next is the

20582
20:53:44,280 --> 20:53:47,190
tests now because we're not
actually learning too much more

20583
20:53:47,190 --> 20:53:50,460
here. I'm not going to walk you
through writing this test. I'm

20584
20:53:50,460 --> 20:53:54,000
going to challenge you now. How
to pause the video and write the

20585
20:53:54,000 --> 20:53:57,480
test out yourself and see how
far in this test you can

20586
20:53:57,480 --> 20:54:00,510
actually get. Remember, to test
it, you're going to want to run

20587
20:54:00,540 --> 20:54:02,820
yarn, hard hat test,

20588
20:54:03,060 --> 20:54:05,640
right, let's see if you can
actually write the test

20589
20:54:05,640 --> 20:54:09,540
yourself, then come back to the
video, see if your tests were

20590
20:54:09,540 --> 20:54:13,440
just as good or not as good as
what we did here. And of course,

20591
20:54:13,680 --> 20:54:16,830
you can always go to the GitHub
repo test sections. And if you

20592
20:54:16,830 --> 20:54:21,360
get lost, you can look at the
basic nft.test.js To follow

20593
20:54:21,360 --> 20:54:33,060
along. All right, welcome back.
Hopefully, you wrote some

20594
20:54:33,090 --> 20:54:36,570
awesome tests, taking the time
to actually do some of those

20595
20:54:36,570 --> 20:54:40,260
exercises is really going to
make you a much better engineer.

20596
20:54:40,440 --> 20:54:43,350
Following along with me, it's
awesome. But tinkering yourself

20597
20:54:43,350 --> 20:54:46,020
and trying to do everything
yourself is really what's gonna

20598
20:54:46,020 --> 20:54:49,380
make this stick. So I hope you
did pause the video. And hope

20599
20:54:49,380 --> 20:54:51,570
you did go ahead and try to
write the test for this

20600
20:54:51,570 --> 20:54:54,330
yourself, you've technically
just created a really

20601
20:54:54,330 --> 20:54:55,530
minimalistic NFT.

20602
20:54:55,620 --> 20:55:02,670
Great job. Let's kick things up
a notch. Let's move now to a

20603
20:55:02,670 --> 20:55:07,470
random IPFS hosted NFT where
we're going to do everything

20604
20:55:07,470 --> 20:55:11,460
pretty much programmatically. So
let's jump in. In our contracts,

20605
20:55:11,490 --> 20:55:16,080
we're going to create a new file
random IPFS, NFT, dot soul. Same

20606
20:55:16,080 --> 20:55:24,180
thing. spdx license identifier,
gonna be MIT pragma, solidity

20607
20:55:24,630 --> 20:55:27,720
carrot zero, point 8.7, or
whatever version you want to

20608
20:55:27,720 --> 20:55:35,340
use, will do contract random
IPFS NF? T, like so. So what is

20609
20:55:35,340 --> 20:55:39,780
this one going to do? So instead
of just minting any NFT, when we

20610
20:55:39,780 --> 20:55:47,280
meant an NF t, we will trigger a
chainlink VRF call to get us a

20611
20:55:47,370 --> 20:55:52,560
random number. Using that
number, we will get get a random

20612
20:55:52,650 --> 20:55:56,280
NF t that we're going to decide
on. And the random n of t that

20613
20:55:56,280 --> 20:55:59,640
we're going to use, it's going
to be either a pug a Shiva in

20614
20:55:59,640 --> 20:56:04,590
you, or a St. Bernard. So
whenever anybody mints NF T,

20615
20:56:04,590 --> 20:56:06,750
they're gonna get one of these
random three dogs. And we're

20616
20:56:06,750 --> 20:56:09,450
going to make this so that each
one of these dogs have a

20617
20:56:09,450 --> 20:56:12,600
different rarity, we're going to
make these dogs rare by

20618
20:56:12,600 --> 20:56:16,560
different amounts, say we want
the pug to be super rare, the

20619
20:56:16,560 --> 20:56:20,970
Shiva to be sort of rare, and
then the St. Bernard to be

20620
20:56:20,970 --> 20:56:23,700
pretty common. So probably it's
gonna be super rare Shiva in us

20621
20:56:23,700 --> 20:56:27,000
is gonna be sort of rare, St.
Bernard is going to be pretty

20622
20:56:27,000 --> 20:56:30,270
common, right? Or the most
common, if you will. So let's go

20623
20:56:30,270 --> 20:56:32,490
ahead and start building this,
we're probably gonna have to

20624
20:56:32,490 --> 20:56:36,330
make a function called like
request NF t, because we're

20625
20:56:36,330 --> 20:56:38,400
going to know that we're gonna
need to kick off a channeling

20626
20:56:38,400 --> 20:56:41,460
VRF request, we're probably
gonna have to make a function

20627
20:56:41,460 --> 20:56:47,070
fulfill random words, that's
going to take a un 256 Request

20628
20:56:47,190 --> 20:56:53,670
ID and a un 256. Array, memory
random words, as we've seen

20629
20:56:53,670 --> 20:56:57,300
before, we've done fulfill
random words in the past. And

20630
20:56:57,300 --> 20:57:00,240
let's let's even go one step
further, we'll make it so that

20631
20:57:00,270 --> 20:57:06,390
users have to pay to mint an NF
t. So this is going to be they

20632
20:57:06,390 --> 20:57:10,230
have to pay a certain amount of
eath to get the NFT and then the

20633
20:57:10,260 --> 20:57:14,700
owner of the contract and
withdraw the eath. So we're

20634
20:57:14,700 --> 20:57:17,220
basically paying the artists
here, we're paying the artists

20635
20:57:17,220 --> 20:57:20,670
to create these NF T's. And then
they can be the ones actually

20636
20:57:20,700 --> 20:57:23,790
actually withdraw the payment
for all these NF T's. And we're

20637
20:57:23,790 --> 20:57:28,020
also going to need, of course, a
function, token URI, which takes

20638
20:57:28,020 --> 20:57:32,640
a un 256. And this is once
again, same as our basic NFT

20639
20:57:32,640 --> 20:57:35,190
gonna be what this token
actually looks like. So let's go

20640
20:57:35,190 --> 20:57:37,470
ahead and get started creating
this. Now, because these red

20641
20:57:37,470 --> 20:57:40,140
lines are going to draw me
crazy. We're going to add some

20642
20:57:40,140 --> 20:57:45,120
visibility here, we'll make this
request NFT public fulfill

20643
20:57:45,120 --> 20:57:48,570
random words, we actually know
from the past is going to be

20644
20:57:48,570 --> 20:57:52,020
internal token URI is going to
be public. Let's build this

20645
20:57:52,020 --> 20:57:57,240
request NFT. And again, to
request a random number, go back

20646
20:57:57,240 --> 20:58:01,020
to EVM. Chains, we go to using
randomness, we can follow along

20647
20:58:01,050 --> 20:58:04,860
with the Dr. chain link again,
to figure out how to get this

20648
20:58:04,860 --> 20:58:07,110
random number. So since we know
we're going to be working with

20649
20:58:07,110 --> 20:58:11,370
chain link, we want to add at
chain link slash contracts. So

20650
20:58:11,370 --> 20:58:16,860
back in in our code base, we'll
add that in yarn add dash dash

20651
20:58:16,860 --> 20:58:21,840
dev at chain link slash
contracts, like so which was

20652
20:58:21,840 --> 20:58:25,440
perfect. And we can go ahead,
and we're going to import that

20653
20:58:25,440 --> 20:58:30,360
VRF consumer base V two and the
VRF coordinator interface into

20654
20:58:30,360 --> 20:58:33,000
our code because we know we're
going to use both of these. If

20655
20:58:33,000 --> 20:58:36,360
you want to just copy paste from
the docs, you absolutely can go

20656
20:58:36,360 --> 20:58:39,510
to pause here. And since we're
going to be using this view of

20657
20:58:39,510 --> 20:58:43,530
consumer base, we want to
inherit it. We're going to say

20658
20:58:43,590 --> 20:58:48,930
random IPFS and f t is V RF
consumer base V two and this

20659
20:58:48,930 --> 20:58:51,840
little, little wiggly line will
show up here saying This seems

20660
20:58:51,840 --> 20:58:54,540
to be override. So I'm just
gonna go ahead and add override

20661
20:58:54,540 --> 20:58:57,630
here. And this little wiggly
line is gonna stay there for a

20662
20:58:57,630 --> 20:59:00,300
little bit until we implement
the rest of the functions. So

20663
20:59:00,360 --> 20:59:03,390
let's go ahead and implement the
rest of those functions. Request

20664
20:59:03,390 --> 20:59:07,080
NFT, of course, is going to be
public here. And in order for us

20665
20:59:07,080 --> 20:59:10,950
to request an NF T, we're going
to need to call the coordinator

20666
20:59:10,980 --> 20:59:14,160
dot request random words where
we pass all this stuff in.

20667
20:59:14,730 --> 20:59:18,900
Right, so let's go ahead and get
all this stuff for our V REF

20668
20:59:18,900 --> 20:59:21,330
coordinator in our constructor,
so let's create a new

20669
20:59:21,330 --> 20:59:25,650
constructor. struct door. And
we're going to use the VRF

20670
20:59:25,680 --> 20:59:30,570
consumer base, the two
constructor to use to create our

20671
20:59:30,570 --> 20:59:34,260
constructor, the VRF consumer
base V two needs an address in

20672
20:59:34,260 --> 20:59:37,920
here for the VRF consumer base.
So we'll go ahead and we'll do

20673
20:59:37,950 --> 20:59:44,490
address VRF. Or did Nate Torre b
two. And then we'll pass this to

20674
20:59:44,490 --> 20:59:48,060
the VRF consumer base
constructor here, just by adding

20675
20:59:48,060 --> 20:59:51,270
that that red squiggly line has
gone away from me perfect. And

20676
20:59:51,270 --> 20:59:55,380
we want to save that address to
a global variable. So we can

20677
20:59:55,380 --> 20:59:59,820
call request random words on it.
So we're gonna go ahead up here,

20678
21:00:00,510 --> 21:00:06,300
we're going to say I underscore
var F chord. To me, Tor, we're

20679
21:00:06,300 --> 21:00:09,180
going to make this immutable VRF
coordinator. And we're going to

20680
21:00:09,180 --> 21:00:13,800
do it by saying VRF v2
interface, it's gonna be

20681
21:00:13,800 --> 21:00:19,320
private, immutable, you have
coordinator and then in our

20682
21:00:19,320 --> 21:00:24,390
constructor here, we're gonna
say IVF coordinator equals VRF,

20683
21:00:24,390 --> 21:00:29,130
coordinator v2 interface wrapped
around this like so. So we know

20684
21:00:29,130 --> 21:00:31,320
we're going to need this, we
know we're actually gonna need a

20685
21:00:31,320 --> 21:00:34,020
ton of these. So let's just add
all these variables in here,

20686
21:00:34,530 --> 21:00:37,890
we're gonna need the
coordinator, we're gonna need a

20687
21:00:37,890 --> 21:00:45,540
UNT 64 private, immutable, I
underscore subscription ID,

20688
21:00:45,960 --> 21:00:50,520
we're gonna need a bytes 32,
private, immutable,

20689
21:00:50,580 --> 21:00:57,330
I underscore gas lane, we're
gonna need a you int 32 private,

20690
21:00:57,480 --> 21:01:02,100
mutable, I underscore callback
gas limit, we're gonna need a

20691
21:01:02,100 --> 21:01:10,140
UNT 16 Private constants,
request confirmations, we're

20692
21:01:10,140 --> 21:01:15,240
gonna say it's gonna be three,
and then a un 32. Private

20693
21:01:16,050 --> 21:01:22,980
constant equals num words, which
is going to be one, and we'll

20694
21:01:22,980 --> 21:01:26,100
get this red squiggly line
saying it's mad at our our

20695
21:01:26,100 --> 21:01:30,630
constructor here. So let's go
ahead and add all of our

20696
21:01:30,690 --> 21:01:33,660
immutable variables in our
constructor. So we'll get the

20697
21:01:33,660 --> 21:01:39,300
VRF coordinator v2 from our
constructor will get the UNT 64

20698
21:01:39,330 --> 21:01:45,390
subscription ID, we'll get the
bytes 32 Gas lane, aka the key

20699
21:01:45,390 --> 21:01:52,530
hash, we'll get the un 256.
We'll do a UNT 32 callback gas

20700
21:01:52,560 --> 21:01:58,200
limit, then we'll go ahead and
do I subscription ID equals

20701
21:01:58,200 --> 21:02:06,210
subscription ID will do I gas
Lane equals gas lane will do I

20702
21:02:06,240 --> 21:02:10,950
call back gas limit equals call
back.

20703
21:02:11,730 --> 21:02:12,720
Yes limit.

20704
21:02:13,020 --> 21:02:15,960
Okay, a lot of variables set up.
But those are the variables that

20705
21:02:15,960 --> 21:02:18,900
we're going to need for the
chainlink VRF. Now we have all

20706
21:02:18,900 --> 21:02:22,770
these variables down in our
request. And if t we can request

20707
21:02:22,830 --> 21:02:26,460
a random number to get for our
random n of t, we're going to

20708
21:02:26,460 --> 21:02:32,550
say and our returns a yuan
tivity six Request ID. So in

20709
21:02:32,550 --> 21:02:37,920
here, we'll say request, Id this
request ID that we just

20710
21:02:37,920 --> 21:02:44,280
initialized I underscore VRF.
Core didn't a Tor dot request.

20711
21:02:44,880 --> 21:02:48,390
random words. And this should
look pretty familiar to what we

20712
21:02:48,390 --> 21:02:54,120
did in our lottery. I underscore
gas Lane comma, I underscore

20713
21:02:54,120 --> 21:03:03,450
subscription ID, comma, request,
con for nations. I underscore

20714
21:03:03,450 --> 21:03:08,670
callback gas limit. And then of
course num words and we can just

20715
21:03:08,790 --> 21:03:12,150
literally copy paste this from
the documentation or from our

20716
21:03:12,150 --> 21:03:16,620
last project, whatever you want
to do. So we are requesting this

20717
21:03:16,650 --> 21:03:26,070
random NFT here. Now here's the
thing, though, we want whoever

20718
21:03:26,070 --> 21:03:30,180
called this request function it
to be there and have tea, right.

20719
21:03:30,180 --> 21:03:34,470
And if we saw in our basic NFT,
when we minted the NFT, we call

20720
21:03:34,470 --> 21:03:38,160
this safe mint which needed the
owner and the token counter.

20721
21:03:38,340 --> 21:03:41,250
When we request a random number
four are NFT. It's going to

20722
21:03:41,250 --> 21:03:43,710
happen in two transactions,
right? We're going to request

20723
21:03:44,130 --> 21:03:47,460
and then later on we're going to
fulfill and it's going to be the

20724
21:03:47,460 --> 21:03:51,480
chain link node that's calling
fulfill random words. So if it

20725
21:03:51,480 --> 21:03:54,990
In the fulfill function, we just
do this safe meant message that

20726
21:03:54,990 --> 21:03:58,800
sender, the owner of this NFT is
actually going to be the chain

20727
21:03:58,800 --> 21:04:03,270
link node that fulfilled our
random words. So we don't want

20728
21:04:03,270 --> 21:04:07,710
that, what we want to do is we
want to create a mapping between

20729
21:04:07,710 --> 21:04:12,210
request IDs. And whoever called
this so that when we call

20730
21:04:12,210 --> 21:04:15,210
fulfill random words, which
returns with that exact same

20731
21:04:15,210 --> 21:04:19,620
request, ID, we can say, Ah,
okay, your request ID X, you

20732
21:04:19,620 --> 21:04:23,310
belong to the person who called
this request and of team, we're

20733
21:04:23,310 --> 21:04:26,460
going to create a mapping
between people who call this and

20734
21:04:26,460 --> 21:04:29,490
their request IDs so that when
we fulfill random words, we can

20735
21:04:29,490 --> 21:04:33,630
properly assign the dogs to
them. So up at the top, right

20736
21:04:33,630 --> 21:04:36,540
underneath here, I'm going to
call them VRF helpers, we're

20737
21:04:36,540 --> 21:04:42,030
going to create a mapping of un
256. To an address, we'll make

20738
21:04:42,030 --> 21:04:44,670
this public which we should make
it private, but we'll just make

20739
21:04:44,670 --> 21:04:50,490
it public s underscore Request
ID to sender. And then when we

20740
21:04:50,490 --> 21:04:56,790
call this request, and F T, will
set the request ID to sender of

20741
21:04:56,790 --> 21:05:03,390
Request ID equals to message dot
sender. Now, when the chain link

20742
21:05:03,390 --> 21:05:07,530
node responds with fulfill
random words, what we can do is

20743
21:05:07,530 --> 21:05:12,510
we can say address dog owner or
the NFT dog owner is going to be

20744
21:05:12,510 --> 21:05:19,140
equal to s Request ID to sender
of Request ID. This way, it's

20745
21:05:19,140 --> 21:05:21,150
not going to be the chain link
nodes that are going to own the

20746
21:05:21,150 --> 21:05:26,130
dog, but it's gonna be whoever
actually called requests. NFT.

20747
21:05:26,430 --> 21:05:29,970
Okay, cool. So we have a way to
request a random number for our

20748
21:05:29,970 --> 21:05:34,260
random NF t. Now, let's go ahead
and mint this random dog, this

20749
21:05:34,260 --> 21:05:40,170
random NF T for this for this
user. So we have the user now

20750
21:05:40,200 --> 21:05:43,500
using this mapping, what else do
we need? Well, we're gonna need

20751
21:05:43,500 --> 21:05:46,860
the token counter here. Let's go
ahead and we'll create a token

20752
21:05:46,860 --> 21:05:49,320
counter variable. So we'll
scroll up and make a new

20753
21:05:49,320 --> 21:05:56,040
section. And we'll say, un 256.
And then again, we'll just make

20754
21:05:56,040 --> 21:05:58,860
a lot of these public just to
make it easier, but you might

20755
21:05:58,860 --> 21:06:01,170
want to make this private and
use that same syntax we were

20756
21:06:01,170 --> 21:06:04,830
doing before do s underscore
since this is a stored variable,

20757
21:06:05,550 --> 21:06:09,180
token counter. And we'll grab
this token counter. And we'll

20758
21:06:09,180 --> 21:06:15,540
say you went to 56. New token ID
equals as token counter, now

20759
21:06:15,540 --> 21:06:19,350
that we have the dog owner, and
the token ID, we can go ahead

20760
21:06:19,350 --> 21:06:21,690
and mint this MFT. So we'll do
safe mint.

20761
21:06:23,490 --> 21:06:30,120
Owner, new token, ID and then
safe man is going to be squiggly

20762
21:06:30,120 --> 21:06:34,380
because our code is gonna say,
what is this? What is the safe

20763
21:06:34,380 --> 21:06:37,140
mint function? Where did you get
this from? Well, we're gonna

20764
21:06:37,140 --> 21:06:39,300
need to get it from open
Zeppelin again. So we're going

20765
21:06:39,300 --> 21:06:44,190
to go ahead and do import at
open Zeppelin slash contracts

20766
21:06:44,220 --> 21:06:53,010
slash token slash ERC. 721 slash
ERC. 720 one.so We'll say a

20767
21:06:53,010 --> 21:06:58,950
random IPFS empty is Vera of
consumer base, and also ERC 721

20768
21:06:59,040 --> 21:07:02,820
In our constructor, right after
our V RF consumer base, we're

20769
21:07:02,820 --> 21:07:08,550
going to put the ERC 721. And
same thing, we need to give it a

20770
21:07:08,550 --> 21:07:15,420
name and a symbol. So we'll call
this random IPFS NF T. Comma,

20771
21:07:15,450 --> 21:07:19,530
we'll just do Rin for random
IPFS NF team. Now safe mint

20772
21:07:19,530 --> 21:07:22,140
actually works and then it's
gonna be mad at me for this. So

20773
21:07:22,140 --> 21:07:24,660
I'm gonna do override just let
it stop getting mad at me.

20774
21:07:24,900 --> 21:07:31,020
public view override turns
string memory. Just that

20775
21:07:31,380 --> 21:07:34,680
squiggly line goes way. Okay,
cool. So great. So now we can

20776
21:07:34,680 --> 21:07:43,890
safe mint to the dog owner this
new token ID Are we done with

20777
21:07:43,890 --> 21:07:47,880
this? Absolutely not. Why not?
Well, we don't know what this

20778
21:07:47,910 --> 21:07:51,120
token looks like. And what we
set above is we want to actually

20779
21:07:51,150 --> 21:07:54,930
make these dogs different
rarities. So how do we actually

20780
21:07:54,930 --> 21:07:58,950
create these dogs with different
rarities, all we could do is we

20781
21:07:58,950 --> 21:08:03,420
create a chance array an array
to show the different chances of

20782
21:08:03,420 --> 21:08:06,780
these different dogs here. So
down below, we're going to

20783
21:08:06,780 --> 21:08:12,060
create a function and it's going
to be a public pure function

20784
21:08:12,570 --> 21:08:20,010
called get chance array. And
this is going to return you went

20785
21:08:20,790 --> 21:08:26,190
to 46 of size three in memory.
And this chance array is going

20786
21:08:26,190 --> 21:08:29,130
to represent the different
chances of the different dogs.

20787
21:08:29,310 --> 21:08:35,610
So we're gonna say return
10 3100 Or we're gonna say Max

20788
21:08:35,820 --> 21:08:37,500
chance value.

20789
21:08:38,760 --> 21:08:42,090
And up at the top under empty
variables. We're gonna say you

20790
21:08:42,090 --> 21:08:48,840
went to 56 internal constant,
Max chance value equals 100. So

20791
21:08:48,840 --> 21:08:53,430
by making this array, we're
saying index Zero has a 10 percent

20792
21:08:53,430 --> 21:08:58,680
chance of happening. We're
saying index one has a 20 percent

20793
21:08:58,680 --> 21:09:03,300
chance of happening because it's
going to be 30 minus 10. And

20794
21:09:03,300 --> 21:09:07,290
then we're saying index two is
going to have a 60 percent chance of

20795
21:09:07,290 --> 21:09:12,150
happening, because it's going to
be 10 plus 30. minus this 100.

20796
21:09:12,390 --> 21:09:15,690
This array that identified the
percentages of the different

20797
21:09:15,690 --> 21:09:20,160
dogs. We're saying the pug is
going to have a 10 percent chance,

20798
21:09:20,490 --> 21:09:25,530
Shiva in you a 20 percent chance and
the St. Bernard a 70 percent chance,

20799
21:09:25,620 --> 21:09:29,100
we're going to use it to give
this token ID that we just

20800
21:09:29,100 --> 21:09:32,370
minted its dog breed. So we're
gonna create a new function

20801
21:09:32,370 --> 21:09:37,380
called Get breed from modded
RNG. And the reason we're

20802
21:09:37,380 --> 21:09:41,400
calling a get breed from modded
RNG is exactly the same way. In

20803
21:09:41,400 --> 21:09:44,190
our lottery. We got a random
number, we're gonna say you went

20804
21:09:44,190 --> 21:09:53,070
to 56 modded RNG equals random
words of zero mod Max chance

20805
21:09:53,070 --> 21:09:57,780
value, we're going to mod any
number we get by 100. Doing it

20806
21:09:57,780 --> 21:10:00,750
like this, we're always going to
get a number between zero and

20807
21:10:00,750 --> 21:10:04,710
99. If random words zero mod Max
Chin's value is going to be

20808
21:10:04,710 --> 21:10:08,940
seven. That means we're gonna
get a pug. If we get 88. That

20809
21:10:08,940 --> 21:10:14,310
means we're gonna get a St.
Bernard, if we get a 45. We're

20810
21:10:14,310 --> 21:10:19,170
gonna get a what? That's right,
a St. Bernard, if we got a 12

20811
21:10:19,830 --> 21:10:24,600
We're getting a Shiva in you. If
the mod ID number that we get by

20812
21:10:24,600 --> 21:10:29,580
modeling this random word is
between zero and 10. It's going

20813
21:10:29,580 --> 21:10:36,000
to be pug between 10 and 30.
shiba inu between 30 and 100 St.

20814
21:10:36,000 --> 21:10:39,480
Bernard and that's how we get
these randomness values. So now

20815
21:10:39,480 --> 21:10:42,510
that we have this modded RNG, we
have this mod ID number that's

20816
21:10:42,510 --> 21:10:46,500
going to be between zero and 99.
Okay, this function called Get

20817
21:10:46,500 --> 21:10:53,280
breed from modded RNG. And this
is going to take the UN 256 mod

20818
21:10:53,280 --> 21:10:57,090
ID RNG will make this a public
pure function, and it's going to

20819
21:10:57,090 --> 21:11:02,640
return the breed of the dog. Now
the breed of the dog is going to

20820
21:11:02,640 --> 21:11:05,880
be an email similar to raffle
state that we did before. We're

20821
21:11:05,880 --> 21:11:08,190
going to do this right at the
top since this is going to be

20822
21:11:08,190 --> 21:11:13,740
what a type declaration or say
enum. Read, we're going to say

20823
21:11:14,220 --> 21:11:18,000
the zero with number is going to
the pug. The ones number is

20824
21:11:18,000 --> 21:11:22,620
going to be the Shiva in you.
And then the second one is going

20825
21:11:22,620 --> 21:11:27,270
to be the St. Bernard. So we
have the pug which is zero to

20826
21:11:27,270 --> 21:11:33,360
10. Shiva in you 10 to 30 St
Bernard 30 to 100. So get breed

20827
21:11:33,360 --> 21:11:38,070
from modded RNG public pure
returns breed. So we're gonna

20828
21:11:38,070 --> 21:11:40,980
loop through this we're gonna
say you intuitive six cumulative

20829
21:11:40,980 --> 21:11:49,170
sum equals zero, we'll say you
went to 56. size three memory

20830
21:11:49,710 --> 21:11:58,050
chance array equals yet chance
array. So we're getting that

20831
21:11:58,050 --> 21:12:00,450
chance array. So we're going to
create a little for loop we're

20832
21:12:00,450 --> 21:12:06,510
gonna say for you went to 56 i
It's gonna start with zero is

20833
21:12:06,510 --> 21:12:11,670
going to be less than the chance
array dot length. i plus plus

20834
21:12:11,670 --> 21:12:16,200
ran through that for loop here.
And we're going to say if modded

20835
21:12:17,730 --> 21:12:26,280
RNG is greater than or equal to
this cumulative sum and modded

20836
21:12:26,310 --> 21:12:34,770
RNG is less than the cumulative
sum plus chance array plus

20837
21:12:34,770 --> 21:12:41,070
wherever we are on the chance
array, then return breed of AI.

20838
21:12:41,220 --> 21:12:44,700
And then outside of this, we're
gonna say cume cumulative sum

20839
21:12:44,760 --> 21:12:49,650
plus equals chance array of I,
let's say moderate orangey

20840
21:12:49,920 --> 21:12:53,760
equals 25. And if it's 25, it
should be a Shiva in you,

20841
21:12:54,030 --> 21:12:58,590
because that's between 10 and
30. So we're saying if mod RNG,

20842
21:12:58,650 --> 21:13:03,030
which is 25 is greater than or
equal to cumulative sum, which

20843
21:13:03,030 --> 21:13:07,860
right now is zero, and it's less
than n, the Moto G is less than

20844
21:13:07,860 --> 21:13:12,240
the cumulative sum plus the
chance array of I which is going

20845
21:13:12,240 --> 21:13:17,130
to be 10 Return breed of I
cumulative sum is currently zero

20846
21:13:17,220 --> 21:13:24,120
plus chance of I which is 10 is
going to be 10. And this is not

20847
21:13:24,120 --> 21:13:28,140
true because Morarji is 25. So
since this is not true, we're

20848
21:13:28,140 --> 21:13:31,170
going to move to the second step
which is just cumulative sum,

20849
21:13:31,530 --> 21:13:35,400
plus equals chance right? So
cumulative sum will now be equal

20850
21:13:35,400 --> 21:13:38,070
to 10. And then we reached the
end of the for loop. So we'll

20851
21:13:38,070 --> 21:13:42,840
restart i is now one, so let's
try this again mod RNG is

20852
21:13:42,840 --> 21:13:45,690
greater than or equal to
cumulative sum Okay, that is

20853
21:13:45,690 --> 21:13:52,770
true cumulative sum is 10. Mod
RNG is 25. And mod RNG is less

20854
21:13:52,770 --> 21:13:57,900
than cumulative sum plus chance
re of AI, which is 30. So we're

20855
21:13:57,900 --> 21:14:03,870
saying 25 is less than 10 plus
30, which is 40. Return breed of

20856
21:14:03,870 --> 21:14:08,880
AI, this is true. So breed of AI
would be true and AI at the

20857
21:14:08,880 --> 21:14:12,330
moment is one. And if we scroll
up, that's indeed the Shiva in

20858
21:14:12,330 --> 21:14:15,180
you. So that's how this function
is going to work, it's going to

20859
21:14:15,180 --> 21:14:19,260
get us the breed from that
modeling bit. And then if for

20860
21:14:19,260 --> 21:14:22,770
some reason, some really wacky
stuff happens here, we want to

20861
21:14:22,770 --> 21:14:25,470
just go ahead and add a revert,
right, because we should be

20862
21:14:25,470 --> 21:14:28,500
returning a breed. But if we
don't return a breed, we should

20863
21:14:28,500 --> 21:14:31,440
just revert. So we're going to
create a new error at the top,

20864
21:14:32,220 --> 21:14:38,700
random IPFS NFT underscore
underscore range out of bounds.

20865
21:14:39,840 --> 21:14:42,660
The down below, we're just going
to say if for some reason you

20866
21:14:42,660 --> 21:14:47,790
don't return anything, just do a
revert random IPFS NFT range out

20867
21:14:47,790 --> 21:14:51,210
of bounds. And now we have this
function. Okay, so now we can

20868
21:14:51,210 --> 21:14:54,900
get the brief from a modded RNG.
So pack in our fulfill random

20869
21:14:54,900 --> 21:14:59,370
words function. Let's go ahead,
and we'll say, we'll uncomment

20870
21:14:59,370 --> 21:15:05,880
this will say breed, dog breed,
equals get breed for modded RNG

20871
21:15:06,300 --> 21:15:10,830
pass the modded RNG here, and
let's move this safe mint down

20872
21:15:11,130 --> 21:15:15,120
below us getting the dog breeder
so we can mint and add the dog

20873
21:15:15,120 --> 21:15:17,490
breed at the same time. So we're
gonna go ahead and safe mint

20874
21:15:17,490 --> 21:15:17,850
here.

20875
21:15:23,040 --> 21:15:26,370
Now we can do a few things to
set this dog breed here, we

20876
21:15:26,370 --> 21:15:30,060
create a mapping between the dog
breed and the token URI, and

20877
21:15:30,060 --> 21:15:34,650
then have that reflected in this
token URI function. Or what we

20878
21:15:34,650 --> 21:15:38,220
could do is we could just call a
function called Set token URI

20879
21:15:38,250 --> 21:15:41,670
and the openzeppelin ERC 721 You
have to set this token your eye

20880
21:15:41,670 --> 21:15:44,880
function yourself. However,
there is an extension in the

20881
21:15:44,880 --> 21:15:50,520
open Zeppelin code called ERC.
721 Uri storage and this version

20882
21:15:50,520 --> 21:15:55,620
of the ERC. 721 comes with a
function called Set token URI

20883
21:15:55,680 --> 21:15:59,460
where we can just call set token
URI. And this will automatically

20884
21:15:59,490 --> 21:16:04,020
update that tokens token URI to
whatever you set it as. So we're

20885
21:16:04,020 --> 21:16:08,850
going to use this extension this
set token URI in our contract.

20886
21:16:09,150 --> 21:16:12,750
And the way that we do this is
instead of doing token ERC 721

20887
21:16:12,780 --> 21:16:21,210
Year C 721 that soul will do
token ERC 721 slash extensions

20888
21:16:21,240 --> 21:16:27,810
slash your C 721 Your arise
storage. That's all. And we'll

20889
21:16:27,810 --> 21:16:35,880
say random IPFS is ERC 721 your
rice storage. Now what's cool is

20890
21:16:35,880 --> 21:16:41,910
that our constructor will still
just use ERC. 721 Because ERC

20891
21:16:41,910 --> 21:16:48,240
721 Uri storage is extending ERC
721. And then this contract just

20892
21:16:48,240 --> 21:16:52,320
comes with some additional
functions like set token URI. So

20893
21:16:52,320 --> 21:16:56,700
right after safe meant, we're
actually going to call set token

20894
21:16:56,730 --> 21:17:03,330
URI with this new item ID. And
then we're going to give it that

20895
21:17:03,360 --> 21:17:08,280
breeds token URI, we're gonna
give it a string here that

20896
21:17:08,310 --> 21:17:11,730
relates to whatever breed that
we just got based off the dog

20897
21:17:11,730 --> 21:17:15,690
breed here. Now, to do this,
what we could do is right at the

20898
21:17:15,690 --> 21:17:19,920
top and our NFT variables, we
could create a string array,

20899
21:17:20,040 --> 21:17:25,170
internal, Alt S dog token, your
eyes, we're gonna make this

20900
21:17:25,170 --> 21:17:29,370
constant where it would just be
this array of all these strings

20901
21:17:29,370 --> 21:17:32,400
that we created. But maybe in
our code, we want to make this a

20902
21:17:32,400 --> 21:17:36,150
little bit more variable. And we
want to parameterize this. And

20903
21:17:36,150 --> 21:17:38,280
that's exactly what we're going
to do. So we're going to create

20904
21:17:38,280 --> 21:17:42,360
this string array, internal s
underscore dog token, your eyes,

20905
21:17:42,510 --> 21:17:47,400
which is just going to be a list
of these URLs are these URLs

20906
21:17:47,400 --> 21:17:50,250
that point to stuff like this,
we're going to do that in our

20907
21:17:50,250 --> 21:17:54,840
code so that when we upload any
image that we want to IPFS we

20908
21:17:54,840 --> 21:17:58,680
can then upload this s dog token
you arise accordingly. In our

20909
21:17:58,680 --> 21:18:00,720
constructor, we're actually
going to take in another

20910
21:18:00,720 --> 21:18:08,610
parameter called a a string of
size three, memory dog token you

20911
21:18:08,610 --> 21:18:12,840
our eyes, we're going to pass as
a constructor parameter, these

20912
21:18:12,840 --> 21:18:17,160
different dog token you arise.
So we're going to pass it this

20913
21:18:17,160 --> 21:18:21,240
list of dog token arise. Of
course zero is going to be the

20914
21:18:21,240 --> 21:18:24,300
token URI of the pug. One is
going to be the Shiva in you and

20915
21:18:24,300 --> 21:18:26,970
two, of course is going to be
the St. Bernard. So we're going

20916
21:18:26,970 --> 21:18:31,890
to pass it this list of dog
token your eyes, and then down

20917
21:18:31,890 --> 21:18:37,050
in set token your eye from that,
that list that we created. We're

20918
21:18:37,050 --> 21:18:40,590
going to set the token URI of
this token based off of that

20919
21:18:40,590 --> 21:18:48,150
array of the UN 256 version of
that breed are casting this dog

20920
21:18:48,150 --> 21:18:53,520
breed back into you and 256 to
get its index. With that we now

20921
21:18:53,520 --> 21:18:57,120
have a way to actually,
programmatically get a provably

20922
21:18:57,120 --> 21:19:00,630
random NFT with different
randomness for different one of

20923
21:19:00,630 --> 21:19:09,510
these NF T's. Now, let's go back
up to our little, our little

20924
21:19:09,510 --> 21:19:13,110
comments we made here, limited
NFT, we trigger a chain link or

20925
21:19:13,110 --> 21:19:16,890
a VRF. To call random number, we
got the rarities down, we got

20926
21:19:16,890 --> 21:19:20,160
the minting down. Awesome. Okay,
we don't have this part, though.

20927
21:19:20,760 --> 21:19:24,450
Users have to pay to Minton NF T
and the owner of the contract

20928
21:19:24,450 --> 21:19:26,910
can withdraw the eath. Okay,
this is stuff we've already done

20929
21:19:26,910 --> 21:19:29,250
before, this should be pretty
familiar here. So back in our

20930
21:19:29,250 --> 21:19:32,880
request NF t function, we'll
make this a public payable. And

20931
21:19:32,880 --> 21:19:38,520
all we'll need to do is we'll
just say if message dot value is

20932
21:19:38,520 --> 21:19:41,880
less than some mint fee, and
actually let's go back to our

20933
21:19:41,880 --> 21:19:46,560
constructor, we'll create a mint
fee, you int 256 Mint fee.

20934
21:19:48,060 --> 21:19:53,670
And then we'll do you in 256
internal I underscore mint fee,

20935
21:19:53,970 --> 21:19:56,880
we'll make this immutable. And
then we'll just say I'm

20936
21:19:56,880 --> 21:20:01,050
intervene equals mint fee. If
message of value is less than

20937
21:20:01,050 --> 21:20:06,000
mint fee, you already know we're
going to do a revert, need more

20938
21:20:06,360 --> 21:20:11,910
eath sent, we'll create a new
air called need more eath sent

20939
21:20:12,000 --> 21:20:16,920
and actually we'll do air random
IPFS and ft underscore

20940
21:20:16,920 --> 21:20:21,900
underscore need more II sent
like that, copy this, paste it

20941
21:20:21,900 --> 21:20:25,800
here and boom. So now just by
adding this line, this is now a

20942
21:20:25,800 --> 21:20:29,970
payable function. And people
have to pay some mint fee to

20943
21:20:30,000 --> 21:20:34,230
mint their randomized NF t. Now
we're also going to want a way

20944
21:20:34,230 --> 21:20:38,130
for owner to withdraw. So we'll
scroll down a little bit. We'll

20945
21:20:38,130 --> 21:20:43,110
scroll down to here, CREATE
FUNCTION withdraw, this will be

20946
21:20:43,110 --> 21:20:46,770
public. And we only want the
owner to do this. So we could

20947
21:20:46,770 --> 21:20:51,120
create our modifier, you know, a
modifier again only owner, or

20948
21:20:51,450 --> 21:20:53,520
what we could do is use
openzeppelin. Again,

20949
21:20:53,670 --> 21:20:58,380
openzeppelin also comes with
some access code, or one of

20950
21:20:58,380 --> 21:21:03,390
them's this ownable code, and in
here, it already has the only

20951
21:21:03,390 --> 21:21:06,270
owner modifier for us, we're
just gonna go ahead and import

20952
21:21:06,270 --> 21:21:12,030
that as well. We'll do import at
openzeppelin slash contracts

20953
21:21:12,060 --> 21:21:17,490
slash access slash ownable dot
som, and we'll say contract

20954
21:21:17,520 --> 21:21:23,160
random IPFS. And if t is this,
this come ownable. And then

20955
21:21:23,160 --> 21:21:26,640
we'll make our withdrawal
function only owner. And so

20956
21:21:26,640 --> 21:21:29,160
whoever deployed this contract
is going to be set to being the

20957
21:21:29,160 --> 21:21:32,430
owner, which is what we want.
And when here, same as what

20958
21:21:32,430 --> 21:21:39,210
we've done, we'll do u and 256.
amount equals address this dot

20959
21:21:39,210 --> 21:21:46,200
balance. And then we'll do bull
success comma equals payable,

20960
21:21:47,010 --> 21:21:53,010
message dot sender, but call
value is going to be a mount and

20961
21:21:53,010 --> 21:21:56,880
then we're going to call
nothing. And then we're going to

20962
21:21:56,880 --> 21:22:04,170
say if not success. And we're
going to revert with transfer

20963
21:22:04,170 --> 21:22:09,060
failed, then on top, we're going
to do error transfer failed. I'm

20964
21:22:09,060 --> 21:22:14,820
just going to copy this a little
quicker, like so and then come

20965
21:22:14,820 --> 21:22:18,600
back down to transfer failed
paste it here. So we're gonna

20966
21:22:18,600 --> 21:22:22,140
revert random IPFS. And if T
transfer failed, perfect, so now

20967
21:22:22,140 --> 21:22:25,740
we have a withdrawal function
and a way for people to pay for

20968
21:22:25,740 --> 21:22:30,360
art here. Now we don't need this
token URI anymore, because when

20969
21:22:30,360 --> 21:22:35,190
we call set token URI, this is
going to set the token URI for

20970
21:22:35,190 --> 21:22:39,750
us because in the back ERC 721
Uri storage already has that

20971
21:22:39,750 --> 21:22:42,840
function laid out. So our
contract will already have the

20972
21:22:42,840 --> 21:22:45,630
token URI function and we don't
have to explicitly set it

20973
21:22:45,660 --> 21:22:48,270
ourselves. But we do have to
explicitly set some other ones.

20974
21:22:48,750 --> 21:22:52,830
We are going to need function
get meant fee will be a public

20975
21:22:52,860 --> 21:23:01,290
view turns you went to 36 turn I
meant fee will need function get

20976
21:23:01,290 --> 21:23:06,300
dog token your eyes, you went to
36 index, this will be a public

20977
21:23:06,300 --> 21:23:10,980
view which will returns the
string memory return s

20978
21:23:10,980 --> 21:23:17,790
underscore dog token your eyes
index will need function get

20979
21:23:17,850 --> 21:23:24,180
token counter. This will be a
public view turns you into 56

20980
21:23:24,930 --> 21:23:29,730
Return s underscore token
counter. Alright, so we just

20981
21:23:29,730 --> 21:23:32,790
wrote a ton of code here. And of
course as we taught you before,

20982
21:23:32,790 --> 21:23:36,630
we also are going to need some
events. So when we request an NF

20983
21:23:36,630 --> 21:23:43,140
T, we're going to emit an event.
So we'll omit NF T requested and

20984
21:23:43,140 --> 21:23:47,460
then we'll pass it the request.
ID in the message dot sender. So

20985
21:23:47,460 --> 21:23:56,370
up at the top will say event NF
T requested. So pet, take a un

20986
21:23:56,370 --> 21:24:02,040
256 index Request ID, and then
an address requester. And then

20987
21:24:02,040 --> 21:24:05,070
we're also going to make an
event for NF T minted for when

20988
21:24:05,070 --> 21:24:09,120
it's finally minted. And it's
going to take a breed, dog

20989
21:24:09,120 --> 21:24:16,350
breed, and an address, mentor.
So write down when we fulfill,

20990
21:24:16,800 --> 21:24:19,080
we're going to emit NFT. minted.

20991
21:24:20,130 --> 21:24:24,360
And it's going to take that dog
breed and then the dog owner.

20992
21:24:29,970 --> 21:24:34,110
Okay, we've just written a lot
of code here. So let's go ahead

20993
21:24:34,110 --> 21:24:37,530
and see if we can compile this
with H H compile, or yarn

20994
21:24:37,530 --> 21:24:40,920
Hardhead, compile. And Wow,
looks like we went ahead and

20995
21:24:40,920 --> 21:24:44,280
compiled it. This is great. So
all of our code now looks good.

20996
21:24:44,310 --> 21:24:46,590
Now might be a good time to take
a quick breather, we've just

20997
21:24:46,590 --> 21:24:49,350
written a lot of code. And it
might be good to just go over

20998
21:24:49,350 --> 21:24:52,140
all the stuff that we just went
through. A lot of this is

20999
21:24:52,140 --> 21:24:55,080
familiar, but it's still really
good to redo some of this stuff

21000
21:24:55,080 --> 21:24:58,020
and really get that muscle
memory and for these credit, an

21001
21:24:58,020 --> 21:25:01,830
NFT contract that when you mint,
one of these NF T's, you're

21002
21:25:01,830 --> 21:25:06,300
gonna get a pug a Shiva in you
or St. Bernard, based off of

21003
21:25:06,330 --> 21:25:09,960
some rarity, where the pug is
really rare. Ship it in you is

21004
21:25:09,960 --> 21:25:13,020
sort of rare in the St. Bernard
is pretty common. The way we do

21005
21:25:13,020 --> 21:25:17,850
it is we have this request NF t
function, which people have to

21006
21:25:17,850 --> 21:25:21,480
pay to call and it makes a
request to a chain link node to

21007
21:25:21,480 --> 21:25:24,540
get a random number. Once our
contract gets that random number

21008
21:25:24,780 --> 21:25:29,490
uses a chance array to figure
out which one of the NF T's

21009
21:25:29,490 --> 21:25:32,700
we're going to actually use for
this for that minting. And we're

21010
21:25:32,700 --> 21:25:35,700
going to set the token URI
accordingly. And we're going to

21011
21:25:35,700 --> 21:25:40,740
store the image data for this on
IPFS, which we haven't done yet.

21012
21:25:40,980 --> 21:25:43,860
So our deploy function for this
is going to be really the

21013
21:25:43,860 --> 21:25:46,650
interesting part of this
contract. But because we just

21014
21:25:46,650 --> 21:25:48,960
went over so much, if you want
to take a quick break quick

21015
21:25:48,960 --> 21:25:52,140
breather, and then come back, I
encourage you to do so we just

21016
21:25:52,290 --> 21:25:55,770
learned a lot. And we wrote a
lot of solidity code. So go take

21017
21:25:55,770 --> 21:25:57,030
a quick breather, and I'll see
you in a

21018
21:25:57,030 --> 21:26:05,250
minute. So let's go ahead and
get on in here, create a new

21019
21:26:05,250 --> 21:26:15,030
deploy, go to ploy, random
ipfs.js. And now this is going

21020
21:26:15,030 --> 21:26:18,180
to look really similar once
again, to the lottery contract

21021
21:26:18,180 --> 21:26:21,000
that we've already done. And we
can copy some boilerplate from

21022
21:26:21,000 --> 21:26:23,790
our code over here, we're gonna
need all this, we'll just copy

21023
21:26:23,790 --> 21:26:27,630
that, close it off with a little
curly and boom, we've already

21024
21:26:27,630 --> 21:26:29,910
got a boilerplate. Now, since
we're working with chainlink,

21025
21:26:29,910 --> 21:26:32,910
here, we are going to be working
with mocks again. So we're gonna

21026
21:26:32,910 --> 21:26:39,210
come back new file 00, deploy
mocks dot j s. And if you want,

21027
21:26:39,210 --> 21:26:42,270
you can just copy paste from the
earlier section that we did with

21028
21:26:42,270 --> 21:26:44,880
the with the raffle slash
lottery. Since we're going to be

21029
21:26:44,880 --> 21:26:48,120
doing the exact same thing here,
I'm gonna go ahead and pause and

21030
21:26:48,120 --> 21:26:51,330
you can copy paste from your
previous projects. Or if you

21031
21:26:51,330 --> 21:26:54,660
want, once again, you can just
come to the GitHub repo

21032
21:26:54,660 --> 21:26:57,630
associated with this course,
come over to the deploy. And go

21033
21:26:57,630 --> 21:27:00,570
ahead and grab the deploy mocks
right from here. If you grab

21034
21:27:00,570 --> 21:27:03,240
from the GitHub repo, we also
are going to be working with a

21035
21:27:03,240 --> 21:27:06,150
mock v3 aggregator, but I'm not
going to add that part in quite

21036
21:27:06,150 --> 21:27:09,780
yet, because we don't need it
quite yet. So go ahead and pause

21037
21:27:09,780 --> 21:27:12,630
the video right now. Copy and
paste the VRF coordinator mock

21038
21:27:12,630 --> 21:27:16,230
or pause the video and try to
write the mock code yourself.

21039
21:27:16,380 --> 21:27:19,350
Okay, great. So once you've done
that, we're of course gonna need

21040
21:27:19,350 --> 21:27:23,670
to concentrate ID network dot
config dot chain ID, because

21041
21:27:23,670 --> 21:27:25,920
we're gonna need to decide if
we're actually on a development

21042
21:27:25,920 --> 21:27:29,430
chain. So same as what we did
before then we're gonna say if

21043
21:27:30,720 --> 21:27:39,690
development chains that includes
network dot name, then we're

21044
21:27:39,690 --> 21:27:46,140
gonna say const VRF coordinator,
B to mock goes await ethers dot

21045
21:27:46,140 --> 21:27:53,040
get contract VRF. Core. The name
for the to mock similar to the

21046
21:27:53,040 --> 21:27:58,080
raffle we're gonna say let VRF
coordinate Tor v two address,

21047
21:27:58,230 --> 21:28:04,500
same, the VRF coordinator v two
address equals VRF. coordinator

21048
21:28:04,530 --> 21:28:08,070
v two mach mock that address and
then we're going to want to

21049
21:28:08,070 --> 21:28:11,160
create a subscription exactly
the same as what we did with our

21050
21:28:11,160 --> 21:28:16,980
lottery. So we're gonna say
const, TX equals weight VRF

21051
21:28:17,160 --> 21:28:23,550
coordinate tore V to mock dot
create subscription. And then

21052
21:28:23,550 --> 21:28:30,360
we'll do const TX receipt equals
weight, TX dot weight one. And

21053
21:28:30,360 --> 21:28:33,900
we're gonna get the sub ID from
this exactly the same way we did

21054
21:28:33,900 --> 21:28:37,320
it in the lottery section. So
we'll say that we need that sub

21055
21:28:37,320 --> 21:28:45,630
ID by saying sub subscription ID
will say subscription ID equals

21056
21:28:45,690 --> 21:28:52,770
TX receipt, dot events, zero.
That args got somebody. So

21057
21:28:52,770 --> 21:28:57,210
that's what we do if we're on a
development chain, else said the

21058
21:28:57,210 --> 21:29:06,030
VRF coordinate tore V to address
equals network config of the

21059
21:29:06,030 --> 21:29:12,990
chain ID dot VRF coordinate or B
to that then the subscription ID

21060
21:29:13,170 --> 21:29:19,800
equals network config. Chain ID
dot subscription ID. Perfect.

21061
21:29:19,890 --> 21:29:23,820
And then we'll just double check
our helper hard hat config. So

21062
21:29:23,820 --> 21:29:28,650
that Rigby has both the VRF
coordinator v2. And we're also

21063
21:29:28,650 --> 21:29:31,650
going to need a subscription ID.
So right now, I have our

21064
21:29:31,650 --> 21:29:34,530
subscription ID from our past
project from our lottery

21065
21:29:34,530 --> 21:29:38,160
project. But we can go ahead to
V or F dot chain link, we can go

21066
21:29:38,160 --> 21:29:41,850
to V RF, that chain link can
make sure we're on rink B here.

21067
21:29:42,060 --> 21:29:44,730
Let's see our other
subscriptions. And it looks like

21068
21:29:44,730 --> 21:29:49,110
we have one here. So I'm going
to copy this and paste it in for

21069
21:29:49,110 --> 21:29:53,340
Rigby. Now again, we can go over
to DockStar, chain link EVM

21070
21:29:53,340 --> 21:29:57,000
chains, contract addresses for
using reminisce to see more

21071
21:29:57,000 --> 21:30:00,840
parameters in here, especially
for Rigby and make sure these

21072
21:30:00,840 --> 21:30:04,080
are all correct. We have our
subscription here, we'll add a

21073
21:30:04,080 --> 21:30:07,650
new consumer very soon once we
deploy this contract if we're

21074
21:30:07,650 --> 21:30:11,760
actually going to use RankBrain.
So we'll do a little log here

21075
21:30:11,820 --> 21:30:19,230
with a bunch of hyphens. We'll
now get args equals, we'll make

21076
21:30:19,230 --> 21:30:22,770
our arguments here. And what do
we need, we need the coordinator

21077
21:30:22,800 --> 21:30:27,810
subscription, gasoline callback,
address, dog, your dog token,

21078
21:30:27,810 --> 21:30:31,920
your eyes and admin fee. So
we're going to need VRF

21079
21:30:32,490 --> 21:30:39,270
coordinator for the to address
subscription ID. And we'll need

21080
21:30:39,270 --> 21:30:46,920
the network config. Chain ID dot
gas lane. We need the network

21081
21:30:46,950 --> 21:30:53,370
config chain ID dot meant fee,
then we'll leave that work

21082
21:30:53,490 --> 21:30:58,710
config chain ID dot callback gas
limit

21083
21:30:59,910 --> 21:31:03,390
the right order? Yes it is. And
then we need the dog token your

21084
21:31:03,390 --> 21:31:05,820
eyes and the mint fee with the
done here.

21085
21:31:12,210 --> 21:31:16,260
Now what do we not have, we
don't have this array of token

21086
21:31:16,260 --> 21:31:19,950
your eyes. Now we can do this
one of a couple of ways. If you

21087
21:31:19,950 --> 21:31:24,900
go to the GitHub repo associated
with this, go to deploy, we

21088
21:31:24,900 --> 21:31:28,020
actually did the randomness for
oh three in the get here,

21089
21:31:28,110 --> 21:31:30,570
there's one section where we
just automatically say, okay,

21090
21:31:30,570 --> 21:31:33,690
great token, you rise is just
going to be these three. And

21091
21:31:33,690 --> 21:31:37,140
then if we can actually even
copy paste these CDs on IPFS,

21092
21:31:37,290 --> 21:31:41,070
these are the better ones that
actually do have the IPFS as the

21093
21:31:41,070 --> 21:31:44,490
image. And we can see them like
that. So we could just use the

21094
21:31:44,490 --> 21:31:46,560
stuff that I've already
deployed. And if you want to do

21095
21:31:46,560 --> 21:31:51,750
that, you absolutely 100 percent Can,
or what we could do is we get to

21096
21:31:51,750 --> 21:31:55,200
actually learn to upload
programmatically our own images

21097
21:31:55,200 --> 21:31:59,130
to IPFS. That sounds a lot
cooler. So let's go ahead and do

21098
21:31:59,130 --> 21:32:02,070
that. Now what I want you to do,
if you want to use your own

21099
21:32:02,070 --> 21:32:04,800
images for this, feel free to do
so. But if you want to just

21100
21:32:04,800 --> 21:32:08,430
follow along with us, then we're
going to go to the Hardhead NFT

21101
21:32:08,460 --> 21:32:14,340
FCC repo. And we're going to
grab these random NF T's from

21102
21:32:14,340 --> 21:32:17,400
him. So all you can do is you
can come to here. And we can go

21103
21:32:17,400 --> 21:32:20,640
ahead, we can right click Save
Image, Jas, we'll save it to our

21104
21:32:20,640 --> 21:32:23,850
downloads, let's actually create
a new folder, we'll call it

21105
21:32:23,880 --> 21:32:27,840
images. And the images will
create a new folder called

21106
21:32:28,290 --> 21:32:33,540
random, then we can pull it just
right into here, make the name

21107
21:32:33,540 --> 21:32:38,280
random NFT. And this is just
going to be plugged up png. So

21108
21:32:38,280 --> 21:32:42,090
we can do that for all of our
images. Now in our images tag,

21109
21:32:42,090 --> 21:32:46,200
we have the pug ship in you and
St Bernard. So we have these

21110
21:32:46,200 --> 21:32:50,400
locally. But we want to upload
these to IPFS. We want to upload

21111
21:32:50,400 --> 21:32:52,980
them in a way that anybody can
actually pin them and work with

21112
21:32:52,980 --> 21:32:56,100
them. So before we do all this
stuff, where we get the

21113
21:32:56,130 --> 21:32:59,010
arguments to deploy this
contract, we're going to need to

21114
21:32:59,160 --> 21:33:04,260
get the IPFS hashes of our
images. And there's a couple of

21115
21:33:04,260 --> 21:33:09,960
ways we can do this. We do with
our own IPFS node, which I've

21116
21:33:09,960 --> 21:33:13,110
already shown you how to do that
manually, we can also do that

21117
21:33:13,110 --> 21:33:15,660
programmatically. Now, I'm not
going to show you how to do this

21118
21:33:15,660 --> 21:33:19,980
here. However, if you go through
the IPFS documentation, you

21119
21:33:19,980 --> 21:33:22,230
actually can learn how to do
through the command line and

21120
21:33:22,260 --> 21:33:25,170
even through some scripts.
However, if we're the only node

21121
21:33:25,170 --> 21:33:27,900
that's running this, again, it's
kind of centralized. So ideally,

21122
21:33:27,900 --> 21:33:31,050
we'd want these images and these
token your eyes and this and

21123
21:33:31,050 --> 21:33:35,880
this token metadata on our own
IPFS node and some other nodes.

21124
21:33:36,240 --> 21:33:39,240
So the second way that we can
look at this is using something

21125
21:33:39,240 --> 21:33:43,410
like Hinata Hinata is a service
that basically you just pay to

21126
21:33:43,440 --> 21:33:46,830
help pin NF T for you. And this
is going to be the one that

21127
21:33:46,830 --> 21:33:49,140
we're going to be looking at
here. Now the issue with binotto

21128
21:33:49,140 --> 21:33:52,260
of course, is that we're just
paying once single centralized

21129
21:33:52,260 --> 21:33:55,560
entity to go ahead and pin our
data, we're kind of trusting

21130
21:33:55,560 --> 21:33:57,420
that they're actually going to
pin it and that they're not

21131
21:33:57,420 --> 21:34:01,170
going to go down. The final way
that we could look into actually

21132
21:34:01,230 --> 21:34:04,110
getting our data is was this
thing called NF T dot storage.

21133
21:34:04,170 --> 21:34:07,830
And if T dot storage uses the
file coin network on the back

21134
21:34:07,830 --> 21:34:11,910
end to pin our data now filecoin
is a blockchain dedicated to

21135
21:34:11,910 --> 21:34:16,020
pinning IPFS data and storing
decentralized data. For us, the

21136
21:34:16,020 --> 21:34:19,380
process is a little bit more
complicated. But NFT dot storage

21137
21:34:19,380 --> 21:34:22,440
makes it really, really easy.
Now, we're not going to go over

21138
21:34:22,440 --> 21:34:26,010
using NFT dot storage in this
video. However, if you want to

21139
21:34:26,010 --> 21:34:29,610
look into NF T dot storage, for
putting your data in the GitHub

21140
21:34:29,610 --> 21:34:32,880
repo associated with this
course, we do have a script that

21141
21:34:32,910 --> 21:34:36,540
uploads your code to NFT to
storage called in the utils

21142
21:34:36,540 --> 21:34:39,780
folder, upload to NFT. Storage.
And if you want to go and try it

21143
21:34:39,780 --> 21:34:42,810
out, I recommend that you do so
working with NF T dot storage

21144
21:34:42,810 --> 21:34:45,690
will be one of the most
persistent ways to keep our data

21145
21:34:45,720 --> 21:34:48,810
up. But it's still good to
upload your own data to your own

21146
21:34:48,810 --> 21:34:52,080
IPFS node, which we've learned
how to do manually and at least

21147
21:34:52,080 --> 21:34:54,660
get one other person also
pinning your data. And then

21148
21:34:54,690 --> 21:34:58,380
ideally, an entire decentralized
network, pinning your data,

21149
21:34:58,410 --> 21:35:02,130
which is what NFS storage helps
you do. But for now, for us,

21150
21:35:02,130 --> 21:35:04,710
we're just going to work with
pinata to keep it nice and

21151
21:35:04,710 --> 21:35:08,340
simple for this video. And then
uploading uploading our metadata

21152
21:35:08,340 --> 21:35:12,000
and our token, your eyes up to
IPFS will give us this list of

21153
21:35:12,000 --> 21:35:15,630
token your eyes for our three
dogs. So up at the top here,

21154
21:35:15,810 --> 21:35:19,110
we're going to do a little if
we're gonna say if process dot e

21155
21:35:19,110 --> 21:35:25,620
NV dot upload to pinata equals
true, yes, we're going to use

21156
21:35:25,620 --> 21:35:29,610
the string true like that. Then
we're going to upload to pinata.

21157
21:35:29,850 --> 21:35:33,030
Above here we're going to say
let's token your eyes. And we're

21158
21:35:33,030 --> 21:35:35,460
gonna say token your eyes equals
await,

21159
21:35:36,690 --> 21:35:40,080
handle token your eyes. And
we're going to create a function

21160
21:35:40,080 --> 21:35:43,020
called handle token your eyes,
which is going to upload our

21161
21:35:43,020 --> 21:35:46,710
code to pinata down outside of
this, we're going to create a

21162
21:35:46,710 --> 21:35:52,470
new function called async.
function. And we'll token your

21163
21:35:52,470 --> 21:35:56,640
eyes. And this is going to
return an array of token your

21164
21:35:56,640 --> 21:35:59,760
eyes for us to upload to our
smart contract, we're gonna say

21165
21:35:59,760 --> 21:36:03,600
token, your eyes equals this and
then way at the bottom, we're

21166
21:36:03,600 --> 21:36:06,900
gonna say return token your
rise, right, so we're going to

21167
21:36:06,900 --> 21:36:10,680
be returning this array here.
Now we need to do two things, we

21168
21:36:10,680 --> 21:36:16,230
need to both store the image in
IPFS. And then we need to store

21169
21:36:16,680 --> 21:36:21,000
the metadata in IPFS. So first,
we're going to create a store

21170
21:36:21,000 --> 21:36:23,640
images function. And this is
where we're going to actually

21171
21:36:23,640 --> 21:36:25,860
get to go to our utils. And
we're going to create a new

21172
21:36:25,860 --> 21:36:29,010
folder in here, we're going to
create a file called New File,

21173
21:36:29,220 --> 21:36:34,710
Upload to pinata dot j s, we're
going to add all of our code for

21174
21:36:34,710 --> 21:36:38,880
actually uploading to pinata in
here. Because again, pinata is

21175
21:36:38,880 --> 21:36:42,090
this service that we're going to
be using to just pin data for us

21176
21:36:42,180 --> 21:36:46,440
and work with pinata, we can go
ahead, try for free. And we can

21177
21:36:46,440 --> 21:36:48,240
create our own application.

21178
21:36:56,190 --> 21:37:00,360
And we're good to go. See the
setup here looks really similar

21179
21:37:00,360 --> 21:37:03,990
to an IPFS node, because that's
essentially what pinata is. It's

21180
21:37:03,990 --> 21:37:07,650
just an IPFS node, run by
somebody else. And we can say,

21181
21:37:07,650 --> 21:37:11,430
Hey, can you please pin this
data for us. So a manual way we

21182
21:37:11,430 --> 21:37:15,780
could do this is we could just
hit Upload Cid just like an IPFS

21183
21:37:15,780 --> 21:37:19,710
node and put the hash of some
IPFS file, and pinata would pin

21184
21:37:19,710 --> 21:37:23,670
it for us, we could also upload
a file or a folder just like an

21185
21:37:23,670 --> 21:37:26,910
IPFS node. But for us, we're
just going to leave this blank

21186
21:37:26,910 --> 21:37:29,130
because we're going to want to
do this programmatically,

21187
21:37:29,130 --> 21:37:32,430
because we're engineers. So what
we can do is we come over to our

21188
21:37:32,430 --> 21:37:36,780
profile, we'll open up API keys
and documentation. And the

21189
21:37:36,780 --> 21:37:39,630
documentation pretty much has
everything that we need to get

21190
21:37:39,630 --> 21:37:44,610
started. If you scroll down to
the pinata Node js SDK, this is

21191
21:37:44,610 --> 21:37:46,500
basically what we're going to be
working with, they've already

21192
21:37:46,500 --> 21:37:49,560
created an SDK for us that we
can work with, we're gonna go

21193
21:37:49,560 --> 21:37:53,550
ahead and install this pinata
SDK. So they're using NPM,

21194
21:37:53,580 --> 21:37:57,690
install dash to save, we're just
gonna go ahead and use yarn, add

21195
21:37:57,690 --> 21:38:02,640
dash dash dev at pinata dash
SDK, and they have all these

21196
21:38:02,640 --> 21:38:05,400
different endpoints, we can call
to actually pin data, we're

21197
21:38:05,400 --> 21:38:08,700
going to be doing pin file to
IPFS, because we're going to

21198
21:38:08,760 --> 21:38:14,460
upload our files and also pin
JSON to IPFS. Since JSON is

21199
21:38:14,460 --> 21:38:17,220
going to be the metadata, and
file is going to be the actual

21200
21:38:17,220 --> 21:38:20,280
image. And if you click on it,
it'll even give you kind of the

21201
21:38:20,280 --> 21:38:23,370
output of the SDK here. So back
in our code, now that we've

21202
21:38:23,370 --> 21:38:26,070
downloaded this, we can go ahead
and start creating this. So

21203
21:38:26,070 --> 21:38:31,650
we'll say const pinata SDK
equals require at pinata slash

21204
21:38:31,650 --> 21:38:36,030
SDK, and then we'll create a
function async function called

21205
21:38:36,030 --> 21:38:41,490
store images, it'll take an
images file path. So we're going

21206
21:38:41,490 --> 21:38:45,960
to use this function will pass
it our images, random n of t

21207
21:38:45,960 --> 21:38:48,630
file paths, and we're going to
have it store everything in that

21208
21:38:48,630 --> 21:38:51,480
folder to help us work with
paths. We're also going to

21209
21:38:51,480 --> 21:38:56,070
Install this path package. So
we're gonna do yarn, add dash

21210
21:38:56,070 --> 21:38:59,760
dash dev path, like, so, we're
just going to work with Fs as

21211
21:38:59,760 --> 21:39:03,120
well not Fs extra. So now that
that's up, we're gonna say

21212
21:39:03,120 --> 21:39:08,460
const. Path equals require path.
And in here, we're gonna say

21213
21:39:08,460 --> 21:39:16,110
const, full images, path, equals
path dot resolve, images file

21214
21:39:16,110 --> 21:39:20,970
path. So if we give that like
dot slash images, slash random,

21215
21:39:21,480 --> 21:39:25,290
you know, NF T or whatever, this
will just give us give you the

21216
21:39:25,290 --> 21:39:28,140
full output of the path. So
we're getting the full images

21217
21:39:28,140 --> 21:39:32,550
path, and then we'll say, we'll
get those files by doing const

21218
21:39:32,550 --> 21:39:37,710
files equals Fs. So we'll do
we'll grab s will say const Fs

21219
21:39:37,710 --> 21:39:42,960
equals require Fs just to read
these files in here, that read

21220
21:39:43,620 --> 21:39:47,580
DirSync. We're just going to
read the entire directory and

21221
21:39:47,580 --> 21:39:53,610
get our files back to read
DirSync full images path. And to

21222
21:39:53,610 --> 21:39:56,670
actually test that this is
working, what we're going to do

21223
21:39:57,060 --> 21:40:03,270
is we're going to do module dot
exports, equals store images.

21224
21:40:03,480 --> 21:40:06,720
And then back in our deploy
script here, we can just go

21225
21:40:06,720 --> 21:40:06,990
ahead and

21226
21:40:08,639 --> 21:40:16,049
comment out args. And we can do
import const, store images

21227
21:40:16,079 --> 21:40:21,269
equals require dot dot slash
utils, slash upload to pinata.

21228
21:40:22,109 --> 21:40:25,799
And in this script, we could
just do a little, we just call

21229
21:40:25,799 --> 21:40:31,589
this we could say await, or
images, and then we'll pass pass

21230
21:40:31,589 --> 21:40:35,699
our images location, maybe way
at the top, even outside of the

21231
21:40:35,699 --> 21:40:42,809
function, we'll say const images
location equals dot slash images

21232
21:40:42,809 --> 21:40:47,219
slash random and ft. So we'll do
a weight store images like that.

21233
21:40:47,309 --> 21:40:51,209
And we should be able to run
Hardhead deploy. Then if we add

21234
21:40:51,209 --> 21:40:57,419
some tags to this deploy thing,
module, dot exports, dot tags

21235
21:40:57,449 --> 21:41:03,869
equals, we'll say all random
IPFS. And then main, we do

21236
21:41:03,869 --> 21:41:09,389
Hardhead deployed dash dash
tags, random IPFS will also do

21237
21:41:09,389 --> 21:41:14,939
mocks believe, and I need to
create a test folder in here New

21238
21:41:14,939 --> 21:41:20,519
Folder test. And we need to add
that VF coordinator v2 Mock in

21239
21:41:20,519 --> 21:41:23,879
here. So again, I'm just copy
pasting the VRF coordinator v2

21240
21:41:23,879 --> 21:41:28,139
Mock from our raffle project.
Feel free to pause, copy, paste

21241
21:41:28,169 --> 21:41:31,499
it over, or again, everything's
available on the GitHub. So

21242
21:41:31,499 --> 21:41:35,819
we'll try one more time. Tags,
random IPFS, and mocks and boom,

21243
21:41:35,849 --> 21:41:40,559
okay, mocks deployed and perfect
pug dot png ship any png St.

21244
21:41:40,559 --> 21:41:44,159
Bernard PNG. Great. So we're
getting the files correctly

21245
21:41:44,159 --> 21:41:49,139
here. Now let's create a little
array for responses from the

21246
21:41:49,139 --> 21:41:52,619
pinata server. So we'll say
responses equals this. And we'll

21247
21:41:52,619 --> 21:41:58,469
say for each file index in files
for each one of these files in

21248
21:41:58,469 --> 21:42:04,289
here, we're gonna say const
readable stream for file equals

21249
21:42:04,319 --> 21:42:17,099
Fs dot create read stream of the
full images path slash files of

21250
21:42:17,519 --> 21:42:21,419
file index. What does this line
doing? Well, we're creating a

21251
21:42:21,419 --> 21:42:25,169
read stream. Since this is an
image file, it doesn't work

21252
21:42:25,199 --> 21:42:28,259
exactly the same as just like
push this data, right? We have

21253
21:42:28,259 --> 21:42:31,499
to create a stream where we
stream all the data inside of

21254
21:42:31,499 --> 21:42:34,469
these images. Because these
images, even though they're just

21255
21:42:34,469 --> 21:42:37,079
like a cute little image here,
they're really this kind of this

21256
21:42:37,079 --> 21:42:40,139
big file with all this bytes and
all this data in here, and then

21257
21:42:40,139 --> 21:42:45,569
we're going to send it by doing
try, we'll say const response

21258
21:42:46,079 --> 21:42:50,519
equals await. And this is where
we're going to do pinata stuff.

21259
21:42:50,729 --> 21:42:54,209
If we go back to the pinata
docks, there's some stuff about

21260
21:42:54,239 --> 21:42:57,509
keys in here. What we can do, if
you go to your profile, go to

21261
21:42:57,509 --> 21:43:02,489
API keys, we can create a new
key, we'll say this is an admin

21262
21:43:02,489 --> 21:43:06,299
key, why not? We'll give it all
the pinning access here. Maybe

21263
21:43:06,299 --> 21:43:07,919
we'll give it this, maybe we'll
just give it everything,

21264
21:43:07,949 --> 21:43:10,979
whatever you want to do. And
then we'll call this hard hat,

21265
21:43:11,249 --> 21:43:17,069
Free Code Camp key, create key.
Now we're going to want to grab

21266
21:43:17,069 --> 21:43:21,359
these and drop these into a dot
env. So the API key, go ahead

21267
21:43:21,359 --> 21:43:26,039
and copy, come back over here.
Open up our dot env. And we're

21268
21:43:26,039 --> 21:43:32,879
gonna call it our pinata. And
data API key equals that key.

21269
21:43:33,029 --> 21:43:38,519
We're going to grab the API
secret and say pinata API secret

21270
21:43:39,149 --> 21:43:42,329
equals that key. We don't need
this massive token here for what

21271
21:43:42,329 --> 21:43:44,279
we're going to do. But if you
want it, you can absolutely have

21272
21:43:44,279 --> 21:43:47,819
it. And then outside of our
store images, we're going to say

21273
21:43:47,819 --> 21:43:54,089
const pinata API key equals
price says, do you need that

21274
21:43:54,179 --> 21:44:03,569
pinata API key? And then can't
pinata. API secret equals

21275
21:44:03,569 --> 21:44:09,809
process dot E and V dot pinata
API secret. And then we'll say

21276
21:44:09,809 --> 21:44:18,089
const. pinata equals pin auta s.
DK of pinata

21277
21:44:19,079 --> 21:44:24,959
API key comma, pinata API.
Secret in order to work with

21278
21:44:24,959 --> 21:44:29,279
pinata, we need to pass it an
API key and API secret so that

21279
21:44:29,279 --> 21:44:32,639
pinata knows it's us who's
working with them. So once we

21280
21:44:32,669 --> 21:44:38,009
initialize this pinata thing, we
can now run pinata dot and then

21281
21:44:38,009 --> 21:44:42,119
do some pinata stuff, right, we
want to work with this pin file

21282
21:44:42,359 --> 21:44:45,689
to IPFS, which takes this
readable stream, which is why we

21283
21:44:45,689 --> 21:44:52,259
created that readable string, so
pinata that pin file to IPFS. Of

21284
21:44:52,259 --> 21:44:58,259
readable stream or file. And
then we're going to push this

21285
21:44:58,259 --> 21:45:02,369
response on to our responses
array. So we'll say responses

21286
21:45:02,369 --> 21:45:06,869
dot push response. And then
we're going to catch error, just

21287
21:45:06,869 --> 21:45:09,359
in case there's some weird error
here. And we'll just say console

21288
21:45:09,359 --> 21:45:14,909
dot log error, and then we're
going to return responses and

21289
21:45:14,909 --> 21:45:18,599
files. So we're going to return
all the responses from pushing

21290
21:45:18,599 --> 21:45:22,469
all these files up, and then the
files as well. Now, at this

21291
21:45:22,469 --> 21:45:25,049
current point, we can go ahead
and actually test this out

21292
21:45:25,049 --> 21:45:28,379
ourselves. So we have this in
here. If we go back to our

21293
21:45:28,379 --> 21:45:31,799
deploy, at the top, we have this
if process dot E and V dot

21294
21:45:31,829 --> 21:45:37,109
upload to Niada equals true, do
this stuff here, uploading to

21295
21:45:37,139 --> 21:45:40,439
IPFS. And the final thing we
need to do in here, of course,

21296
21:45:40,439 --> 21:45:48,509
is going to be require dot env
dot config, so that we can pull

21297
21:45:48,509 --> 21:45:52,409
in our dot env file. Down here,
we're just doing a weight store

21298
21:45:52,409 --> 21:45:57,749
images. So if we run this as is,
it should go ahead and store

21299
21:45:57,749 --> 21:46:02,309
images. So let's run that same
command, or that deploy random

21300
21:46:02,309 --> 21:46:05,819
IPFS and the MOX to run this
store images command. And if we

21301
21:46:05,819 --> 21:46:09,749
come back to our pinata, after
we run it, we'll be able to see

21302
21:46:09,749 --> 21:46:15,149
the code uploaded here. If we
run now, the script loaded IPFS

21303
21:46:15,449 --> 21:46:17,519
it'll give us a little bit of a
delay, because it needs to

21304
21:46:17,519 --> 21:46:22,589
upload these big picture files
to IPFS. or more correctly.

21305
21:46:22,589 --> 21:46:27,209
pinata, I'm gonna say uploading
to nada. And we could even say,

21306
21:46:27,989 --> 21:46:35,309
console dot log, working on file
index, done Excel. And okay,

21307
21:46:35,309 --> 21:46:38,819
great. It looks like it finished
running. So if we come back to

21308
21:46:38,819 --> 21:46:43,079
our project here, and we do a
little refresh, we see our three

21309
21:46:43,079 --> 21:46:46,379
files have been uploaded, and we
see they each come with their

21310
21:46:46,379 --> 21:46:50,819
own CID. Now, if you want, you
can go ahead and copy the CID.

21311
21:46:51,209 --> 21:46:55,319
And if you have your IPFS node,
what you can do, what we can do

21312
21:46:55,319 --> 21:47:00,449
is actually we can hit import
from IPFS. Paste it in here. And

21313
21:47:00,449 --> 21:47:04,829
we can say exactly what this is,
which is IPFS dot dot slash last

21314
21:47:05,039 --> 21:47:10,409
as the St. Bernard called St.
Bernard. Important. And now

21315
21:47:10,409 --> 21:47:14,819
we'll have it pinned on our
IPFS. I've got mine saved in a

21316
21:47:14,819 --> 21:47:17,129
little puppies file. Now that
we've got them uploaded, and

21317
21:47:17,129 --> 21:47:20,069
pinata do actually recommend you
pin your own on your own node as

21318
21:47:20,069 --> 21:47:25,319
well. So cool. So we've got a
way to get those images up onto

21319
21:47:25,349 --> 21:47:26,789
IPFS. Awesome

21320
21:47:26,820 --> 21:47:34,770
onto. Now that we've done that,
we're also going to need to

21321
21:47:34,770 --> 21:47:39,990
store the token URI metadata. So
let's go ahead and we'll delete

21322
21:47:39,990 --> 21:47:43,710
that for now. What we can do
back in here, is back up at the

21323
21:47:43,710 --> 21:47:49,950
top again, we can say const meta
data, template equals and we'll

21324
21:47:49,950 --> 21:47:53,820
create a metadata template. This
is going to have all the basics

21325
21:47:53,820 --> 21:47:57,330
of what we need for our metadata
for our token URI. So in here,

21326
21:47:57,330 --> 21:48:01,560
we'll have a name, set, it's
blank, we'll have a description,

21327
21:48:02,340 --> 21:48:06,600
which will also set as blank
will have the image which this

21328
21:48:06,600 --> 21:48:10,770
is going to be replaced with the
image URI that IPFS URI we just

21329
21:48:10,770 --> 21:48:14,580
created. And if you want to give
your NFT like any types of

21330
21:48:14,580 --> 21:48:20,100
stats, you can do some you can
create this Attributes section

21331
21:48:20,130 --> 21:48:25,860
like so. And if you give it like
traits type, cuteness, comma,

21332
21:48:26,640 --> 21:48:29,310
value 100. And this is how if
you wanted to create like

21333
21:48:29,310 --> 21:48:33,300
different cards or have
different attack, defense, HP

21334
21:48:33,300 --> 21:48:37,170
speed in different different
stats for your NF T's, you would

21335
21:48:37,170 --> 21:48:40,380
add them in this Attributes
section. Typically, you'd want

21336
21:48:40,380 --> 21:48:43,740
these attributes also stored on
chain so your contracts can

21337
21:48:43,920 --> 21:48:46,440
obviously programmatically
interact with these attributes.

21338
21:48:46,620 --> 21:48:49,590
But so now we have this metadata
data template. This is what

21339
21:48:49,590 --> 21:48:52,020
we're going to fill out for each
one of our dogs. Yes, we're

21340
21:48:52,020 --> 21:48:57,030
going to create a new function
in here called async, store

21341
21:48:57,360 --> 21:49:03,150
token URI metadata. And we'll
pass in the meta data to the

21342
21:49:03,150 --> 21:49:07,140
async function. And we'll pass
in the metadata that we get from

21343
21:49:07,140 --> 21:49:10,560
our script over here. So we have
this little template here. And

21344
21:49:10,560 --> 21:49:14,010
we're going to populate this
template based off of what we

21345
21:49:14,010 --> 21:49:17,190
get from storing data in IPFS.
So now we're going to write the

21346
21:49:17,190 --> 21:49:20,040
rest of this handle token your
eyes bit. And so we're going to

21347
21:49:20,040 --> 21:49:23,790
want to do in our data and V,
we're going to say, upload to

21348
21:49:23,790 --> 21:49:28,170
pinata equals true, so that we
can do everything and handle

21349
21:49:28,170 --> 21:49:31,860
token your eyes. So upload to
pinata, it's true, we'll scroll

21350
21:49:31,860 --> 21:49:34,290
down, we'll start creating this.
So the first thing we got to do,

21351
21:49:34,290 --> 21:49:37,230
obviously, we're gonna want to
get those responses and those

21352
21:49:37,230 --> 21:49:41,550
files, right, because it's in
the responses, pin file to IPFS

21353
21:49:41,580 --> 21:49:45,360
is going to return the hash of
the file, right, and we need

21354
21:49:45,360 --> 21:49:48,600
that hash, to add to our
metadata. So we're going to do

21355
21:49:48,810 --> 21:49:52,590
is down here, we're gonna say
const, responses, which is going

21356
21:49:52,590 --> 21:50:00,660
to be image upload, responses,
comma files, equals await, store

21357
21:50:00,660 --> 21:50:06,900
images, and then images,
location. And so this response

21358
21:50:06,900 --> 21:50:11,130
is, is going to be a list of
these responses from pinata. And

21359
21:50:11,130 --> 21:50:14,250
these responses are going to
have the hash of each one of

21360
21:50:14,250 --> 21:50:17,370
these uploaded files. So now
we're going to loop through that

21361
21:50:17,370 --> 21:50:20,910
list and upload each of the
metadata does. So we're going to

21362
21:50:20,910 --> 21:50:28,410
say for each image upload
response index, in image upload

21363
21:50:29,160 --> 21:50:30,390
responses.

21364
21:50:31,740 --> 21:50:34,560
For each one of these, we're
going to create the metadata,

21365
21:50:34,710 --> 21:50:38,760
we're going to create metadata
and then upload the metadata. So

21366
21:50:38,790 --> 21:50:45,450
we're gonna say let token URI,
metadata equals dot dot, dot

21367
21:50:45,600 --> 21:50:50,280
meta data template. So this is
some fun JavaScript, syntactic

21368
21:50:50,280 --> 21:50:54,180
sugar, which kind of means like,
unpack. So basically, we're

21369
21:50:54,180 --> 21:50:57,720
saying token URI metadata is
going to be equal to this stuff.

21370
21:50:57,810 --> 21:51:01,500
We're sticking all this stuff
into this token, your metadata

21371
21:51:01,530 --> 21:51:05,640
variable, now we're gonna say
token, your metadata. dot name

21372
21:51:05,700 --> 21:51:12,630
is going to be equal to files
of, of the index, dot replace,

21373
21:51:13,140 --> 21:51:17,910
dot png, dot png with nothing.
So files is going to be each one

21374
21:51:17,910 --> 21:51:22,380
of those files, right? It's
going to be dot png can be St

21375
21:51:22,380 --> 21:51:26,370
Bernard dot PNG, and it's going
to be Shiva dot png. And

21376
21:51:26,370 --> 21:51:28,590
basically, all we're doing is
we're saying, okay, cool, the

21377
21:51:28,590 --> 21:51:31,560
name inside of our token,
metadata is just going to be

21378
21:51:31,560 --> 21:51:34,440
pug. So we're just going to drop
the extension, basically. So

21379
21:51:34,440 --> 21:51:39,240
that's how we're gonna get the
name token, your AI metadata dot

21380
21:51:39,270 --> 21:51:46,380
description, is going to be
equal to and adore a bowl. And

21381
21:51:46,380 --> 21:51:50,010
then we're just going to get the
name, token URI metadata dot

21382
21:51:50,010 --> 21:51:53,280
name. So it's going to be an
adorable pug pup and adorable

21383
21:51:53,280 --> 21:51:57,120
St. Bernard pop or an adorable
ship and you pup token URI

21384
21:51:57,150 --> 21:52:01,110
metadata dot image, which is
probably the most important one

21385
21:52:01,110 --> 21:52:05,760
here, this is going to be, it's
going to be that IPFS extension

21386
21:52:05,970 --> 21:52:10,920
with the IPFS hash that we get
from the response. So we can get

21387
21:52:10,920 --> 21:52:18,360
that by doing image, upload
responses of the image upload

21388
21:52:19,020 --> 21:52:26,160
response index dot i IPFS. Hash,
so we can go to the pinata docs.

21389
21:52:26,700 --> 21:52:31,950
And we can see pin file to IPFS
returns in IPFS hash, the pin

21390
21:52:31,950 --> 21:52:36,090
size and the timestamp, all we
care about is the IPFS hash. And

21391
21:52:36,090 --> 21:52:41,310
we're going to use that to give
the our metadata image here. And

21392
21:52:41,310 --> 21:52:45,510
then finally, I'll do a little
console dot log uploading. And

21393
21:52:45,510 --> 21:52:52,560
then we'll say, token, your eye
metadata dot name, dot dot dot.

21394
21:52:52,890 --> 21:52:58,020
And now we'll have to store the
file or store store the JSON to

21395
21:52:58,020 --> 21:53:02,010
pinata slash IPFS. And this is
where in our upload to pinata

21396
21:53:02,010 --> 21:53:05,070
bit here, we're going to add
this function here. So we have

21397
21:53:05,070 --> 21:53:08,850
store token URI metadata. And
all we're gonna do in here, so

21398
21:53:08,850 --> 21:53:13,950
we're gonna say try const
response equals await, and nada,

21399
21:53:13,980 --> 21:53:20,850
that pin JSON to IPFS of the
metadata, right. And again, we

21400
21:53:20,850 --> 21:53:25,320
have, we want pin JSON to IPFS,
which is going to be really

21401
21:53:25,320 --> 21:53:29,010
similar. So we need to pass the
body, which is going to be the

21402
21:53:29,010 --> 21:53:31,470
JSON. And we have some optional
stuff here, but it's gonna give

21403
21:53:31,470 --> 21:53:36,270
us the same return the IPFS hash
pin, size and timestamp. And

21404
21:53:36,270 --> 21:53:38,970
then if this works, well, we're
just going to do return

21405
21:53:39,300 --> 21:53:43,980
response. Otherwise, we'll do
catch error. And then we'll just

21406
21:53:43,980 --> 21:53:48,510
do console dot log error, and
then we'll just do return null

21407
21:53:50,130 --> 21:53:54,000
and then we'll exports or token
URI metadata. And then back in

21408
21:53:54,000 --> 21:53:58,740
our deploy, we'll go ahead and
import this store token URI

21409
21:53:58,740 --> 21:54:04,020
metadata. And we'll scroll down.
And they'll do const, metadata,

21410
21:54:04,260 --> 21:54:10,260
upload response equals await,
store token URI metadata where

21411
21:54:10,260 --> 21:54:15,930
we pass the token, Uri,
metadata. And now finally, and

21412
21:54:15,930 --> 21:54:19,530
now with all of these metadata
is being uploaded are finally

21413
21:54:19,530 --> 21:54:22,650
going to have the token you
arise that we need. So we'll

21414
21:54:22,650 --> 21:54:28,230
say, token, your eyes dot push,
IPFS, slash slash, and then the

21415
21:54:28,230 --> 21:54:33,510
metadata response here, metadata
upload response dot IPFS. Hash.

21416
21:54:33,540 --> 21:54:37,680
So we finally will have this
array of IPFS hashes that points

21417
21:54:37,680 --> 21:54:40,800
to the metadata, and each one of
these metadata are pointing to

21418
21:54:40,800 --> 21:54:44,310
the image. And then we'll do a
little console dot log token.

21419
21:54:44,550 --> 21:54:50,550
You arise, uploaded, they are
and then we'll do another little

21420
21:54:50,550 --> 21:54:56,880
console dot log token your eyes.
Oh, all right. So let's go ahead

21421
21:54:56,880 --> 21:55:00,330
and run this. And let's see if
it works. In our pinata, we

21422
21:55:00,330 --> 21:55:04,620
should see both the images and
then also the metadata. If

21423
21:55:04,620 --> 21:55:08,250
process dot E and V dot upload
to pinata equals true, looks

21424
21:55:08,250 --> 21:55:12,210
like it is true. And we should
run this and handle token, your

21425
21:55:12,210 --> 21:55:17,310
eyes will both upload our images
with store images here and then

21426
21:55:17,340 --> 21:55:21,900
upload our metadata. We'll only
see it in here once because

21427
21:55:21,900 --> 21:55:24,900
again, it's gonna have the exact
same Cid right, it's gonna have

21428
21:55:24,900 --> 21:55:28,800
the same hash, so we won't get
duplicates of the same file in

21429
21:55:28,800 --> 21:55:33,360
pinata, or in our IPFS. So let's
open this up. Let's run this one

21430
21:55:33,360 --> 21:55:37,320
more time, or had deployed dash
dash tags, random IPFS and

21431
21:55:37,320 --> 21:55:40,320
mocks. Okay, it looks like we
almost worked uploading to

21432
21:55:40,320 --> 21:55:44,520
banana working on zero working
on one working on two metadata

21433
21:55:44,520 --> 21:55:50,670
template is not defined. Ha,
because I spelt meta data

21434
21:55:50,670 --> 21:55:54,480
template, meta data template,
let's spell things correctly.

21435
21:55:55,170 --> 21:55:58,080
Now let's try this again, it
working on zero is it working on

21436
21:55:58,200 --> 21:56:02,850
two image upload response is not
defined. I should spell

21437
21:56:02,850 --> 21:56:07,470
correctly. There we go. Let's,
let's do our caps correctly.

21438
21:56:07,470 --> 21:56:11,610
Let's try this one more time.
Okay, 012, uploading pug

21439
21:56:11,640 --> 21:56:14,940
uploading Shiva in you uploading
St. Bernard token your eyes

21440
21:56:14,970 --> 21:56:18,990
upload it and they're here. Now
if we grab this, and stick it

21441
21:56:18,990 --> 21:56:22,920
into our browser, or your IPFS
node, boom, we have them in

21442
21:56:22,920 --> 21:56:26,880
here. And what we can do is we
can grab this hash, we can jump

21443
21:56:26,880 --> 21:56:32,700
into our IPFS desktop, go to
files, we import from IPFS paste

21444
21:56:32,700 --> 21:56:35,610
it in here. And you know give it
the name etc, that we have it on

21445
21:56:35,610 --> 21:56:39,960
our own IPFS node as well.
Awesome. Now if we go over to

21446
21:56:39,960 --> 21:56:43,800
pinata give this a little
refresh, we can see we have

21447
21:56:43,800 --> 21:56:47,610
everything in here. So if I copy
one of these, and I go to IPFS

21448
21:56:47,610 --> 21:56:51,120
dot dot slash paste that in, we
can see the metadata in here.

21449
21:56:51,420 --> 21:56:55,080
And everything looks good. So
this is absolutely massive that

21450
21:56:55,080 --> 21:56:58,950
we've just done this because now
we can store data both on our

21451
21:56:58,950 --> 21:57:02,550
own IPFS node and at least one
other nodes so that if our

21452
21:57:02,580 --> 21:57:04,890
computer goes down or our server
goes down, and there's at least

21453
21:57:04,890 --> 21:57:05,940
somebody else who's done it.

21454
21:57:11,459 --> 21:57:14,909
Now we finally have this list of
token your eyes, we can finally

21455
21:57:14,909 --> 21:57:20,009
go back to our arguments. And
now we can do like this. And we

21456
21:57:20,009 --> 21:57:23,339
can upload all of those token
your eyes to our smart contract.

21457
21:57:23,459 --> 21:57:26,699
And then we're going to need a
mint fee as well for this. So if

21458
21:57:26,699 --> 21:57:29,879
we go to our upper heart at
config will create like a little

21459
21:57:29,879 --> 21:57:33,779
mint fee in here, say mint fee
is going to be whatever we want

21460
21:57:33,929 --> 21:57:41,369
12345678123456789 What we'll do
is 0.01 eath. So we'll even drop

21461
21:57:41,369 --> 21:57:44,669
this down one, we'll do it for
we'll do it for the Hard Hat

21462
21:57:44,669 --> 21:57:47,759
Network. And then we'll also do
it for Rinckey as well. We have

21463
21:57:47,759 --> 21:57:51,869
the arguments here. Now we can
finally deploy our contract. So

21464
21:57:51,869 --> 21:57:57,869
we'll do const random IPFS. And
if t equals await, deploy, if

21465
21:57:57,869 --> 21:58:05,789
the contract is random IPFS NF T
from Deployer. args is args. Log

21466
21:58:05,789 --> 21:58:11,159
is true. And then wait
confirmations is going to be

21467
21:58:11,159 --> 21:58:21,599
network dot config dot block for
confirm terminations, or one,

21468
21:58:21,869 --> 21:58:25,049
and great they might do another
little line here. We'll do the

21469
21:58:25,049 --> 21:58:28,799
verification bit. I'm actually
just going to copy that from our

21470
21:58:28,799 --> 21:58:32,999
deploy. Our basic I'm just going
to copy this it's going to be

21471
21:58:33,059 --> 21:58:36,269
code is going to be exactly the
same, except for we're going to

21472
21:58:36,269 --> 21:58:41,009
verify random IPFS instead of
and then actually we use args

21473
21:58:41,009 --> 21:58:44,549
instead of arguments, then that
is it. So we'll give this a

21474
21:58:44,549 --> 21:58:49,499
quick deploy test, HH deploy or
yarn Hardhead deploy. And it

21475
21:58:49,499 --> 21:58:52,019
looks like we almost worked we
almost got Everything's done.

21476
21:58:52,049 --> 21:58:56,249
Network config is not defined,
because we didn't import it. So

21477
21:58:56,249 --> 21:58:59,339
let's go ahead and import
network config from our helper

21478
21:58:59,339 --> 21:59:03,179
Hardhead. Config. So import
network config. We'll try this

21479
21:59:03,179 --> 21:59:07,079
one more time chain ID is not
defined, it's going to be chain

21480
21:59:07,079 --> 21:59:13,169
ID, that chain Id try one more
time. And awesome, it's at least

21481
21:59:13,169 --> 21:59:15,629
working for our heart Hat
Network. And then we can copy

21482
21:59:15,629 --> 21:59:19,919
this array, and just paste it in
here. Boom. And now we have this

21483
21:59:19,919 --> 21:59:23,699
token your eyes. And now back in
our dot env. Now we can set this

21484
21:59:23,699 --> 21:59:27,629
to false. Since we have all
those token neurons already, we

21485
21:59:27,629 --> 21:59:30,839
just run hard hit Deploy, we'll
just use the token heroes that

21486
21:59:30,839 --> 21:59:34,709
we already have uploaded. Yes,
we have done it. Now I know

21487
21:59:34,709 --> 21:59:38,159
you're excited to see this on
something like open See, you're

21488
21:59:38,159 --> 21:59:41,519
excited to see this right away.
But let's save deploying all

21489
21:59:41,519 --> 21:59:44,579
these to rink B for our last
thing, because again, deploying

21490
21:59:44,579 --> 21:59:47,459
to test nets is really slow. So
let's just wait until our last

21491
21:59:47,459 --> 21:59:51,119
bit and then we'll go ahead, and
we'll deploy this to rank B. But

21492
21:59:51,119 --> 21:59:53,309
before we write tests, something
that I noticed when I was

21493
21:59:53,309 --> 21:59:56,489
writing my test is that we
forgot to update the token

21494
21:59:56,489 --> 21:59:59,909
counter. So in here, before we
do, our safe, men will do s

21495
21:59:59,909 --> 22:00:03,719
token counter plus equals s
token counter, which is going to

21496
22:00:03,719 --> 22:00:07,319
be esto. Encounter equals es
token counter plus one. And

21497
22:00:07,319 --> 22:00:09,839
that's a perfect example of why
writing tests is so important.

21498
22:00:10,229 --> 22:00:12,419
Before you write any tests,
you're definitely going to need

21499
22:00:12,419 --> 22:00:16,139
to fund that subscription, which
we didn't do in here. So we need

21500
22:00:16,139 --> 22:00:24,719
to do a wait VRF coordinate Tor
V to mock dot fund, sub

21501
22:00:25,649 --> 22:00:32,939
scription. subscription ID,
comma will do fund amount, and

21502
22:00:32,939 --> 22:00:35,429
then just up at the top,
actually, we can even pull this

21503
22:00:35,429 --> 22:00:38,999
out too. Since that's not gonna
change at all. We can do let

21504
22:00:38,999 --> 22:00:44,009
token year I was like that looks
like const fund amount equals

21505
22:00:44,189 --> 22:00:46,829
cool. Or you could do you know,
you could also do ethers dot

21506
22:00:46,829 --> 22:00:59,849
parse. But as you know, before
we can even deploy to rink beam,

21507
22:01:00,089 --> 22:01:03,869
what should we do? Well, you got
it right, we should absolutely

21508
22:01:03,929 --> 22:01:08,429
100 percent write some tests. So we're
create a new file called random

21509
22:01:08,549 --> 22:01:14,009
IPFS NF t dot test dot j s. And
we can write some tests here.

21510
22:01:14,129 --> 22:01:16,979
Now, once again, there isn't
anything new that you're going

21511
22:01:16,979 --> 22:01:20,789
to learn in this test here, it's
going to be very similar to the

21512
22:01:20,789 --> 22:01:23,969
lottery tests that we've written
before. So here's what I'm going

21513
22:01:23,969 --> 22:01:27,359
to say, I'm going to highly
recommend once again, that you

21514
22:01:27,359 --> 22:01:30,749
try to write at least two or
three of your own tests, but

21515
22:01:30,749 --> 22:01:33,839
definitely write a test fulfill
random words. But I'm going to

21516
22:01:33,839 --> 22:01:37,469
encourage you to pause the video
now, please pause the video and

21517
22:01:37,469 --> 22:01:40,019
try to write some tests yourself
struggling with some of these

21518
22:01:40,019 --> 22:01:42,599
tests. And writing some of these
tests is going to be what really

21519
22:01:42,599 --> 22:01:45,599
gives you those coding muscles,
if you will, that's going to

21520
22:01:45,599 --> 22:01:47,819
give you the skills to keep
writing these tests and be

21521
22:01:47,819 --> 22:01:50,519
really fast and really
efficient. When you're building

21522
22:01:50,519 --> 22:01:53,339
these smart contracts. These
tests are the tests that protect

21523
22:01:53,339 --> 22:01:57,359
you from writing bad immutable
code. So please pause the video,

21524
22:01:57,419 --> 22:01:59,729
I'm going to copy paste from the
GitHub repo. But please take

21525
22:01:59,729 --> 22:02:02,369
this time to write some of your
own tests here.

21526
22:02:08,700 --> 22:02:12,330
Alright, great. Did you write
some tests? Hope you did. If you

21527
22:02:12,330 --> 22:02:14,370
didn't write some tests, pause
this video and go write some

21528
22:02:14,370 --> 22:02:17,940
tests. I promise you doing these
tests, writing exercises on your

21529
22:02:17,940 --> 22:02:20,790
own will help you dramatically
at this point, what have we

21530
22:02:20,790 --> 22:02:24,450
done, we've done some some
amazing stuff, we've deployed a

21531
22:02:24,450 --> 22:02:27,390
basic NFT with pretty much
nothing to it, then we've

21532
22:02:27,390 --> 22:02:31,530
deployed a provably random NFT
with random stats with random

21533
22:02:31,530 --> 22:02:35,370
traits with different rarities,
for each NF T's depending on

21534
22:02:35,550 --> 22:02:38,760
when it was minted, or who
minted it. We've stored the data

21535
22:02:38,760 --> 22:02:42,300
for this on IPFS. And we've
learned how to programmatically

21536
22:02:42,330 --> 22:02:46,020
upload our files to pinata,
which is another pinning service

21537
22:02:46,020 --> 22:02:49,800
for us. We learned a little bit
about NFT debt storage, which is

21538
22:02:49,830 --> 22:02:54,960
another way to pin data to IPFS.
And then of course, we learned

21539
22:02:54,960 --> 22:02:58,020
that if we wanted to, we could
programmatically pin data to

21540
22:02:58,020 --> 22:03:01,410
IPFS on our own node. But since
a lot of us aren't gonna be

21541
22:03:01,410 --> 22:03:04,620
running our own computers 24/7.
We went ahead and said, Okay,

21542
22:03:04,620 --> 22:03:07,500
well, we'll stick with pinata
for our default here. Now that

21543
22:03:07,500 --> 22:03:10,620
we've done all that, boom, got
another little checkmark here.

21544
22:03:13,230 --> 22:03:16,500
Now I got something to say we
don't need to host our data on

21545
22:03:16,500 --> 22:03:21,150
IPFS can actually host our data,
our metadata directly on chain

21546
22:03:21,150 --> 22:03:24,060
if we want to. However, there
are some pros and cons to IT

21547
22:03:24,180 --> 22:03:27,540
pros of hosting on IPFS, or
that's going to be cheap. And

21548
22:03:27,540 --> 22:03:32,640
the cons are that someone needs
to pin our data, right? There's

21549
22:03:32,880 --> 22:03:36,030
at least one person always needs
to have her data pinned, right?

21550
22:03:36,030 --> 22:03:39,600
It's decentralized, but you at
least need somebody to pin your

21551
22:03:39,600 --> 22:03:42,540
data, right? And using something
like file coin is a way to

21552
22:03:42,540 --> 22:03:45,150
incentivize people to pin that
data. But if you're not using

21553
22:03:45,150 --> 22:03:48,810
File coin, it's not necessarily
guaranteed the pros of doing our

21554
22:03:48,810 --> 22:03:53,670
SVG on chain NFT the data A is
on chain. And you never have to

21555
22:03:53,670 --> 22:03:56,910
worry about somebody actually
pinning the data. The cons are

21556
22:03:56,910 --> 22:04:01,890
that this is much more
expensive. These little images,

21557
22:04:02,100 --> 22:04:05,160
right here are actually
surprisingly large and storing

21558
22:04:05,160 --> 22:04:07,980
them on chain can actually get
pretty expensive. So we're going

21559
22:04:07,980 --> 22:04:10,830
to use some different images, so
much smaller images, much

21560
22:04:10,830 --> 22:04:13,830
cheaper images to work with
here. And if you want to see

21561
22:04:13,830 --> 22:04:17,460
another version of this, I have
another video, how to make NFT

21562
22:04:17,460 --> 22:04:20,760
art with on chain metadata, it
goes through pretty much what

21563
22:04:20,760 --> 22:04:23,220
we're about to go through here
as well if you want a second

21564
22:04:23,250 --> 22:04:25,650
reference, and there's a link to
this in the GitHub repo

21565
22:04:25,680 --> 22:04:29,250
associated with this course. So
instead of these PNGs that we're

21566
22:04:29,250 --> 22:04:38,190
using, we're going to use
something called SVG s. Now, an

21567
22:04:38,190 --> 22:04:42,600
SVG stands for Scalable Vector
Graphics. And these are much

21568
22:04:42,600 --> 22:04:46,260
much more minimalistic files
that we can go ahead and upload

21569
22:04:46,260 --> 22:04:49,020
to to the blockchain. So that's
why we're going to use them

21570
22:04:49,020 --> 22:04:51,090
because since there's so much
more minimalistic, they're a lot

21571
22:04:51,090 --> 22:04:53,580
cheaper to upload. Because
remember, the more data that you

21572
22:04:53,580 --> 22:04:56,160
upload to the blockchain, the
more expensive it is. Now in

21573
22:04:56,160 --> 22:05:00,180
this video, I make randomize SVG
data on chain. And here's kind

21574
22:05:00,180 --> 22:05:02,580
of an example of what one looks
like. It's just a whole bunch of

21575
22:05:02,580 --> 22:05:06,360
random lines. Not super
thrilling, but random and kind

21576
22:05:06,360 --> 22:05:09,480
of cool. And it's 100 percent. On
chain, these SVG is actually

21577
22:05:09,480 --> 22:05:12,720
work right in HTML. So if you
want to use these for your

21578
22:05:12,720 --> 22:05:16,020
websites, you can as well now
there's a link to this tutorial

21579
22:05:16,020 --> 22:05:18,690
in the GitHub repo associated
with this course, where we can

21580
22:05:18,690 --> 22:05:21,450
go ahead and try it yourself.
And we can actually play with

21581
22:05:21,450 --> 22:05:23,760
making an SVG, right, so they
have all these different

21582
22:05:23,760 --> 22:05:29,250
commands in this web through
schools.com/graphics/svg intro

21583
22:05:29,250 --> 22:05:32,850
dot ASP, you can see some of the
different commands, right, you

21584
22:05:32,850 --> 22:05:36,480
can make a rectangle you can
make a circle path is a big one

21585
22:05:36,480 --> 22:05:40,140
where you can say exactly what
the path or the line you want to

21586
22:05:40,140 --> 22:05:42,840
draw is going to look like.
There's a whole bunch of stuff

21587
22:05:43,080 --> 22:05:46,680
you can make in this SVG. And
the cool thing is, no matter how

21588
22:05:46,680 --> 22:05:50,340
big you make an SVG, the quality
is always going to be exactly

21589
22:05:50,340 --> 22:05:53,550
the same, because SVG just
explains exactly how to draw it

21590
22:05:53,550 --> 22:05:56,760
no matter how big or how little,
the image is going to be. So if

21591
22:05:56,760 --> 22:05:59,580
you want to learn more about SVG
is you want to play with SVG is

21592
22:05:59,610 --> 22:06:02,010
you know, you can come in here
and try it yourself. So with

21593
22:06:02,010 --> 22:06:04,770
that being said, that's what
we're going to store on chain.

21594
22:06:04,830 --> 22:06:07,680
So that's how we're going to
store this SVG stuff on chain.

21595
22:06:07,950 --> 22:06:09,810
But we're gonna go one step
further, we're gonna make this

21596
22:06:09,810 --> 22:06:13,740
dynamic, we're gonna make this
actually change based off of

21597
22:06:13,770 --> 22:06:17,340
some data on chain. If you go to
the GitHub repo associated with

21598
22:06:17,340 --> 22:06:20,880
this lesson, and you go to the
images, and you go to dynamic

21599
22:06:20,880 --> 22:06:24,960
NFT, you'll see two images, see
happy dot SVG, which looks like

21600
22:06:24,960 --> 22:06:29,280
this. And you'll see frown dot
SVG, which looks like this. So

21601
22:06:29,280 --> 22:06:32,130
we're going to make this NFT
dynamic in the sense that we're

21602
22:06:32,130 --> 22:06:37,440
going to say, if the price of
eath is above some number, then

21603
22:06:37,440 --> 22:06:39,750
we're going to have it be a
happy face. And then if it's

21604
22:06:39,750 --> 22:06:44,130
below that, we're going to make
it a frowny face. So our NFT is

21605
22:06:44,130 --> 22:06:47,340
going to change based off of
some real world parameters. And

21606
22:06:47,340 --> 22:06:49,230
this is obviously really
powerful and really cool,

21607
22:06:49,230 --> 22:06:53,100
because we can have an NFT that
changes based off stats, we can

21608
22:06:53,100 --> 22:06:56,640
have an NF t that changes based
off of really whatever, and

21609
22:06:56,640 --> 22:06:59,760
we're going to store all the
data 100 percent on chain, it's going

21610
22:06:59,760 --> 22:07:02,040
to be a little bit more
expensive. So that's what we're

21611
22:07:02,040 --> 22:07:03,000
going to be building here.

21612
22:07:08,459 --> 22:07:11,129
Let's go ahead, let's jump into
it. And let's do the final

21613
22:07:11,129 --> 22:07:14,489
contract for our ultimate NFT
section. So we're going to

21614
22:07:14,489 --> 22:07:17,609
create a new contract in here,
new contract, and this is going

21615
22:07:17,609 --> 22:07:24,149
to be our dynamic, SVG and F T
dot soul. And it's going to look

21616
22:07:24,149 --> 22:07:28,919
real similar to what we've been
doing. slash slash dynamic. SVG

21617
22:07:28,919 --> 22:07:37,229
and ft dot saw, slash lat spdx,
license identifier, and my team

21618
22:07:37,889 --> 22:07:46,709
pragma. solidity, Eric zero,
point 8.7. Contract, dynamic

21619
22:07:46,739 --> 22:07:52,109
SVG, NF t. Now let's talk about
what the architecture of this is

21620
22:07:52,109 --> 22:07:54,959
going to look like. It's gonna
look like pretty normal NF T,

21621
22:07:55,439 --> 22:07:58,559
with a couple of caveats. We're
gonna give it a min function to

21622
22:07:58,559 --> 22:08:02,939
mint, these NF T's are also
going to store our SVG

21623
22:08:02,969 --> 22:08:07,169
information somewhere. And then
we're going to need to have some

21624
22:08:07,169 --> 22:08:14,099
logic to say show x image or
show y image, right. And as we

21625
22:08:14,099 --> 22:08:17,579
know, that's really just going
to be switching the token URI to

21626
22:08:17,579 --> 22:08:21,149
say show X or show y. So let's
go into how we'd actually do

21627
22:08:21,149 --> 22:08:25,289
this. So first, we know this is
going to be in ERC. 721. So we

21628
22:08:25,289 --> 22:08:27,869
can go ahead and import that
from open Zeppelin. So we're

21629
22:08:27,869 --> 22:08:33,479
going to say import at open
Zeppelin slash contracts, slash

21630
22:08:33,479 --> 22:08:40,409
token slash ERC. 721 slash ERC.
721 That's all. Now we're not

21631
22:08:40,409 --> 22:08:43,859
going to call that set token URI
function that we call before so

21632
22:08:43,859 --> 22:08:47,309
we can just use the raw ERC 721
instead of an extension. So

21633
22:08:47,309 --> 22:08:52,889
we'll say our contract is ERC
721 and Now that we're making it

21634
22:08:52,889 --> 22:08:57,389
an ERC 721. We can say construct
dorm like this, then we'll call

21635
22:08:57,389 --> 22:09:01,349
the constructor of the ERC. 721,
which we're going to call this

21636
22:09:01,499 --> 22:09:09,749
dynamic SVG, and f t DSN,
dynamic SVG and s, t and f t,

21637
22:09:10,259 --> 22:09:14,579
like so then we're also going to
need a mint function. So let's

21638
22:09:14,579 --> 22:09:18,929
just create that right now say
function, mint and f t or

21639
22:09:18,929 --> 22:09:21,659
request NFT. And we'll be a
little bit looser here, we'll

21640
22:09:21,659 --> 22:09:25,199
say the user doesn't need to pay
any money for this. So this will

21641
22:09:25,199 --> 22:09:27,959
just be a public function. And
we're just going to mint them

21642
22:09:27,959 --> 22:09:31,979
and NFT. Same thing, we're just
going to call Safe mint message

21643
22:09:31,979 --> 22:09:35,969
dot sender. And of course, we
need that token count term. So

21644
22:09:35,969 --> 22:09:40,949
let's go ahead and in our top
will do you in 256, private s

21645
22:09:40,949 --> 22:09:45,209
underscore token counter, we'll
do token counter here. And then

21646
22:09:45,209 --> 22:09:47,609
after we meant we'll do tag
counter plus, there's gonna be

21647
22:09:47,609 --> 22:09:52,169
equals token counter plus one.
And then that's pretty much it,

21648
22:09:52,529 --> 22:09:55,319
we have a way to meant we've
done some of the basics here.

21649
22:09:55,619 --> 22:09:58,829
We'll even we'll be explicit
will say s token counter equals

21650
22:09:58,829 --> 22:10:02,219
zero to initialize it. But now
what is this token going to look

21651
22:10:02,219 --> 22:10:05,939
like? We want these to look like
SVGs. And we want it to be based

21652
22:10:05,939 --> 22:10:09,869
off the price of some asset in
our constructor, all right,

21653
22:10:10,049 --> 22:10:15,389
create a string memory. We'll
call it low SVG and a string

21654
22:10:15,419 --> 22:10:27,569
memory, high SVG. And in our
code will save this low SVG in

21655
22:10:27,569 --> 22:10:30,089
this highest V G. So these will
be the images, these will be

21656
22:10:30,089 --> 22:10:32,729
like the frowny face and the
smiley face that will just

21657
22:10:32,759 --> 22:10:37,259
import as input parameters here.
So as we know, we can make these

21658
22:10:37,259 --> 22:10:39,959
immutable since these are
probably not going to change. We

21659
22:10:39,959 --> 22:10:47,309
can say String, private, I
underscore low image URI. And in

21660
22:10:47,309 --> 22:10:52,409
string private, I underscore
high image URI. But if we just

21661
22:10:52,409 --> 22:10:55,439
pass the SVG data, right, the
SVG data is going to look like

21662
22:10:55,439 --> 22:11:00,539
what in this GitHub, I can go to
display the source blob here and

21663
22:11:00,539 --> 22:11:03,569
I can see exactly what this code
looks like this code here is

21664
22:11:03,569 --> 22:11:07,589
definitely not an image URI.
What we need is the image URI to

21665
22:11:07,589 --> 22:11:09,929
look something like this, right?
Now, the way that we're going to

21666
22:11:09,929 --> 22:11:12,809
pass it in is like with this SVG
code, right? Because we want to

21667
22:11:12,809 --> 22:11:15,719
just pass it the SVG code, and
then have the contract handle

21668
22:11:15,719 --> 22:11:16,589
everything else.

21669
22:11:16,679 --> 22:11:21,509
So how do we actually do this?
Well, what we can do is we can

21670
22:11:21,509 --> 22:11:28,559
create a function called SVG to
image URI. And on chain, we can

21671
22:11:28,559 --> 22:11:33,929
convert these SVGs from SVGs. To
image arise. So instead of

21672
22:11:33,929 --> 22:11:37,649
having IPFS, as their start,
we're gonna use something called

21673
22:11:37,679 --> 22:11:43,019
base 64 encoding, you can
actually encode any SVG to a

21674
22:11:43,019 --> 22:11:48,089
base 64 image URL. That's right.
It'll look something like this

21675
22:11:48,179 --> 22:11:51,509
base. 64 is group a binary to
text encoding schemes that

21676
22:11:51,509 --> 22:11:56,159
represents binary data. Or in
our case, our SVG data. Base. 64

21677
22:11:56,159 --> 22:11:59,489
is particularly prevalent in the
world wide web, or one of its

21678
22:11:59,489 --> 22:12:03,059
uses is the ability to embed
image files or other binary

21679
22:12:03,059 --> 22:12:07,259
assets inside textual assets,
such as HTML, and CSS, what we

21680
22:12:07,259 --> 22:12:12,809
can do, can actually convert all
this SVG stuff to a URL or an

21681
22:12:12,809 --> 22:12:16,439
image URI would be great, right?
That's exactly what we want, we

21682
22:12:16,439 --> 22:12:20,579
want to be able to convert this
to a URL or an image URI. Now,

21683
22:12:20,609 --> 22:12:23,699
if you take one of these images,
or these SVG images, like the

21684
22:12:23,699 --> 22:12:26,639
happy to have SVG, what we can
actually do in this happy dot

21685
22:12:26,639 --> 22:12:31,589
SVG is we can actually copy the
image address, which is going to

21686
22:12:31,589 --> 22:12:34,319
be the URL of this address. And
if we paste it back in, we'll

21687
22:12:34,319 --> 22:12:38,099
see justice file here. And in
this site, we can actually do

21688
22:12:38,099 --> 22:12:43,349
data type, remote URL, paste it
in here. And we can say encode

21689
22:12:43,349 --> 22:12:48,599
SVG to base 64. And down here,
we'll get this weird job role of

21690
22:12:48,629 --> 22:12:53,279
numbers and letters and stuff.
This base 64 encoding represents

21691
22:12:53,279 --> 22:12:56,759
the SVG that we just got and
what we can do in our browser,

21692
22:12:56,789 --> 22:13:06,419
we can type data, colon, image,
slash SVG, plus XML, semicolon,

21693
22:13:06,989 --> 22:13:11,789
base, 64, comma, and then paste
that massive thing in here and

21694
22:13:11,789 --> 22:13:16,109
Enter. And wouldn't you know it,
we get exactly that image back

21695
22:13:16,109 --> 22:13:21,029
up. So that huge, massive thing
here is the base 64 encoding of

21696
22:13:21,029 --> 22:13:24,719
this image. So with this basic C
four encoded image, we can use

21697
22:13:24,719 --> 22:13:28,829
this on chain as the image you
arrive for our images. And then

21698
22:13:28,829 --> 22:13:31,709
for our metadata. We'll just
bake that directly into our

21699
22:13:31,709 --> 22:13:34,559
token URI. You'll see what I
mean in a second. So we have a

21700
22:13:34,559 --> 22:13:38,159
way where we can actually
directly put our SVG code right

21701
22:13:38,159 --> 22:13:40,589
into our smart contracts. Let's
figure out how to do that. So we

21702
22:13:40,589 --> 22:13:44,159
have function, SVG to image URI,
so we know we're going to want

21703
22:13:44,159 --> 22:13:47,909
to probably do that same base 64
encoding on chain. We're gonna

21704
22:13:47,909 --> 22:13:50,849
100 percent do this off chain if you
want to save some gas but it's

21705
22:13:50,849 --> 22:13:53,669
kind of fun for To show how to
do this all on chain, so we'll

21706
22:13:53,669 --> 22:13:56,969
make this a public pure
function. And we'll have it

21707
22:13:56,969 --> 22:14:02,189
returns a string memory. So
we're going to give this

21708
22:14:02,189 --> 22:14:05,039
function an SVG, which we're
going to pass in from our

21709
22:14:05,039 --> 22:14:08,279
constructor. And we're going to
return a string, which is going

21710
22:14:08,279 --> 22:14:11,759
to be that base 64 encoded URL
that we just saw, while up at

21711
22:14:11,759 --> 22:14:20,759
our top will do string, private
constant, base S feed, base 64,

21712
22:14:21,239 --> 22:14:29,159
encoded SVG prefix equals that
right there. And we'll use this

21713
22:14:29,189 --> 22:14:34,199
to generate our SVG now, well,
we can do. And then we're going

21714
22:14:34,199 --> 22:14:39,449
to do string memory SVG, we're
going to encode this SVG in

21715
22:14:39,449 --> 22:14:43,529
basically for ourself by adding
the base 64 encoding on chain.

21716
22:14:43,679 --> 22:14:46,979
Now, we don't really want to
have to rewrite that ourselves.

21717
22:14:47,039 --> 22:14:49,559
So luckily for us, somebody has
already done this. And we can

21718
22:14:49,559 --> 22:14:52,709
see the GitHub repo associated
with this, this was created by

21719
22:14:52,709 --> 22:14:55,469
one of the LoopRing devs really
awesome project, if you want to

21720
22:14:55,469 --> 22:14:58,109
check that out as well. And
we're going to borrow this code

21721
22:14:58,139 --> 22:15:02,219
for our SVG on chain. So what we
can do is we can add this in

21722
22:15:02,219 --> 22:15:05,939
here, add their GitHub code,
where they have basically

21723
22:15:05,939 --> 22:15:09,269
everything that we need in here
to encode and decode basics

21724
22:15:09,269 --> 22:15:15,869
before, we can do yarn, add dash
dash Dev, base 64 Dash soul,

21725
22:15:16,049 --> 22:15:18,599
this is going to add their code
as a dependency. And once we've

21726
22:15:18,629 --> 22:15:23,939
added it, we can go ahead and
import it with import, base 64,

21727
22:15:24,329 --> 22:15:31,439
dash soul slash, base 64 dot
Sol. And this contract comes

21728
22:15:31,439 --> 22:15:36,989
with an encoder. So then we can
just do string memory, SVG base,

21729
22:15:37,019 --> 22:15:44,099
64, encoded, equals base 64 dot
ENCODE. And here's where it gets

21730
22:15:44,129 --> 22:15:45,389
a little bit weird.

21731
22:15:45,870 --> 22:15:56,190
We'll do bytes string, abi dot
ENCODE, act, SVG, and then we'll

21732
22:15:56,190 --> 22:16:04,350
return string API dot encode
packed, base 64, encoded SVG

21733
22:16:04,350 --> 22:16:09,900
prefix, comma SVG base 64
encoded, and just this function,

21734
22:16:09,900 --> 22:16:15,240
this SVG to image URI will take
in any SVG and spit us back out

21735
22:16:15,450 --> 22:16:20,310
a URL or URI that looks exactly
like this. Now, I kind of sped

21736
22:16:20,310 --> 22:16:22,740
through some stuff in here.
There's a whole bunch of new

21737
22:16:22,740 --> 22:16:26,730
stuff like ABI dot encode packed
that we did twice, what is this

21738
22:16:26,760 --> 22:16:28,650
ABI dot encode packed doing?

21739
22:16:29,040 --> 22:16:37,710
Well, let's learn about that. So
from a really, really high

21740
22:16:37,710 --> 22:16:41,940
level, this is basically how you
concatenate strings. Right, this

21741
22:16:41,940 --> 22:16:44,220
is how you combine strings
together. And we're going to

21742
22:16:44,220 --> 22:16:49,260
jump over remix to actually
explore this ABI dot encode pact

21743
22:16:49,260 --> 22:16:52,980
and this ABI encoding stuff a
little bit more. Now the section

21744
22:16:52,980 --> 22:16:56,670
that we're about to go through
is definitely advanced. And

21745
22:16:56,670 --> 22:16:59,940
we're going to be going over
some really low level stuff, and

21746
22:16:59,940 --> 22:17:03,240
how solidity works behind the
scenes, how the binary works,

21747
22:17:03,240 --> 22:17:06,390
and this thing called opcodes.
And all this crazy, low level,

21748
22:17:06,750 --> 22:17:09,930
tricky, difficult things to
understand. If you want to move

21749
22:17:09,930 --> 22:17:13,350
past this section, there are
timestamps in the GitHub repo.

21750
22:17:13,530 --> 22:17:16,830
To help you move past this.
However, I do encourage you to

21751
22:17:16,830 --> 22:17:20,160
at least try to absorb most of
this material, if you don't

21752
22:17:20,160 --> 22:17:24,810
understand it the first time.
That's 100 percent. Okay, this is more

21753
22:17:24,840 --> 22:17:28,410
advanced. Anyways, for most of
your basic projects, you won't

21754
22:17:28,410 --> 22:17:32,100
really need this information.
It's only later on once you get

21755
22:17:32,100 --> 22:17:35,160
more advanced that knowing all
this is really going to make you

21756
22:17:35,340 --> 22:17:38,580
a phenomenal solidity developer.
And when you approach this

21757
22:17:38,580 --> 22:17:42,090
section, when you approach this
sub lesson on EVM, opcodes, and

21758
22:17:42,090 --> 22:17:45,570
coding and calling, just know
that if you don't 100 percent

21759
22:17:45,570 --> 22:17:48,720
understand it the first time
that is okay, if you want to

21760
22:17:48,720 --> 22:17:52,380
watch this section a couple of
times fantastic. So if you want

21761
22:17:52,380 --> 22:17:55,110
to jump over to remix and follow
along, let's do it. Now in our

21762
22:17:55,110 --> 22:17:57,450
contract section, let's go ahead
and create a new file, we're

21763
22:17:57,450 --> 22:18:01,230
going to call it encoding dot
soul. And remember, all the code

21764
22:18:01,230 --> 22:18:03,420
that we're going to be going
with in here is going to be in

21765
22:18:03,420 --> 22:18:07,980
this sub Lesson folder of the
Hardhead NFT. FCC. And all the

21766
22:18:07,980 --> 22:18:10,200
code we're going to be working
with is going to be in this

21767
22:18:10,200 --> 22:18:13,590
encoding dot soul. And then in a
little bit, we're going to work

21768
22:18:13,590 --> 22:18:17,040
on this call anything that soul
so we're in this encoding dot

21769
22:18:17,040 --> 22:18:20,640
soul. And let's just make our
basic code here. So we'll say

21770
22:18:20,880 --> 22:18:31,620
spdx, license identifier, MIT
pragma, solidity, carrot, zero,

21771
22:18:32,130 --> 22:18:36,660
point 8.7, like that, do
contract encoding, boom,

21772
22:18:36,780 --> 22:18:40,650
compile, or Command S or ctrl S
great things are looking good.

21773
22:18:40,710 --> 22:18:44,250
Now remember, the whole purpose
for this is to first understand

21774
22:18:44,250 --> 22:18:48,480
what's going on here, and more
about this API dot encode packed

21775
22:18:48,480 --> 22:18:52,470
stuff. So let's first just write
a function that should owes us

21776
22:18:52,500 --> 22:18:55,950
wrapping API dot encode packed
with some strings and wrapping

21777
22:18:55,950 --> 22:18:59,340
it around a string is going to
return a string. So we could do

21778
22:18:59,700 --> 22:19:04,440
function, bind strings, or
concatenate strings. This will

21779
22:19:04,440 --> 22:19:08,340
be a public pure since we're not
going to be reading any storage,

21780
22:19:08,790 --> 22:19:15,450
we'll say returns string memory.
And we'll say return string, API

21781
22:19:15,450 --> 22:19:21,330
dot encode packed. I'm I'm
comma, space in here, I miss

21782
22:19:21,330 --> 22:19:25,380
you, like so. We need another
parenthesis here. Okay, great.

21783
22:19:25,650 --> 22:19:28,950
Now let's go ahead and deploy
this, we'll start a JavaScript

21784
22:19:28,950 --> 22:19:33,900
VM will deploy encoding
coding.so. We'll come down here,

21785
22:19:34,050 --> 22:19:37,020
we'll click Combine strings, and
we get that whole string output.

21786
22:19:37,020 --> 22:19:41,820
Hi, Mom, miss you. So what we're
doing here is we're encoding hi

21787
22:19:41,820 --> 22:19:46,710
mom misuse together into its
bytes form, because API dot

21788
22:19:46,710 --> 22:19:50,760
encode packed returns a bytes
object, and we are typecasting

21789
22:19:50,760 --> 22:19:53,580
it by wrapping it in this string
thing to be a string. And

21790
22:19:53,580 --> 22:19:56,790
solidity says, okay, yeah, bytes
to string, that's fine, that

21791
22:19:56,790 --> 22:20:00,690
totally works. And this API dot
encode packed are these globally

21792
22:20:00,750 --> 22:20:04,650
available methods and units. And
actually, in solidity, there's a

21793
22:20:04,650 --> 22:20:07,920
whole bunch of these, there's
this solidity cheat sheet, and

21794
22:20:07,920 --> 22:20:10,320
there's gonna be a link to this
in the GitHub repo as well, that

21795
22:20:10,320 --> 22:20:13,110
has a whole bunch of operators
and it has a whole bunch of

21796
22:20:13,110 --> 22:20:15,720
these global variables and
methods. You can see if we look

21797
22:20:15,720 --> 22:20:19,770
in here, we look for ABI dot
encode pact, we see ABI dot

21798
22:20:19,770 --> 22:20:22,800
encode pact right here, we
scroll down, we'll see some more

21799
22:20:22,800 --> 22:20:25,590
that we're familiar with as
well. Like, for example, message

21800
22:20:25,590 --> 22:20:29,730
dot sender, sender of the
message, message dot value.

21801
22:20:29,880 --> 22:20:33,540
There's a whole bunch of other
globally available methods and

21802
22:20:33,570 --> 22:20:36,840
variables that we can use when
we're coding our stuff. Now, I

21803
22:20:36,840 --> 22:20:41,160
will say though, in 0.8, point,
well, plus, you can actually do

21804
22:20:41,160 --> 22:20:47,460
string dot concat, you know,
string a, comma string B, if you

21805
22:20:47,460 --> 22:20:51,630
want to, instead of doing this
API to encode packed, but I

21806
22:20:51,630 --> 22:20:53,790
still wanted to show you the API
dot encode pack, because it's a

21807
22:20:53,790 --> 22:20:56,700
great segue into all this ABI
stuff that we're about to go

21808
22:20:56,700 --> 22:21:00,810
over. But let's focus on this
encode packed thing. So what is

21809
22:21:00,810 --> 22:21:05,310
actually going on here? Well,
before we dive deeper into this

21810
22:21:05,310 --> 22:21:09,480
encode pact, let's understand a
little bit more about what

21811
22:21:09,480 --> 22:21:12,570
happens when we send a
transaction. So when we compile

21812
22:21:12,570 --> 22:21:15,210
our code, and again, all these
pictures are going to be in the

21813
22:21:15,210 --> 22:21:18,420
GitHub repo. Remember back to
ethers.js, we had those two

21814
22:21:18,420 --> 22:21:22,950
files, we got a dot ABI file,
and a dot bin or dot binary.

21815
22:21:23,160 --> 22:21:26,040
Back in our ether symbol
storage, when we ran yarn,

21816
22:21:26,190 --> 22:21:30,870
compile. The two main files that
we got, were this symbol storage

21817
22:21:30,870 --> 22:21:34,620
that abi, which was this, you
know, this ABI thing that we've

21818
22:21:34,620 --> 22:21:37,800
become familiar with. And then
the simple storage dot bin,

21819
22:21:38,010 --> 22:21:40,920
which is the binary, which has a
whole bunch of just numbers and

21820
22:21:40,920 --> 22:21:43,350
letters and stuff we didn't
understand. And you can see that

21821
22:21:43,350 --> 22:21:47,340
in remix to, like if we were to
compile this, you get a

21822
22:21:47,340 --> 22:21:50,310
compilation details, you get a
whole bunch of stuff in here,

21823
22:21:50,310 --> 22:21:53,280
right? You can see the ABI in
here, which this is kind of like

21824
22:21:53,280 --> 22:21:56,340
a different way of viewing that
API, we also get this bytecode

21825
22:21:56,340 --> 22:22:00,510
bit and it's this object that
has the same stuff that has like

21826
22:22:00,510 --> 22:22:03,330
those random numbers and
letters. But this is actually

21827
22:22:03,330 --> 22:22:05,850
the binary this is actually
what's getting put on the

21828
22:22:05,850 --> 22:22:09,060
blockchain. It's this binary,
it's this low level stuff. Now,

21829
22:22:09,090 --> 22:22:12,300
when we actually send these
contracts to the blockchain,

21830
22:22:12,330 --> 22:22:15,210
we're sending like I said, we're
sending this binary thing.

21831
22:22:15,240 --> 22:22:17,610
That's exactly what we're
sending to the blockchain. And

21832
22:22:17,610 --> 22:22:22,290
remember how, again, back in our
ethers project, we saw what is a

21833
22:22:22,290 --> 22:22:25,290
transaction, right, a
transaction has a nonce, it has

21834
22:22:25,290 --> 22:22:29,220
a gas price guess limit to value
data, we kind of skipped over

21835
22:22:29,220 --> 22:22:31,860
the VRS a little bit, because
that's kind of that mathy

21836
22:22:31,860 --> 22:22:34,980
component of the transaction
signature. But again, back in

21837
22:22:34,980 --> 22:22:37,620
our ethos project, we did this
as well, right in our deploy

21838
22:22:37,620 --> 22:22:41,370
script, ended up sending a
transaction ourselves, using

21839
22:22:41,370 --> 22:22:46,170
just ethers. We passed a nonce,
a gas price, gas limit to value

21840
22:22:46,530 --> 22:22:50,010
data was this massive thing to
declare a contract, and then

21841
22:22:50,010 --> 22:22:53,490
also the chain ID. We didn't
work with the VAR s, because

21842
22:22:53,520 --> 22:22:56,460
ethers does that for us. But
there's also this VAR s

21843
22:22:56,460 --> 22:22:59,460
component that we don't bother
to look at. When we send a

21844
22:22:59,460 --> 22:23:04,410
transaction that actually
creates a contract, the two is

21845
22:23:04,410 --> 22:23:06,240
going to be empty. We're not
going to send this contract

21846
22:23:06,240 --> 22:23:10,590
deployment to any address. But
the data of this is going to

21847
22:23:10,590 --> 22:23:15,930
have the contract initialization
code and contract bytecode.

21848
22:23:15,960 --> 22:23:18,960
Right. So when we compile it, we
get all this code, like how do

21849
22:23:18,960 --> 22:23:21,990
you initialize the contract, and
then what the contract actually

21850
22:23:21,990 --> 22:23:24,420
looks like. So if you look at
any of the contracts that you

21851
22:23:24,420 --> 22:23:27,030
deployed, for example, I'm going
to look at our raffle that we

21852
22:23:27,030 --> 22:23:30,810
deployed. If you go to the
transactions of your contract,

21853
22:23:30,870 --> 22:23:35,070
we can see create raffle, right,
let's go to that transaction. If

21854
22:23:35,070 --> 22:23:39,090
we go down and click to see more
in the ether scan, we can see

21855
22:23:39,090 --> 22:23:42,660
this input data thing. And once
again, it's got all this random

21856
22:23:42,750 --> 22:23:47,130
garbled numbers and letters.
This is that binary data of the

21857
22:23:47,130 --> 22:23:50,370
contract initialization code and
the contract byte code right

21858
22:23:50,370 --> 22:23:53,700
what we send in our trend In
this action is this data thing,

21859
22:23:53,730 --> 22:23:58,050
we send this this weird bunch of
garbled nonsense. Now we're

21860
22:23:58,050 --> 22:24:00,690
going to head back to remix. And
I'm just going to leave this as

21861
22:24:00,690 --> 22:24:03,630
comments in here in the encoding
dot soul and the GitHub repo.

21862
22:24:03,630 --> 22:24:06,780
There's a ton of comments in
here explaining exactly what I'm

21863
22:24:06,780 --> 22:24:09,330
explaining. So if you want to
follow along there, you can as

21864
22:24:09,330 --> 22:24:12,870
well. But now in order for the
blockchain to understand, okay,

21865
22:24:12,870 --> 22:24:16,350
what do these numbers and
letters even mean? You need a

21866
22:24:16,350 --> 22:24:18,870
special reader cerium or the
blockchain needs to be able to

21867
22:24:18,870 --> 22:24:23,220
read all this stuff, it needs to
be able to map all these random

21868
22:24:23,220 --> 22:24:28,020
numbers and letters to what they
actually do. How does Aetherium

21869
22:24:28,020 --> 22:24:32,040
or polygon or avalanche know
that all this nonsense is

21870
22:24:32,040 --> 22:24:34,410
basically telling it to make a
contract, you kind of think of

21871
22:24:34,410 --> 22:24:37,530
it as saying, like, take off
your coat. The only reason that

21872
22:24:37,530 --> 22:24:41,310
we as human beings understand
what take off your coat means is

21873
22:24:41,310 --> 22:24:44,610
that we understand English,
We're all reading English, for

21874
22:24:44,610 --> 22:24:47,700
solidity. And for blockchains.
Instead of English, I read these

21875
22:24:47,700 --> 22:24:50,550
numbers and letters kind of like
words, just instead of take off

21876
22:24:50,550 --> 22:24:53,250
your coat, it's like deploy
contract, and the contract does

21877
22:24:53,250 --> 22:24:55,860
next XYZ and all this random
stuff. So this bytecode

21878
22:24:55,860 --> 22:24:58,350
represents the low level
computer instructions to make

21879
22:24:58,350 --> 22:25:00,660
our contract happen. And all
these numbers and letters

21880
22:25:00,660 --> 22:25:04,860
represent kind of an alphabet,
just like how take off your coat

21881
22:25:04,860 --> 22:25:07,500
is an alphabet. And when you
combine them like this, it makes

21882
22:25:07,500 --> 22:25:10,260
something that to us makes
sense, you can kind of think of

21883
22:25:10,260 --> 22:25:13,800
the alphabet for these as what's
called opcodes. If you go to

21884
22:25:13,830 --> 22:25:17,790
create a new tab, if you go to
EVM dot codes, we'll get to this

21885
22:25:17,790 --> 22:25:21,960
place where it just has a list
of all these instructions. On

21886
22:25:21,960 --> 22:25:25,410
the left side, you can see this
thing called opcode. And then

21887
22:25:25,410 --> 22:25:29,610
you can see name, so this opcode
section is saying, Hey, if you

21888
22:25:29,610 --> 22:25:36,930
see a 00 in this bytecode, that
00 represents this opcode stop,

21889
22:25:36,990 --> 22:25:41,280
which does what which halts
execution, if you see a 01

21890
22:25:41,370 --> 22:25:44,790
you're gonna do some addition
stuff, a 02 is multiply, there

21891
22:25:44,790 --> 22:25:49,080
are all these op codes that are
kind of like the alphabet, or

21892
22:25:49,080 --> 22:25:52,050
the language of this binary
stuff, right, and they go all

21893
22:25:52,050 --> 22:25:55,470
the way down to f f self
destruct, these op codes also

21894
22:25:55,470 --> 22:25:58,950
have, and that's what this is
reading. Right? So if we look at

21895
22:25:59,040 --> 22:26:01,140
our transaction here, and your
yours might be a little bit

21896
22:26:01,140 --> 22:26:04,350
different. Oh six, one says,
Okay, the first thing we want

21897
22:26:04,350 --> 22:26:07,980
you to do is the O six, one
opcode. And if we go to EVM,

21898
22:26:07,980 --> 22:26:12,510
opcodes, we look for six one,
it's saying push to place to buy

21899
22:26:12,510 --> 22:26:15,600
item on the stack. That's
exactly how it's reading this

21900
22:26:15,660 --> 22:26:19,860
any language that can compile
down to this opcode stuff down

21901
22:26:19,860 --> 22:26:23,130
to this specific set of
Aetherium opcodes, or EVM.

21902
22:26:23,130 --> 22:26:27,270
opcodes, is what's known as the
EVM, the Etherium virtual

21903
22:26:27,270 --> 22:26:30,750
machine. So being able to read
these op codes is sometimes

21904
22:26:30,990 --> 22:26:34,830
abstractly called the EVM, the
Etherium virtual machine, the

21905
22:26:34,830 --> 22:26:39,720
EVM basically represents all the
instructions, a computer must be

21906
22:26:39,720 --> 22:26:42,870
able to read for it to interact
with Aetherium, or Aetherium,

21907
22:26:42,870 --> 22:26:47,040
like applications. And this is
why so many blockchains all work

21908
22:26:47,040 --> 22:26:50,940
with solidity because solidity
compiles down to this bytecode

21909
22:26:50,940 --> 22:26:55,830
here, and polygon, avalanche
arbitrage Aetherium, they all

21910
22:26:55,830 --> 22:27:00,510
compiled down to the exact same
type of binary, and they all

21911
22:27:00,510 --> 22:27:03,210
have the exact same readers. Now
why are we telling you all this

21912
22:27:03,210 --> 22:27:05,250
stuff, you might be saying, hey,
Patrick, this is cool and all

21913
22:27:05,250 --> 22:27:07,920
but it looks like ABI dot encode
packed, all that does is

21914
22:27:07,920 --> 22:27:12,420
concatenate strings, abi encode
pack can do actually way more.

21915
22:27:12,630 --> 22:27:16,620
And if we look at these global
variables, API dot encode packed

21916
22:27:16,620 --> 22:27:19,620
is like what the third one down
the list because it's a non

21917
22:27:19,620 --> 22:27:23,460
standard way to encode stuff to
this binary stuff that we just

21918
22:27:23,460 --> 22:27:27,300
talked about, we can actually
encode pretty much anything we

21919
22:27:27,300 --> 22:27:32,160
want to being in this binary
format, basically. And let's

21920
22:27:32,160 --> 22:27:34,650
take a look at at encoding
something. So let's create a

21921
22:27:34,650 --> 22:27:38,850
function called encode number.
And this will be a public pure

21922
22:27:38,850 --> 22:27:41,910
function, since we're not going
to read any state, and we'll say

21923
22:27:41,910 --> 22:27:46,050
returns a bytes memory. We're
going to have this function

21924
22:27:46,050 --> 22:27:49,890
return a bytes object, we're
going to have it returned the

21925
22:27:49,920 --> 22:27:52,860
what this number is going to
look like but in binary, so

21926
22:27:52,860 --> 22:27:59,760
we'll say bytes, memory number
equals ABI dot encode one, and

21927
22:27:59,760 --> 22:28:04,560
then return number. So we're
going to encode number down to

21928
22:28:04,560 --> 22:28:08,850
it's a bi or it's binary format.
So I know a lot of times when we

21929
22:28:08,850 --> 22:28:12,420
say oh, what's the ABI what's
the ABI right? Previously, we

21930
22:28:12,420 --> 22:28:15,960
say, Oh, the ABI is, is this
thing, right? It's, it's all

21931
22:28:15,960 --> 22:28:18,840
these inputs and outputs. This
is kind of the human readable

21932
22:28:18,840 --> 22:28:21,810
version of the ABI. But again,
the ABI is the application

21933
22:28:21,810 --> 22:28:26,040
binary interface we want to
encode or numbers down to it's

21934
22:28:26,040 --> 22:28:29,520
basically it's binary, this ABI
dot ENCODE is going to be a

21935
22:28:29,520 --> 22:28:32,310
little different than like the
ABI that you see when you're

21936
22:28:32,310 --> 22:28:35,700
looking at compilation details.
This is technically like the ABI

21937
22:28:35,730 --> 22:28:39,420
technically is how to interact
with this contract. However,

21938
22:28:39,510 --> 22:28:42,270
it's not the actual binary
version of it. So we're saying,

21939
22:28:42,270 --> 22:28:46,530
okay, encode this number one
down to its binary version, so

21940
22:28:46,530 --> 22:28:49,620
that our contracts can interact
with it in a way that they

21941
22:28:49,620 --> 22:28:52,620
understand. So we're just saying
okay, Watch that number one,

21942
22:28:52,680 --> 22:28:56,580
let's make you machine readable.
And if we go, we compile this

21943
22:28:56,610 --> 22:28:59,310
and we deploy this right, let's
delete that that old contract,

21944
22:28:59,310 --> 22:29:02,580
we deploy this, we now have
combined strings and encode

21945
22:29:02,580 --> 22:29:07,950
number, we click it, we get this
big hex thing. This is how the

21946
22:29:07,950 --> 22:29:11,430
computer is going to understand
the number one. Now we can

21947
22:29:11,430 --> 22:29:14,100
encode pretty much anything
actually, we could encode a

21948
22:29:14,100 --> 22:29:16,380
string. So we'll say,

21949
22:29:17,549 --> 22:29:22,709
function, encode string, we'll
make this a public key here as

21950
22:29:22,709 --> 22:29:27,029
well. It'll return a bytes
memory, because we want to give

21951
22:29:27,029 --> 22:29:30,659
it that binary stuff or that
bites stuff. And we'll say bytes

21952
22:29:30,659 --> 22:29:37,109
memory, some string equals ABI
dot encode some string, and then

21953
22:29:37,109 --> 22:29:41,309
return some string. Now let's
compile that delete our old

21954
22:29:41,309 --> 22:29:45,839
contract, deploy that code
string, we get this big, big,

21955
22:29:45,839 --> 22:29:49,589
big object here. And this is the
binary. Now you'll notice

21956
22:29:49,589 --> 22:29:53,309
something here, there's a ton of
zeros, and those zeros take up

21957
22:29:53,309 --> 22:29:56,339
space, right, that's a lot of
space for the computer to take

21958
22:29:56,339 --> 22:29:58,829
up, even though they're not
really doing anything. They're

21959
22:29:58,829 --> 22:30:02,969
just kind of taking up space. So
solidity also comes with this

21960
22:30:02,999 --> 22:30:07,229
ABI dot encode tact, which
performs packed encoding of the

21961
22:30:07,229 --> 22:30:10,019
given arguments. And you can
read more about it in the

21962
22:30:10,019 --> 22:30:13,169
solidity docs, if you want. And
this is called the non standard

21963
22:30:13,169 --> 22:30:16,499
packed mode. And it does the
same encoding with some

21964
22:30:16,499 --> 22:30:19,859
stipulations type shorter than
32 bytes are concatenated

21965
22:30:19,859 --> 22:30:23,129
directly without padding, or
sign extension, dynamic types

21966
22:30:23,129 --> 22:30:25,379
are encoded in place. And
without the length array

21967
22:30:25,379 --> 22:30:28,109
elements are padded, but still
encoded in place, you can kind

21968
22:30:28,109 --> 22:30:31,079
of think of ENCODE packed as
sort of like a compressor,

21969
22:30:31,109 --> 22:30:34,799
right? It's the ENCODE function.
But it compresses stuff, if we

21970
22:30:34,799 --> 22:30:37,949
wanted to encode some string but
want to save space. And we

21971
22:30:37,949 --> 22:30:41,699
didn't need the perfect low
level binary of it. We could do

21972
22:30:41,699 --> 22:30:46,769
function and code string packed,
make this a public pure, and

21973
22:30:46,769 --> 22:30:51,929
have it return a bytes memory.
We could say, bytes memory, some

21974
22:30:51,929 --> 22:30:57,059
string equals ABI dot encode
packed once again, some string.

21975
22:30:57,509 --> 22:31:00,689
So we're doing a code pack
instead of a code. And we'll

21976
22:31:00,689 --> 22:31:03,749
return some string here, we'll
compile this and we'll see the

21977
22:31:03,749 --> 22:31:07,649
difference, right compile, we'll
delete our old one, we'll deploy

21978
22:31:07,649 --> 22:31:11,819
this. Now we have ENCODE string,
which again, that's what encoded

21979
22:31:11,819 --> 22:31:14,459
string is gonna give us and we
have encoded string packed,

21980
22:31:14,759 --> 22:31:19,379
which returns us this much, much
smaller bytes object. So you see

21981
22:31:19,379 --> 22:31:23,009
the size difference, if we're
trying to save gas, in code,

21982
22:31:23,009 --> 22:31:26,489
string packed is going to be a
way for us to save a lot more

21983
22:31:26,489 --> 22:31:30,119
gas. Now, abi dot encode pact is
actually really similar to

21984
22:31:30,119 --> 22:31:33,569
something that we've done
before, which is typecasting, if

21985
22:31:33,569 --> 22:31:39,029
we didn't function and code
string, bytes, public pure

21986
22:31:39,059 --> 22:31:45,989
returns, bytes, memory, bytes,
memories, some string equals

21987
22:31:46,469 --> 22:31:51,419
bytes, some string, turn some
string, these two are going to

21988
22:31:51,419 --> 22:31:54,869
look nearly identical, right? So
if we compile, we'll delete our

21989
22:31:54,869 --> 22:31:59,999
old contract, deploy this code
string bytes, which gives us

21990
22:31:59,999 --> 22:32:03,209
this and encode string pack
using the ABI to encode pack,

21991
22:32:03,269 --> 22:32:06,149
they give us the exact same
output, whereas encode strings

21992
22:32:06,149 --> 22:32:09,029
to give us this big piece. So
the two of these get the same

21993
22:32:09,029 --> 22:32:11,459
result. But behind the scenes,
they're doing something a little

21994
22:32:11,459 --> 22:32:14,429
bit different. And I'm not going
to go over exactly what that is.

21995
22:32:14,429 --> 22:32:18,479
But I've left a link inside of
the code here, if you want to

21996
22:32:18,479 --> 22:32:21,359
learn more, which is exactly
what we're doing in our NFT.

21997
22:32:21,359 --> 22:32:24,269
Right, we're doing ABR dot
encode packed, we're combining

21998
22:32:24,269 --> 22:32:28,049
two strings. By putting them
together, we're encoding them to

21999
22:32:28,049 --> 22:32:31,169
their bytes implementation to
their packed bytes

22000
22:32:31,169 --> 22:32:35,099
implementation, and then we're
just typecasting them back from

22001
22:32:35,129 --> 22:32:39,089
bytes to string. And that's how
we concatenate them. Now, at

22002
22:32:39,089 --> 22:32:39,509
this point, you

22003
22:32:39,510 --> 22:32:42,540
might be thinking, okay, cool.
Great, Patrick. I'm all set. I

22004
22:32:42,540 --> 22:32:45,720
understand this. I'm happy to go
back to my project. And if you

22005
22:32:45,720 --> 22:32:48,540
want to do that, absolutely go
for it and skip over this

22006
22:32:48,540 --> 22:32:51,750
section, but some other viewers
might be going okay, Patrick,

22007
22:32:51,750 --> 22:32:55,890
this is seems pretty cool. But
I'm sure this encode pacts in

22008
22:32:55,890 --> 22:32:58,950
this encode function aren't just
here to concatenate strings,

22009
22:32:59,280 --> 22:33:01,290
they probably have some other
function, what do they actually

22010
22:33:01,290 --> 22:33:04,470
do? Well, if that's what you're
asking, I'm glad you asked. And

22011
22:33:04,470 --> 22:33:06,750
I'm glad you're curious, because
we're going to find out. Now not

22012
22:33:06,750 --> 22:33:11,370
only can you encode stuff, like
strings and numbers, and really

22013
22:33:11,370 --> 22:33:17,010
anything, but you can decode
stuff. So I can say, function,

22014
22:33:17,280 --> 22:33:23,370
decode string, public, your
returns string memory, string

22015
22:33:23,370 --> 22:33:28,890
memory, some string equals ABI
dot decode. This is going to

22016
22:33:28,890 --> 22:33:32,880
take a couple parameters. So if
you look in the docs here, abi

22017
22:33:32,880 --> 22:33:38,430
dot decode, it takes as a first
argument, the encoded data, and

22018
22:33:38,430 --> 22:33:41,610
then it takes a tuple. You can
kind of think of it as a list

22019
22:33:41,610 --> 22:33:45,750
but not quite a list, a set of
types to decode this into and it

22020
22:33:45,750 --> 22:33:48,690
returns the number of parameters
that you gave it. So we might

22021
22:33:48,690 --> 22:33:52,290
want to say this string memory
some string Adding, let's give

22022
22:33:52,290 --> 22:33:56,160
it as input this encode string
function, the result of this

22023
22:33:56,160 --> 22:33:58,770
encode string function, right,
which again, is going to be this

22024
22:33:58,770 --> 22:34:02,310
big thing. So this is kind of
equivalent to sticking this

22025
22:34:02,310 --> 22:34:04,560
massive thing in here, but we're
just not going to stick the

22026
22:34:04,560 --> 22:34:06,720
massive thing in there, because
it's really big. So we're gonna

22027
22:34:06,720 --> 22:34:10,920
say, Let's decode the result of
ENCODE string, and let's decode

22028
22:34:10,920 --> 22:34:16,590
it into a string. Because we
need to tell solidity, hey,

22029
22:34:16,590 --> 22:34:19,890
we're going to decode this, but
it doesn't know what to decode

22030
22:34:19,890 --> 22:34:22,530
it into. It's like, okay, cool.
I can decode this, but like,

22031
22:34:22,530 --> 22:34:26,070
what, what do you want me to do
with it, and we say, Oh, this is

22032
22:34:26,070 --> 22:34:29,340
a string, so decode it into a
string. And then we can do

22033
22:34:29,340 --> 22:34:33,570
return some string. Now, once
again, we deploy that old

22034
22:34:33,570 --> 22:34:36,270
Cotters, we delete the last
contract, we deploy this new

22035
22:34:36,270 --> 22:34:40,560
one. So in code string, and code
string, whereas in code, string,

22036
22:34:40,590 --> 22:34:43,800
and code string returns this
massive thing, as a human being,

22037
22:34:43,800 --> 22:34:47,670
we're like, God, I can't read
that computers can read that.

22038
22:34:47,790 --> 22:34:50,430
But we can't really read that.
So we say, okay, let's decode

22039
22:34:50,430 --> 22:34:54,540
that back into its string form,
we hit decode string, and we get

22040
22:34:54,540 --> 22:34:58,950
back some string. And now we can
actually multi encode and multi

22041
22:34:58,950 --> 22:35:02,430
and decode, right, we can encode
as much stuff as we want. So I

22042
22:35:02,430 --> 22:35:07,770
can say function, multi ENCODE,
public pure, returns bytes

22043
22:35:07,770 --> 22:35:10,560
memory, we're going to encode a
couple of things, we'll say

22044
22:35:10,560 --> 22:35:16,230
bytes, memory, some string
equals ABI dot encode some

22045
22:35:16,230 --> 22:35:21,960
string, comma, it's bigger. So
we're going to encode two

22046
22:35:21,960 --> 22:35:25,890
strings here, we're gonna encode
some string, and it's bigger. So

22047
22:35:25,890 --> 22:35:29,610
we have two strings, we're going
to encode and we'll return some

22048
22:35:29,610 --> 22:35:33,030
string, even though it's you
know, bytes. And then we can

22049
22:35:33,030 --> 22:35:38,280
actually multi decode. So we'll
say function, multi decode, this

22050
22:35:38,280 --> 22:35:42,150
will be a public pure returns,
we'll say it returns two

22051
22:35:42,150 --> 22:35:46,710
strings, string memory, and
string memory. And instead of

22052
22:35:46,710 --> 22:35:51,060
doing string memory, some string
equals API decode, we'll say,

22053
22:35:51,720 --> 22:35:57,810
string memory, some string,
comma string memory, some other

22054
22:35:57,810 --> 22:36:02,940
string. So we're gonna get to
returns equals Avi dot decode.

22055
22:36:03,060 --> 22:36:07,590
Let's decode this multi encode
result, which is the doubly

22056
22:36:07,590 --> 22:36:12,870
encoded strings into a string
and another string. And then

22057
22:36:12,870 --> 22:36:17,610
we'll return both of these are
some string, there we go. Now

22058
22:36:17,610 --> 22:36:20,130
we'll return some string, and
then some other string,

22059
22:36:20,580 --> 22:36:24,450
I need a semicolon here. So now
when we deploy this, let's close

22060
22:36:24,450 --> 22:36:28,140
this out, deploy this new one,
right, we now have this multi in

22061
22:36:28,140 --> 22:36:32,100
code, which gives us this even
bigger bites object, right?

22062
22:36:32,100 --> 22:36:36,210
Because this is two strings
encoded. And now if we hit multi

22063
22:36:36,210 --> 22:36:38,670
decode, take a second, what do
you think it's going to put out

22064
22:36:38,700 --> 22:36:41,550
output? Let's go ahead and hit
it. Now it's gonna give us two

22065
22:36:41,550 --> 22:36:44,550
strings, right, it's gonna give
you these two strings, some

22066
22:36:44,550 --> 22:36:49,410
string, it's bigger. So we can
tell solidity to encode a bunch

22067
22:36:49,410 --> 22:36:53,070
of stuff. And then we can even
decode it by telling it, okay,

22068
22:36:53,160 --> 22:36:56,130
this big object here, it's two
strings combined, and then we

22069
22:36:56,130 --> 22:37:00,030
decode it. Now you can even
multi encode with that encode

22070
22:37:00,030 --> 22:37:03,930
pack thing, right? We could do
function, multi encode packed,

22071
22:37:04,500 --> 22:37:10,080
public pure returns, bytes
memory, and then bytes memory,

22072
22:37:10,080 --> 22:37:14,910
some string equals ABI dot
encode packed some string,

22073
22:37:15,150 --> 22:37:20,910
comma, it's bigger than return
some string, we could do this,

22074
22:37:20,940 --> 22:37:24,120
right, but this is going to give
us the packed version of these

22075
22:37:24,120 --> 22:37:29,460
two strings. So the decoding
actually isn't going to work on

22076
22:37:29,460 --> 22:37:33,570
this because this is packed
encoding. So if we tried to do,

22077
22:37:33,870 --> 22:37:38,130
I'm gonna say this doesn't work.
Try to do function, multi

22078
22:37:38,310 --> 22:37:45,390
decode, packed, public pure
returns, string memory, string

22079
22:37:45,420 --> 22:37:51,900
memory, some string equals Avi
dot decode multi encode packed

22080
22:37:52,560 --> 22:37:56,160
in a string and have exactly
what we did above to, if we do

22081
22:37:56,160 --> 22:38:00,210
return some string, what do you
think's gonna happen? Let's,

22082
22:38:00,390 --> 22:38:02,940
let's try to delete the old
contract, deploy a new one.

22083
22:38:03,420 --> 22:38:07,410
We'll do multi decode, packed,
multi encode multi decode,

22084
22:38:07,410 --> 22:38:11,280
packed, and we actually just get
an error. solidity basically

22085
22:38:11,280 --> 22:38:15,870
goes, Yeah, this looks like it's
packed. I don't know how to

22086
22:38:15,870 --> 22:38:19,260
decode that. But instead, what
we can do is we can do function

22087
22:38:19,620 --> 22:38:26,040
more to string cast packed like
this a public pure returns

22088
22:38:26,430 --> 22:38:33,630
string memory, string, memory,
some string equals string, multi

22089
22:38:33,930 --> 22:38:39,720
and code packed, return some
string. This one will work right

22090
22:38:39,720 --> 22:38:43,530
because again, this pact
encoding is kind of similar to

22091
22:38:43,530 --> 22:38:48,660
just type casting. So we'll
compile will redeploy multi

22092
22:38:48,660 --> 22:38:52,650
string cast pact, we get some
Trying, it's bigger, right? And

22093
22:38:52,650 --> 22:38:54,660
we don't have a space here. But
we should have put a space in

22094
22:38:54,660 --> 22:39:03,360
there. Now that we've learned
more about this in ABI dot

22095
22:39:03,360 --> 22:39:06,360
encode and decoding, and we know
that okay, this is what the

22096
22:39:06,360 --> 22:39:09,840
computer, this is, what
Aetherium. This is what the EVM,

22097
22:39:09,840 --> 22:39:12,990
or any EVM compatible chain is
looking for. It's looking for

22098
22:39:12,990 --> 22:39:16,560
this bytecode. It's looking for
this, this binary stuff. And we

22099
22:39:16,560 --> 22:39:19,410
just learned a little bit more
about how to encode different

22100
22:39:19,410 --> 22:39:22,380
variables into the binary into
that data bit. Well,

22101
22:39:22,619 --> 22:39:26,819
what do we do now? Now since we
know that our transactions are

22102
22:39:26,819 --> 22:39:30,059
just going to be compiled down
to this binary stuff, what we

22103
22:39:30,059 --> 22:39:35,159
can do then is we can actually
populate this data value of our

22104
22:39:35,159 --> 22:39:38,879
transactions ourselves with the
binary that code is going to

22105
22:39:38,879 --> 22:39:42,509
use. So here's our transaction
for a contract deployment, the

22106
22:39:42,509 --> 22:39:44,999
data field of the contract
deployment is going to be all

22107
22:39:44,999 --> 22:39:49,409
that binary code of the contract
for a function call, the data

22108
22:39:49,409 --> 22:39:53,879
piece is going to be what to
send to the address what data

22109
22:39:53,879 --> 22:39:57,119
what function to call on the to
address. Let's look at another

22110
22:39:57,119 --> 22:39:59,699
one of our transactions on ether
scan right on one of our

22111
22:39:59,699 --> 22:40:02,549
contracts, you don't have to I'm
going to look at enter raffle

22112
22:40:02,549 --> 22:40:06,929
from a previous section. And if
we select down, we look at input

22113
22:40:06,929 --> 22:40:09,989
data. It says function enter
raffle method ID. But if we look

22114
22:40:09,989 --> 22:40:14,369
at the original, this is what's
getting sent in the data field.

22115
22:40:14,579 --> 22:40:18,929
It's this binary, it's this hex
it's this weird, low level bytes

22116
22:40:18,929 --> 22:40:22,139
thing. This is how the Ethereum
blockchain or the or whatever

22117
22:40:22,139 --> 22:40:25,319
EVM chain you're working with
knows which function to call, it

22118
22:40:25,319 --> 22:40:29,969
translates this into a function.
And we can do the exact same

22119
22:40:29,969 --> 22:40:34,079
thing and call these functions
ourselves. So what we can

22120
22:40:34,079 --> 22:40:38,849
actually do with this crazy
newfound data and coding stuff,

22121
22:40:38,909 --> 22:40:43,619
what we can actually do is send
the data field of a transaction

22122
22:40:43,649 --> 22:40:48,329
ourself, in a transaction call
back in this ether throwback

22123
22:40:48,329 --> 22:40:52,259
where this data thing was the
contract creation code. Well,

22124
22:40:52,259 --> 22:40:56,339
instead, we could populate this
data thing with our function

22125
22:40:56,339 --> 22:41:00,449
call code, the exact function
that we want to call in the

22126
22:41:00,449 --> 22:41:04,679
binary in hex addition. Now you
might be thinking, Oh, well, why

22127
22:41:04,679 --> 22:41:08,039
would I do that, I can always
just use the interface, the ABI,

22128
22:41:08,039 --> 22:41:10,619
all that stuff, well, maybe you
don't have that maybe all you

22129
22:41:10,619 --> 22:41:14,189
have is the function name, maybe
all you have is the parameters

22130
22:41:14,189 --> 22:41:17,249
you want to send. Or maybe you
want to make your code, be able

22131
22:41:17,249 --> 22:41:21,149
to send arbitrary functions, or
make arbitrary calls or do

22132
22:41:21,479 --> 22:41:25,019
random really advanced stuff,
right, that's where sending our

22133
22:41:25,019 --> 22:41:27,899
function calls directly by
populating this data field is

22134
22:41:27,899 --> 22:41:30,269
going to be incredibly
important. So remember, I said,

22135
22:41:30,269 --> 22:41:33,989
you're always going to need the
ABI, and the contract address,

22136
22:41:34,109 --> 22:41:37,589
send a function. Now, when I
said, you always need the API.

22137
22:41:37,919 --> 22:41:41,639
Originally, we were kind of
talking about this thing, this

22138
22:41:41,639 --> 22:41:45,269
big, this big thing, which is
cool, which is the API. But this

22139
22:41:45,269 --> 22:41:48,779
is like the human readable API,
you can also do it with the non

22140
22:41:48,779 --> 22:41:52,139
human readable API. And
additionally, you don't need all

22141
22:41:52,139 --> 22:41:56,789
this stuff, you can really use
just the name of a function, and

22142
22:41:56,789 --> 22:42:00,749
then the input types to send a
function call. So the question

22143
22:42:00,749 --> 22:42:05,519
is, then, okay, how do we send?
How do we send transactions that

22144
22:42:05,519 --> 22:42:10,589
call functions with just the
data field populated? And then

22145
22:42:10,589 --> 22:42:14,699
the next question is, how do we
populate the data field? What do

22146
22:42:14,699 --> 22:42:17,309
we populate the data field with
to make one of these function

22147
22:42:17,309 --> 22:42:20,639
calls? And then how do we send
these transactions slowly,

22148
22:42:20,639 --> 22:42:25,019
actually has some more low level
keywords, namely, static call

22149
22:42:25,049 --> 22:42:29,579
and call we actually we've used
call in the past before, does

22150
22:42:29,609 --> 22:42:32,999
this code look at all familiar
to you? Well, it should, because

22151
22:42:32,999 --> 22:42:36,719
this is, we use a similar setup
in our fulfill random words for

22152
22:42:36,719 --> 22:42:40,259
our lottery, right, we sent
money doing this recent winner

22153
22:42:40,259 --> 22:42:42,989
dot call, right? Recently, it
was the address of the recent

22154
22:42:42,989 --> 22:42:46,409
winner, and we did not call. And
then we have this weird stuff in

22155
22:42:46,409 --> 22:42:49,229
this brackets here, and then
nothing in the parentheses. So

22156
22:42:49,229 --> 22:42:52,979
we did actually, essentially, we
use this call keyword

22157
22:42:52,979 --> 22:42:56,249
previously, but we didn't really
tell you what it did. So call is

22158
22:42:56,249 --> 22:42:58,589
how we can call functions to
change the state of the

22159
22:42:58,589 --> 22:43:02,759
blockchain. Static call is
basically how at a low level, we

22160
22:43:02,759 --> 22:43:05,249
call our view, or pure
functions, write static calls

22161
22:43:05,249 --> 22:43:07,619
gonna be like, okay, don't
change the state of the

22162
22:43:07,619 --> 22:43:10,829
blockchain with this one, just
give us the return value. So

22163
22:43:10,829 --> 22:43:13,589
this is kind of similar to like
a view or a pure function at low

22164
22:43:13,589 --> 22:43:17,129
level, there's also a Send word
but like, basically forget about

22165
22:43:17,129 --> 22:43:20,399
it. We're just gonna be working
with call, instead of call. And,

22166
22:43:20,489 --> 22:43:21,239
you know, later on, we'll

22167
22:43:21,240 --> 22:43:23,250
learn about another one called
delegate call. But don't worry

22168
22:43:23,250 --> 22:43:27,300
about that for now. Recent
winter duck call like this, in

22169
22:43:27,300 --> 22:43:30,540
these little squiggly brackets,
we said, Okay, we updated the

22170
22:43:30,540 --> 22:43:33,840
value directly of our
transaction in solidity. So

22171
22:43:33,840 --> 22:43:36,780
which again, if we have these
transaction fields, and we just

22172
22:43:36,780 --> 22:43:40,260
directly updated value in these
little brackets, right, we can

22173
22:43:40,260 --> 22:43:43,290
also directly update gas limited
gas price in these little

22174
22:43:43,290 --> 22:43:46,470
brackets if we wanted to as
well. And in here, these

22175
22:43:46,470 --> 22:43:49,650
parentheses is where we're going
to stick our data. Since all we

22176
22:43:49,650 --> 22:43:52,380
wanted to do with our
withdrawal. function previously

22177
22:43:52,380 --> 22:43:57,090
was send money. We said, Okay,
send money change the value that

22178
22:43:57,090 --> 22:44:00,600
we're going to send. But don't
pass any data, keep that data

22179
22:44:00,600 --> 22:44:05,130
bit empty, which is why, again,
remember how we hit this button

22180
22:44:05,130 --> 22:44:08,310
before, right and we had called
data be empty, that's

22181
22:44:08,400 --> 22:44:12,840
essentially running this command
with called data be empty with

22182
22:44:12,840 --> 22:44:17,010
this section be empty, and then
just updating the value that we

22183
22:44:17,010 --> 22:44:19,620
set with the transaction. And so
it's this section that we can

22184
22:44:19,620 --> 22:44:23,160
use to populate data to actually
call specific functions. We're

22185
22:44:23,160 --> 22:44:25,230
going to put a whole bunch more
comments here. So when our

22186
22:44:25,230 --> 22:44:27,990
squiggly brackets, we're able to
pass specific fields of a

22187
22:44:27,990 --> 22:44:31,380
transaction like value. And in
our parentheses, we're able to

22188
22:44:31,380 --> 22:44:34,530
pass data in order to call a
specific function. But in here,

22189
22:44:34,530 --> 22:44:37,110
there's no function to call
since we were just sending them

22190
22:44:37,170 --> 22:44:40,530
if we want to call a function or
send any data, we can do this in

22191
22:44:40,530 --> 22:44:49,440
the parentheses. And I think I
spelt that wrong. Now, we've

22192
22:44:49,440 --> 22:44:52,560
learned a ton here. So let's do
a quick refresher of what we

22193
22:44:52,560 --> 22:44:55,410
just learned. And then we're
going to actually learn how we

22194
22:44:55,410 --> 22:44:59,880
can call any function just by
using this syntax here. Well, we

22195
22:44:59,880 --> 22:45:02,850
learned from really high level,
if we want to combine strings,

22196
22:45:02,880 --> 22:45:05,610
we can do ABI dot encode packed
and then typecast that to a

22197
22:45:05,610 --> 22:45:09,420
string. And in newer versions of
solidity you can do, you can do

22198
22:45:09,420 --> 22:45:16,320
string dot concat, you know, Hi,
Mom, come on, miss you. In newer

22199
22:45:16,320 --> 22:45:18,690
versions of solidity. This works
as well, but not in older

22200
22:45:18,690 --> 22:45:22,050
versions of solidity. Then we
learned a lot about some low

22201
22:45:22,050 --> 22:45:25,200
level stuff we learned, okay,
when we compile our contracts,

22202
22:45:25,410 --> 22:45:29,490
we get an ABI file, and this
weird binary thing that numbers

22203
22:45:29,490 --> 22:45:33,030
and letters stuff that gets when
we deploy a contract that gets

22204
22:45:33,030 --> 22:45:36,990
sent in the data field of our
contract creation transaction.

22205
22:45:37,020 --> 22:45:40,050
So for contract creations, the
data is populated with that

22206
22:45:40,050 --> 22:45:43,440
binary code for function calls
is going to define which

22207
22:45:43,440 --> 22:45:46,380
functions to call in with what
parameters and this is what

22208
22:45:46,380 --> 22:45:49,530
we're gonna go over next. Now,
we learned that we can actually

22209
22:45:49,560 --> 22:45:54,330
encode stuff into this binary
into this low level code. And

22210
22:45:54,360 --> 22:45:58,680
any program any process that can
read this low level stuff and

22211
22:45:58,680 --> 22:46:02,040
execute accordingly, read this
EVM stuff, read the specific

22212
22:46:02,040 --> 22:46:05,700
binary that Aetherium has
specified, or the EVM has

22213
22:46:05,700 --> 22:46:09,150
specified is considered EVM.
compatible. We can encode

22214
22:46:09,180 --> 22:46:12,660
numbers, we can encode strings,
we can encode pretty much

22215
22:46:12,870 --> 22:46:16,710
anything we want to encode. To
save space, we do encode packed,

22216
22:46:16,890 --> 22:46:20,670
we can decode stuff that we've
encoded, but we can't decode

22217
22:46:20,700 --> 22:46:24,090
stuff that we encode packed, we
can multi encode stuff, and then

22218
22:46:24,090 --> 22:46:27,720
multi decode stuff. And then
finally, we can use this call

22219
22:46:27,720 --> 22:46:32,550
function and add data in here to
make any call that we want to

22220
22:46:32,550 --> 22:46:34,860
any smart contract. And this is
what we're going to learn next.

22221
22:46:35,070 --> 22:46:37,530
Alright, so now's a great time
to take a break, because we just

22222
22:46:37,530 --> 22:46:40,200
learned some really difficult
concepts. And like I said, if

22223
22:46:40,200 --> 22:46:41,340
you don't get it the first

22224
22:46:41,340 --> 22:46:49,440
time, that is okay. Alright,
welcome back. Now that we've

22225
22:46:49,440 --> 22:46:52,320
learned about this encoding
stuff, let's learn how we can

22226
22:46:52,320 --> 22:46:56,820
populate this parenthesis this
data field, so we can call any

22227
22:46:56,820 --> 22:47:00,900
function and we can do
essentially, what the blockchain

22228
22:47:00,900 --> 22:47:03,060
is going to do at the low level,
we can work with just that

22229
22:47:03,060 --> 22:47:05,490
binary, we can work with just
that bytes, we can work with

22230
22:47:05,490 --> 22:47:08,910
that hex to interact with our
smart contracts. So let's create

22231
22:47:08,910 --> 22:47:12,480
a new file. And we're gonna call
it call anything, that's all

22232
22:47:12,870 --> 22:47:16,200
start off with spdx, license
identifier, MIT. And let's talk

22233
22:47:16,200 --> 22:47:19,590
about this. Now in order to call
now in order to call a function

22234
22:47:19,650 --> 22:47:23,340
using only the data field of the
call, we need to encode the

22235
22:47:23,340 --> 22:47:26,010
function name, and the
parameters that we want to add,

22236
22:47:26,010 --> 22:47:27,900
right, because when we call a
function, we call the function

22237
22:47:27,900 --> 22:47:31,380
name. And we call the
parameters. So we need to encode

22238
22:47:31,380 --> 22:47:35,490
these down to the binary level
so that the EVM, or these

22239
22:47:35,550 --> 22:47:38,280
Aetherium based smart contracts
and solidity stuff can

22240
22:47:38,310 --> 22:47:40,860
understand what's actually going
on. In order to do this, we're

22241
22:47:40,860 --> 22:47:44,250
going to need to work with two
concepts to encode the function

22242
22:47:44,250 --> 22:47:48,060
name so that the EVM or solidity
can understand it, we actually

22243
22:47:48,060 --> 22:47:51,030
have to grab something called
the function selector. Now the

22244
22:47:51,030 --> 22:47:54,570
function selector is going to be
the first four bytes of the

22245
22:47:54,570 --> 22:47:58,140
function signature. And the
function signature is just going

22246
22:47:58,140 --> 22:48:00,720
to be a string, which defines
the function name of parameter.

22247
22:48:00,960 --> 22:48:03,240
Now, what does this actually
mean? Well, if we have a

22248
22:48:03,240 --> 22:48:06,240
transfer function, this right
here is known as the function

22249
22:48:06,270 --> 22:48:09,570
signature. So the function name
is going to be transfer. And

22250
22:48:09,570 --> 22:48:14,310
it's going to take an address
and a un 256 as its inputs, if

22251
22:48:14,310 --> 22:48:17,760
we encode this transfer
function, and then we take the

22252
22:48:17,760 --> 22:48:21,510
first four bytes of it, we get
this, which refers to the

22253
22:48:21,510 --> 22:48:25,800
function selector. So that's how
solidity knows. So in the

22254
22:48:25,800 --> 22:48:29,700
bytecode, in the binary code,
this function selector is how

22255
22:48:29,700 --> 22:48:32,340
slitting knows Oh, they're
talking about the transfer

22256
22:48:32,340 --> 22:48:35,130
function they want me to call
the transfer function. And this

22257
22:48:35,130 --> 22:48:38,730
is one of the first things that
we need to use call to call any

22258
22:48:38,730 --> 22:48:42,360
function that we want, we need
to get the function selector and

22259
22:48:42,360 --> 22:48:44,310
we can get it a number of
different ways but one of the

22260
22:48:44,310 --> 22:48:47,670
ways is by encoding the function
signature and grabbing the first

22261
22:48:47,670 --> 22:48:51,120
four bytes. So we'll create this
contract we'll do pragma

22262
22:48:51,480 --> 22:48:57,360
solidity zero point 8.7 Say
contract, call anything. And

22263
22:48:57,360 --> 22:49:00,030
we'll give this to stored
variables, give the to stored

22264
22:49:00,030 --> 22:49:04,440
variables and address public s,
underscore some amount, or some

22265
22:49:04,440 --> 22:49:10,080
address, and then you in 256,
public s underscore mount. And

22266
22:49:10,080 --> 22:49:12,570
then we'll create a function
called transfer function

22267
22:49:12,570 --> 22:49:15,960
transfer. Now normally in here,
we would actually do like

22268
22:49:15,960 --> 22:49:19,110
transfer for like an ERC 20
transfer, but we're just going

22269
22:49:19,110 --> 22:49:24,750
to do address some address, and
then you add 256 amount, amount

22270
22:49:24,750 --> 22:49:28,230
here, we'll make this a public
function. And then all we'll do

22271
22:49:28,350 --> 22:49:32,850
is we'll set S, some address
equals some address, and then s

22272
22:49:32,850 --> 22:49:36,930
amount equals amount. So here's
gonna be the function that we're

22273
22:49:36,930 --> 22:49:39,930
going to work with. And the
function selector for that

22274
22:49:39,930 --> 22:49:43,320
function is this, the function
signature is this. So it takes

22275
22:49:43,320 --> 22:49:46,710
an address some address amount,
that gets boiled down to the

22276
22:49:46,710 --> 22:49:49,350
function selector, and the
function signature. And of

22277
22:49:49,350 --> 22:49:52,110
course, in our bytecode, there's
going to be some code saying,

22278
22:49:52,110 --> 22:49:55,440
Okay, here's what this function
does, blah, blah, blah. So we

22279
22:49:55,440 --> 22:49:57,570
can actually even write a
function to get that function

22280
22:49:57,570 --> 22:50:01,770
selector. So we can say,
function, get selector and I'm

22281
22:50:01,770 --> 22:50:03,780
gonna say get selector one,
because I'm gonna show you a few

22282
22:50:03,780 --> 22:50:05,940
ways to get the function
selector, we'll make this a

22283
22:50:05,940 --> 22:50:11,550
public pure. And we'll have this
return a bytes for selector, we

22284
22:50:11,550 --> 22:50:17,700
could say select or equals bytes
for, and then we hash with a

22285
22:50:17,700 --> 22:50:25,230
check to 56 of the bytes of that
signature, which is transfer.

22286
22:50:25,500 --> 22:50:31,080
And it takes an address and a
UNT 56. Right? If we compile

22287
22:50:31,080 --> 22:50:34,650
this, and then we run it, let's
get rid of our old contract,

22288
22:50:34,800 --> 22:50:37,350
deploy, make sure we're on call
anything, if you have the other

22289
22:50:37,350 --> 22:50:41,670
one up. In here, now we have a
couple of things, we hit Get

22290
22:50:41,670 --> 22:50:47,190
selector one, we get this Oh X,
a 905, blah, blah, blah, right.

22291
22:50:47,190 --> 22:50:49,890
And that's the same as the
example I just gave. So this

22292
22:50:49,890 --> 22:50:53,670
right here tells solidity tells
our smart contract, okay, when

22293
22:50:53,670 --> 22:50:57,450
we make a call to this contract,
if you see this in the function

22294
22:50:57,450 --> 22:51:01,710
data, this is referring to our
transfer function with an

22295
22:51:01,710 --> 22:51:05,580
address and a un 256 as input
parameter. So we see address you

22296
22:51:05,580 --> 22:51:09,570
into 56. Our function knows to
execute this data here. Great.

22297
22:51:09,570 --> 22:51:12,570
And then of course, sml, and S
address are zeros. Now, while

22298
22:51:12,570 --> 22:51:15,600
we're here, we can also see,
okay, what happens if we call

22299
22:51:15,600 --> 22:51:18,450
the transfer function, right? It
takes an address and an amount,

22300
22:51:18,450 --> 22:51:21,180
so let's just give it its own
address or an address. And we'll

22301
22:51:21,180 --> 22:51:25,650
do 777 for an amount. If we hit
transfer, we have the log up,

22302
22:51:25,710 --> 22:51:28,590
right, we'll get a little
checkmark here saying success.

22303
22:51:28,650 --> 22:51:32,190
Now, if we hit S amount, we'll
get 777. And then the address

22304
22:51:32,190 --> 22:51:34,320
will be the same, right? So
that's us directly calling

22305
22:51:34,320 --> 22:51:38,490
transfer. When we directly call
transfer, we're basically

22306
22:51:38,490 --> 22:51:41,160
saying, hey, grab this function
selector, and then do some other

22307
22:51:41,160 --> 22:51:43,080
stuff, which we'll we'll tell
you the other stuff in a minute.

22308
22:51:43,110 --> 22:51:46,050
Now we have the function
selector. Okay, great. What else

22309
22:51:46,050 --> 22:51:49,440
do we need, we also now need the
parameters we want to add. So

22310
22:51:49,440 --> 22:51:54,120
we're going to need to encode
those parameters with our

22311
22:51:54,120 --> 22:51:56,370
function selector. So what we're
gonna do is we're gonna say

22312
22:51:56,370 --> 22:52:03,000
function, get data to call
transfer. And in here, we're

22313
22:52:03,000 --> 22:52:05,340
just going to have this get data
to call transfer, we're going to

22314
22:52:05,340 --> 22:52:07,710
have it take these input
parameters, and we're going to

22315
22:52:07,710 --> 22:52:11,460
encode these to work with our
function selector, we're gonna

22316
22:52:11,460 --> 22:52:18,630
say address, some address. And
if it is x, amount, public pure

22317
22:52:18,660 --> 22:52:21,720
returns, bytes memory.

22318
22:52:22,800 --> 22:52:26,760
And then we can return and use
one of those ABI and codings

22319
22:52:26,790 --> 22:52:29,670
from the cheat sheet. Now, so
far, we've just been doing API

22320
22:52:29,670 --> 22:52:32,880
and code for a lot of our
encoding. So it since we have

22321
22:52:32,880 --> 22:52:37,080
the function selector, we can
actually do ABI dot encode with

22322
22:52:37,110 --> 22:52:40,740
selector. This ABI encodes the
given arguments starting from

22323
22:52:40,740 --> 22:52:43,800
the second and prepends, the
given four byte selector. When

22324
22:52:43,800 --> 22:52:47,760
we do in Cobra selector, we're
just sticking our selector onto

22325
22:52:47,790 --> 22:52:49,920
the data that we're going to
give it. So we're going to do

22326
22:52:49,920 --> 22:52:56,040
return API dot encode with
select door. And we're going to

22327
22:52:56,040 --> 22:53:00,840
pass it the result of get
selector one, and then we're

22328
22:53:00,840 --> 22:53:05,220
going to give it some address,
and amount. So what this is

22329
22:53:05,220 --> 22:53:08,400
going to do, it's gonna give us
all the data that we need to put

22330
22:53:08,400 --> 22:53:11,820
in that data field of our
transaction, to send to this

22331
22:53:11,820 --> 22:53:15,420
contract to let this contract
know, hey, go use the transfer

22332
22:53:15,420 --> 22:53:18,720
function, pass in some address,
and then an amount. And then if

22333
22:53:18,720 --> 22:53:22,080
we compile this, we run it,
let's delete our old contract,

22334
22:53:22,110 --> 22:53:25,950
we'll deploy up, we now got a
new function called Get Data to

22335
22:53:25,950 --> 22:53:29,820
call and transfer, we'll just
pass you know, we'll just pass

22336
22:53:29,850 --> 22:53:34,140
this contract address and then
we'll also do 777 again. And so

22337
22:53:34,140 --> 22:53:37,500
this thing right here is what
we're going to put into the data

22338
22:53:37,500 --> 22:53:41,880
field of our transaction in
order for us to call transfer

22339
22:53:41,880 --> 22:53:45,480
from anywhere. So this is the
bytes This is the binary encoded

22340
22:53:45,480 --> 22:53:50,640
data of Hey, call the transfer
function with this address that

22341
22:53:50,640 --> 22:53:54,750
we specified. with, you know,
777 Mt. So what we can do once

22342
22:53:54,750 --> 22:53:57,240
we have all this, we can
actually call our transfer

22343
22:53:57,240 --> 22:54:01,380
function without even having to
directly call it. So what we can

22344
22:54:01,380 --> 22:54:07,620
do is we can say function, call
transfer function directly, or I

22345
22:54:07,620 --> 22:54:11,490
guess with binary might be a
better title, but you get the

22346
22:54:11,490 --> 22:54:15,540
gist, we'll say address some
address, you in 256 amount,

22347
22:54:16,230 --> 22:54:18,660
we'll make this a public
function. And we'll have a

22348
22:54:18,660 --> 22:54:23,610
returns a bytes four and a bool.
You'll see why in a minute. And

22349
22:54:23,610 --> 22:54:27,780
we'll do that same call thing
that we did to send our raffle

22350
22:54:27,780 --> 22:54:31,320
money. So what we'll do is,
before we did recent winner dot

22351
22:54:31,320 --> 22:54:34,620
call, right, we're going to do
some address. And then for us,

22352
22:54:34,620 --> 22:54:38,610
we're going to address this dot
call. And then we're saying this

22353
22:54:38,610 --> 22:54:41,970
contracts address which we could
put any address here address dot

22354
22:54:41,970 --> 22:54:46,530
call, and we're going to call
the encoded data that points us

22355
22:54:46,530 --> 22:54:50,460
to the transfer function with
some parameters. So we're going

22356
22:54:50,460 --> 22:54:54,540
to do address this.com. And we
could just do get data to call

22357
22:54:54,540 --> 22:54:55,470
transfer

22358
22:54:56,940 --> 22:55:01,020
address amounts, right, we could
do it like this. Or we could do

22359
22:55:01,020 --> 22:55:04,410
it kind of the wrong way. We
could do ABI dot and code with

22360
22:55:04,410 --> 22:55:10,800
select dorm, get selector one,
comma, some address, comma

22361
22:55:10,800 --> 22:55:14,040
amount. And actually, there's no
semicolon there, sorry. So those

22362
22:55:14,040 --> 22:55:18,270
are going to be the same. And
this dot call thing, right, it's

22363
22:55:18,270 --> 22:55:21,630
going to return exactly what we
saw before, it's going to return

22364
22:55:21,630 --> 22:55:23,940
a bool success. So whether or
not the transaction was

22365
22:55:23,940 --> 22:55:29,790
successful, and then bytes,
memory, returned data, which is

22366
22:55:29,790 --> 22:55:32,520
going to be you know, whatever
the call returns. So right, and

22367
22:55:32,520 --> 22:55:35,190
this is where we put like
require success, right. But for

22368
22:55:35,190 --> 22:55:40,110
us, we're just going to return
bytes, four bytes for a return

22369
22:55:40,110 --> 22:55:43,620
datum, and then success. So
we're just going to return the

22370
22:55:43,620 --> 22:55:47,370
first four bytes of whatever
data we get returned. And then

22371
22:55:47,370 --> 22:55:49,620
we're going to return whether
this was successful or not. So

22372
22:55:49,620 --> 22:55:54,000
this function is going to have
us directly call the transfer

22373
22:55:54,000 --> 22:55:57,900
function by passing these
parameters without us having to

22374
22:55:57,900 --> 22:56:01,320
do like contract dot transfer,
or, or transfer whatever, right.

22375
22:56:01,440 --> 22:56:04,320
And you can do this across
multiple contracts across

22376
22:56:04,320 --> 22:56:07,290
different contracts, just by
changing the address that you

22377
22:56:07,290 --> 22:56:10,410
call on. So let's go ahead and
compile this. We'll run this now

22378
22:56:10,410 --> 22:56:13,620
we'll delete our old contract,
we'll deploy call anything. Now

22379
22:56:13,620 --> 22:56:17,070
if we if we were. So right now
sml, and estimators are both

22380
22:56:17,070 --> 22:56:21,630
zero. Now, if we do call
transfer function directly, and

22381
22:56:21,630 --> 22:56:26,040
we'll pass in this one's
address, and then we'll do 777.

22382
22:56:26,490 --> 22:56:31,800
Now, if we pull up the logs, we
hit this, we're gonna get this

22383
22:56:31,800 --> 22:56:35,070
transaction response here. But
if we scroll down, we'll ever

22384
22:56:35,070 --> 22:56:38,550
see the decoded output, which is
a bytes for of just a bunch of

22385
22:56:38,550 --> 22:56:41,520
zeros, right? Because our
transfer doesn't actually return

22386
22:56:41,520 --> 22:56:44,580
anything. So it's just gonna be
a whole bunch of zeros, and then

22387
22:56:44,580 --> 22:56:47,580
our Boolean true, which means it
was successful. So since it was

22388
22:56:47,580 --> 22:56:51,510
successful, these two should
have changed based off of that.

22389
22:56:51,510 --> 22:56:54,180
So let's go ahead and try them
out. And we do indeed see that

22390
22:56:54,180 --> 22:56:58,110
they're changed. So we have just
directly called this transfer

22391
22:56:58,110 --> 22:57:01,710
function without having to call
the transfer function itself, we

22392
22:57:01,710 --> 22:57:05,880
can also do encode with
signature instead of selector.

22393
22:57:05,970 --> 22:57:08,640
So if we go to our cheat sheet,
there's also this encode with

22394
22:57:08,640 --> 22:57:12,240
signature down here, which takes
the string memory signature, and

22395
22:57:12,240 --> 22:57:15,600
it's equivalent to doing ABI dot
encode with selector bytes for

22396
22:57:15,600 --> 22:57:18,900
CAC bytes, you know, signature,
it's, it's equivalent to doing

22397
22:57:18,900 --> 22:57:23,190
exactly what we did up here. But
it does this step for us. So we

22398
22:57:23,190 --> 22:57:26,340
could copy this whole thing,
paste it down here, right, and

22399
22:57:26,340 --> 22:57:30,090
we could do, instead of encoded
with selector, we can do encode

22400
22:57:30,360 --> 22:57:35,550
with SIG netshare, the function
signature, and then we'll copy

22401
22:57:35,550 --> 22:57:39,030
our function signature from up
here, paste that in here.

22402
22:57:39,870 --> 22:57:43,170
Compile, we ran into a
compilation error, up, these are

22403
22:57:43,170 --> 22:57:47,730
the same call transfer function
directly SIG, called that

22404
22:57:48,210 --> 22:57:53,190
compile, leader, old contract,
deploy. Now these two are both

22405
22:57:53,190 --> 22:57:56,370
zeros again. Now if we copy the
contract address, we do call

22406
22:57:56,370 --> 22:57:59,310
contract call transfer function
directly SIG. We paste that in

22407
22:57:59,310 --> 22:58:03,930
here, we do 777, we call it, let
me check these we can see that

22408
22:58:03,930 --> 22:58:07,440
that does the exact same thing.
So this is API dot encode with

22409
22:58:07,440 --> 22:58:10,650
signature. This is abi dot
encode selector. Encode with

22410
22:58:10,650 --> 22:58:14,280
signature just turns us into the
selector for us. That's all up

22411
22:58:14,280 --> 22:58:17,940
here, we just, we encoded this
selector ourselves. Now, there

22412
22:58:17,940 --> 22:58:20,190
are a whole bunch of different
ways to get the selectors. And

22413
22:58:20,430 --> 22:58:22,860
we're not going to code these
out ourselves. I'm just gonna

22414
22:58:22,860 --> 22:58:29,790
say a bunch of different ways to
get selector. And who knows why

22415
22:58:29,820 --> 22:58:31,710
why you might want to use one of
these other reasons, right?

22416
22:58:31,710 --> 22:58:34,110
There's there's a ton of reasons
why you might want to get the

22417
22:58:34,110 --> 22:58:36,960
selector a different way. And
here's some now in this video,

22418
22:58:36,960 --> 22:58:40,020
we're not going to explain or go
over all these different all

22419
22:58:40,020 --> 22:58:43,320
these different function
selector getting methods. But if

22420
22:58:43,320 --> 22:58:45,330
you go through them in the
GitHub repo associated with this

22421
22:58:45,330 --> 22:58:48,120
course, they all have a ton of
comments to explain what they're

22422
22:58:48,120 --> 22:58:50,190
doing. Well, we are going to
show you though, it's actually

22423
22:58:50,190 --> 22:58:53,850
how to contracts can interact
with each other without actually

22424
22:58:53,850 --> 22:58:56,880
having all the code for each
contract. So we're going to make

22425
22:58:56,910 --> 22:59:00,300
a second contract that has all
this binary this byte

22426
22:59:00,300 --> 22:59:03,960
information to call the transfer
function on a different

22427
22:59:03,960 --> 22:59:06,360
contract. And we're gonna show
you how that can work. This is

22428
22:59:06,360 --> 22:59:09,000
just another contract that I've
made called call function

22429
22:59:09,000 --> 22:59:11,580
without contract. Actually, down
here, we're going to call the

22430
22:59:11,580 --> 22:59:15,240
transfer function, just by using
the address and the function

22431
22:59:15,240 --> 22:59:18,060
selector signature and stuff,
we're going to update these

22432
22:59:18,060 --> 22:59:22,200
storage variables in our call
anything contract from another

22433
22:59:22,200 --> 22:59:26,520
contract just by doing this
binary calling, if you will,

22434
22:59:26,790 --> 22:59:29,760
right, so let's compile, it's
going to deploy, we can actually

22435
22:59:29,760 --> 22:59:32,820
leave this up right, we can
leave this up is let's deploy

22436
22:59:32,820 --> 22:59:36,330
our call function without
contract, we'll pass it as an

22437
22:59:36,330 --> 22:59:40,800
input parameter, the call
anything contract address, we'll

22438
22:59:40,800 --> 22:59:45,240
deploy it. Now in here, I can
call the transfer function

22439
22:59:45,240 --> 22:59:50,220
directly by you know, maybe I'll
switch it to this, this contract

22440
22:59:50,220 --> 22:59:53,130
address this new contract
address, and we'll give it a new

22441
22:59:53,130 --> 22:59:57,240
number of 123. Right, and we'll
click call transfer function.

22442
22:59:57,750 --> 22:59:59,700
And then when we go back up
here, we see that this has

22443
22:59:59,700 --> 23:00:03,000
indeed been updated. Now doing
this call stuff is considered

22444
23:00:03,030 --> 23:00:06,240
low level. And it's a best
practice to try to avoid it when

22445
23:00:06,240 --> 23:00:09,420
you can. So if you can import an
interface, it's much better to

22446
23:00:09,420 --> 23:00:11,700
do it like that. Because you're
going to have the compiler on

22447
23:00:11,700 --> 23:00:13,830
your side, you're going to be
able to check to see if your

22448
23:00:13,860 --> 23:00:17,400
types are matching and all this
other stuff. So usually doing

22449
23:00:17,400 --> 23:00:21,000
these low level calls some
security auditor checkers might

22450
23:00:21,000 --> 23:00:24,090
say, hey, like this books been
out a little bit, you doing this

22451
23:00:24,090 --> 23:00:24,870
low level stuff.

22452
23:00:24,930 --> 23:00:28,470
But with that being said, You
have just learned a ton about

22453
23:00:28,500 --> 23:00:31,050
lower level solidity. This is
some really advanced stuff. And

22454
23:00:31,050 --> 23:00:34,260
like I said, if this was hard,
if you're kind of confused here,

22455
23:00:34,650 --> 23:00:37,110
don't worry, you can always come
back to this section and try it

22456
23:00:37,110 --> 23:00:39,780
again, when you're a little bit
more advanced, if you want to

22457
23:00:39,780 --> 23:00:43,080
try to understand it all now.
Awesome. Absolutely, we've left

22458
23:00:43,080 --> 23:00:45,840
some links in the GitHub repo
associated with this lesson that

22459
23:00:45,840 --> 23:00:48,570
I definitely recommend you check
out one of the ones you should

22460
23:00:48,570 --> 23:00:51,330
definitely check out, it's going
to be this deconstructing

22461
23:00:51,330 --> 23:00:55,170
solidity by openzeppelin, it
really breaks down exactly

22462
23:00:55,170 --> 23:00:57,180
what's going on behind the
scenes of a contract. If you

22463
23:00:57,180 --> 23:00:59,700
want to learn more about
opcodes, about low level stuff,

22464
23:00:59,970 --> 23:01:02,190
definitely give this a read, it
is a phenomenal read,

22465
23:01:02,220 --> 23:01:04,710
essentially, it breaks down a
little bit more than what we

22466
23:01:04,710 --> 23:01:08,160
went over here. A couple other
videos as well. And I've left a

22467
23:01:08,160 --> 23:01:09,030
whole bunch of links in here

22468
23:01:09,030 --> 23:01:19,320
too. With that being said, here
we are back in our NFT. And now

22469
23:01:19,320 --> 23:01:22,320
we know all about this ABI dot
encoding stuff, right and what

22470
23:01:22,320 --> 23:01:25,080
it does, and we know that ABI
dot encode packed, the way we're

22471
23:01:25,080 --> 23:01:27,540
using here is just a way to
concatenate strings. And we're

22472
23:01:27,540 --> 23:01:30,630
not using ABI dot encode for
really any of its crazy

22473
23:01:30,630 --> 23:01:33,750
superpowers, but we might in the
later section of this course. In

22474
23:01:33,750 --> 23:01:37,980
other case, so we do use this
base 64 dot encode thing that

22475
23:01:37,980 --> 23:01:41,310
we've imported, right, we
imported this base 64 dot encode

22476
23:01:41,310 --> 23:01:46,080
so that we can encode our SVG
that we pass it in to its base

22477
23:01:46,080 --> 23:01:48,960
64 encoding. I'm going to copy
paste an example here, you don't

22478
23:01:48,960 --> 23:01:51,930
have to do this. But like, for
example, we'll pass it in like

22479
23:01:51,960 --> 23:01:55,950
SVG width equals blah, blah,
blah, all this SVG stuff, kind

22480
23:01:55,950 --> 23:01:59,280
of similar to what I was showing
you before, we pass that in as

22481
23:01:59,280 --> 23:02:02,400
an input parameter here, and
output it, we're gonna get the

22482
23:02:02,400 --> 23:02:05,310
base 64 encoding of it, we're
gonna get this massive kind of

22483
23:02:05,310 --> 23:02:08,940
string here. We will test this
later to make sure that this

22484
23:02:08,940 --> 23:02:12,270
works. Normally, if I added a
function in like this right now,

22485
23:02:12,270 --> 23:02:14,970
I probably would test it right
away. For now we can just leave

22486
23:02:14,970 --> 23:02:17,790
it in here. That's going to be
great for getting this image

22487
23:02:17,790 --> 23:02:21,660
here. But we don't want just an
image, right? We were going to

22488
23:02:21,660 --> 23:02:25,710
need that metadata. We need this
to be a JSON object, not just an

22489
23:02:25,710 --> 23:02:30,600
image URL like this, we need
stick this image, this base 64

22490
23:02:30,600 --> 23:02:35,580
encoded image into this image
field of our JSON. So how do we

22491
23:02:35,580 --> 23:02:39,450
actually do this? Well, what we
can do is we know that our ERC

22492
23:02:39,450 --> 23:02:44,580
721 code comes with a token URI,
and it's that token URI that

22493
23:02:44,580 --> 23:02:48,150
points to this, which tells us
what our code is going to look

22494
23:02:48,150 --> 23:02:52,590
like. So what we can do is we
can actually base 64 encode our

22495
23:02:52,590 --> 23:02:58,020
JSON as well, to turn into a
JSON token URI. So we basically

22496
23:02:58,020 --> 23:03:01,590
four encoded this image to get
this, we're going to stick this

22497
23:03:01,590 --> 23:03:05,220
URL into our JSON. And then
we're going to base 64 encode

22498
23:03:05,220 --> 23:03:09,720
our JSON, and that's going to be
the URI that our token uses. So

22499
23:03:09,720 --> 23:03:14,610
we have our function, token URI,
right. And this takes a un 256

22500
23:03:14,640 --> 23:03:19,980
token ID, we'll say it's going
to be a public view, public view

22501
23:03:20,010 --> 23:03:24,540
override, and it returns a
string memory. So we're going to

22502
23:03:24,540 --> 23:03:29,310
override the token URI function
of the ERC 721 to whatever we

22503
23:03:29,310 --> 23:03:33,300
want it to be. And here we're
going to encode some JSON text

22504
23:03:33,300 --> 23:03:39,870
that we give our contract into a
base 64 based JSON token URI

22505
23:03:39,930 --> 23:03:45,600
just to get started we'll do a
require underscore exists. Token

22506
23:03:45,600 --> 23:03:51,180
ID, and then I'm just gonna say
your I query for non existent

22507
23:03:51,480 --> 23:03:56,160
token. And yeah, this price
should be an if not exists,

22508
23:03:56,340 --> 23:03:59,250
Revert with an error. However,
we're just going to go like

22509
23:03:59,250 --> 23:04:05,370
this. And this exists function
comes in my ear C 721. So we're

22510
23:04:05,370 --> 23:04:07,440
going to do same thing here. So
we're gonna say require this

22511
23:04:07,440 --> 23:04:10,920
token, a D exists. And again, we
can 100 percent. And probably should

22512
23:04:10,920 --> 23:04:14,490
make this an IF EXISTS token,
ID, you know, now what we want

22513
23:04:14,490 --> 23:04:17,910
to do is we want to figure out
how to make this token URI

22514
23:04:17,940 --> 23:04:23,310
return a base 64 encoded version
of this JSON. So first, we know

22515
23:04:23,310 --> 23:04:26,070
how to how to concatenate a
string, right, so that's gonna

22516
23:04:26,070 --> 23:04:28,350
be the first thing that we're
going to do. So we'll do API dot

22517
23:04:28,350 --> 23:04:33,840
and code packed. And we're going
to encode ourselves the JSON on

22518
23:04:33,840 --> 23:04:36,570
chain, we're going to use single
quotes here, because inside of

22519
23:04:36,570 --> 23:04:39,480
this API and code packed, we're
going to use double quotes in

22520
23:04:39,480 --> 23:04:43,530
here is where we're going to add
our JSON. So we'll give a name,

22521
23:04:43,800 --> 23:04:47,400
right, so the first piece of
metadata needs to be a name. So

22522
23:04:47,400 --> 23:04:52,290
we'll give it a name. And we'll
put a comma here. And we'll say

22523
23:04:52,350 --> 23:04:57,570
the name of this NF T is going
to be the name we get from, we

22524
23:04:57,570 --> 23:05:00,540
have a name function, which
returns the name. So we're gonna

22525
23:05:00,540 --> 23:05:02,850
say the name is going to be the
name. And we're gonna just

22526
23:05:02,850 --> 23:05:05,820
concatenate all this stuff, name
right there. We're gonna

22527
23:05:05,820 --> 23:05:09,750
continue on with the JSON. So we
put a little quote here, and a

22528
23:05:09,750 --> 23:05:13,800
little quote here. So we
encapsulate this name in quotes,

22529
23:05:13,830 --> 23:05:16,230
right? Because remember, we're,
we're concatenating, this big

22530
23:05:16,230 --> 23:05:19,560
string that we're making here,
we'll do a comma, we'll say,

22531
23:05:19,980 --> 23:05:23,790
description, we'll do another
quote. And this time, we're just

22532
23:05:23,790 --> 23:05:26,760
going to put the description
ourselves, and we'll say, and

22533
23:05:26,760 --> 23:05:32,880
NFT, that changes, based on the
chain link feed, we'll put an

22534
23:05:32,880 --> 23:05:35,940
end quote here and a comma, and
we'll put a comma outside the

22535
23:05:35,940 --> 23:05:40,500
quote, down here, we'll say,
attributes.

22536
23:05:42,390 --> 23:05:52,710
We'll just say, trait type, it's
going to be coolness. Comma,

22537
23:05:53,070 --> 23:06:01,440
value, me 100. Boom, to a comma
to image. We'll put a comma out

22538
23:06:01,440 --> 23:06:05,160
here. And this is where we're
going to put our image URI,

22539
23:06:05,460 --> 23:06:08,400
image URI, which we're going to
have to get from somewhere. So

22540
23:06:08,400 --> 23:06:11,160
for now, I'm just gonna say,
string.

22541
23:06:12,690 --> 23:06:16,770
Memory image URI equals i,
right, which clearly isn't an

22542
23:06:16,770 --> 23:06:18,990
image arrived. But just to make
this format and stuff, we'll

22543
23:06:18,990 --> 23:06:21,570
we'll put this there. This is
where we're going to put that

22544
23:06:21,600 --> 23:06:26,520
image URI that we get from SVG
to image URI. And then that's

22545
23:06:26,520 --> 23:06:31,440
it. I mean, close off our JSON,
though. So doing ABI dot encode

22546
23:06:31,440 --> 23:06:34,380
pack is going to concatenate
this all together. So this is

22547
23:06:34,380 --> 23:06:37,980
basically going to be a string
that looks like this. Great. But

22548
23:06:37,980 --> 23:06:43,140
how do we turn this into a base
64 encoded token you arrive so

22549
23:06:43,140 --> 23:06:45,840
that other people can read it is
we're going to typecast this

22550
23:06:45,840 --> 23:06:48,930
whole thing to bytes. And then
now that this whole thing is in

22551
23:06:48,930 --> 23:06:52,680
bytes, we can do exactly what we
did with the SVG above is now we

22552
23:06:52,680 --> 23:06:57,210
can base 64 encoded. So we'll do
base 64, dot ENCODE. And then

22553
23:06:57,210 --> 23:07:00,210
we'll just put another pair of
parentheses around this save and

22554
23:07:00,210 --> 23:07:04,830
auto formatted. And this here is
going to give us this second

22555
23:07:04,830 --> 23:07:08,010
line, right, it's going to give
us all of this bit, but it's not

22556
23:07:08,010 --> 23:07:11,550
going to give us this first bit,
right. So we just need to append

22557
23:07:11,550 --> 23:07:14,700
to this first bit now. And we
should be good to go. For basics

22558
23:07:14,700 --> 23:07:19,830
before data image SVG plus XML
basics, the form, this is the

22559
23:07:19,830 --> 23:07:24,270
prefix for images for SVG
images, right? We use that above

22560
23:07:24,270 --> 23:07:27,690
because that's the prefix for
SVG images. The prefix for base

22561
23:07:27,690 --> 23:07:32,670
64. Jason is going to be it's
going to be data application

22562
23:07:32,670 --> 23:07:36,990
JSON base 64. So we're going to
do it like this instead. Now the

22563
23:07:36,990 --> 23:07:40,410
ERC 721 has something called a
base URI that we're going to

22564
23:07:40,410 --> 23:07:43,500
override and that we're going to
use. So we're gonna say function

22565
23:07:43,650 --> 23:07:48,120
underscore base URI. This will
be internal pure. And we're

22566
23:07:48,120 --> 23:07:51,960
going to override the one that
ERC 721 has. And this is going

22567
23:07:51,960 --> 23:07:57,660
to returns a string memory. And
we're just going to return this

22568
23:07:57,660 --> 23:08:02,640
bit right here. And now we can
use this base URI. to append,

22569
23:08:02,760 --> 23:08:06,630
right, we're going to append
this first part to our base 64

22570
23:08:06,630 --> 23:08:11,670
encoded JSON. So in order to
append them, once again, we'll

22571
23:08:11,670 --> 23:08:18,090
do ABI dot ENCODE, packed. And
then we'll put this down here.

22572
23:08:19,110 --> 23:08:22,740
And we'll say, we're going to,
we're going to concatenate base

22573
23:08:22,740 --> 23:08:25,740
URI to this massive thing that
we just created. And then we

22574
23:08:25,740 --> 23:08:28,440
save and we ought to format the
now this is obviously a bytes

22575
23:08:28,440 --> 23:08:31,830
object, and we want it to be a
string. So then all we got to do

22576
23:08:32,100 --> 23:08:36,180
is typecast it as a string, but
another prints see down here,

22577
23:08:36,990 --> 23:08:39,570
and then we can actually just
return this, but basically what

22578
23:08:39,570 --> 23:08:44,610
we're doing is we're creating a
JSON string, we encode it in

22579
23:08:44,610 --> 23:08:49,590
bytes, that way we can encode it
in base 64. Once we have encoded

22580
23:08:49,590 --> 23:08:53,280
in base 64, which is going to
look like this second string,

22581
23:08:53,400 --> 23:08:57,540
it's gonna look like here out,
we then just append this initial

22582
23:08:57,540 --> 23:09:03,420
part. But for JSON objects, it's
data application JSON. We we

22583
23:09:03,420 --> 23:09:06,480
append that we do API dot encode
packed, and then cast it to

22584
23:09:06,480 --> 23:09:10,350
string and then boom, we now
have a token URI. That'll look

22585
23:09:10,350 --> 23:09:12,690
something like this. And then
all we have to do is update our

22586
23:09:12,690 --> 23:09:16,110
image URI with what we get from
our function appear, and then

22587
23:09:16,110 --> 23:09:19,860
we'll be good to go. So let's
finish this out. Let's do this.

22588
23:09:25,080 --> 23:09:29,010
So in our constructor, we're
passing a low SVG and a high

22589
23:09:29,010 --> 23:09:32,400
SVG. And what are these low SVG
is in these high SVG as well,

22590
23:09:32,610 --> 23:09:38,100
basically saying, when the price
of this asset is too low, show a

22591
23:09:38,100 --> 23:09:42,180
frown. And when the price of the
asset is high, show a smiley

22592
23:09:42,180 --> 23:09:46,350
face. So we're gonna give it
this frown, SVG, and this happy

22593
23:09:46,350 --> 23:09:50,490
SVG as input parameters, low CG
and high SVG, we probably want

22594
23:09:50,490 --> 23:09:53,790
to save those. But we don't
necessarily want to save them in

22595
23:09:53,790 --> 23:09:57,690
like their SVG format. So we
just want to store the image

22596
23:09:57,690 --> 23:10:00,750
URI, right, we will just want to
store this string up here

22597
23:10:00,780 --> 23:10:04,230
instead of the actual SVG. So
right in our constructor, we can

22598
23:10:04,230 --> 23:10:12,060
do I underscore low image URI
equals, and we have this SVG to

22599
23:10:12,060 --> 23:10:17,160
image your eye function, where
we can pass the low SVG. And

22600
23:10:17,160 --> 23:10:22,080
then we can do the same thing
for the high image URI. So now,

22601
23:10:22,110 --> 23:10:26,520
SVG image URI is going to return
something that looks like this.

22602
23:10:26,640 --> 23:10:30,690
And we're going to store just
this string this image URI on

22603
23:10:30,690 --> 23:10:34,110
chain. Now that we have the two
of those, we can use that down

22604
23:10:34,110 --> 23:10:37,920
below. In our token, Uri
function, when somebody calls

22605
23:10:37,920 --> 23:10:41,700
token, your I have token ID
zero, we're going to stick into

22606
23:10:41,730 --> 23:10:45,900
our JSON, either the low image
or I or the high image arrive.

22607
23:10:46,380 --> 23:10:48,990
And we're actually going to base
that off of the channeling price

22608
23:10:48,990 --> 23:10:51,390
feed. So how do we do that?
Well,

22609
23:10:51,510 --> 23:10:53,400
we've already worked with
channeling price feeds before so

22610
23:10:53,400 --> 23:10:56,880
let's go ahead and add it. So
yarn add dash dash dev at chain

22611
23:10:56,880 --> 23:11:00,720
link slash contracts. Once
that's done at the top, we can

22612
23:11:00,720 --> 23:11:07,290
do import at chain link slash
contracts, slash SRC slash V

22613
23:11:07,290 --> 23:11:14,790
0.8, slash interfaces, slash ag
reg gate, Tor V three interface,

22614
23:11:14,850 --> 23:11:20,010
that soul like so. And then down
here, let's comment this out.

22615
23:11:20,010 --> 23:11:23,220
For now, we're going to want to
call a price feed to figure out

22616
23:11:23,220 --> 23:11:26,250
what the price is and then show
the high image or the low image

22617
23:11:26,250 --> 23:11:28,410
based off that. So in order to
get a price feed in our

22618
23:11:28,410 --> 23:11:30,810
constructor, let's just add
another price feed address,

22619
23:11:31,500 --> 23:11:36,060
street address. And then we'll
make another variable. We'll do

22620
23:11:36,870 --> 23:11:44,220
aggregate Tor v3 interface.
Internal, immutable, I

22621
23:11:44,220 --> 23:11:48,930
underscore price feed. And we'll
say in our constructor, I price

22622
23:11:48,930 --> 23:11:55,380
feed equals aggregate Tor v3
interface at price feed,

22623
23:11:56,100 --> 23:12:00,030
address. And then what we can do
down here, the old bunch of

22624
23:12:00,030 --> 23:12:05,790
commas in here into 256 Price
comma, comma comma equals i

22625
23:12:05,790 --> 23:12:12,960
price feed that latest round
data. And what we can do is we

22626
23:12:12,960 --> 23:12:19,320
can say if price is greater than
or equal to some value, then

22627
23:12:19,320 --> 23:12:22,410
show one image dry otherwise,
show another one. So we can say

22628
23:12:22,410 --> 23:12:30,030
String memory, image URI equals
s underscore low image URI. And

22629
23:12:30,030 --> 23:12:32,640
then if the price is higher than
some value, well greater than

22630
23:12:32,640 --> 23:12:35,820
the image URI we're going to use
is going to be there's gonna be

22631
23:12:35,850 --> 23:12:40,920
AI is going to equal the high
image URI. And then we have

22632
23:12:40,920 --> 23:12:43,650
image right down here. So all we
got to do is figure out the

22633
23:12:43,650 --> 23:12:47,640
price. So we can make, and in
our mind, we'll let the mentors

22634
23:12:47,640 --> 23:12:53,760
choose the value that they want
to use. So we can say, into 256,

22635
23:12:54,090 --> 23:12:58,830
I value and we'll assign each
NFT, their own high value. So

22636
23:12:58,830 --> 23:13:02,040
we'll need to create like a
little mapping up top, we'll

22637
23:13:02,040 --> 23:13:09,540
say, mapping, you went to 56.
Two, you went to 56. Let's just

22638
23:13:09,540 --> 23:13:15,720
make this public for the heck of
it public s underscore token ID

22639
23:13:15,840 --> 23:13:22,200
to high value. And we'll say
that when they meant an NF T

22640
23:13:22,530 --> 23:13:26,220
will do s token ID to high
value, s underscore token

22641
23:13:26,220 --> 23:13:31,140
counter. We'll set that equal to
high value. So when they meant

22642
23:13:31,140 --> 23:13:34,470
they choose the high value that
they want. And then down here

22643
23:13:34,470 --> 23:13:38,160
we'll say if the price is
greater than or equal to the

22644
23:13:38,160 --> 23:13:42,300
high value of the token ID, then
we'll use the high one.

22645
23:13:42,330 --> 23:13:44,730
Otherwise, we'll just use the
low one. Oops, and this needs to

22646
23:13:44,730 --> 23:13:49,110
be you into videos x two into
256. Excuse me, since we want to

22647
23:13:49,110 --> 23:13:53,190
be able to compare them pretty
equally. And boom, our contract

22648
23:13:53,190 --> 23:13:56,580
looks really good. Now the only
thing we'd want to add in here

22649
23:13:56,610 --> 23:13:59,820
is probably an event. So we
probably want to emit an event

22650
23:13:59,850 --> 23:14:04,230
in time we met to one of these
NF T's. So we might do event

22651
23:14:05,040 --> 23:14:11,820
created NF T, will say you went
to 56 indexed token ID comma int

22652
23:14:11,880 --> 23:14:18,780
256. I value like so. And then
when we met this NFT, will do

22653
23:14:19,410 --> 23:14:25,290
emit create n t, s underscore
token counter, comma, I value.

22654
23:14:25,620 --> 23:14:29,310
And then it's best practice to
to have to update our token

22655
23:14:29,310 --> 23:14:31,800
counter before we actually do
the minting. So we'll do that as

22656
23:14:31,800 --> 23:14:35,790
well. Okay, there's a ton of
code here. And like I said, we

22657
23:14:35,790 --> 23:14:38,790
definitely would not have
written all that code without

22658
23:14:38,820 --> 23:14:41,370
having compiled to run some
tests first, but we decided we

22659
23:14:41,370 --> 23:14:44,910
want to just write it all right
off first. So and I did some

22660
23:14:45,120 --> 23:14:47,820
misspellings. Let's just make
sure everything compiles here.

22661
23:14:48,150 --> 23:14:50,850
Awesome. Everything's compiled
here. As you already know, a

22662
23:14:50,880 --> 23:14:53,370
couple things that we're going
to need to do to test this out.

22663
23:14:53,640 --> 23:14:56,310
First thing we're gonna need to
do is write our deploy function,

22664
23:14:56,460 --> 23:15:01,500
we've got our basic NFT, we've
got our random and f t, both of

22665
23:15:01,500 --> 23:15:06,030
these hosted on IPFS. Now we're
going to do a dynamic NFT that's

22666
23:15:06,030 --> 23:15:11,130
hosted 100 percent on chain, and it
changes based off the price of

22667
23:15:11,220 --> 23:15:24,840
an asset. So let's do this. Oh,
three, deploy dynamic, SVG

22668
23:15:25,740 --> 23:15:28,620
nft.js. We are no, we're gonna
need a little bit of

22669
23:15:28,620 --> 23:15:32,430
boilerplate. So let's go to our
basic NFT. And we'll just grab

22670
23:15:32,430 --> 23:15:36,780
all this the first seven lines
or so. And we'll just paste it

22671
23:15:36,780 --> 23:15:39,420
in here. What do we need for our
constructor? Well, we

22672
23:15:39,420 --> 23:15:44,130
need a price feed address, a low
SVG and a highest CG. Okay, so

22673
23:15:44,130 --> 23:15:47,580
let's get all of those. So price
feed address is something we've

22674
23:15:47,580 --> 23:15:50,460
already done before. And we can
add that into our helper

22675
23:15:50,460 --> 23:15:54,660
Hardhead config. And we'll do
one and a foreign local, we're

22676
23:15:54,660 --> 23:15:57,150
going to use what we're going to
use a mock. And if we're on

22677
23:15:57,150 --> 23:15:59,790
Rinkeby, or an actual network,
we're going to use an actual

22678
23:15:59,940 --> 23:16:03,180
address. So let's go ahead to
dark side chain that link will

22679
23:16:03,180 --> 23:16:08,700
grab a price feed address, the M
Aetherium. data feeds will go to

22680
23:16:08,700 --> 23:16:14,550
rank B, rank B and let's just
use eath USD copy that will make

22681
23:16:14,550 --> 23:16:21,150
a new entry eath USD price feed
like so. And for localhost,

22682
23:16:21,150 --> 23:16:23,190
we're good. So since we know for
localhost, we're going to need

22683
23:16:23,190 --> 23:16:27,330
to do a mock. Let's see if we
have a price feed mock. Okay,

22684
23:16:27,330 --> 23:16:31,380
now we don't, we're gonna need a
mock v3 aggregator dot soul. I

22685
23:16:31,380 --> 23:16:34,470
just copied pasted mine. If you
want, you can just go right to

22686
23:16:34,470 --> 23:16:38,160
the to a repo here. Or you can
copy from a previous section,

22687
23:16:38,190 --> 23:16:43,320
just a reminder heart at f and f
t FCC contracts asked moc v3

22688
23:16:43,320 --> 23:16:48,240
aggregator and this is using
point 06 of solidity. So we're

22689
23:16:48,240 --> 23:16:51,150
going to want to make sure that
in our hard hat dot config, we

22690
23:16:51,150 --> 23:16:55,650
have at least one 0.6 version,
which we do so we're good there.

22691
23:16:55,980 --> 23:17:18,390
That means in our deploy mocks,
we're going to want to add So

22692
23:17:18,390 --> 23:17:21,570
initial price will be 2000
decimals will be a team. So now

22693
23:17:21,570 --> 23:17:24,420
we've waited to deploy mocks for
that price feed. So we're gonna

22694
23:17:24,420 --> 23:17:29,790
say const chain ID equals
network dot config dot chain Id

22695
23:17:30,090 --> 23:17:36,600
do if development chains dot
includes network dot name, and

22696
23:17:36,600 --> 23:17:38,520
the more we need to import
development chains looks like

22697
23:17:38,520 --> 23:17:45,810
where did say const eth USD
akregator equals we'll get that

22698
23:17:45,810 --> 23:17:52,230
price feed equals awaits ethers
dot get contract Mark v3 Air

22699
23:17:52,320 --> 23:17:57,390
gate tour, and then we'll up
here we'll do let eath USD price

22700
23:17:57,600 --> 23:18:03,000
feed address eath USD price feed
address equals eath USD

22701
23:18:03,120 --> 23:18:08,910
aggregate tore that address else
will say the eath USD price feed

22702
23:18:08,910 --> 23:18:11,250
address is going to be equal to
what we find in the network

22703
23:18:11,250 --> 23:18:19,920
config. Network config. Chain ID
dot eth USD price. Okay, so we

22704
23:18:19,920 --> 23:18:24,090
have the eth USD price feed
rate. Now we need the lowest VG

22705
23:18:24,090 --> 23:18:28,440
and the high SVG. So we're going
to create a new folder in our

22706
23:18:28,440 --> 23:18:35,370
images folder. So we go CD
images, MK dir dynamic NF t. And

22707
23:18:35,370 --> 23:18:38,700
now we'll have two folders in
here dynamic which is empty and

22708
23:18:38,700 --> 23:18:41,250
random, which has all the random
stuff. If you want to use your

22709
23:18:41,250 --> 23:18:44,760
own SVGs for this, you
absolutely can. But if you want

22710
23:18:44,760 --> 23:18:48,030
to just come to my images file
and then save these images as so

22711
23:18:48,030 --> 23:18:52,110
just come right click Save image
as. Save them. and then drag and

22712
23:18:52,110 --> 23:18:54,810
drop them into your images files
here, you can absolutely do

22713
23:18:54,810 --> 23:19:00,810
that. So now that we have those,
we want to go ahead and read

22714
23:19:00,810 --> 23:19:05,220
those into our script here.
We'll say const, low SVG equals

22715
23:19:05,250 --> 23:19:09,240
a weight. And we're going to use
Fs again. So we're gonna do

22716
23:19:10,260 --> 23:19:17,760
const Fs equals require Fs, or
do await Fs dot read file sync,

22717
23:19:18,600 --> 23:19:22,470
we're going to read in this
file, which for me, it's at dot

22718
23:19:22,470 --> 23:19:29,550
slash images slash dynamic NF T
slash brown dot SVG. And we're

22719
23:19:29,550 --> 23:19:35,130
using encoding of UTF eight. And
then we'll say const. Hi, SVG

22720
23:19:35,460 --> 23:19:41,430
equals await Fs dot read file
sync. Copy this whole thing,

22721
23:19:41,460 --> 23:19:44,730
because we're using the same
stuff. This one's going to be

22722
23:19:44,730 --> 23:19:49,560
happy about SVG. And that's it.
So when price is good, we're

22723
23:19:49,560 --> 23:19:52,080
gonna do happiness, SVG, when
price is bad, we're gonna do

22724
23:19:52,080 --> 23:19:54,780
frown at SVG. Now, let's go
ahead and let's deploy this

22725
23:19:54,780 --> 23:19:59,460
contract. So we'll say arguments
or args equals, it's gonna be

22726
23:19:59,460 --> 23:20:05,430
the price feed address, low SVG,
and then high SVG. And we'll say

22727
23:20:05,460 --> 23:20:14,760
const, dynamic S, G and F T
equals await, deploy dynamic SVG

22728
23:20:14,910 --> 23:20:19,830
and f t, comma little bracket
here, from Deployer.

22729
23:20:21,990 --> 23:20:29,820
args, args log true. And the
weights confirmations, it's

22730
23:20:29,820 --> 23:20:38,370
going to be network dot config,
that block confirmations, or one

22731
23:20:38,910 --> 23:20:45,270
will do some logging, I will do
log to do that. But Larry, do

22732
23:20:45,270 --> 23:20:48,180
some verification, I'm actually
just going to copy paste that

22733
23:20:48,180 --> 23:20:50,730
from our last script, because
it's going to be exactly the

22734
23:20:50,730 --> 23:20:55,020
same copy paste. But instead of
random IPFS, it's going to be

22735
23:20:55,080 --> 23:20:59,730
dynamic SVG and f t. The rest of
this looks good. And that's just

22736
23:20:59,730 --> 23:21:06,000
about it. So we'll do module,
exports dot tags, equals and

22737
23:21:06,000 --> 23:21:14,880
we'll do all dynamic. SVG. And
we'll do main. Oh, okay. Let's

22738
23:21:14,880 --> 23:21:19,260
try to see if our deploy script
that we just created works. To

22739
23:21:19,260 --> 23:21:26,280
do h h, or yarn hardhat deployed
dash dash tags, die Namic SVG,

22740
23:21:26,430 --> 23:21:28,830
that makes sense, because we
didn't deploy the mocks. So

22741
23:21:28,830 --> 23:21:33,150
we'll do tags, dynamic SVGs. And
then also the mocks. Local

22742
23:21:33,150 --> 23:21:36,660
network detected play marks, we
deploy the marks, deploying

22743
23:21:36,660 --> 23:21:45,930
dynamic SVG, awesome. You know
what comes next? You Gosh, darn

22744
23:21:45,930 --> 23:21:50,730
right, it's time for some tests.
Now, once again, I'm going to

22745
23:21:50,730 --> 23:21:53,700
encourage you to pause the video
now and try to write your own

22746
23:21:53,700 --> 23:21:57,480
test for this test for this
section actually can be a little

22747
23:21:57,480 --> 23:22:00,750
bit tricky. Since we are going
to be manipulating the price of

22748
23:22:00,750 --> 23:22:04,680
our mock aggregator, we are
checking for these long strings,

22749
23:22:04,860 --> 23:22:08,340
and such. So be sure to use the
GitHub repository associated

22750
23:22:08,340 --> 23:22:11,670
with this lesson, in case you
get lost. Now, I want to show

22751
23:22:11,670 --> 23:22:18,660
you what this looks like on a
marketplace, like OpenCL. So we

22752
23:22:18,660 --> 23:22:22,020
are going to deploy this to rink
B. Now keep in mind test that

22753
23:22:22,020 --> 23:22:24,990
can be slow. So you might want
to be patient here. And you

22754
23:22:24,990 --> 23:22:27,630
don't even have to do it if you
don't want to. But it is kind of

22755
23:22:27,630 --> 23:22:30,270
nice to see. Okay, that's what
it really looks like. And you

22756
23:22:30,270 --> 23:22:33,180
can go to the contract on chain
once it's verified. And you can

22757
23:22:33,180 --> 23:22:35,970
read the token URI and
everything. And it's pretty fun.

22758
23:22:35,970 --> 23:22:40,110
So let's just add one more bit
to our deploy folder. Let's add

22759
23:22:40,110 --> 23:22:43,260
a mint script that just emits an
NF T for each one of these

22760
23:22:43,260 --> 23:22:47,820
contracts. So we're going to
create no for mint.js. And we're

22761
23:22:47,820 --> 23:22:52,350
just going to have each one of
these contracts mint NFT. Let's

22762
23:22:52,350 --> 23:22:57,000
go ahead and do this. So in
here, we'll do const ethers

22763
23:22:57,480 --> 23:23:03,330
network equals require arhat.
And then I'm going to do a

22764
23:23:03,330 --> 23:23:06,540
little copy paste in. I'm just
going to copy this part because

22765
23:23:06,540 --> 23:23:10,440
I know I'm going to need that.
We are going to need a deploy

22766
23:23:10,440 --> 23:23:13,560
but we're not going to need to
deploy. So I'll grab get named

22767
23:23:13,560 --> 23:23:16,320
accounts, get named accounts,
it's going to come right from

22768
23:23:16,320 --> 23:23:19,530
there. So we have a Deployer.
Our deployer is just gonna be

22769
23:23:19,530 --> 23:23:22,800
used to mint them. First we'll
mint the basic NF t. So we'll

22770
23:23:22,800 --> 23:23:29,130
say const basic NF t equals wait
ethers dot get contract, basic N

22771
23:23:29,130 --> 23:23:32,370
ft, and we'll connect the
deployer to it. And then we'll

22772
23:23:32,370 --> 23:23:38,370
say const basic mint and if T or
basic mint, TX equals await

22773
23:23:38,580 --> 23:23:44,640
basic NF T dot mint NF t. And
then we'll do a weight basic

22774
23:23:45,210 --> 23:23:50,610
mint, TX dot weight one and then
we'll do a little console dot

22775
23:23:50,610 --> 23:23:57,630
log base Again, T index zero has
token URI, we'll put in a little

22776
23:23:57,810 --> 23:24:02,970
await basic NF T dot token URI
of zero. That's it for the basic

22777
23:24:02,970 --> 23:24:09,300
entity. Now we'll do our random
IPFS and empty. So we'll say

22778
23:24:09,300 --> 23:24:16,830
const, random IPFS NF t equals
await ethers dot get contract,

22779
23:24:16,950 --> 23:24:22,170
random IPFS and f t, connected
to the Deployer. This one, we

22780
23:24:22,170 --> 23:24:26,310
need a mint fee. So we'll say
const, mint V equals await

22781
23:24:26,550 --> 23:24:31,200
random IPFS NF T dot get mint
fee. And then we'll do the mint.

22782
23:24:31,230 --> 23:24:37,590
So we'll say const, random IPFS
and ft mint, TX equals await,

22783
23:24:38,190 --> 23:24:44,550
random IPFS and F T dot request
and F team. And for this one, we

22784
23:24:44,550 --> 23:24:47,910
need to pass a value, which is
going to be the mint v.to

22785
23:24:47,910 --> 23:24:53,220
string. Now for this one, just
like what we saw in our tests,

22786
23:24:53,370 --> 23:24:57,690
we're going to have to do this
await new promise again, right,

22787
23:24:57,690 --> 23:25:01,200
because we need to wait for it
to return need to listen for

22788
23:25:01,200 --> 23:25:04,440
those events, we probably should
set up the listener first. So

22789
23:25:04,440 --> 23:25:06,510
let's actually set up the
listener first. So we're going

22790
23:25:06,510 --> 23:25:11,010
to do await new promise, and
we're gonna do async function.

22791
23:25:11,760 --> 23:25:16,170
And we're going to do resolve
reject. In here, we're gonna use

22792
23:25:16,170 --> 23:25:18,810
that, that fun little arrow
syntax in here.

22793
23:25:19,050 --> 23:25:21,900
And now since we're in this
function here, we actually set

22794
23:25:21,900 --> 23:25:27,150
the timeout resolve like this,
which means we have five minutes

22795
23:25:27,450 --> 23:25:30,810
to time this out, you might want
to bump this up even more five

22796
23:25:30,810 --> 23:25:33,360
minutes might not be enough,
this is gonna be 300

22797
23:25:33,630 --> 23:25:36,270
milliseconds here, we're gonna
do that once again. So we'll say

22798
23:25:36,270 --> 23:25:41,100
random IPFS and ft dot once.
Once we get that NFT minted

22799
23:25:41,460 --> 23:25:45,960
event, we're going to run an
async function, we're just gonna

22800
23:25:45,960 --> 23:25:50,340
do resolve. And inside here is
where we can actually put,

22801
23:25:50,610 --> 23:25:56,670
actually requesting the NFT. But
below our listener, right, so in

22802
23:25:56,670 --> 23:26:02,400
there, and then we can say if
developments chains, that

22803
23:26:02,430 --> 23:26:07,410
includes network dot name. So
let's just make sure we import

22804
23:26:07,410 --> 23:26:11,400
those development chains and
network or affect them and

22805
23:26:11,400 --> 23:26:14,280
chains that includes network dot
name. So we're on a test net,

22806
23:26:14,310 --> 23:26:17,130
this is where we go ahead and we
pretend to be those mocks. So

22807
23:26:17,130 --> 23:26:21,630
we'll say const Request ID
equals random IPFS. Oh,

22808
23:26:21,630 --> 23:26:27,360
actually, we're going to need to
do const random IPFS and ft min

22809
23:26:27,360 --> 23:26:32,550
TX receipt equals await on IPFS
and empty minted TX dot weight

22810
23:26:32,640 --> 23:26:36,090
one. So we're gonna need to get
the receipt. And from the

22811
23:26:36,090 --> 23:26:41,370
receipt, we can get the request
ID. That events one dot args dot

22812
23:26:41,370 --> 23:26:49,590
request id.to string. And then
we can do const VRF. coordinator

22813
23:26:49,620 --> 23:26:56,190
V to mock equals await ethers
dot get contract, the RF

22814
23:26:56,280 --> 23:27:00,360
coordinate for V to mock,
connect this to the Deployer.

22815
23:27:00,780 --> 23:27:06,510
And then we'll do a wait the RF
corded and a Tor V to mock that

22816
23:27:06,510 --> 23:27:12,450
fulfill random words with
Request ID, random IPFS. And if

22817
23:27:12,450 --> 23:27:19,770
T dot address, we can do console
dot log random IPFS and have T

22818
23:27:20,190 --> 23:27:29,010
index zero token URI to await
random IP. That's NF T dot token

22819
23:27:29,040 --> 23:27:37,500
URI of zero. Finally, we can do
our dynamic SVG, NF t. So we can

22820
23:27:37,500 --> 23:27:43,920
say const, high high value
equals ethers.utils.do parse

22821
23:27:43,920 --> 23:27:48,630
ether here. So we'll say
4000 $4,000 will be the high

22822
23:27:48,630 --> 23:27:55,680
value. We'll say const. Dynamic
SVG and f t equals await ethers

22823
23:27:55,680 --> 23:28:00,300
dot get contract, dynamic. SVG
and a T will connect it to the

22824
23:28:00,300 --> 23:28:09,330
deployer say const by Namic, s,
B, G, and f t mint, TX equals

22825
23:28:09,360 --> 23:28:17,130
await dynamic SVG and F T dot
mint and f t i value to string

22826
23:28:17,460 --> 23:28:24,300
then we'll just do wait. This
stat wait one. And finally

22827
23:28:24,300 --> 23:28:33,000
console dot log dynamic. SVG NFT
index zero token URI is going to

22828
23:28:33,000 --> 23:28:42,270
be a weight dynamic. SVG and ft
dot token URI of zero. Okay, I

22829
23:28:42,270 --> 23:28:44,910
think that looks good. Let's try
this on a local network. So

22830
23:28:44,910 --> 23:28:49,230
we'll do yarn hard hat deploy.
And we'll run all those scripts

22831
23:28:51,480 --> 23:28:55,860
It looks like everything worked.
So we have random, basic NFT

22832
23:28:55,980 --> 23:29:00,000
index zero has a token year, I
have this IPFS thing, random

22833
23:29:00,030 --> 23:29:04,920
IPFS NFT. index zero has this
thing. And then our SVG has this

22834
23:29:04,920 --> 23:29:07,380
giant monstrosity, okay,
perfect. And then we can even

22835
23:29:07,380 --> 23:29:12,210
check, right, we can even grab
this IPFS hash, we go to our

22836
23:29:12,210 --> 23:29:16,020
IPFS node, or if you installed
IPFS in your browser, or you're

22837
23:29:16,020 --> 23:29:18,240
working with Brave, we can just
pop it right into our browsers

22838
23:29:18,240 --> 23:29:20,790
and see what it looks like.
Right. And then if I zoom in,

22839
23:29:21,270 --> 23:29:24,330
and adorable St. Bernard, with
the image of the St. Bernard,

22840
23:29:25,170 --> 23:29:27,720
looking like that, this one's
also gonna be St. Bernard. And

22841
23:29:27,720 --> 23:29:31,950
then of course, are SVG, which
we can also copy, paste, and

22842
23:29:31,950 --> 23:29:35,640
boom, that looks great. And then
we can copy the image. And it's

22843
23:29:35,640 --> 23:29:39,660
a frowny face or shad. But
Awesome. Okay, so it's working

22844
23:29:39,690 --> 23:29:43,500
locally for us. Now, let's go
ahead and try to make this work

22845
23:29:43,620 --> 23:29:47,490
on an actual test net. So
hopefully, our helper hard hat

22846
23:29:47,490 --> 23:29:50,820
config is set up correctly. And
there's enough stuff in here

22847
23:29:50,880 --> 23:29:54,510
where we need to make sure that
we have a subscription ID,

22848
23:29:54,630 --> 23:29:56,610
right, we're going to need to
make sure we have a subscription

22849
23:29:56,610 --> 23:30:00,180
ID. And we shouldn't call the
mint function, right, because

22850
23:30:00,180 --> 23:30:03,810
we're going to need to add our
consumer to the VRF. Before we

22851
23:30:03,810 --> 23:30:07,140
can actually meant so let me
let's add some tags to our meant

22852
23:30:07,140 --> 23:30:11,940
here. So we'll do module dot
exports, dot tags equals, and

22853
23:30:11,940 --> 23:30:17,340
we'll say all comma meant a
while ago, I said okay, let's

22854
23:30:17,340 --> 23:30:22,530
add a main tag. Now we're coming
around to why we added this main

22855
23:30:22,530 --> 23:30:25,770
tag here. So what we want to do
is want to deploy all of these

22856
23:30:25,770 --> 23:30:31,590
contracts. But before we finally
meant for our IPFS one, we need

22857
23:30:31,590 --> 23:30:34,560
to add that contract to our
consumer, here's what we're

22858
23:30:34,560 --> 23:30:38,790
gonna do, we're gonna run yarn,
Hardhead, deploy dash dash

22859
23:30:38,790 --> 23:30:45,030
network Rinkeby dash dash tags
main. Now, this won't meant any

22860
23:30:45,030 --> 23:30:48,240
of our NF T's, okay, won't mean
to any of our NF T's, it'll just

22861
23:30:48,240 --> 23:30:51,090
deploy those contracts might
just sit around and wait a

22862
23:30:51,090 --> 23:30:54,270
little bit for these to actually
deploy. So this is a great time

22863
23:30:54,270 --> 23:30:56,880
to go take a break, maybe go
take a walk, get a sip of water,

22864
23:30:56,880 --> 23:30:59,550
get a cup of coffee, whatever
you want to do. Yeah, once

22865
23:30:59,550 --> 23:31:02,280
everything is deployed, then we
can go to V or F dot chain dot

22866
23:31:02,280 --> 23:31:06,450
link, we're already connected
here, we used our subscription.

22867
23:31:06,690 --> 23:31:11,400
And then we would just add our
IPFS consumer in here. And we'd

22868
23:31:11,400 --> 23:31:13,890
be good to go. And All right,
once everything goes through,

22869
23:31:13,890 --> 23:31:16,830
and we have all three of our
transactions on the blockchain,

22870
23:31:17,100 --> 23:31:21,810
we can go ahead, we can grab our
random IPFS NF T, we'll grab

22871
23:31:21,810 --> 23:31:24,870
that address, we'll come back
over to V or F dot chain dot

22872
23:31:24,870 --> 23:31:30,150
link slash rink D, we'll go to
our subscription ID, and we'll

22873
23:31:30,150 --> 23:31:35,280
add a new consumer will add that
contract address. So we'll go

22874
23:31:35,280 --> 23:31:38,520
ahead and approve and Metamask.
And once this goes through, we

22875
23:31:38,520 --> 23:31:42,600
can finish running the mint part
of our deploy folder. Once it's

22876
23:31:42,600 --> 23:31:46,170
confirmed, we can close maybe we
can do a little refresh, we

22877
23:31:46,170 --> 23:31:49,410
should see our new address added
as a subscription here. Now that

22878
23:31:49,410 --> 23:31:52,890
we've added that we can mint one
NF T from each one of these

22879
23:31:52,890 --> 23:31:58,650
contracts are in hard hats,
deploy dash dash tags meant dash

22880
23:31:58,650 --> 23:32:02,670
dash network Rinkeby. And we'll
have to wait a little bit for

22881
23:32:02,670 --> 23:32:06,240
this too. Okay, now that we have
them all minted, we should get a

22882
23:32:06,240 --> 23:32:10,230
little output like this. Right?
Basic NF t zero has token URI

22883
23:32:10,230 --> 23:32:15,300
here. Basic random IPFS NF T has
token your eye here. And then

22884
23:32:15,300 --> 23:32:19,620
our SVG has this as a token
year, right. So what can we do

22885
23:32:19,620 --> 23:32:24,570
now? Well, let me go grab, I'll
grab my wallet address and stick

22886
23:32:24,570 --> 23:32:28,320
it into Rinkeby ether scan. And
we can see we called mint

22887
23:32:28,470 --> 23:32:33,030
request and mint again. And we
created three contracts, right,

22888
23:32:33,030 --> 23:32:37,590
we created our basic NFT, our
random IPFS NFT and our dynamic

22889
23:32:37,710 --> 23:32:42,750
SVG NFT. What we can do now is
we can grab, we can copy the

22890
23:32:42,750 --> 23:32:46,890
address of our contract. And we
can go to test nets that open

22891
23:32:46,890 --> 23:32:48,840
see that i Oh,

22892
23:32:49,860 --> 23:32:53,280
and we can put that address in
the bar here in the search bar

22893
23:32:53,280 --> 23:32:57,810
here. Now this part is
incredibly, incredibly variable.

22894
23:32:57,840 --> 23:33:01,830
Okay, open C can be really slow.
And it can take open see up to a

22895
23:33:01,830 --> 23:33:05,520
couple of hours to register that
a contract has been deployed to

22896
23:33:05,520 --> 23:33:08,700
a test net. So if it doesn't
show up right away, don't be

22897
23:33:08,700 --> 23:33:11,850
discouraged. Don't let it drag
you down. But if it does, you

22898
23:33:11,850 --> 23:33:15,750
should be able to click on your
collection and see the NFT is

22899
23:33:15,750 --> 23:33:19,860
actually here. I'm going to grab
our random IPFS NFT. Let's grab

22900
23:33:19,860 --> 23:33:23,130
that contract address. I'm going
to grab that test net site open

22901
23:33:23,130 --> 23:33:27,840
c.io. Paste that address in
there. And what do you know we

22902
23:33:27,840 --> 23:33:32,130
do indeed see, random IPFS and f
t, right and I've deployed a

22903
23:33:32,130 --> 23:33:35,190
couple of them. So this one's v
two, and we have our adorable

22904
23:33:35,190 --> 23:33:38,610
Shiva in you right here. So this
is what it looks like an open C

22905
23:33:38,640 --> 23:33:43,320
now we can 100 percent verify that our
code is good even if it doesn't

22906
23:33:43,320 --> 23:33:46,920
show up on Open. See. If we go
to the contract we go to read

22907
23:33:46,920 --> 23:33:51,750
contract. And then we go to
token URI punch and zero here. A

22908
23:33:51,960 --> 23:33:56,370
query, grabbed this, stick it
into our browsers, the JSON

22909
23:33:56,370 --> 23:34:00,660
looks good. So let's grab the
image URI. Paste that in. And if

22910
23:34:00,660 --> 23:34:04,560
we can see this here, that means
that our code is good. And you

22911
23:34:04,560 --> 23:34:08,850
have successfully deployed a
number of FFTs to the

22912
23:34:08,850 --> 23:34:15,210
blockchain. We have learned a
massive amount in this course,

22913
23:34:15,210 --> 23:34:17,340
this is definitely one of the
most jam packed one. And it's

22914
23:34:17,340 --> 23:34:20,700
all about art. Right? Isn't that
crazy? Let's do a quick

22915
23:34:20,700 --> 23:34:25,230
refresher of this entire course
here. So first off, we learned

22916
23:34:25,230 --> 23:34:29,400
the basics of an NF T with our
basic NF T dot Sol, we learn

22917
23:34:29,400 --> 23:34:33,450
that these NF T's are based off
of the ERC 721 standard. And

22918
23:34:33,450 --> 23:34:37,080
that just means they have
functions like name, token, Uri,

22919
23:34:37,110 --> 23:34:42,900
etc. We learned that NF T's use
this token URI to tell us what

22920
23:34:43,020 --> 23:34:45,540
the token actually looks like a
token, your eye will look

22921
23:34:45,540 --> 23:34:49,410
something like this, it's going
to be a name a description, it's

22922
23:34:49,410 --> 23:34:52,710
going to have an image URL,
which points to a different

22923
23:34:52,710 --> 23:34:56,340
location for what the NFT
actually looks like. It'll have

22924
23:34:56,340 --> 23:34:59,340
stuff like attributes, it can
have stuff like attributes, and

22925
23:34:59,340 --> 23:35:03,570
a few other tags. This is known
as the metadata of the NFT. And

22926
23:35:03,570 --> 23:35:07,560
this tells us about the NFT. We
can also have all that metadata

22927
23:35:07,560 --> 23:35:10,800
on chain, of course, to
customize it on chain, and make

22928
23:35:10,800 --> 23:35:14,460
it look and grow and change and
be interactive on chain, we

22929
23:35:14,460 --> 23:35:17,760
learned more about IPFS, we
actually wrote a script called

22930
23:35:17,790 --> 23:35:21,420
upload to pinjarra.js, where we
can actually programmatically

22931
23:35:21,450 --> 23:35:26,490
upload images and files to
another IPFS pinning service for

22932
23:35:26,490 --> 23:35:31,410
us, we can of course, always use
our own IPFS nodes if we want.

22933
23:35:31,440 --> 23:35:35,760
Now this token URI can really be
anything. And we hosted it on

22934
23:35:35,910 --> 23:35:40,350
IPFS for our basic NFT and for
our random NFT. But for our

22935
23:35:40,350 --> 23:35:45,270
dynamic NFT, we actually hosted
the token, you're right 100 percent On

22936
23:35:45,270 --> 23:35:49,230
chain, so we didn't use IPFS.
And we made this dynamic where

22937
23:35:49,230 --> 23:35:54,000
the token URI actually changes
based off of the price of a

22938
23:35:54,030 --> 23:35:58,890
changeling price feed in our
random IPFS NFT, we gave our NFT

22939
23:35:59,160 --> 23:36:03,030
a chance we gave different
rarities to the different dogs

22940
23:36:03,060 --> 23:36:06,810
so that we could create
programmatically rare NF TS

22941
23:36:06,840 --> 23:36:10,680
where our pug is super rare. Our
Shiva is sort of rare, and our

22942
23:36:10,680 --> 23:36:13,170
St. Bernard is pretty common. So
the fact that we got to ship it

22943
23:36:13,170 --> 23:36:16,680
in you was awesome. We did some
amazing deployments, we wrote

22944
23:36:16,680 --> 23:36:19,860
some tests. Not only that, but
we learned a lot about

22945
23:36:19,890 --> 23:36:23,610
transactions, and how we can
actually add whatever data we

22946
23:36:23,610 --> 23:36:26,010
want to this data section. And a
little bit more about what our

22947
23:36:26,010 --> 23:36:29,910
transactions look like, and how
we can actually use functions,

22948
23:36:29,910 --> 23:36:33,270
selectors and function
signatures to be able to call

22949
23:36:33,330 --> 23:36:37,110
anything, right and we learn
more about ABI dot encoding, and

22950
23:36:37,110 --> 23:36:39,630
encoding packed and all this
binary stuff if you want it to

22951
23:36:39,630 --> 23:36:42,900
go deep into that. So this was
an absolutely JAM PACKED

22952
23:36:42,930 --> 23:36:45,690
session. And you should be
incredibly proud of yourself,

22953
23:36:45,750 --> 23:36:48,090
especially with your little
puppy that you can see on open

22954
23:36:48,090 --> 23:36:51,510
sea or you can see directly on
ether scan, or you can just look

22955
23:36:51,510 --> 23:36:55,410
at it and IPFS and be really
proud of what you've done. But

22956
23:36:55,440 --> 23:36:58,230
with that being said, huge
congratulations on making this

22957
23:36:58,230 --> 23:37:01,110
far. Definitely definitely
definitely take a break here,

22958
23:37:01,290 --> 23:37:02,820
and we'll see you in the next
one.

22959
23:37:12,219 --> 23:37:16,179
Okay, now we have less than
fifth team, which is going to be

22960
23:37:16,179 --> 23:37:21,369
our next JS NFT marketplace. And
if you finish this lesson, you

22961
23:37:21,399 --> 23:37:25,899
are a web three full stack
monster, this is going to be our

22962
23:37:25,929 --> 23:37:30,159
most complicated front end using
the web three stack and using a

22963
23:37:30,159 --> 23:37:33,669
lot of really advanced web
three, and blockchain tools. So

22964
23:37:33,669 --> 23:37:37,119
get really excited because we
are going to learn a ton in this

22965
23:37:37,119 --> 23:37:40,299
lesson. Now there are actually
three different repos associated

22966
23:37:40,299 --> 23:37:43,599
with this lesson. The first one
is going to be our typical hard

22967
23:37:43,599 --> 23:37:46,839
hat project. For the back end,
after the hard hat project, we

22968
23:37:46,839 --> 23:37:50,589
actually have two repos both are
going to be our front end repos,

22969
23:37:50,589 --> 23:37:53,349
and they're going to be slightly
different. In this project,

22970
23:37:53,349 --> 23:37:56,439
we're going to learn more about
how events are so important and

22971
23:37:56,439 --> 23:37:59,139
why events are so important,
especially for off chain

22972
23:37:59,139 --> 23:38:01,599
services. And so we're actually
going to look at two different

22973
23:38:01,599 --> 23:38:04,119
ways to work with them, one
using the mirallas, or a

22974
23:38:04,119 --> 23:38:07,989
centralized database, and then
one using the graph. And the

22975
23:38:07,989 --> 23:38:10,899
reason that I want to show both
of these is that oftentimes,

22976
23:38:10,899 --> 23:38:12,909
when people are looking to scale
the projects, when people are

22977
23:38:12,909 --> 23:38:16,059
looking to get things done
really quickly, taking a more

22978
23:38:16,059 --> 23:38:19,539
centralized approach can often
be a little quicker, and you can

22979
23:38:19,539 --> 23:38:22,479
sometimes add more functionality
to your website. And there's

22980
23:38:22,479 --> 23:38:24,969
still a lot of protocols that
have decentralized backends. And

22981
23:38:24,969 --> 23:38:29,379
centralized front ends. One such
example, is open sea, open sea,

22982
23:38:29,379 --> 23:38:33,309
for example, has the ability to
actually like different and fts.

22983
23:38:33,369 --> 23:38:36,039
Now, this isn't something that
we would actually want to spend

22984
23:38:36,039 --> 23:38:38,499
any gas on. But it is something
that we're gonna have to store

22985
23:38:38,499 --> 23:38:41,139
in some type of database
somewhere, so that people have

22986
23:38:41,139 --> 23:38:44,139
the ability to do that. So I
want to show you this optional

22987
23:38:44,139 --> 23:38:47,469
first way to build these front
ends, since all of our logic is

22988
23:38:47,469 --> 23:38:50,829
still going to be 100 percent. On
chain, the front end matters a

22989
23:38:50,829 --> 23:38:53,469
little bit less, because anybody
can still interact with the

22990
23:38:53,469 --> 23:38:56,319
contracts that we build on
chain. Now in web three, we

22991
23:38:56,319 --> 23:38:59,439
don't want to stay there.
However, getting an MVP done

22992
23:38:59,439 --> 23:39:02,439
getting a minimal viable project
done is really, really

22993
23:39:02,439 --> 23:39:04,599
important. So using a
centralized server, like

22994
23:39:04,599 --> 23:39:07,749
Morales, or centralized project
can make us much quicker. In

22995
23:39:07,749 --> 23:39:10,479
fact, we have been using
centralized services, like

22996
23:39:10,479 --> 23:39:13,419
alchemy, kind of throughout this
whole project. But of course, I

22997
23:39:13,449 --> 23:39:16,119
also want to show you the
decentralized way to make your

22998
23:39:16,119 --> 23:39:18,729
front end. So after we work with
Morales, we're also going to

22999
23:39:18,729 --> 23:39:21,729
show you how to use the graph
then for to do all this event

23000
23:39:21,729 --> 23:39:25,119
indexing. Now the graph is going
to be the decentralized way we

23001
23:39:25,119 --> 23:39:27,999
can make our front end and work
with these events. And the graph

23002
23:39:28,029 --> 23:39:31,809
also comes with its own graph
repo. So we'll learn all about

23003
23:39:31,809 --> 23:39:34,599
that once we get to the front
end section. But let me show you

23004
23:39:34,599 --> 23:39:37,479
what we're going to build
because it is really cool. Now

23005
23:39:37,479 --> 23:39:39,819
that we've learned a ton about
how to make NF T's what they

23006
23:39:39,819 --> 23:39:42,969
are, we're going to make our own
NFT marketplace. And like I

23007
23:39:42,969 --> 23:39:45,549
said, this is really going to be
our deep dive into all these

23008
23:39:45,549 --> 23:39:48,219
amazing front end tools. So
here's what our front end is

23009
23:39:48,219 --> 23:39:51,579
gonna look like. But what we can
do is we can connect with our

23010
23:39:51,579 --> 23:39:55,059
little connect button, we hit
Metamask Metamask pops up, we'll

23011
23:39:55,059 --> 23:39:58,419
go ahead and connect. And now
that we're connected, we can see

23012
23:39:58,419 --> 23:40:01,869
the different entities in here.
And if we're on an address

23013
23:40:01,869 --> 23:40:05,769
that's owned by us, it will say
owned by you. And if we switch

23014
23:40:05,769 --> 23:40:10,599
addresses, or UI will go ahead
and update, connect there. And

23015
23:40:10,599 --> 23:40:13,179
now we're owned by a different
address. Now, if it's owned by

23016
23:40:13,179 --> 23:40:15,849
us, we get this little hover
that says Update listing. And

23017
23:40:15,849 --> 23:40:19,149
right now it's worth 0.18.
That's what it's listed for on

23018
23:40:19,149 --> 23:40:22,029
our marketplace. If it's owned
by us, and we click it, we can

23019
23:40:22,059 --> 23:40:26,739
update it to a different price.
Let's update it to 50 eath, or

23020
23:40:26,739 --> 23:40:29,499
whatever your layer one currency
is, we'll just say new listing

23021
23:40:29,499 --> 23:40:33,159
price, we'll go ahead and
confirm. And I'll say listing

23022
23:40:33,159 --> 23:40:36,519
updated, please refresh, and
what we can do them. And we'll

23023
23:40:36,519 --> 23:40:40,269
mine some blocks on the back
end, and boom, now we see that

23024
23:40:40,269 --> 23:40:43,839
it's worth 50 here. Now if we
switch to a different account,

23025
23:40:44,169 --> 23:40:46,899
now we can see owned by blah,
blah, blah, and the hovered now

23026
23:40:46,899 --> 23:40:51,699
says by me, if his selected as a
different user, I'm gonna get

23027
23:40:51,849 --> 23:40:55,329
this transaction to actually buy
it. Now go ahead and confirm

23028
23:40:55,329 --> 23:40:57,609
that I'm gonna buy it, I get a
little pop up. This is item

23029
23:40:57,609 --> 23:41:00,999
bought successfully. Now if I do
a little refresh, we'll now see

23030
23:41:00,999 --> 23:41:04,179
that that NFT is gone from the
marketplace, since we bought it

23031
23:41:04,239 --> 23:41:07,599
right, it's no longer available
to be sold. Now what we can do

23032
23:41:07,599 --> 23:41:12,549
then is we can come over to sell
NF Ts and at the bottom, we'll

23033
23:41:12,549 --> 23:41:17,079
see a withdraw proceeds. So
whenever somebody buys an NF T,

23034
23:41:17,259 --> 23:41:20,109
the NFT marketplace actually
keeps the proceeds that actually

23035
23:41:20,109 --> 23:41:24,609
keeps the result of the sale. So
if we switch back to our address

23036
23:41:24,609 --> 23:41:28,179
that had the NF T listed, we can
now see Withdraw 50 proceeds

23037
23:41:28,179 --> 23:41:30,939
because we know that we have 50
eath, because we just bought

23038
23:41:30,939 --> 23:41:35,319
that for 50. So if we hit
withdraw, Metamask is gonna pop

23039
23:41:35,319 --> 23:41:39,909
up, we can go ahead and confirm,
wait a little bit as transaction

23040
23:41:39,909 --> 23:41:43,449
populates, and boom once it goes
through, we'll see now we have

23041
23:41:43,449 --> 23:41:46,719
zero proceeds. Right, we
withdrew everything from here.

23042
23:41:46,989 --> 23:41:50,769
So what we can do now, is we can
relist that NFT. So if we come

23043
23:41:50,769 --> 23:41:55,179
back, let's go back to the one
who just bought that NF t. If we

23044
23:41:55,179 --> 23:41:58,509
know the address and the token
ID of the NF t and we own it, we

23045
23:41:58,509 --> 23:42:00,849
can go ahead and relist it,
because we can place the address

23046
23:42:00,849 --> 23:42:05,829
in here with the token ID Give
us some sort of price, we'll

23047
23:42:05,829 --> 23:42:11,229
submit, we'll approve giving the
NFT marketplace access to our

23048
23:42:11,379 --> 23:42:15,519
NFT to our little doggie. And
then we'll go ahead and actually

23049
23:42:15,519 --> 23:42:20,439
send the transaction to actually
list the NFT on a marketplace

23050
23:42:20,889 --> 23:42:24,039
that we get NFT listed
successfully. After we remove

23051
23:42:24,039 --> 23:42:27,189
some blocks in the back end, we
can go back to the front end.

23052
23:42:27,519 --> 23:42:31,389
And we now see, it's owned by
us, instead of the original

23053
23:42:31,389 --> 23:42:35,019
owner, right and set for 10
ether. And then we can of

23054
23:42:35,019 --> 23:42:38,469
course, switch back to a
different user, and we can have

23055
23:42:38,499 --> 23:42:42,159
them actually buy. So this is
going to be a NFT marketplace

23056
23:42:42,159 --> 23:42:45,549
that's completely decentralized,
we are going to learn a ton

23057
23:42:45,579 --> 23:42:49,599
about front end a ton about
indexing a ton about events, and

23058
23:42:49,599 --> 23:42:53,259
why they are so powerful. And
I'm really excited for you for

23059
23:42:53,259 --> 23:42:55,779
this one. Because if you get
through this one, you will have

23060
23:42:55,779 --> 23:43:00,939
so many tools at your fingertips
for working with the blockchain.

23061
23:43:01,689 --> 23:43:05,109
Are you ready, let's jump in.
Let's build the contracts first,

23062
23:43:05,109 --> 23:43:07,659
and then we'll build the front
end. Let's do this. Now this

23063
23:43:07,659 --> 23:43:11,379
project is going to be based off
the Arteon project, which is a

23064
23:43:11,409 --> 23:43:15,609
completely open source
decentralized smart contract NFT

23065
23:43:15,609 --> 23:43:18,609
marketplace, I'll leave a link
to it in the GitHub repo

23066
23:43:18,639 --> 23:43:21,189
associated with this course,
ours of course, is going to be a

23067
23:43:21,189 --> 23:43:22,899
minimalistic version of this.

23068
23:43:28,030 --> 23:43:30,430
So we're in our VS code pre
normal. And we're going to

23069
23:43:30,430 --> 23:43:37,060
create a new folder here called
hard hat. And if T marketplace,

23070
23:43:37,330 --> 23:43:43,960
FCC, oops, MK dir, like them,
we're gonna cd into it. And then

23071
23:43:43,960 --> 23:43:47,290
open this up and its own VS
code. Once again, you can use

23072
23:43:47,290 --> 23:43:51,880
code period, or file open
folder, and open this folder.

23073
23:43:52,000 --> 23:43:53,830
Once we get in here, we're going
to do all of our normal stuff

23074
23:43:53,830 --> 23:43:56,920
that we've been doing throughout
the course. And once again, if

23075
23:43:56,920 --> 23:43:59,440
you want to copy paste over your
package, JSON, if you want to

23076
23:43:59,440 --> 23:44:02,260
copy paste in the modules,
whatever you want to do, feel

23077
23:44:02,260 --> 23:44:06,160
free to do so I'm gonna go ahead
actually, this repo here, we're

23078
23:44:06,160 --> 23:44:09,970
gonna scroll up and just grab
once again, this line from less

23079
23:44:09,970 --> 23:44:14,350
than nine. And just run that I
know I'm gonna be using prettier

23080
23:44:14,380 --> 23:44:16,840
so I'm just gonna go ahead and
copy paste those two prettier

23081
23:44:16,840 --> 23:44:20,290
files over prettier ignore and
prettier RC going to be using

23082
23:44:20,290 --> 23:44:23,290
them again, for linting. With
solidity we're going to use Sol

23083
23:44:23,290 --> 23:44:25,780
hint dot JSON. So we're going to
grab that dot soul hint dot

23084
23:44:25,780 --> 23:44:30,070
JSON. And the dots will hint dot
ignore. I'm also going to grab

23085
23:44:30,070 --> 23:44:32,800
the hard hat dot config dot j s
because we're going to be using

23086
23:44:33,070 --> 23:44:36,970
a really, really similar setup.
And this hard hat dot config dot

23087
23:44:36,970 --> 23:44:40,510
j s. It's got waffle in it,
ether scan, hard hat deploy

23088
23:44:40,510 --> 23:44:44,470
coverage gas reporter sizer and
Dottie and v dot config, we're

23089
23:44:44,470 --> 23:44:47,320
going to bring over our Dotty
and V. And we're also gonna

23090
23:44:47,320 --> 23:44:50,650
bring over our utils folder as
well. Right, so a lot of that

23091
23:44:50,650 --> 23:44:53,290
boilerplate we're gonna bring on
over. And now just like that,

23092
23:44:53,290 --> 23:44:56,470
since we have the hard hat dot
config dot j s in here, if we

23093
23:44:56,470 --> 23:45:01,360
run yarn, hard hat, right now,
yarn hard hat will actually see

23094
23:45:01,390 --> 23:45:05,770
we get the output like this. So
let's go ahead. And before we

23095
23:45:05,770 --> 23:45:08,530
actually write our contracts,
let's go ahead and write a

23096
23:45:08,530 --> 23:45:11,320
little doc saying what our
contract is even going to do,

23097
23:45:11,350 --> 23:45:15,040
what do we want this to do?
We're going to create a

23098
23:45:15,040 --> 23:45:19,900
decentralized NFT marketplace.
So what does that mean? What

23099
23:45:19,900 --> 23:45:23,410
will we probably need? Well,
we'll probably need some type of

23100
23:45:23,440 --> 23:45:27,010
list item function, because
we'll want to list NF T's and

23101
23:45:27,010 --> 23:45:31,240
this will be to list NF t's on
the marketplace, we'll need some

23102
23:45:31,240 --> 23:45:34,690
type of buy item to buy the NF
T's. And then we'll probably

23103
23:45:34,690 --> 23:45:38,680
need maybe like a cancel listing
or cancel item, if you no longer

23104
23:45:38,680 --> 23:45:44,170
want to sell it, maybe an update
listing, update price. And then

23105
23:45:44,170 --> 23:45:50,560
maybe a withdraw proceeds to
withdraw payment or my bot and

23106
23:45:50,560 --> 23:45:53,950
fts. So when somebody buys an
NFT, I'm gonna have to withdraw

23107
23:45:53,950 --> 23:45:56,290
it from the contract since the
contract is going to be the one

23108
23:45:56,290 --> 23:45:58,750
to actually hold those funds.
That looks pretty good to me.

23109
23:45:58,810 --> 23:46:01,570
Let's go ahead and start
building this. So let's create a

23110
23:46:01,570 --> 23:46:06,100
new folder, contracts. And let's
jump into this. So we'll create

23111
23:46:06,100 --> 23:46:08,620
a new file NFT marketplace.

23112
23:46:09,460 --> 23:46:18,520
That's all. So let's get our
boilerplate. spdx pragma,

23113
23:46:18,580 --> 23:46:23,950
solidity, carrot zero, point,
8.7, contract and ft.

23114
23:46:24,340 --> 23:46:29,560
Marketplace, boom. If we're
doing this, right, h h compile

23115
23:46:29,560 --> 23:46:33,760
or yarn Hardhead to compile or
MPX, art, hit, compile, boom,

23116
23:46:33,790 --> 23:46:37,300
things are looking good. So if
we go back to our readme, we can

23117
23:46:37,300 --> 23:46:42,310
grab these here, even stick them
in as like a little comment for

23118
23:46:42,310 --> 23:46:45,370
us to kind of reference later
on. Let's start with listing the

23119
23:46:45,370 --> 23:46:48,820
items. How are we going to keep
track of listing people's items.

23120
23:46:48,880 --> 23:46:51,580
And once again, remember, when
I'm usually coding this, I'm

23121
23:46:51,580 --> 23:46:54,130
going back and forth between
writing tests and writing the

23122
23:46:54,130 --> 23:46:57,160
actual code. We're just going to
write all the solidity in one

23123
23:46:57,190 --> 23:47:00,280
chunk, and then go write the
tests. So we're going to say,

23124
23:47:00,580 --> 23:47:04,720
these are going to be our main
functions. I'm going to start

23125
23:47:05,020 --> 23:47:09,190
with function list item. And we
are going to make this one look

23126
23:47:09,250 --> 23:47:12,190
really, really good. So we're
going to do natspec. And

23127
23:47:12,190 --> 23:47:15,010
everything, this is going to
need to be an external function,

23128
23:47:15,040 --> 23:47:18,070
right, we're probably not going
to want any of our internal

23129
23:47:18,100 --> 23:47:20,320
functions calling list item,
it's going to be called by

23130
23:47:20,320 --> 23:47:23,080
external projects or external
accounts are probably going to

23131
23:47:23,080 --> 23:47:26,800
need an address and ft address,
write the address of the NFT,

23132
23:47:26,800 --> 23:47:32,530
contract a un 256 token ID, the
ID of the token ID of the

23133
23:47:32,530 --> 23:47:34,720
contract that we're going to
use. And then we're going to

23134
23:47:34,720 --> 23:47:37,810
want to set a un 256 price. So
first off, we're probably going

23135
23:47:37,810 --> 23:47:41,260
to want the price to be greater
than zero. So maybe we'll put in

23136
23:47:41,290 --> 23:47:45,190
like a little if or require
statement here, we'll say if

23137
23:47:45,340 --> 23:47:50,290
price is less than or equal to
zero, then we'll go ahead and

23138
23:47:50,290 --> 23:47:57,280
revert with a price must be
above zero error. And then of

23139
23:47:57,280 --> 23:48:01,180
course, we'll prepend it with
the name of the contract into

23140
23:48:01,180 --> 23:48:06,310
underscores. And then at the
top, the error price must be

23141
23:48:06,310 --> 23:48:09,520
above zero. Now in order for us
to list it, we could actually do

23142
23:48:09,520 --> 23:48:13,180
this one of two ways we could
one, we could send the NFT to

23143
23:48:13,180 --> 23:48:16,330
the contract, this would require
us doing like a transfer, right,

23144
23:48:16,390 --> 23:48:21,850
we could have got the contract
hold the NFT. Now we could do

23145
23:48:21,850 --> 23:48:25,330
this, but this is going to be
kind of gas expensive for

23146
23:48:25,330 --> 23:48:29,140
someone to actually list on f t.
And we can have the owner of the

23147
23:48:29,140 --> 23:48:32,890
NFT be our NFT marketplace, we
could 100 percent do that. The issue

23148
23:48:32,890 --> 23:48:35,620
with this, though is that the
marketplace will then own the

23149
23:48:35,620 --> 23:48:38,350
NFT. And the user won't be able
to say like, Hey, I own this

23150
23:48:38,350 --> 23:48:40,990
NFT, it's in the marketplace,
they technically would be able

23151
23:48:40,990 --> 23:48:43,720
to but they would have to
withdraw it, we might do this a

23152
23:48:43,720 --> 23:48:47,680
slightly different way where we
can say owners can still hold

23153
23:48:47,680 --> 23:48:53,800
their NFT and give the
marketplace approval to sell the

23154
23:48:53,830 --> 23:48:57,220
NFT for them. Now, of course the
owners of the entity could

23155
23:48:57,220 --> 23:49:00,730
withdraw approval at any time
and the marketplace wouldn't be

23156
23:49:00,730 --> 23:49:03,010
able to sell it anymore.
However, this would be really

23157
23:49:03,010 --> 23:49:05,410
easy for people to actually
read, they would all they would

23158
23:49:05,410 --> 23:49:09,220
have to do is read like is
approved for marketplace. And

23159
23:49:09,220 --> 23:49:11,320
they can actually see if the
item was really listed or not.

23160
23:49:11,350 --> 23:49:14,560
So we're gonna go ahead and
write it this second way,

23161
23:49:14,860 --> 23:49:18,070
because that's what Ardian does.
And this is the least intrusive

23162
23:49:18,070 --> 23:49:21,460
way to have this marketplace,
right? People still will have

23163
23:49:21,460 --> 23:49:24,640
ownership of their NF Ts, and
the marketplace will just have

23164
23:49:24,640 --> 23:49:29,020
approval to actually swap and
sell their NF T once the prices

23165
23:49:29,020 --> 23:49:32,320
are met. So since we want to
make sure the marketplace has

23166
23:49:32,320 --> 23:49:36,070
approval, let's make sure the
marketplace has approval. So we

23167
23:49:36,070 --> 23:49:39,910
can call we can call this get
approved function on that token

23168
23:49:39,910 --> 23:49:44,560
ID to make sure that the
marketplace is approved to work

23169
23:49:44,560 --> 23:49:49,540
with the NFT. To do this, we're
going to need the AI ERC 720

23170
23:49:49,540 --> 23:49:52,840
interface and we can actually
grab that from open Zeppelin.

23171
23:49:53,170 --> 23:49:56,230
Right and this interface will
wrap around an address and then

23172
23:49:56,230 --> 23:50:01,810
we can call get approved on that
address. So we'll do import at

23173
23:50:01,810 --> 23:50:08,320
open Zeppelin slash contracts
slash token slash ERC 721 slash

23174
23:50:08,350 --> 23:50:13,330
I ERC 721 dot Sol. And since
we're doing an import from open

23175
23:50:13,330 --> 23:50:19,060
Zeppelin, we'll do yarn add dash
dash Dev, add open Zeppelin now

23176
23:50:19,060 --> 23:50:23,590
that we have this interface in
here, what we can do is we'll

23177
23:50:23,590 --> 23:50:33,550
say I ERC 721 NF t equals IRC
721 wrapped around this NF T

23178
23:50:33,550 --> 23:50:37,840
address that we're passing in.
And we'll say if NF T dot get

23179
23:50:37,840 --> 23:50:43,300
approved of the token ID that
we're trying to list does not

23180
23:50:43,300 --> 23:50:48,850
equal address this. So if we are
not approved, then we'll revert

23181
23:50:49,810 --> 23:50:56,380
not approved or market place.
And then we'll of course we'll

23182
23:50:56,380 --> 23:51:01,390
want to do prepend it with NFT
marketplace into underscores. So

23183
23:51:01,420 --> 23:51:06,910
error like this, Bada bing bada
boom, now that we've gotten a

23184
23:51:06,910 --> 23:51:09,730
little bit of that out of the
way, we're probably going to

23185
23:51:09,730 --> 23:51:12,790
want to have some type of data
structure to list all these NF

23186
23:51:12,790 --> 23:51:15,280
T's. And typically we get to
Okay, do we want to use an

23187
23:51:15,280 --> 23:51:17,740
array? Or do we want to use a
mapping? What do you think?

23188
23:51:17,830 --> 23:51:20,230
Before we continue? Let's pause
for a second, do you think it

23189
23:51:20,230 --> 23:51:23,140
makes more sense to put these NF
T's and an array or an A

23190
23:51:23,140 --> 23:51:25,540
mapping? And when you're
thinking about this, try to

23191
23:51:25,540 --> 23:51:28,270
think about, okay, well, people
are gonna have to buy these and

23192
23:51:28,270 --> 23:51:30,940
sell these, what makes more
sense, think about this for a

23193
23:51:30,940 --> 23:51:34,630
second, maybe pause it and write
in a comment here, what you

23194
23:51:34,630 --> 23:51:37,030
think an array or a mapping is
better. Now, if you said

23195
23:51:37,030 --> 23:51:40,690
mapping, I would agree with you.
You couldn't do an array and you

23196
23:51:40,690 --> 23:51:43,390
wouldn't necessarily be wrong,
but it's not the way that I

23197
23:51:43,390 --> 23:51:46,540
would go about that for an
array. Anytime someone wants to

23198
23:51:46,540 --> 23:51:49,150
buy an item, we're gonna have to
traverse through the array,

23199
23:51:49,390 --> 23:51:53,170
we're gonna have to make this
massive dynamic array. And that

23200
23:51:53,170 --> 23:51:56,230
might get a little bit dicey as
that array gets really, really

23201
23:51:56,230 --> 23:51:59,800
big. So we're gonna go ahead and
make this a mapping. And this is

23202
23:51:59,800 --> 23:52:03,190
probably going to be a global
variable or a state variable. So

23203
23:52:03,190 --> 23:52:05,890
up at the top, let's go ahead
and create this mapping, it's

23204
23:52:05,890 --> 23:52:08,980
going to be a mapping of
addresses of NFT addresses.

23205
23:52:09,400 --> 23:52:13,720
Right? So it's going to be the
NFT contract address mapped to

23206
23:52:13,720 --> 23:52:19,240
the NFT, token ID mapped to some
type of listing. So we'll say, a

23207
23:52:19,240 --> 23:52:26,290
mapping of address to a mapping
of UNT 256. to, well, what do we

23208
23:52:26,290 --> 23:52:28,810
want here? Well, we want we want
the price, right? So is that

23209
23:52:28,810 --> 23:52:32,560
another you went up to six. But
we also want, we also want to

23210
23:52:32,560 --> 23:52:36,190
keep track of the sellers, we
know who to send money to. So we

23211
23:52:36,190 --> 23:52:39,940
could make two mappings or we
just create a new type of type

23212
23:52:39,940 --> 23:52:42,730
listing, let's go ahead and do
that. We'll comment this out for

23213
23:52:42,730 --> 23:52:46,300
now. And so at the top, since
this is going to be a type

23214
23:52:46,780 --> 23:52:50,530
where, say, struct listing, and
in here, we're going to do a

23215
23:52:50,530 --> 23:52:55,690
utility six, the price of the NF
t, and then address the seller

23216
23:52:55,870 --> 23:52:58,810
of the NF team. And now that we
have that new typing, we can

23217
23:52:58,810 --> 23:53:03,070
uncomment this, we can say NFT,
contract address map to the NFT

23218
23:53:03,070 --> 23:53:07,360
token ID mapped to the listing,
and we'll make this a private

23219
23:53:08,080 --> 23:53:12,940
variable called S underscore
listings. Now back down in our

23220
23:53:12,970 --> 23:53:16,780
list item function, we're going
to update that s listing

23221
23:53:17,020 --> 23:53:21,220
mapping. So we're gonna say s
listing of NF T address, right,

23222
23:53:21,220 --> 23:53:25,900
the address of the NF T at the
token ID is going to equal we're

23223
23:53:25,900 --> 23:53:29,920
gonna create a listing of the
price. And then who, well the

23224
23:53:29,920 --> 23:53:32,860
seller is going to be message
that sender, right? So message

23225
23:53:32,860 --> 23:53:36,010
dot sender, they're the one
who's actually listing the item.

23226
23:53:36,100 --> 23:53:38,980
And since we're updating a
mapping here, what's the best

23227
23:53:38,980 --> 23:53:42,040
practice for update mappings,
you guessed it, we need to emit

23228
23:53:42,070 --> 23:53:46,150
an event and especially for this
project, you're gonna see why

23229
23:53:46,180 --> 23:53:49,900
emitting events, for at least
this project, this is so

23230
23:53:49,900 --> 23:53:53,500
helpful. So we're gonna go ahead
and emit an item listed event,

23231
23:53:53,530 --> 23:53:56,260
which we're going to create in
just a second. And we'll give

23232
23:53:56,260 --> 23:54:01,300
the message that sender, the NFT
address, the token ID, and the

23233
23:54:01,300 --> 23:54:06,460
price item listed. And then up
at the top, of course, but below

23234
23:54:06,460 --> 23:54:11,470
our structure, we're gonna say
event item listed will do an

23235
23:54:11,500 --> 23:54:14,680
address indexed seller

23236
23:54:15,879 --> 23:54:26,979
address indexed NFT, address,
address indexed token ID, and

23237
23:54:26,979 --> 23:54:31,599
then a un 256 price. Sorry, this
needs to be a un 256 token ID,

23238
23:54:31,899 --> 23:54:37,449
you int 56. This looks pretty
good to us. However, we probably

23239
23:54:37,449 --> 23:54:40,839
want to make sure we only list
and FTEs that haven't already

23240
23:54:40,839 --> 23:54:45,069
been listed. So we can add like
an if then in here. And this is

23241
23:54:45,069 --> 23:54:47,559
kind of where preference comes
in a little bit. But I'm

23242
23:54:47,559 --> 23:54:51,009
actually going to create a
modifier called not listed. So

23243
23:54:51,009 --> 23:54:54,459
we make sure we don't relist,
and if T's that are already

23244
23:54:54,459 --> 23:54:59,979
listed above our main functions,
or do like a little indicator

23245
23:55:00,009 --> 23:55:06,609
modifier not listed. This is
gonna take an an address NFT

23246
23:55:06,609 --> 23:55:13,119
address, a un 256 token ID and
an address owner. And what we're

23247
23:55:13,119 --> 23:55:16,389
going to say is we're going to
check, we're going to make a new

23248
23:55:16,389 --> 23:55:22,869
listing memory listing equals s
underscore listings of NFT

23249
23:55:22,869 --> 23:55:30,339
address token ID. Now we're
gonna say if listing dot price

23250
23:55:30,489 --> 23:55:33,609
is greater than zero, we're
gonna go ahead and revert with

23251
23:55:33,639 --> 23:55:40,239
already passing the NFT address
and a token ID. And of course,

23252
23:55:40,689 --> 23:55:46,419
we're going to prepend this with
NFT marketplace. And at the top,

23253
23:55:47,199 --> 23:55:52,959
we do error ft marketplace
already listed, like so. And

23254
23:55:52,959 --> 23:55:56,199
then we're going to put a little
underscore right underneath and

23255
23:55:56,199 --> 23:56:01,689
then up here, we'll do address
and if the address you went to

23256
23:56:01,689 --> 23:56:06,459
56. Okay, ID. So this modifier
looks pretty good. Let's just

23257
23:56:06,459 --> 23:56:09,219
make sure it's actually going to
compile we'll do yarn Hardhead

23258
23:56:09,219 --> 23:56:13,899
compile or hh compile. Great.
That looks good. We'll add this

23259
23:56:13,899 --> 23:56:18,549
modifier to our list item
function will do NFT address,

23260
23:56:18,879 --> 23:56:23,679
token ID message dot sender.
Cool. What else should we check

23261
23:56:23,679 --> 23:56:28,179
for here? Well, we should also
check that the NF T that's being

23262
23:56:28,209 --> 23:56:32,559
listed is owned by message dot
sender. This way only the owners

23263
23:56:32,559 --> 23:56:35,799
of the NF T can actually listed
here so let's go ahead and we'll

23264
23:56:35,799 --> 23:56:44,979
add a is owner modifier modifier
is owner NFT address token ID

23265
23:56:45,429 --> 23:56:55,479
spender you into 256 here and an
address spender I ERC 721 NF t

23266
23:56:55,509 --> 23:57:01,809
equals IRC 721 And if the
address address owner equals NF

23267
23:57:01,809 --> 23:57:08,169
T dot owner a Have a token ID.
And then we'll say if spender

23268
23:57:08,199 --> 23:57:13,629
does not equal owner. And we'll
revert with a not owner error

23269
23:57:13,659 --> 23:57:16,659
that we're going to go ahead and
create up top. So we'll say

23270
23:57:16,689 --> 23:57:22,689
error, not owner. And we'll
prepend it with NFT marketplace

23271
23:57:22,689 --> 23:57:27,249
with two underscores revert
revert not owner, then will do

23272
23:57:27,279 --> 23:57:31,179
underscore for the rest of the
code, and boom, now underneath

23273
23:57:31,179 --> 23:57:39,189
are not listed will do is owner
NFT address, token ID message

23274
23:57:39,189 --> 23:57:42,999
dot center. So now our list item
checks to see if it's already

23275
23:57:42,999 --> 23:57:48,009
listed, make sure that only the
owner of the NFT of that token,

23276
23:57:48,009 --> 23:57:51,399
Id can list it. And then it goes
ahead and lists it looking

23277
23:57:51,429 --> 23:57:55,719
nicely. Okay, cool. So that is
our list item method here. Now

23278
23:57:55,719 --> 23:57:57,609
let's go ahead and do a little
bit of natspec on

23279
23:57:57,610 --> 23:58:05,740
this. And now we have a little
natspec here, which looks really

23280
23:58:05,740 --> 23:58:08,830
professional. Alright, great. So
we have a list item function.

23281
23:58:09,100 --> 23:58:12,490
All right, what's next? Well,
maybe let's make a buy item

23282
23:58:12,520 --> 23:58:15,760
function for people to buy their
NF T's after they've been

23283
23:58:15,760 --> 23:58:21,580
listed. So let's create them do
function by item. So we'll take

23284
23:58:21,580 --> 23:58:28,660
an address, and if the address
un 256 token ID, and this will

23285
23:58:28,660 --> 23:58:32,920
be an external function. And
that will also make this payable

23286
23:58:33,220 --> 23:58:36,940
an external function because we
know only people or contracts

23287
23:58:36,940 --> 23:58:40,120
outside of this contract are
going to call by item and

23288
23:58:40,120 --> 23:58:44,260
payable so that people can spend
eath to spend eath, or whatever

23289
23:58:44,260 --> 23:58:47,350
layer one currency to actually
buy these prices, we could want

23290
23:58:47,350 --> 23:58:51,610
100 percent at channeling prices in now
for listing, we could of course,

23291
23:58:51,820 --> 23:58:57,550
add price and then do like, you
know address token price. And do

23292
23:58:57,550 --> 23:59:00,310
what we did before with chain
link price feeds to convert the

23293
23:59:00,310 --> 23:59:02,830
price of these tokens into how
much they actually cost. And we

23294
23:59:02,830 --> 23:59:05,680
could 100 percent do that with chaining
price feeds. But for simplicity,

23295
23:59:06,010 --> 23:59:08,620
we're gonna leave that off. But
I will put that as a challenge

23296
23:59:08,620 --> 23:59:12,760
to you through challenge is
going to be have this contract

23297
23:59:12,850 --> 23:59:17,800
accept payment in a subset of
tokens as well, of course, we

23298
23:59:17,800 --> 23:59:21,610
would need to give a little hint
here is channeling price feeds

23299
23:59:21,670 --> 23:59:26,650
to convert the price of the
tokens between each other, we're

23300
23:59:26,650 --> 23:59:30,370
gonna choose which NFT in which
token ID we want to buy. So

23301
23:59:30,370 --> 23:59:33,010
what's the first thing that we
probably want to do? Well, we

23302
23:59:33,010 --> 23:59:36,190
probably want to check that this
by item is actually listed. So

23303
23:59:36,190 --> 23:59:38,740
we're actually going to make a
new modifier instead of not

23304
23:59:38,740 --> 23:59:43,840
listed we'll make it is listed
up and modifiers modifier is

23305
23:59:43,840 --> 23:59:47,950
listed. And this is going to
take an address and up the

23306
23:59:47,950 --> 23:59:54,100
address un 256 token ID. And to
check to see if this is listed,

23307
23:59:54,160 --> 00:00:01,930
we'll say listing memory listing
equals s underscore listings of

23308
00:00:01,930 --> 00:00:07,810
the NFT address of the token, Id
sort of go into the mapping

23309
00:00:07,810 --> 00:00:11,590
here. And then we're just gonna
check the price. So we'll say if

23310
00:00:11,620 --> 00:00:15,610
the listing that price is less
than or equal to zero, so

23311
00:00:15,610 --> 00:00:19,450
basically, if there's no price,
if it's defaulted to zero, if

23312
00:00:19,450 --> 00:00:25,060
the price is zero, then we're
gonna say revert, not listed.

23313
00:00:26,260 --> 00:00:32,290
And after the address, token ID,
and of course, we're going to

23314
00:00:32,290 --> 00:00:36,100
prepend. And if the marketplace
and the marketplace underscore

23315
00:00:36,100 --> 00:00:40,120
underscore, not listed, and then
we're gonna copy this up here,

23316
00:00:40,120 --> 00:00:45,520
we're gonna say air listed, and
this is going to take address,

23317
00:00:45,520 --> 00:00:51,640
NFT address, and au int 256
token Id like so, the down in

23318
00:00:51,640 --> 00:00:53,920
our modifier, then we're going
to add the underscore and to add

23319
00:00:53,920 --> 00:00:56,770
the rest of our code here. So
now we have an is listed

23320
00:00:56,770 --> 00:01:00,100
modifier, we're going to check
to make sure that that NFT is

23321
00:01:00,100 --> 00:01:03,010
actually listed down here now
we're gonna say is listed

23322
00:01:03,460 --> 00:01:08,800
address and ft address or excuse
me, and if the address and token

23323
00:01:08,800 --> 00:01:16,000
ID. Now once again, we're gonna
say listing memory listed item

23324
00:01:16,060 --> 00:01:24,040
equals s underscore listings.
And if T address token ID, or

23325
00:01:24,040 --> 00:01:30,940
say if message dot value is less
than listed item dot price, then

23326
00:01:30,940 --> 00:01:36,100
we're going to revert with price
not met. Then we'll do NFT

23327
00:01:36,100 --> 00:01:43,360
address, Open ID listed item dot
price Excel so we're going to

23328
00:01:43,360 --> 00:01:47,470
create a new air price not met
error. Price not met of course

23329
00:01:47,470 --> 00:01:51,520
we're going to prepend this with
NFT marketplace to take an

23330
00:01:51,520 --> 00:01:58,870
address. And if the address you
went to 56 token ID and then a

23331
00:01:58,870 --> 00:02:05,020
UNT 256 price. So we can see exe
exactly how the price wasn't

23332
00:02:05,020 --> 00:02:09,730
met, and then back down here,
we'll get the full error. So we

23333
00:02:09,730 --> 00:02:12,460
want to make sure they're
sending us enough money. First

23334
00:02:12,460 --> 00:02:16,390
of all, when they send this
money, it needs to belong to

23335
00:02:16,390 --> 00:02:20,500
whomever listed the item. So we
actually need to keep track of

23336
00:02:20,530 --> 00:02:24,040
how much money these people
have. So let's create another

23337
00:02:24,040 --> 00:02:28,540
data structure called proceeds
where we keep track of how much

23338
00:02:28,540 --> 00:02:32,650
money people have earned selling
their NF T's. So we'll create a

23339
00:02:32,650 --> 00:02:40,090
mapping of address to you and
256. And this is going to be a

23340
00:02:40,090 --> 00:02:46,300
mapping of seller address to
amount earned. And we'll make

23341
00:02:46,300 --> 00:02:53,170
this private called S underscore
proceeds. And what we'll do is

23342
00:02:53,170 --> 00:02:57,280
when somebody buys an item, is
will update their proceeds.

23343
00:02:58,389 --> 00:03:06,459
So we'll say as proceeds of
listed item, that seller equals

23344
00:03:06,549 --> 00:03:13,689
s proceeds of illicit IO dot
seller plus MSG dot value. Now,

23345
00:03:13,689 --> 00:03:17,109
once we buy this item, we're
going to want to delete the

23346
00:03:17,109 --> 00:03:21,609
listing. So to delete a mapping
from a wreck, so to delete an

23347
00:03:21,609 --> 00:03:26,559
entry and a mapping, we just use
delete s underscore listings and

23348
00:03:26,559 --> 00:03:32,709
ft address of the token ID. So
we remove that mapping. And then

23349
00:03:32,709 --> 00:03:35,619
finally, we're going to go ahead
and transfer it. So we'll say I

23350
00:03:35,619 --> 00:03:41,049
ERC 721 and ft address, we're
going to call dot transfer from

23351
00:03:43,779 --> 00:03:49,299
the listed item dot seller to
the message dot sender with the

23352
00:03:49,299 --> 00:03:54,159
token ID. Now you'll notice
something here, we don't just

23353
00:03:54,159 --> 00:03:58,869
send the seller the money. Now
why is that? Well, solidity has

23354
00:03:58,869 --> 00:04:02,319
this concept called pull over
push. And it's considered a best

23355
00:04:02,319 --> 00:04:05,139
practice when working with
solidity, you want to shift the

23356
00:04:05,139 --> 00:04:08,529
risk associated with
transferring ether to the user.

23357
00:04:08,619 --> 00:04:12,279
So instead of sending the money
to the user, this is what we

23358
00:04:12,279 --> 00:04:16,269
don't want to do want to have
them withdraw the money, we

23359
00:04:16,269 --> 00:04:19,929
always want to shift the risk of
working with money and working

23360
00:04:19,929 --> 00:04:23,799
with eath or whatever layer one
you're working with, to the

23361
00:04:23,799 --> 00:04:27,459
actual user. So we don't want to
send them the money directly, we

23362
00:04:27,459 --> 00:04:31,779
want to create this s proceeds
data structure and we can have

23363
00:04:31,779 --> 00:04:34,719
them withdraw from it later on.
Now, we could probably do some

23364
00:04:34,719 --> 00:04:39,789
checking here. Or we could say
okay, check to make sure the NFT

23365
00:04:39,789 --> 00:04:45,969
was transferred. And if we look
at I ERC 721 though, and we're

23366
00:04:45,969 --> 00:04:49,299
looking at the transfer from
function, we don't see it

23367
00:04:49,299 --> 00:04:56,289
actually has a return. And if we
go to the IP 721 We can see that

23368
00:04:56,289 --> 00:04:59,469
none of these have a return type
though, transfer from doesn't

23369
00:04:59,469 --> 00:05:02,799
have a return type here.
However, we do see this safe

23370
00:05:02,799 --> 00:05:06,309
transfer from bit safe transfer
from it's going to be a little

23371
00:05:06,309 --> 00:05:09,279
bit better, right because if we
look at transfer from transfers

23372
00:05:09,309 --> 00:05:12,369
ownership of an entity, the
caller is responsible to confirm

23373
00:05:12,369 --> 00:05:16,329
that underscore two is capable
of receiving entities or else

23374
00:05:16,359 --> 00:05:19,689
they may be permanently lost. So
maybe instead we want to use

23375
00:05:19,689 --> 00:05:23,769
safe transfer from which throws
an error unless message sender

23376
00:05:23,769 --> 00:05:26,559
is the current owner and
authorize operator, or blah,

23377
00:05:26,559 --> 00:05:29,169
blah, blah. So instead of
transfer from we're going to

23378
00:05:29,169 --> 00:05:31,929
actually use safe transfer from
just to be a little bit safer.

23379
00:05:32,379 --> 00:05:37,419
So we'll do safe transfer from
instead of transfer from. And

23380
00:05:37,419 --> 00:05:39,789
then since we're updating a
mapping, we're going to do what,

23381
00:05:40,149 --> 00:05:45,699
you guessed it, let's omit an
event, we'll call item bot. Lab

23382
00:05:45,699 --> 00:05:50,979
will be a message that sender,
an empty address, token ID and

23383
00:05:50,979 --> 00:05:55,179
for listed item that price. So
off the top, let's create a new

23384
00:05:55,179 --> 00:06:05,319
event. To event item bought. And
this will be a an address

23385
00:06:05,949 --> 00:06:16,719
indexed fire an address indexed
NFT address an address indexed

23386
00:06:17,589 --> 00:06:22,329
token ID and then a un 236
price. Just kidding, that

23387
00:06:22,329 --> 00:06:25,209
doesn't look fantastic. This
should be intuitive six. Now it

23388
00:06:25,209 --> 00:06:32,259
looks fantastic. Now in this buy
item, we've set this up in a way

23389
00:06:32,409 --> 00:06:36,219
that is safe from something
called a reentrancy attack. And

23390
00:06:36,219 --> 00:06:38,829
we've been coding these
contracts in a way where we kind

23391
00:06:38,829 --> 00:06:42,579
of do all this state change
first. And then we transfer the

23392
00:06:42,579 --> 00:06:47,949
NFT that token or etc. But why
are we doing that? Cognitively

23393
00:06:47,979 --> 00:06:50,529
we think it might make sense.
Okay, first, maybe we should

23394
00:06:50,529 --> 00:06:54,459
actually send the NFT right,
we'd want to send the entity

23395
00:06:54,459 --> 00:06:54,939
first.

23396
00:06:57,040 --> 00:07:01,420
This is actually a huge security
vulnerability. And to understand

23397
00:07:01,420 --> 00:07:05,110
why let's learn about one The
most common hacks in blockchain,

23398
00:07:05,470 --> 00:07:08,260
the reentrant. See attack. Now
in this sub lesson, we're going

23399
00:07:08,260 --> 00:07:11,290
to talk about reentrant. C, and
in the GitHub repo associated

23400
00:07:11,290 --> 00:07:14,320
with this lesson, we're going to
have the code for everything

23401
00:07:14,320 --> 00:07:16,960
that we're going to go through
here. And the code that we're

23402
00:07:16,960 --> 00:07:21,130
looking at is based off of this
solidity by example. reentrant.

23403
00:07:21,130 --> 00:07:24,010
See example. And I have a link
to it in the GitHub repo

23404
00:07:24,040 --> 00:07:26,980
associated with this course.
Now, I have a sample contract

23405
00:07:26,980 --> 00:07:30,280
here, it's a place where you can
deposit and withdraw your eath.

23406
00:07:30,850 --> 00:07:34,660
So what it does is it has a
mapping called balances, where

23407
00:07:34,660 --> 00:07:39,280
you can call deposit, and it'll
update how much you've deposited

23408
00:07:39,280 --> 00:07:42,820
into the protocol. And then it
has a withdrawal function as

23409
00:07:42,820 --> 00:07:47,260
well. So what it does is it
first grabs your balance from

23410
00:07:47,260 --> 00:07:50,230
this balances mapping, make sure
that you have more than zero.

23411
00:07:50,650 --> 00:07:53,200
And then the way that we've been
sending eath, this whole time,

23412
00:07:53,470 --> 00:07:57,280
we do message that sender dot
call, we send the balance, and

23413
00:07:57,280 --> 00:08:01,300
then we update bounces of
message sender equals zero. Now

23414
00:08:01,300 --> 00:08:04,270
this is the line that actually
makes this contract incredibly

23415
00:08:04,300 --> 00:08:07,660
vulnerable. And if we run this
right now, though, we'll say

23416
00:08:07,660 --> 00:08:10,630
hey, no, it looks like it's
working as expected, we can go

23417
00:08:10,630 --> 00:08:16,960
to deploy a copy the accounts
that I'm working with, like that

23418
00:08:16,960 --> 00:08:23,470
in a bounce zero, we can
deposit, you know, it's going

23419
00:08:23,470 --> 00:08:28,150
away, let's go to ether, will
deposit to ether, come down,

23420
00:08:28,480 --> 00:08:33,370
what deposit now had to balance
bounces up, we'll hit withdraw,

23421
00:08:33,550 --> 00:08:36,580
now have bounces goes back to
zero. And it seems like it's

23422
00:08:36,580 --> 00:08:39,820
working as intended. Now,
there's actually a way we can

23423
00:08:39,820 --> 00:08:43,810
attack this function to drain
all the money in this contract.

23424
00:08:44,260 --> 00:08:48,220
And this is what's known as a
reentrancy attack. The two most

23425
00:08:48,220 --> 00:08:52,120
common kinds of attacks in this
space are going to be reentrancy

23426
00:08:52,120 --> 00:08:55,180
attacks, which is what we're
talking about here. And Oracle

23427
00:08:55,180 --> 00:08:58,840
attacks, which usually only
happen when a protocol doesn't

23428
00:08:58,840 --> 00:09:01,570
use the decentralized Oracle,
lucky for you, we're teaching

23429
00:09:01,570 --> 00:09:04,060
you right from the get go how to
use chain link so that you can

23430
00:09:04,060 --> 00:09:07,870
be protected. And it's these two
types of attacks that often

23431
00:09:07,900 --> 00:09:11,020
result in the most amount of
money last, there's a

23432
00:09:11,020 --> 00:09:14,440
leaderboard called rec dot news,
which keeps track of many of the

23433
00:09:14,440 --> 00:09:18,310
top attacks that have ever
happened in the defi space. With

23434
00:09:18,310 --> 00:09:21,490
many of them if you go into the
retrospectives are either an

23435
00:09:21,490 --> 00:09:25,600
Oracle attack or a reentrancy
attack. And you might be saying,

23436
00:09:25,600 --> 00:09:28,030
Hey, where are we just talking
about NF T's this, this doesn't

23437
00:09:28,030 --> 00:09:31,360
have anything to do with NF T's
we'll get there, don't worry. In

23438
00:09:31,360 --> 00:09:35,200
a new contract below, we're
going to create a new contract

23439
00:09:35,200 --> 00:09:38,950
called attack down here. And
what we'll do with this attack

23440
00:09:38,980 --> 00:09:42,100
contract is we'll grab this
reentrant vulnerable contract,

23441
00:09:42,580 --> 00:09:47,380
we'll say reentrant, vulnerable,
public reentrant vulnerable,

23442
00:09:47,740 --> 00:09:51,010
like so. And we'll save that
reentrant vulnerable contract as

23443
00:09:51,010 --> 00:09:55,960
a global variable. And we'll say
construct door address,

23444
00:09:56,110 --> 00:10:02,620
underscore ranch and vulnerable
address. And then we'll say

23445
00:10:02,620 --> 00:10:09,340
reentrant vulnerable equals
rancher and vulnerable at

23446
00:10:10,360 --> 00:10:14,440
reentrant vulnerable address.
Now what we're going to do is

23447
00:10:14,440 --> 00:10:18,280
we're going to create a function
called attack. And it's this

23448
00:10:18,280 --> 00:10:24,070
function that's going to call
withdraw in a malicious way. So

23449
00:10:24,070 --> 00:10:26,440
we're going to say attack, this
is going to be an external

23450
00:10:26,440 --> 00:10:30,130
payable contract. And we're
going to call the posit on this.

23451
00:10:30,130 --> 00:10:33,340
So we'll deposit some money
first. So we'll do reentrant

23452
00:10:33,340 --> 00:10:36,250
vulnerable dot the posit

23453
00:10:37,510 --> 00:10:42,130
will send a value of one ether.
And then immediately we will

23454
00:10:42,130 --> 00:10:49,060
call re N Trent vulnerable dot
withdraw. Now at first glance,

23455
00:10:49,060 --> 00:10:50,320
this seems pretty harmless.

23456
00:10:51,040 --> 00:10:57,490
But remember, when we call
message dot call like this to

23457
00:10:57,490 --> 00:11:01,870
send we're calling back to this
this attack contract. Now when

23458
00:11:01,870 --> 00:11:05,440
we call this attack contract, is
there a way to execute any other

23459
00:11:05,440 --> 00:11:10,060
code? Well, there is remember
how we learned about fallback

23460
00:11:10,060 --> 00:11:15,070
functions. If we put a fallback
function in here or a receive

23461
00:11:15,070 --> 00:11:20,890
function. When this code runs
call and seconds our contract

23462
00:11:20,920 --> 00:11:25,870
ether we can have it trigger our
fallback function to call

23463
00:11:25,870 --> 00:11:30,820
withdraw again. So that will
send our contract more ether

23464
00:11:30,820 --> 00:11:34,420
than it's do before we update
the balance. So let's see what

23465
00:11:34,420 --> 00:11:39,520
this looks like. So in our
fallback here, we'll say if the

23466
00:11:39,550 --> 00:11:46,960
address of reentrant vulnerable
balance is greater than or equal

23467
00:11:46,960 --> 00:11:50,620
to one ether aka we're saying if
there's money left in the

23468
00:11:50,620 --> 00:11:57,340
contract, then rancher
invulnerable dot withdraw. And

23469
00:11:57,340 --> 00:12:02,380
then we'll put to get balanced
function in our attacking

23470
00:12:02,380 --> 00:12:06,100
contract. We're going to attack
reentrant vulnerable by calling

23471
00:12:06,100 --> 00:12:10,150
withdraw. When we get to this
send section, what are we going

23472
00:12:10,150 --> 00:12:13,660
to do, we're going to have our
fallback function trigger

23473
00:12:13,690 --> 00:12:18,910
calling withdraw again. Now when
we call withdraw again, bounces

23474
00:12:18,910 --> 00:12:22,870
a message that sender hasn't
been zeroed out yet. So the

23475
00:12:22,870 --> 00:12:25,900
contract code will go, oh, you
still have some money here.

23476
00:12:26,020 --> 00:12:29,890
Let's go ahead and let's send
you that, which will then again,

23477
00:12:30,220 --> 00:12:32,950
trigger us to call withdraw. And
so we'll just keep calling

23478
00:12:32,950 --> 00:12:36,340
withdraw until we're done. So
let's see what this looks like.

23479
00:12:36,370 --> 00:12:40,150
So we compile this, and then
let's go to deploy, first, let's

23480
00:12:40,150 --> 00:12:45,610
deploy the reentrant vulnerable
contract. Alright, and we can

23481
00:12:45,610 --> 00:12:48,220
have any contract address, you
know, like the one that deployed

23482
00:12:48,220 --> 00:12:53,440
it, we can have a deposit, let's
do, we have a deposit one ether

23483
00:12:54,070 --> 00:12:59,740
deposit. Now we can check the
balances of it. Copy. Paste

23484
00:12:59,830 --> 00:13:07,300
great, is one. So now let's have
a do 10. Deposit, it took the

23485
00:13:07,300 --> 00:13:10,840
balance. And now we have this
much in here. So we have this

23486
00:13:10,840 --> 00:13:13,660
much in here. And if we
withdrew, we withdraw all of it.

23487
00:13:13,840 --> 00:13:18,550
And if we switched accounts, to
somebody else, we hit withdrew.

23488
00:13:19,990 --> 00:13:21,940
Nothing would happen because
that other account doesn't have

23489
00:13:21,940 --> 00:13:25,810
anything, which makes sense. So
there's a lot of money in here,

23490
00:13:25,810 --> 00:13:29,710
right. And if we do get balanced
with the contract, we can see

23491
00:13:29,740 --> 00:13:33,220
how much money it has, right? It
has this much money total. Now

23492
00:13:33,220 --> 00:13:36,850
what we can do on a different
account, let's choose this, this

23493
00:13:36,850 --> 00:13:40,810
brand new account, let's go
ahead and deploy the attack

23494
00:13:40,840 --> 00:13:44,980
contract. And we'll pass it the
reentrant value address as an

23495
00:13:44,980 --> 00:13:50,200
input parameter. So we'll deploy
that. And now what we'll do is

23496
00:13:50,200 --> 00:13:54,520
we'll call attack. And you'll
see even though this contract

23497
00:13:54,520 --> 00:13:58,330
doesn't have anything deposited
in the reentrant vulnerable

23498
00:13:58,330 --> 00:14:02,140
contract, we will still steal
all the funds in here or just

23499
00:14:02,140 --> 00:14:06,130
about all the funds. So right
now hit get balance, and a

23500
00:14:06,130 --> 00:14:09,340
reentrant vulnerable, here's
what it is, get balance a here

23501
00:14:09,340 --> 00:14:13,840
zero, you know, there's the
address, we had attack now, now

23502
00:14:13,840 --> 00:14:17,560
that get bounce, oh, excuse me
in public, and withdrawal should

23503
00:14:17,560 --> 00:14:22,510
be payable as well. Now we'll
pass one ether as an input

23504
00:14:22,510 --> 00:14:24,430
parameter to our attack
function, and we're going to

23505
00:14:24,430 --> 00:14:27,580
deposit just one ether. And then
we're going to withdraw. And

23506
00:14:27,580 --> 00:14:30,880
we're going to keep withdrawing,
because our fallback function is

23507
00:14:30,880 --> 00:14:34,750
going to keep calling withdraw.
And all we had to do was deposit

23508
00:14:34,750 --> 00:14:38,170
one ether, and we're gonna be
able to pull out all 11 that are

23509
00:14:38,170 --> 00:14:38,560
in here.

23510
00:14:39,550 --> 00:14:44,770
So we'll hit attack now.
Transaction went through, the

23511
00:14:44,770 --> 00:14:48,520
new balance of our contract is
12, because the one that we

23512
00:14:48,520 --> 00:14:52,450
deposited and then the 11 that
we stole, and the new balance of

23513
00:14:52,450 --> 00:14:55,840
our old contract is now zero. So
this is known as a reentrant.

23514
00:14:55,840 --> 00:14:59,620
See attack. Basically, since we
call a function in another

23515
00:14:59,620 --> 00:15:03,490
contract in the middle of our
withdraw, we allow code to run

23516
00:15:03,520 --> 00:15:06,970
on a different contract. And the
code that ran runs on this

23517
00:15:06,970 --> 00:15:11,680
contract, recalls withdraw
before balances is set to zero,

23518
00:15:11,980 --> 00:15:14,740
we get to here we call the
fallback function of our other

23519
00:15:14,740 --> 00:15:18,460
code, and it calls withdraw, and
we need to reread withdraw

23520
00:15:18,460 --> 00:15:21,040
before we get to setting
balances a message that sender

23521
00:15:21,040 --> 00:15:24,580
equals zero. So this is an
issue, obviously. And there are

23522
00:15:24,580 --> 00:15:27,940
two ways we can prevent it.
There's the easy way. And then

23523
00:15:27,940 --> 00:15:30,370
the mutex way, I don't wanna say
the hard way, it's just a

23524
00:15:30,370 --> 00:15:33,070
different way. So one of the
things you'll always see in

23525
00:15:33,070 --> 00:15:36,760
security tools is you always
want to call any external

23526
00:15:36,760 --> 00:15:40,690
contract as the last step in
your function, or the last step

23527
00:15:40,690 --> 00:15:44,830
in transaction. And we want to
update bounces to zero before we

23528
00:15:44,830 --> 00:15:48,880
call that external contract,
because of balances of message

23529
00:15:48,910 --> 00:15:53,320
sender is reset to zero before
we call external code, then if

23530
00:15:53,320 --> 00:15:56,470
it were to try to re enter this,
it would hit this require step

23531
00:15:56,530 --> 00:15:59,350
and just cancel out right here
and wouldn't be able to send any

23532
00:15:59,350 --> 00:16:03,310
ether again. So that's the first
step that we can do. The next

23533
00:16:03,310 --> 00:16:06,250
step that we can do is using
something called a mutex lock.

23534
00:16:06,610 --> 00:16:09,940
And this is what open Zeppelin
does with one of the modifiers

23535
00:16:09,940 --> 00:16:16,420
that they have, we can have some
type of a Boolean called locked

23536
00:16:16,420 --> 00:16:20,050
or something and just right at
the top, we can just say require

23537
00:16:21,250 --> 00:16:27,070
not locked. Otherwise, revert.
And then the first thing we do

23538
00:16:27,070 --> 00:16:31,540
in this contract is we can say
locked equals true. And then the

23539
00:16:31,540 --> 00:16:34,870
last thing we do in here is we
say locked equals false. And

23540
00:16:34,870 --> 00:16:40,000
using this lock in here, we only
allow one piece of code to ever

23541
00:16:40,330 --> 00:16:44,350
execute in here at a time and we
only unlock it once the code

23542
00:16:44,350 --> 00:16:48,580
finishes. Now open Zeplin comes
with a reentrancy guard which we

23543
00:16:48,580 --> 00:16:53,620
can use on our code. And it has
a modifier non reentrant which

23544
00:16:53,620 --> 00:16:56,530
does essentially what we were
talking about with our locks it

23545
00:16:56,530 --> 00:17:01,000
creates a variable called status
and changes it to enter whenever

23546
00:17:01,000 --> 00:17:05,110
a function has been entered. It
runs out code, and then changes

23547
00:17:05,110 --> 00:17:08,320
it back to not entered when it's
finishes. And whenever any code

23548
00:17:08,320 --> 00:17:11,680
runs, it just requires that it
is not entered. So if we wanted

23549
00:17:11,680 --> 00:17:19,600
to use this on our code, we can
import at open Zeppelin, slash,

23550
00:17:20,230 --> 00:17:30,700
contracts, slash security, slash
reentrancy. Guard about so we

23551
00:17:30,700 --> 00:17:34,630
can inherit the functions by
saying NFT marketplace is

23552
00:17:34,630 --> 00:17:38,950
reentrancy guard. And then any
function that we're nervous is

23553
00:17:38,950 --> 00:17:43,030
going to have this reentrant see
issue, like maybe by item, for

23554
00:17:43,030 --> 00:17:48,880
example, we would just add the
modifier non reentrant. Just

23555
00:17:48,880 --> 00:17:51,760
like that. And that'll add that
mutex, that locking mechanism

23556
00:17:51,760 --> 00:17:54,130
that we talked about. Now, the
mutex way is a little bit more

23557
00:17:54,130 --> 00:17:56,890
explicit with our security,
right? Because we're saying,

23558
00:17:56,890 --> 00:18:00,610
Hey, this is locked. This is a
non reentrant function. Still a

23559
00:18:00,610 --> 00:18:04,090
best practice, whenever you call
external code, like what we see

23560
00:18:04,090 --> 00:18:08,260
here is you do all of your state
changes before you call an

23561
00:18:08,260 --> 00:18:10,510
external contract. Now, you
might be saying, Oh, that's cool

23562
00:18:10,510 --> 00:18:13,210
at all. But what about how does
this relate to our NF Ts? Well,

23563
00:18:13,210 --> 00:18:16,300
imagine for a second, instead of
message that sender dot call,

23564
00:18:16,450 --> 00:18:21,610
this is, you know, all success
equals, you know, some NF T dot

23565
00:18:21,610 --> 00:18:24,670
transfer from, and then we do
some transfers from stuff in

23566
00:18:24,670 --> 00:18:30,970
here. And instead of doing some
fallback stuff, our NF T has our

23567
00:18:30,970 --> 00:18:35,740
NF T's function transfer from
the similis code to re enter

23568
00:18:35,740 --> 00:18:38,860
into our withdraw. If we have
our withdrawal set up like this,

23569
00:18:38,950 --> 00:18:41,860
since we're still calling an
external contract with NFT. To

23570
00:18:41,860 --> 00:18:45,400
transfer from that transfer from
in that external contract could

23571
00:18:45,400 --> 00:18:48,610
be malicious and try to re enter
our contract. As a best

23572
00:18:48,610 --> 00:18:52,900
practice, you always want to
change your state, before you

23573
00:18:52,900 --> 00:18:57,040
call any external contracts that
you might not have control of, I

23574
00:18:57,040 --> 00:18:59,620
highly recommend playing around
with this a little bit just

23575
00:18:59,650 --> 00:19:02,980
because seeing is believing. And
with that being said, again, all

23576
00:19:02,980 --> 00:19:06,100
the code for this is going to be
available in the GitHub sociated

23577
00:19:06,100 --> 00:19:09,700
with this lesson for this
reentrant vulnerable code. And

23578
00:19:09,700 --> 00:19:12,070
with that, let's go back to our
NFT project.

23579
00:19:15,100 --> 00:19:20,080
Okay, so now we know why we're
doing this safe transfer from at

23580
00:19:20,080 --> 00:19:23,530
the bottom of our function here
at the bottom of our bio,

23581
00:19:23,590 --> 00:19:27,370
because if our safe transfer
function from was a little bit

23582
00:19:27,370 --> 00:19:31,990
higher, maybe what ends up
happening is we send multiple NF

23583
00:19:31,990 --> 00:19:35,260
T's to the wrong address before
we update them. So that's why we

23584
00:19:35,260 --> 00:19:38,650
do that. And we favor push over
Paul. As we said, Here, there's

23585
00:19:38,650 --> 00:19:41,560
a whole lot of these security
tips that you'll learn going on

23586
00:19:41,590 --> 00:19:44,770
through this course and in
solidity. But this is still

23587
00:19:44,800 --> 00:19:48,850
fantastic, right, we have our by
item. And we have our list item

23588
00:19:48,850 --> 00:19:52,810
functions. Let's do a cancel
item now, or cancelled listing.

23589
00:19:53,140 --> 00:19:54,520
So we'll do a function.

23590
00:19:57,130 --> 00:20:04,480
Cancel listing we'll do the NFT
address. And the UN 256 token

23591
00:20:04,480 --> 00:20:11,200
ID. This will be an external
function. One will want to make

23592
00:20:11,200 --> 00:20:14,230
sure only the owner of this
entity can cancel it. So we'll

23593
00:20:14,230 --> 00:20:15,430
say is owner.

23594
00:20:17,170 --> 00:20:24,850
And if T address, token ID
message dot Sen. Want to make

23595
00:20:24,850 --> 00:20:29,050
sure that the NFT is actually
listed. So we'll do is listed

23596
00:20:29,680 --> 00:20:36,310
and ft address, token ID. And
great. Now to cancel this, all

23597
00:20:36,310 --> 00:20:41,950
we're going to do is we're going
to delete s listings NFT address

23598
00:20:43,150 --> 00:20:46,930
token ID, we're just going to
delete that mapping. And then

23599
00:20:46,930 --> 00:20:53,350
we'll emit an event item
cancelled message dot sender and

23600
00:20:53,350 --> 00:20:59,410
if T address and token ID. And
of course, we're going to create

23601
00:20:59,410 --> 00:21:05,650
a new event here. We'll say
event item canceled. And it will

23602
00:21:05,650 --> 00:21:15,400
be an address indexed seller
address. Index NFT address. You

23603
00:21:15,400 --> 00:21:19,900
want to 56 indexed token ID. All
right. Great. That was pretty

23604
00:21:19,900 --> 00:21:24,790
quick. Cancel listening. Boom.
Jack. Done. What's next? Okay,

23605
00:21:24,790 --> 00:21:29,440
let's update our listings. So
we'll do function update listing

23606
00:21:30,910 --> 00:21:36,850
address and if the address you
went to for the sixth token ID

23607
00:21:37,510 --> 00:21:42,430
you went to the six new price
will update the price of this of

23608
00:21:42,430 --> 00:21:45,940
this external we'll make sure
it's listed with is listed

23609
00:21:51,070 --> 00:21:59,920
say is owner do a token ID and
then we'll do message dot

23610
00:21:59,920 --> 00:22:04,690
sender. Now to update our
listing We'll just say s

23611
00:22:04,690 --> 00:22:11,710
underscore listings of NF T
address. At token ID dot price

23612
00:22:12,640 --> 00:22:16,870
equals the new price that we're
giving it. And then we'll admit,

23613
00:22:16,900 --> 00:22:20,500
we can omit like item updated.
But we can also just omit an

23614
00:22:20,500 --> 00:22:27,310
item listed with MSG dot sender
NFT address, token ID, new

23615
00:22:27,310 --> 00:22:31,120
price. Because essentially, by
updating it, we're essentially

23616
00:22:31,120 --> 00:22:34,390
just relisting it with a new
price. So we're just going to do

23617
00:22:34,630 --> 00:22:38,200
an item listed event, we only
have one more function to do, we

23618
00:22:38,200 --> 00:22:43,510
need to do a withdraw proceeds.
So we'll say function, withdraw

23619
00:22:43,720 --> 00:22:49,000
proceeds to get all the payments
for all of our entities. So

23620
00:22:49,030 --> 00:22:52,450
we'll get the the proceeds by
doing new activity six proceeds

23621
00:22:52,630 --> 00:22:57,460
equals s underscore proceeds of
MSG dot sender, right, we're

23622
00:22:57,460 --> 00:23:01,150
getting all the payments that
were collected in by item, and

23623
00:23:01,150 --> 00:23:07,060
we're saying if proceeds is less
than or equal to zero, then

23624
00:23:07,060 --> 00:23:12,760
we're going to revert with no
proceeds. And we're going to

23625
00:23:12,940 --> 00:23:16,420
make this a NFT. Marketplace
underscore underscore no

23626
00:23:16,420 --> 00:23:23,710
proceeds. Excel create at the
top error empty marketplace no

23627
00:23:23,710 --> 00:23:30,970
proceeds being otherwise, we'll
say s underscore proceeds of MSG

23628
00:23:30,970 --> 00:23:35,290
dot sender equals zero. So we're
going to reset the proceeds to

23629
00:23:35,290 --> 00:23:37,600
zero, right, we're going to do
this before we send any

23630
00:23:37,600 --> 00:23:40,420
proceeds. And then we're going
to do our traditional way we

23631
00:23:40,420 --> 00:23:42,430
send payments, so bool success

23632
00:23:43,960 --> 00:23:54,250
equals payable, message dot
sender call value is going to be

23633
00:23:54,250 --> 00:24:01,450
proceeds all blank here. And
then we could do require, you

23634
00:24:01,450 --> 00:24:03,940
know, we could do require
success, or we could say

23635
00:24:05,259 --> 00:24:14,259
if not success, reverts revert
with Aleksey marketplace,

23636
00:24:15,759 --> 00:24:19,569
transfer failed. And then we'll
make this a new air, air NFT

23637
00:24:19,569 --> 00:24:24,729
marketplace transfer failed. Put
a semicolon here. And we're

23638
00:24:24,729 --> 00:24:29,499
looking pretty good. Now we even
have a way to withdraw. So we

23639
00:24:29,499 --> 00:24:33,009
have our five functions here.
Awesome. Let's just create a

23640
00:24:33,009 --> 00:24:37,089
couple of getters. So maybe
we'll do we even copy this.

23641
00:24:38,829 --> 00:24:43,389
Paste it here we'll say getter
functions like so. And we'll do

23642
00:24:43,389 --> 00:24:47,709
function maybe we'll do get
listing. Take an address, NF T

23643
00:24:47,709 --> 00:24:55,569
address, the utilities X token
ID, external view, which returns

23644
00:24:56,259 --> 00:25:02,619
a listing in memory. And we'll
say return s underscore listings

23645
00:25:02,649 --> 00:25:12,699
of NF T address token Id like
so. And also function, get

23646
00:25:12,699 --> 00:25:19,599
proceeds of address seller,
external view returns, you went

23647
00:25:19,599 --> 00:25:26,019
to the desex return s underscore
proceeds of the seller. So we'll

23648
00:25:26,019 --> 00:25:30,399
get how much money somebody is
owed. And then any listings and

23649
00:25:30,399 --> 00:25:34,389
let's run a little compile here,
yarn, or hit Compile or hh

23650
00:25:34,389 --> 00:25:37,779
compile just to see where we
messed up. Oh, we did a mess up.

23651
00:25:37,809 --> 00:25:42,879
Wow, that's great. And now,
guess what? You have

23652
00:25:42,879 --> 00:25:47,409
successfully created a
minimalistic NFT marketplace

23653
00:25:47,409 --> 00:25:52,839
that's completely decentralized.
That is pretty wild. And that is

23654
00:25:52,839 --> 00:25:55,869
incredibly powerful. And you
should feel really excited for

23655
00:25:55,869 --> 00:25:59,199
yourself. Very cool, very good
job. But you know, we're not

23656
00:25:59,199 --> 00:26:02,349
done, we got to write some
deploys and some tests. So let's

23657
00:26:02,349 --> 00:26:05,919
jump into that. Now since we've
done this a couple of times, I

23658
00:26:05,919 --> 00:26:08,829
actually encourage you to pause
the video here and try writing

23659
00:26:08,829 --> 00:26:12,909
your own deploy scripts and your
own tests. And then go ahead and

23660
00:26:12,909 --> 00:26:15,579
come back and follow along with
us and see if you did it

23661
00:26:15,579 --> 00:26:21,999
correctly, we're going to create
a new folder called deploy. Of

23662
00:26:21,999 --> 00:26:26,259
course, we already have the hard
hat deploy in our hard hat

23663
00:26:26,259 --> 00:26:29,049
config. So we know we're good to
go here. So let's go ahead and

23664
00:26:29,049 --> 00:26:35,799
create a one. Deploy NFT
marketplace.js. Now once again,

23665
00:26:35,799 --> 00:26:38,439
you've seen a lot of this
before, so we're going to spare

23666
00:26:38,439 --> 00:26:49,299
the details do const network
equals require hard hat to

23667
00:26:49,299 --> 00:26:55,269
constant development chains,
equal equals require dot dot

23668
00:26:55,269 --> 00:27:00,249
slash help our hard hats config,
which we should have let's see.

23669
00:27:00,249 --> 00:27:02,859
Do we copy paste it over? No.
Okay, so we didn't copy paste

23670
00:27:02,859 --> 00:27:05,919
over Are helper Hardhead config
from the last project, let's go

23671
00:27:05,919 --> 00:27:08,049
ahead and grab it. Or we can
grab it from the smart contract

23672
00:27:08,049 --> 00:27:11,979
lottery and paste that in here.
And we really only need this

23673
00:27:12,009 --> 00:27:16,269
file for the development chains
here. Right for hard hat and

23674
00:27:16,269 --> 00:27:18,579
localhost, we're going to grab
the development chains from

23675
00:27:18,579 --> 00:27:24,129
that. And then we'll also grab
const. Verify, equals require,

23676
00:27:25,269 --> 00:27:29,649
get this from utils. Verify,
right? Do we have utils, we have

23677
00:27:29,649 --> 00:27:34,479
verify. Fantastic. Now we'll do
module that exports equals

23678
00:27:35,439 --> 00:27:41,589
async. an async function where
it's gonna take get named

23679
00:27:41,589 --> 00:27:49,149
accounts and deployments. From
the hard hat input parameter,

23680
00:27:49,269 --> 00:27:53,289
and then we're gonna do const.
Deploy comma log equals

23681
00:27:53,289 --> 00:28:00,609
deployments. And then const,
Deployer equals await, get named

23682
00:28:00,609 --> 00:28:04,599
accounts. Which, of course,
we're getting from our heart

23683
00:28:04,599 --> 00:28:08,529
head dot config. We have named
accounts, we have a Deployer.

23684
00:28:08,529 --> 00:28:11,019
And we have a player or whatever
you have in here from our last

23685
00:28:11,019 --> 00:28:14,529
project. And now does our entity
marketplace have a constructor?

23686
00:28:14,799 --> 00:28:18,249
Construct? Nope, no constructor.
So we know args is going to be

23687
00:28:18,309 --> 00:28:25,539
blank. And then we can say const
NFT. Marketplace equals await,

23688
00:28:25,779 --> 00:28:34,329
deploy. And if T marketplace,
say from Deployer, args is going

23689
00:28:34,329 --> 00:28:42,309
to be args. Log will be true.
And then wait confirmations will

23690
00:28:42,309 --> 00:28:50,049
be network dot config dot wait
confirmations or one, two, this

23691
00:28:50,049 --> 00:28:53,979
is going to be block on for
patients, we'll go to the

23692
00:28:53,979 --> 00:28:57,339
config, just make sure that
those are in here. I'm sorry, I

23693
00:28:57,339 --> 00:29:01,419
didn't add them in here. So
we'll do block confirmations is

23694
00:29:01,419 --> 00:29:02,559
going to be six

23695
00:29:03,880 --> 00:29:10,330
for all of our networks. So I
actually grabbed this not from

23696
00:29:10,330 --> 00:29:13,330
the last project, it looks like
I grabbed this from the hard hat

23697
00:29:13,330 --> 00:29:15,760
starter kit. So I'm just going
to add those block confirmations

23698
00:29:15,760 --> 00:29:18,700
in there. And now we're good to
go. Now we're gonna say if we're

23699
00:29:18,700 --> 00:29:23,020
not on a development chain, not
development chains that includes

23700
00:29:23,590 --> 00:29:31,270
network dot name, and process
study and be done ether scan API

23701
00:29:32,320 --> 00:29:39,160
key, then we're gonna go ahead,
we'll do log verifying. And then

23702
00:29:39,160 --> 00:29:45,040
we'll do a weight verify. And if
the markets place dot address

23703
00:29:45,310 --> 00:29:50,470
with arcs, and then we'll do
like log a whole bunch of

23704
00:29:50,470 --> 00:29:56,530
hyphens here. And then finally,
module that exports dot tags

23705
00:29:56,740 --> 00:30:04,630
equals all and then NFT Mar good
place. And we can test this

23706
00:30:04,630 --> 00:30:09,970
deploy function with yarn
Hardhead deploy. Tada, we did

23707
00:30:09,970 --> 00:30:12,910
it. Great. So now we have the
deploy function, we can verify

23708
00:30:12,910 --> 00:30:15,340
we have our contract, what else
are we probably gonna need to

23709
00:30:15,340 --> 00:30:18,700
do. Since this is an NFT
marketplace, we're probably

23710
00:30:18,700 --> 00:30:22,150
going to need some NF Ts. So
what we can do is in our

23711
00:30:22,150 --> 00:30:26,560
contracts, and we'll create a
new folder for tests got a new

23712
00:30:26,560 --> 00:30:32,020
file in here called Basic NF T
dot soul. And in here, we can

23713
00:30:32,050 --> 00:30:36,880
add that basic NF T from our
last project. Or you can just go

23714
00:30:36,880 --> 00:30:40,000
to my or you can just go to the
GitHub repo associated with this

23715
00:30:40,000 --> 00:30:44,650
course, go to contracts, test,
basic NF t, and then just copy

23716
00:30:44,650 --> 00:30:50,740
paste. That works too. So this
basic NF t that we're using is

23717
00:30:50,740 --> 00:30:55,870
just pointing to the pug as the
basic NF T for us to use just to

23718
00:30:55,870 --> 00:30:59,860
test this out. So now that we
have a basic NFT we're gonna

23719
00:30:59,860 --> 00:31:05,770
need to create new file, oh to
deploy basic NF T dot j s, and

23720
00:31:05,770 --> 00:31:08,830
we'll borrow a lot of the
boilerplate from over here. So

23721
00:31:08,830 --> 00:31:14,290
we'll copy all of this actually
paste it in. We'll say const

23722
00:31:14,320 --> 00:31:20,380
args equals blank, and we'll say
const basic NF t equals await

23723
00:31:20,440 --> 00:31:30,400
deploy basic NF T. From
Deployer. args is going to be

23724
00:31:30,400 --> 00:31:36,340
args. Log is going to be true
weight con confirmations is

23725
00:31:36,340 --> 00:31:43,600
going to be network dot config
dot block confirmations or one

23726
00:31:44,800 --> 00:31:50,140
and then we'll verify this with
if not develop meant chains dot

23727
00:31:50,140 --> 00:31:58,450
includes network dot name and
process dot EMV that ether scan

23728
00:31:59,560 --> 00:32:07,000
API key that will say log or To
find dot A dot await there if I

23729
00:32:07,570 --> 00:32:13,990
basic NFT dot address, and arcs,
module dot exports dot tags

23730
00:32:14,020 --> 00:32:19,900
equals all, and basic NFT. And
we can test both of these with

23731
00:32:19,900 --> 00:32:25,390
yarn, art had deploy. And
fantastic. Both of these have

23732
00:32:25,390 --> 00:32:28,930
been deployed. Again, you don't
have to pause. But it is a good

23733
00:32:28,930 --> 00:32:32,890
way to really hone in to really
sharpen those skills on doing

23734
00:32:32,890 --> 00:32:36,670
all this. And repetition is the
mother of all skill. So

23735
00:32:36,670 --> 00:32:39,220
repeating this stuff yourself
and thinking through these

23736
00:32:39,220 --> 00:32:42,220
problems yourself and trying to
code these things yourself, are

23737
00:32:42,220 --> 00:32:47,740
really what's going to make you
successful at this. All right,

23738
00:32:47,740 --> 00:32:51,100
awesome. Now that we have our
deploy Betson, it's time to

23739
00:32:51,100 --> 00:32:54,400
write some tests. Now, if you go
to the GitHub repo associated

23740
00:32:54,400 --> 00:32:57,250
with this course, and you go to
the test folder, the tests and

23741
00:32:57,250 --> 00:33:00,190
here are some of the robust,
we've actually written out of

23742
00:33:00,190 --> 00:33:03,490
all of our projects, there's a
lot of tests in here. Now,

23743
00:33:03,490 --> 00:33:06,160
pretty much everything in here,
we've already learned about and

23744
00:33:06,160 --> 00:33:09,430
you already know how to do you
have the ability to do it. So

23745
00:33:09,430 --> 00:33:11,740
I'm just going to go ahead and
get you started off, and we're

23746
00:33:11,740 --> 00:33:14,260
going to write one test
together. And then I highly

23747
00:33:14,260 --> 00:33:17,080
recommend you going back in, you
tried to write some tests

23748
00:33:17,080 --> 00:33:20,050
yourself, to get that code
coverage to get that test

23749
00:33:20,050 --> 00:33:24,340
coverage to be 100 percent. So let's go
ahead, we'll write one test

23750
00:33:24,340 --> 00:33:27,190
together, then you should pause
this video and try to write some

23751
00:33:27,190 --> 00:33:30,490
tests yourself. When you're done
writing tests and you think

23752
00:33:30,490 --> 00:33:34,000
you've hit 100 percent, feel free to
compare back to the test that we

23753
00:33:34,000 --> 00:33:41,080
wrote. So let's create a new
folder called tests. Test. And

23754
00:33:41,080 --> 00:33:44,350
in here, we'll do a new one
called unit. And if you want to

23755
00:33:44,350 --> 00:33:47,440
write staging tests later on,
you absolutely can we will not.

23756
00:33:48,010 --> 00:33:54,640
We'll create a new file in here
called NFT marketplace.test.js.

23757
00:33:55,720 --> 00:33:59,110
And we'll start some tests. So
we'll do const.

23758
00:34:00,520 --> 00:34:11,260
cert, expect equals require Chai
const. Network deployments,

23759
00:34:11,530 --> 00:34:21,730
ethers, equals require hard hat
const development chains equals

23760
00:34:21,730 --> 00:34:26,350
require dot dot slash dot dot
slash helper, hothead config.

23761
00:34:26,890 --> 00:34:29,380
And we're gonna do the same
setup we've been doing. We'll

23762
00:34:29,380 --> 00:34:36,190
say bang development chains dot
includes network dot name,

23763
00:34:38,620 --> 00:34:47,620
question mark, describe dot
skip. Else describe. And if NF T

23764
00:34:48,640 --> 00:34:55,930
marketplace tests, comma async
function, excuse me, this is

23765
00:34:55,930 --> 00:34:59,230
just gonna be a function.
Scrabble oval is just a

23766
00:34:59,230 --> 00:35:03,490
function, not an async function,
like so. Great. Now let's get

23767
00:35:03,490 --> 00:35:07,780
some variables and do a before
each. So we'll say NF T

23768
00:35:08,350 --> 00:35:14,650
marketplace, basic NF T, we'll
create a constant price. So

23769
00:35:14,650 --> 00:35:17,950
we're just always set the price
of all of our NF T's to the same

23770
00:35:17,950 --> 00:35:20,860
thing. This will be ethers dot
utils dot parse

23771
00:35:22,360 --> 00:35:30,130
ether 0.1. We'll say const token
ID for now will always be zero.

23772
00:35:31,660 --> 00:35:35,560
And then we'll do before each
will be an async function.

23773
00:35:38,020 --> 00:35:45,010
And we'll get out and we'll also
get Deployer. Say deployer

23774
00:35:45,190 --> 00:35:50,170
equals await, get named
accounts. We're gonna need to

23775
00:35:50,170 --> 00:35:53,950
grab getting into accounts from
hard hat as well wrap this all

23776
00:35:53,950 --> 00:35:58,240
up dot deployer Excel and then
we'll also in our heart

23777
00:35:58,240 --> 00:36:02,680
hat.config.js. Under get named
accounts, we also have something

23778
00:36:02,680 --> 00:36:05,590
called player. Now I didn't talk
about this too much. But we're

23779
00:36:05,590 --> 00:36:08,980
going to have a second account
which is defaulted to the first

23780
00:36:09,010 --> 00:36:15,070
index, right? So we can do at
the top to come up player. And

23781
00:36:15,070 --> 00:36:21,790
we can say player equals await
get named accounts dot player.

23782
00:36:23,350 --> 00:36:26,590
Now we have a player and a
deployer account will do await

23783
00:36:26,680 --> 00:36:32,500
deployments, that fixture. All
will just deploy all of those

23784
00:36:32,500 --> 00:36:36,820
contracts will run through
everything in our deploy folder.

23785
00:36:37,090 --> 00:36:41,650
We'll get our NFT marketplace.
We'll say NFT marketplace equals

23786
00:36:41,680 --> 00:36:49,150
await ethers dot get contract
and ft. marketplace. And then

23787
00:36:49,150 --> 00:36:57,850
we'll do basic NF t equals await
ethers dot get contract. Basic

23788
00:36:57,910 --> 00:37:02,740
NF T. The way ethers dot get
contract works is it defaults to

23789
00:37:02,740 --> 00:37:06,040
grab thing, whatever account is
that account zero, which right

23790
00:37:06,040 --> 00:37:09,370
now is our Deployer. If we want
to call a function on NFT

23791
00:37:09,370 --> 00:37:12,490
marketplace, with the player
being the one calling the

23792
00:37:12,490 --> 00:37:17,170
function, we would have to say,
entity marketplace equals await

23793
00:37:18,580 --> 00:37:25,960
and empty marketplace dot
connect player like this. And

23794
00:37:25,960 --> 00:37:30,520
now whenever we call a function,
we would use the player instead

23795
00:37:30,520 --> 00:37:33,280
of the Deployer. Sometimes what
I like to do and you'll see this

23796
00:37:33,280 --> 00:37:39,070
in my code, is I'll do let NFT
marketplace contract. And then

23797
00:37:39,070 --> 00:37:45,340
let NFT marketplace, and then
I'll do NFT marketplace contract

23798
00:37:45,370 --> 00:37:49,450
equals await ethers dot
contract. And then I'll connect

23799
00:37:49,480 --> 00:37:53,530
and set that to the NF T
marketplace. Yes, we can do, we

23800
00:37:53,530 --> 00:37:57,520
can automatically choose who to
connect by placing whoever want

23801
00:37:57,520 --> 00:38:00,250
to connect to write and get
contract. But sometimes it's

23802
00:38:00,250 --> 00:38:02,680
really nice to be kind of
explicit. So it's really up to

23803
00:38:02,680 --> 00:38:06,070
you. I'm going to undo all that,
I just want to re show you that

23804
00:38:06,070 --> 00:38:08,530
to make sure that you knew
that's how you kind of switch

23805
00:38:08,530 --> 00:38:10,180
around with the different
accounts and the different

23806
00:38:10,180 --> 00:38:13,030
users. Now that we have an NF T,
we're probably going to need to

23807
00:38:13,030 --> 00:38:16,000
mint the NFT so that we can
actually place it on the market.

23808
00:38:16,180 --> 00:38:20,740
So we'll do await basic NF T dot
meant NF t, and then we'll

23809
00:38:20,740 --> 00:38:24,160
approve to send it on to the
marketplace. So we'll do a wait.

23810
00:38:24,640 --> 00:38:33,430
Basic NF T dot approve and T
market place dot address token

23811
00:38:33,430 --> 00:38:38,230
ID, which is going to be zero.
And just like that, the NOC

23812
00:38:38,230 --> 00:38:41,470
marketplace remember, it can't
call approve, because it doesn't

23813
00:38:41,470 --> 00:38:45,610
own that NF t. So we need to
have the Deployer. Call

23814
00:38:45,610 --> 00:38:49,840
approved, right. And remember,
since we're not we need to put

23815
00:38:49,840 --> 00:38:53,320
basic NF T in here. Since we
didn't tell ethers who to

23816
00:38:53,320 --> 00:38:56,050
connect this to it just
automatically connected it to

23817
00:38:56,080 --> 00:38:58,750
our Deployer because that's
what's at account zero. So it's

23818
00:38:58,750 --> 00:39:03,340
the deployer calling minting it
and then the deployer approving

23819
00:39:03,400 --> 00:39:06,850
to send it to the marketplace.
Only after this approved

23820
00:39:06,850 --> 00:39:10,900
function has been called canned
the NFT marketplace called

23821
00:39:10,900 --> 00:39:14,410
transfer from all those NF T's.
Now we're just going to do one

23822
00:39:14,410 --> 00:39:20,860
test here. We're gonna say it
lists and can be bought. That's

23823
00:39:20,860 --> 00:39:24,940
it, and this will be an async
function. And we're just gonna

23824
00:39:24,940 --> 00:39:31,210
list the NFT and buy a weight
entity marketplace.if We go to

23825
00:39:31,210 --> 00:39:33,430
our energy marketplace, what are
we doing, we're listing it

23826
00:39:33,430 --> 00:39:36,700
right, we want to list the item
or with the address token ID and

23827
00:39:36,700 --> 00:39:43,180
the price. So we'll do dot list
item. Basic NF T dot address,

23828
00:39:44,470 --> 00:39:47,830
token ID is zero, which we've
defined right here. And then

23829
00:39:47,830 --> 00:39:51,820
price we've hard coded up here
as well. So we're listing it. So

23830
00:39:51,820 --> 00:39:55,810
the deployer owns the NF T, the
player is now listing it, now we

23831
00:39:55,810 --> 00:39:59,770
want to buy it, let's have the
player be the one to buy it. So

23832
00:39:59,770 --> 00:40:02,110
what we're going to do is we're
going to have to connect the

23833
00:40:02,110 --> 00:40:07,120
player to the NFT marketplace.
So we can say const player

23834
00:40:07,180 --> 00:40:13,150
connected NF T, marketplace
equals and ft marketplace dot

23835
00:40:13,150 --> 00:40:19,510
Connect. Player. And then we can
buy the item by saying a weight

23836
00:40:19,750 --> 00:40:24,670
player connected and ft
marketplace.by item. It'll be

23837
00:40:24,670 --> 00:40:27,430
the basic and if we look back at
the end of the marketplace, what

23838
00:40:27,430 --> 00:40:31,720
does buy item need, needs the
NFT address and the token ID. So

23839
00:40:31,720 --> 00:40:33,310
basic NF t that address

23840
00:40:35,110 --> 00:40:39,610
and then the token ID and after
this bot, we should check to see

23841
00:40:39,610 --> 00:40:43,720
that the player actually does
indeed own that NF team. So we

23842
00:40:43,720 --> 00:40:47,650
can say const new owner and we
check to see if that owner is

23843
00:40:47,650 --> 00:40:52,120
indeed updated. We can say basic
NFT dot owner of because NF T's

23844
00:40:52,120 --> 00:40:58,540
have an owner of function, token
ID and then we also want to see

23845
00:41:01,390 --> 00:41:04,120
that the deployer actually is
going to get paid. So we can say

23846
00:41:04,120 --> 00:41:08,020
await and if T marketplace dot
get

23847
00:41:08,049 --> 00:41:17,139
proceeds of Deployer. So now we
can do assert new owner dot two

23848
00:41:17,139 --> 00:41:29,349
string equals player and we can
assert deployer proceeds.to

23849
00:41:29,349 --> 00:41:35,379
string equals price.to string
because they should have been

23850
00:41:35,379 --> 00:41:38,709
paid that price. And that's
right, it's actually a little

23851
00:41:38,709 --> 00:41:41,259
bit easier. instead of grabbing
players from getting named

23852
00:41:41,259 --> 00:41:43,599
accounts. It's a little bit
easier just to grab it right

23853
00:41:43,599 --> 00:41:48,399
from ethers. So we'll do const
accounts equals await

23854
00:41:49,570 --> 00:41:56,530
get signers. And then we'll save
player equals accounts of one

23855
00:41:56,590 --> 00:41:59,260
just because when we connect
it's expecting it type of

23856
00:41:59,260 --> 00:42:02,560
account and then the the get
named account is a different

23857
00:42:02,560 --> 00:42:04,840
type. So Oh, it's just a little
bit easier to actually connect

23858
00:42:04,840 --> 00:42:07,960
like this. So now we'll connect
to the player like so just know

23859
00:42:07,960 --> 00:42:11,740
that player and deployer are now
different types. So you'll see a

23860
00:42:11,740 --> 00:42:15,220
little bit differences there. To
me, this is ethers that gets

23861
00:42:15,220 --> 00:42:18,550
signers. And then when we buy
the item, we're of course gonna

23862
00:42:18,550 --> 00:42:23,350
have to pass a value, it's gonna
be price, of course, we're going

23863
00:42:23,350 --> 00:42:26,890
to need to pay the price of the
NFT. And then of course, this

23864
00:42:26,890 --> 00:42:29,140
needs to be player dot address.
And that's the difference right

23865
00:42:29,200 --> 00:42:31,450
now we got to do player that
address whenever we want the

23866
00:42:31,450 --> 00:42:34,480
address of one of the ethers
accounts. And then this new

23867
00:42:34,480 --> 00:42:37,450
owner, of course, should be in a
wait. And now we can run this

23868
00:42:37,450 --> 00:42:47,560
all. In Tada, we see things
pass. So our NFT marketplace is

23869
00:42:47,590 --> 00:42:52,090
able to facilitate the buying
and selling of an NF T with

23870
00:42:52,120 --> 00:42:56,500
arbitrary humans. This is
fantastic. So we just ran the

23871
00:42:56,500 --> 00:42:58,960
single test to show a little bit
of the oddities when working

23872
00:42:58,960 --> 00:43:03,550
with NF T's and some different
accounts. But 100 percent If you feel

23873
00:43:03,550 --> 00:43:08,020
up for the challenge, take this
time, pause this video and try

23874
00:43:08,020 --> 00:43:11,710
to write some tests. Remember,
the goal here is for us to do

23875
00:43:11,710 --> 00:43:16,690
yarn hardhat coverage, and see
what our coverage is and try to

23876
00:43:16,690 --> 00:43:22,060
get it to be 100 percent coverage. If
we run it right now, we'll see

23877
00:43:22,060 --> 00:43:26,050
Oh, my goodness, we are missing
a lot of coverage. Here, we have

23878
00:43:26,050 --> 00:43:29,500
a ton of uncovered lines, on top
of uncovered functions,

23879
00:43:29,500 --> 00:43:32,560
branches, statements, etc. Try
to write some tests to get this

23880
00:43:32,560 --> 00:43:41,590
to 100 percent and then come back.
Okay, welcome back. Hopefully

23881
00:43:41,590 --> 00:43:44,890
now you've written some tests.
And when you run your tests, you

23882
00:43:44,890 --> 00:43:47,170
can get some of them, I look
like this, right. And these are

23883
00:43:47,170 --> 00:43:49,270
my tests, these are the tests
that I wrote, you could do more

23884
00:43:49,270 --> 00:43:51,820
you could do last. And let's
see, when I run yarn Hardhead

23885
00:43:51,820 --> 00:43:55,360
coverage, I even missed some
lines. And I could I could test

23886
00:43:55,360 --> 00:43:58,090
a little bit more. So make your
tests even better than the ones

23887
00:43:58,090 --> 00:44:00,550
that I made. So these are the
tests from the GitHub repo

23888
00:44:00,550 --> 00:44:03,370
associated with this. Now that
we've written some tests here,

23889
00:44:03,400 --> 00:44:06,760
let's just write a couple of
scripts. And the reason we're

23890
00:44:06,760 --> 00:44:08,650
gonna write a couple of scripts
is we're gonna need these a

23891
00:44:08,650 --> 00:44:12,520
little bit later. So we'll write
some scripts to mint, some

23892
00:44:12,520 --> 00:44:15,640
amount of teased by some NF T's
etc. And we'll need this to

23893
00:44:15,640 --> 00:44:19,750
fiddle around and play on the
front end a little bit later. So

23894
00:44:19,780 --> 00:44:23,410
to create a script, again, we've
done this perform, let's do a

23895
00:44:23,410 --> 00:44:29,920
script called mint, and list dot
j s. And this will be to mint at

23896
00:44:29,920 --> 00:44:34,330
NFT. And then immediately listed
on the marketplace. So let's

23897
00:44:34,330 --> 00:44:40,720
create an async function called
mint, and list. And down below,

23898
00:44:40,720 --> 00:44:42,850
we're going to call mint and
list I'm going to copy paste

23899
00:44:42,850 --> 00:44:45,940
with that same script thing that
we've been doing. Obviously,

23900
00:44:45,940 --> 00:44:48,520
instead of Maine, though, we're
calling this mountain list. Now

23901
00:44:48,520 --> 00:44:52,330
in this mountain list, where
it's a constant, NFT mark, and

23902
00:44:52,330 --> 00:44:59,260
of tea market, place equals
await ethers dot get contract.

23903
00:45:01,180 --> 00:45:06,280
And ft marketplace. And right
we're going to import ethers

23904
00:45:06,280 --> 00:45:09,850
from hard hat. And then we'll do
we'll grab basic NF t. So we'll

23905
00:45:09,850 --> 00:45:15,160
say const. Basic kind of T
equals await ethers dot get

23906
00:45:15,190 --> 00:45:21,970
contract. Basic NF t. And then
first we'll mint a basic NF t.

23907
00:45:22,000 --> 00:45:27,490
So we'll do console dot log,
maintained at the top. And we'll

23908
00:45:27,490 --> 00:45:31,960
do a weight or actual we'll say
const. Mint, TX equals await

23909
00:45:32,410 --> 00:45:39,340
basic NF T dot mint NF t. And
then we'll do await min TX dot

23910
00:45:39,340 --> 00:45:44,140
Wait, wait one block. And
actually we'll say const. Mint

23911
00:45:44,260 --> 00:45:50,170
TX receipt. So that equals that.
And in this receipt, here's

23912
00:45:50,170 --> 00:45:53,110
another reason why events are so
good. When we met this NFT.

23913
00:45:53,140 --> 00:45:58,090
We're omitting the token ID in
an event in this document ID

23914
00:45:58,090 --> 00:46:07,180
event. So we could say const
token ID equals mint TX receipt

23915
00:46:08,320 --> 00:46:14,680
dot events of zero. That args
dot token Id like that. And now

23916
00:46:14,680 --> 00:46:17,380
we have the token ID. And now
that we have the token ID and

23917
00:46:17,380 --> 00:46:21,940
the basic NFT. minted we can now
call on our NFT marketplace list

23918
00:46:21,940 --> 00:46:27,370
item. So now we'll say console
dot log. Approving NFT right,

23919
00:46:27,370 --> 00:46:29,800
it's gonna be real similar to
our tests here. I'm gonna say

23920
00:46:29,800 --> 00:46:36,250
const approval TX equals await
basic NFT data prove

23921
00:46:36,969 --> 00:46:42,279
NFT marketplace dot address
token ID and then we'll do a

23922
00:46:42,279 --> 00:46:48,549
weight approved TX dot wait one
and we'll do console dot log

23923
00:46:49,119 --> 00:46:54,429
listing NF t.at that and then
we'll do const TX equals await

23924
00:46:54,519 --> 00:47:00,219
and if T market market place
that list item and we'll do NFT

23925
00:47:00,819 --> 00:47:06,699
marketplace that address So can
Id do await TX dot wait one,

23926
00:47:07,809 --> 00:47:14,199
console dot log listed and cool.
And we can try this out by

23927
00:47:14,199 --> 00:47:17,049
running yarn hardhat node, which
is going to run through our

23928
00:47:17,049 --> 00:47:19,449
deploy scripts, right, it's
going to run to these deployed

23929
00:47:19,449 --> 00:47:23,709
scripts here. And then in a new
terminal, we'll run our script,

23930
00:47:23,919 --> 00:47:29,619
yarn hard hat, run scripts meant
and list dash dash network

23931
00:47:30,219 --> 00:47:34,479
localhost. And we missed an
argument, oh, we need a price as

23932
00:47:34,479 --> 00:47:39,009
well to list our entity. So
we'll create a constant price

23933
00:47:39,249 --> 00:47:49,149
equals and we'll say ethers dot
utils dot parse, ether 0.1. And

23934
00:47:49,149 --> 00:47:54,189
we'll pass the price and to the
list item. So oops, and sorry,

23935
00:47:54,189 --> 00:47:58,029
it's not the marketplace that
we're listing, the basic NF t

23936
00:47:58,029 --> 00:48:02,139
that we're listing, of course,
so run that again. And Bada

23937
00:48:02,139 --> 00:48:06,279
bing, bada boom, got some listed
events. And we can see here,

23938
00:48:06,609 --> 00:48:09,159
we're doing some listing and
awesome. So now we have a

23939
00:48:09,159 --> 00:48:12,129
script. Alright, so now that we
have a script, and we're going

23940
00:48:12,129 --> 00:48:14,889
to be writing a couple other
scripts a little bit later, we

23941
00:48:14,889 --> 00:48:19,149
essentially have a really solid
repo here are our totally

23942
00:48:19,149 --> 00:48:23,709
decentralized, NFT marketplace,
this is absolutely massive, and

23943
00:48:23,709 --> 00:48:25,899
you should be incredibly,
incredibly proud of yourself.

23944
00:48:31,270 --> 00:48:34,510
Now, of course, this is all
code. And people can interact

23945
00:48:34,510 --> 00:48:38,290
with this, if they're software
developers, which is great. But

23946
00:48:38,290 --> 00:48:41,980
we're going to want to allow
anybody to be able to interact

23947
00:48:42,010 --> 00:48:46,510
and list their own NF t's on our
marketplace. So what are we

23948
00:48:46,510 --> 00:48:50,470
going to do? Well, we're going
to want to build a front end for

23949
00:48:50,470 --> 00:48:53,440
this. And now we're gonna get
into the second part of this

23950
00:48:53,440 --> 00:48:58,210
lesson. So on lesson 15, we just
finished the backend. Now we're

23951
00:48:58,210 --> 00:49:00,970
gonna move on to the front end,
we're gonna start with this

23952
00:49:00,970 --> 00:49:05,260
morass code. The code for both
of these is pretty much nearly

23953
00:49:05,260 --> 00:49:07,510
identical. But we're going to
start with Morales, and we're

23954
00:49:07,510 --> 00:49:09,580
going to teach you how to do
both of these. And we're going

23955
00:49:09,580 --> 00:49:11,770
to teach you the difference
between the Morales and the

23956
00:49:11,770 --> 00:49:14,590
MoGraph. And kind of why we're
even using them in the first

23957
00:49:14,590 --> 00:49:17,740
place, we're going to start with
Morales. So if you want to

23958
00:49:17,740 --> 00:49:20,260
follow along with this next
section, all the code we're

23959
00:49:20,260 --> 00:49:23,830
going to be working with, is
going to be in here. So you

23960
00:49:23,830 --> 00:49:27,640
excited, I hope you are because
this is going to be a phenomenal

23961
00:49:27,640 --> 00:49:30,550
session, we are about to build
one of the most sophisticated

23962
00:49:30,550 --> 00:49:34,420
front ends that we can using the
tools that we have. And like I

23963
00:49:34,420 --> 00:49:36,880
said, we showed you a little bit
earlier what this is going to

23964
00:49:36,880 --> 00:49:39,790
look like. So let's do a quick
refresher here. So here's what

23965
00:49:39,790 --> 00:49:42,550
our front end is going to look
like. But what we can do is we

23966
00:49:42,550 --> 00:49:45,610
can connect with our little
connect button, we hit Metamask

23967
00:49:45,640 --> 00:49:48,670
Metamask pops up, we'll go ahead
and connect. And now that we're

23968
00:49:48,670 --> 00:49:52,990
connected, we can see the
different NF T's in here. And if

23969
00:49:53,020 --> 00:49:56,980
we're on an address that's owned
by us, it will say owned by you.

23970
00:49:57,190 --> 00:50:00,520
And if we switch addresses, are
you I will go ahead and update,

23971
00:50:01,120 --> 00:50:04,390
connect there. And now we're
owned by a different address.

23972
00:50:04,510 --> 00:50:06,850
Now if it's owned by us, we get
this little hover that says

23973
00:50:06,880 --> 00:50:10,000
Update listing. And right now
it's worth 0.18. That's what

23974
00:50:10,000 --> 00:50:13,030
it's listed for on our
marketplace. If it's owned by

23975
00:50:13,030 --> 00:50:16,030
us, and we click it, we can
update it to a different price.

23976
00:50:16,060 --> 00:50:20,140
Let's update it to 50 eath, or
whatever your layer one currency

23977
00:50:20,140 --> 00:50:23,110
is, we'll just save new listing
price. We'll go ahead and

23978
00:50:23,110 --> 00:50:26,680
confirm. And I'll say the
listing updated, please refresh,

23979
00:50:27,010 --> 00:50:30,250
what we can do them. And we'll
mine some blocks on the back

23980
00:50:30,250 --> 00:50:33,910
end, and boom, now we see that
it's worth 50 here. Now if we

23981
00:50:33,910 --> 00:50:37,900
switch to a different account,
now we can see owned by Baba

23982
00:50:37,900 --> 00:50:41,770
blah, and the hovered now says
by me enough is selected as a

23983
00:50:41,770 --> 00:50:45,250
different user, I'm going to get
this transaction to actually buy

23984
00:50:45,250 --> 00:50:48,490
it. Now go ahead and confirm
that I'm going to buy it, I get

23985
00:50:48,490 --> 00:50:51,250
a little pop up. This is item
bought successfully. Now if I do

23986
00:50:51,250 --> 00:50:55,000
a little refresh, we'll now see
that that NFT is gone from the

23987
00:50:55,000 --> 00:50:57,160
marketplace since we bought it
right and it's no longer

23988
00:50:57,160 --> 00:51:00,880
available to be sold. Now what
we can do then is we can come

23989
00:51:00,880 --> 00:51:05,710
over to sell NF tees. And at the
bottom, we'll see a withdraw

23990
00:51:05,710 --> 00:51:09,850
proceeds. So whenever somebody
buys an NF T, the NFT

23991
00:51:09,850 --> 00:51:13,120
marketplace actually keeps the
proceeds that actually keeps the

23992
00:51:13,180 --> 00:51:16,840
result of the sale. So if we
switch back to our address that

23993
00:51:16,840 --> 00:51:20,470
had the NFT listed, we can now
see Withdraw 50 proceeds because

23994
00:51:20,470 --> 00:51:23,620
we know that we have 50 eath,
because we just bought that for

23995
00:51:23,740 --> 00:51:27,970
50. So if we hit withdraw,
Metamask is going to pop up, we

23996
00:51:27,970 --> 00:51:31,960
can go ahead and confirm, wait a
little bit as transaction

23997
00:51:31,960 --> 00:51:35,320
populates, and boom once it goes
through, and we'll see now we

23998
00:51:35,320 --> 00:51:38,800
have zero proceeds. Right? We
withdrew everything from here.

23999
00:51:39,070 --> 00:51:42,850
So what we can do now is we can
relist that NFT. So if we come

24000
00:51:42,850 --> 00:51:47,260
back, go back to the one who
just bought that at a T if we

24001
00:51:47,260 --> 00:51:50,590
know the address and the token
ID of the NF t and we own it, we

24002
00:51:50,590 --> 00:51:53,350
can go ahead and relisted you're
gonna place the address in here

24003
00:51:54,100 --> 00:51:58,480
with the token Id give it some
sort of price. We'll submit

24004
00:51:59,230 --> 00:52:03,280
we'll approve giving the NFT
marketplace access to our or

24005
00:52:03,400 --> 00:52:07,570
NFT, to our little doggie. And
then we'll go ahead and actually

24006
00:52:07,570 --> 00:52:12,490
send the transaction to actually
list the NFT on a marketplace

24007
00:52:12,970 --> 00:52:16,270
that we get NF T listed
successfully. After we move some

24008
00:52:16,270 --> 00:52:19,840
blocks in the backend, we can go
back to the front end. And we

24009
00:52:19,840 --> 00:52:23,740
now see, it's owned by us,
instead of the original owner,

24010
00:52:23,770 --> 00:52:27,940
right and set for 10 ether. And
then we can of course, switch

24011
00:52:27,940 --> 00:52:30,520
back to a different user, and we
can have

24012
00:52:30,550 --> 00:52:36,460
them actually buy. Alright, so
now that we have the contracts,

24013
00:52:36,460 --> 00:52:39,340
we know what this looks like on
the contract side. So now let's

24014
00:52:39,340 --> 00:52:42,520
figure out how to do this on the
front end side. So let's jump

24015
00:52:42,520 --> 00:52:46,570
into our code editor. And begin
if we're on our hard hat and my

24016
00:52:46,780 --> 00:52:50,410
NFT marketplace Free Code Camp
folder. That's great. But we're

24017
00:52:50,410 --> 00:52:52,870
going to create another folder,
we're going to CD down and

24018
00:52:52,870 --> 00:52:55,900
directory. And we're going to
make a new directory. I'm going

24019
00:52:55,900 --> 00:53:01,870
to call it next Jas and if T
marketplace dash FCC. Now you

24020
00:53:01,870 --> 00:53:05,650
can do next Jas marketplace dash
mirallas FCC if you want. Again,

24021
00:53:05,650 --> 00:53:10,090
we're starting with mirallas CD
next Jas NFT marketplace FCC. So

24022
00:53:10,120 --> 00:53:14,950
now that we have this folder,
will do code dot will open up a

24023
00:53:14,950 --> 00:53:18,820
new VS code, or you can do File
Open folder and open this new

24024
00:53:18,820 --> 00:53:22,330
folder. And we can begin working
in this new folder in here. Now

24025
00:53:22,330 --> 00:53:25,240
that we're in our new project,
we're in our new folder, we're

24026
00:53:25,240 --> 00:53:29,650
gonna do exactly what we've done
before. Yarn create next app,

24027
00:53:30,190 --> 00:53:36,040
period. Okay, we've done our
setup here. Now, I don't like es

24028
00:53:36,040 --> 00:53:37,930
lint. So once again, I'm just
going to go ahead and delete

24029
00:53:37,930 --> 00:53:42,010
that. And what we're going to
add in instead is our prettier

24030
00:53:42,010 --> 00:53:45,850
stuff. So prettier, ignore
prettier RC. Again, some people

24031
00:53:45,850 --> 00:53:48,790
may strongly disagree with me on
that, but to each their own

24032
00:53:48,790 --> 00:53:50,530
right, this is what I like to
do. So this is what I'm going to

24033
00:53:50,530 --> 00:53:54,850
do. Now we have a minimalistic
react project, right? If we run

24034
00:53:54,850 --> 00:54:00,460
yarn Dev, we open up our UI on
that site, copy this, or

24035
00:54:00,460 --> 00:54:04,120
Command, click it. Tada. Welcome
to next. Jas Yeah, we've got an

24036
00:54:04,120 --> 00:54:09,430
x js application. As we know, we
go to pages, we go to index.js.

24037
00:54:09,730 --> 00:54:16,030
Let's delete everything in here.
Bom will leave the stuff and

24038
00:54:16,030 --> 00:54:19,360
head if it comes with stuff and
head will write Hi, exclamation

24039
00:54:19,360 --> 00:54:22,240
mark. We'll save we'll come
back. And now we see Hi. And

24040
00:54:22,240 --> 00:54:25,270
I'll zoom in a whole bunch.
Boom. So now we have some

24041
00:54:25,270 --> 00:54:29,110
minimalistic reacts minimalistic
next, Jas. Now, I know we

24042
00:54:29,110 --> 00:54:32,290
already started the project
here. But let's jump to the

24043
00:54:32,290 --> 00:54:35,380
readme that's given to us. And
let's talk about how we want to

24044
00:54:35,380 --> 00:54:39,160
do this what we want this to
actually look like. Well, we're

24045
00:54:39,160 --> 00:54:42,340
going to want to make a
homepage. And in this homepage,

24046
00:54:42,340 --> 00:54:46,840
we'll say we'll have it show
recently listed, NF T's homepage

24047
00:54:46,840 --> 00:54:50,140
will show recently listed
entities that will say if you

24048
00:54:50,170 --> 00:54:55,150
own the NFT, you can update the
listing. If not, you can buy the

24049
00:54:55,150 --> 00:54:58,990
listing. So we'll have that. And
then we'll have a sell page. And

24050
00:54:58,990 --> 00:55:03,820
in this page, you can list your
NFT on the marketplace. So these

24051
00:55:03,820 --> 00:55:05,380
are going to be our two main
pages, we're gonna have a

24052
00:55:05,380 --> 00:55:08,440
homepage and a sell page. Now
we're going to have a ton of

24053
00:55:08,440 --> 00:55:10,990
components, but we're really
only going to have two main

24054
00:55:10,990 --> 00:55:15,460
pages. So if we go back over to
Pages, right, right now we have

24055
00:55:15,460 --> 00:55:19,330
our apps dot j s, which serves
our app, which is cool, which

24056
00:55:19,330 --> 00:55:21,700
everything runs through. And
then we have our homepage. Let's

24057
00:55:21,700 --> 00:55:27,280
also create right now, our sell
page or selling of T dot j s.

24058
00:55:27,610 --> 00:55:30,640
And then in here, we'll just
make this really minimal, that

24059
00:55:30,640 --> 00:55:33,460
we can copy most of what's in
here, we can actually just copy

24060
00:55:33,460 --> 00:55:36,340
paste this whole thing, paste it
in here. And instead of high,

24061
00:55:36,340 --> 00:55:42,070
we'll say sell page. We'll save
that. Now if we go to our

24062
00:55:42,070 --> 00:55:48,280
localhost do debt slash sell.
And if T oops, we gotta run. Run

24063
00:55:48,280 --> 00:55:51,730
the front end again. With yarn
Dev. Sorry, we'll run yarn dev

24064
00:55:51,730 --> 00:55:55,600
again. Now we refresh. And now
we can see sell page. So sell

24065
00:55:55,600 --> 00:55:58,330
pages that slash sell page, and
then home is just going to be

24066
00:55:58,330 --> 00:56:02,740
high. Okay, cool. So we have our
two pages. Which one should we

24067
00:56:02,740 --> 00:56:07,060
work on first? Well, let's work
on our homepage. So we're going

24068
00:56:07,060 --> 00:56:10,510
to be in our index.js. I'm going
to keep this front end bit

24069
00:56:10,510 --> 00:56:13,540
running, we're going to hide it
oops, that's the opposite of

24070
00:56:13,540 --> 00:56:16,960
hiding it, push it down, we're
going to hide it like that. And

24071
00:56:16,960 --> 00:56:19,630
let's go ahead and let's start
building this. So we see in our

24072
00:56:19,630 --> 00:56:22,210
index js, we have some head
stuff here, I'm going to change

24073
00:56:22,210 --> 00:56:28,540
this to NFT. Marketplace.
Description is going to be just

24074
00:56:28,540 --> 00:56:29,590
an empty marketplace.

24075
00:56:32,050 --> 00:56:36,670
Like so Fabcon looks great. Now
if we do a little refresh, now

24076
00:56:36,700 --> 00:56:40,000
it says NFT marketplace up at
the top here, which is good.

24077
00:56:40,000 --> 00:56:42,610
That's what we want. Well in our
index page, what's one of the

24078
00:56:42,610 --> 00:56:45,280
first things that we're always
going to need to do? You guessed

24079
00:56:45,280 --> 00:56:47,890
it, we're going to need a little
connect button right? We're

24080
00:56:47,890 --> 00:56:51,400
going to need our users to be
able to connect to to web three

24081
00:56:51,400 --> 00:56:55,180
to connect to a blockchain. So
same as we've done before. Let's

24082
00:56:55,180 --> 00:56:57,340
go ahead let's create a
components folder. And we'll

24083
00:56:57,340 --> 00:57:01,870
create a header component
component Nance folder and we'll

24084
00:57:01,870 --> 00:57:06,460
create a new file The header
digests. Now remember, since

24085
00:57:06,460 --> 00:57:09,790
we've done this before, with our
front end lottery code, we can

24086
00:57:09,820 --> 00:57:12,580
always refer back to the lottery
code as well when we're building

24087
00:57:12,580 --> 00:57:16,120
this, okay. And of course, we
have all of the code for this on

24088
00:57:16,120 --> 00:57:19,120
the GitHub repo. So you can use
that to what I'm not going to

24089
00:57:19,120 --> 00:57:22,270
have you all do is last time, we
did that manual header thing,

24090
00:57:22,270 --> 00:57:24,880
right, where we had to do all
the local storage and do all

24091
00:57:24,880 --> 00:57:28,150
that crazy stuff, we're not
going to do that. This time,

24092
00:57:28,480 --> 00:57:30,850
we're going to just do it the
easy way, we're going to just

24093
00:57:30,850 --> 00:57:34,960
use the web three UI kit. So to
use this connect button, we're

24094
00:57:34,960 --> 00:57:38,920
going to do yarn, add. And we're
not going to do dash dash Dev,

24095
00:57:38,950 --> 00:57:42,550
because this connect button is a
necessary component for the

24096
00:57:42,550 --> 00:57:46,510
front end, yarn add web through
UI Kit. This also means we're

24097
00:57:46,510 --> 00:57:51,670
going to do Morales and react
mirallas. I said, and this is

24098
00:57:51,670 --> 00:57:54,460
where it might be a little
confusing. I know I said in here

24099
00:57:54,730 --> 00:57:59,170
that we have both a Morales and
other graph edition. So we're

24100
00:57:59,170 --> 00:58:02,560
still going to use the Morales
package in both of them. The

24101
00:58:02,560 --> 00:58:05,620
only difference is we're going
to use a Morales server as well

24102
00:58:05,620 --> 00:58:08,290
in our Morales edition. And
we're not going to use a morale

24103
00:58:08,290 --> 00:58:11,260
server on our the graph edition,
they're both can use the Morales

24104
00:58:11,260 --> 00:58:14,830
package because all the open
source hooks and tools are still

24105
00:58:14,830 --> 00:58:18,310
incredibly powerful, even if we
don't use the Morales server. So

24106
00:58:18,310 --> 00:58:20,440
we're still going to use the
Morales package even when we're

24107
00:58:20,440 --> 00:58:23,020
going to be using the graph.
Great. So now that we've added

24108
00:58:23,020 --> 00:58:26,680
those all, we're going to do
exactly what we did before on

24109
00:58:26,680 --> 00:58:30,760
our last next Jas process. So in
order to use our web through UI

24110
00:58:30,760 --> 00:58:37,480
component in our app, dot j, s,
and do import mirallas provider

24111
00:58:40,450 --> 00:58:45,190
quotes and without sorry, and
curly brace, it's from react

24112
00:58:45,700 --> 00:58:49,780
mirallas like that. And then
we're going to wrap our whole

24113
00:58:49,780 --> 00:58:53,650
component thing in a morass
provider. So we're gonna do

24114
00:58:53,650 --> 00:59:00,430
return, little open parentheses,
close parentheses here. We're

24115
00:59:00,430 --> 00:59:06,040
gonna do rounds provider. And
then we're gonna do in if she

24116
00:59:06,070 --> 00:59:12,280
allies on Mount is going to
equal false, because we're not

24117
00:59:12,280 --> 00:59:15,490
going to use the server yet, or
else provider. Okay, cool. Now

24118
00:59:15,490 --> 00:59:19,030
that we've wrapped our app in a
Morales provider, and go back to

24119
00:59:19,060 --> 00:59:24,820
our header, we're gonna say
Export default function header,

24120
00:59:26,650 --> 00:59:29,410
we're going to grab our Connect
button from what through your

24121
00:59:29,410 --> 00:59:35,920
eye kit. So we'll do import
connect button from web three UI

24122
00:59:35,920 --> 00:59:42,700
kits. And then in here, we're
just gonna say return. The next

24123
00:59:42,700 --> 00:59:46,570
button. Now what we can do back
in our app, J. S, is we can do

24124
00:59:46,600 --> 00:59:53,950
import, import, do header from
dot dot slash components header,

24125
00:59:54,460 --> 00:59:57,940
and we have our header, we'll
just put our header right above

24126
00:59:57,970 --> 01:00:01,030
the component. And we're going
to add some stuff to the header

24127
01:00:01,090 --> 01:00:03,400
in a bit. Let's just make sure
that we're importing the header

24128
01:00:03,400 --> 01:00:06,730
correctly. Let's go back to our
UI here. And okay, boom, we have

24129
01:00:06,730 --> 01:00:09,670
our connects button. If we click
it, you know, we'll get this

24130
01:00:09,670 --> 01:00:12,160
little pop up. And I'm way
zoomed in. So I'm going to anway

24131
01:00:12,160 --> 01:00:12,790
zoom in.

24132
01:00:14,080 --> 01:00:16,030
Now, what else do we want to put
in our header? Well, we're

24133
01:00:16,030 --> 01:00:19,150
probably going to want to like
give this like a name and make

24134
01:00:19,150 --> 01:00:22,090
this look a little bit nicer,
probably going to want to a link

24135
01:00:22,090 --> 01:00:27,280
as well to our cell NF T page.
So let's create a navbar. So

24136
01:00:27,280 --> 01:00:29,950
instead of just returning the
connect button, put this in

24137
01:00:29,950 --> 01:00:33,310
parenthesis and we'll have a
return some other stuff too. So

24138
01:00:33,310 --> 01:00:37,150
we can use this nav tag, which
usually defines like a nav bar.

24139
01:00:37,330 --> 01:00:41,080
So it's really similar to a div,
it's just another tag. Right, so

24140
01:00:41,080 --> 01:00:44,710
now we'll put everything into
this nav tag. And in next Jas,

24141
01:00:44,710 --> 01:00:51,520
we can actually make links using
the next Jas link tag. So what

24142
01:00:51,520 --> 01:00:55,630
we can do in this is link allows
us to basically connect to

24143
01:00:55,660 --> 01:01:00,700
different links or URLs in our
application, like so. So we can

24144
01:01:00,700 --> 01:01:07,600
do import link from next slash
link. And in here, let's say if

24145
01:01:07,600 --> 01:01:10,930
we want it to go to the
homepage, we can make a link.

24146
01:01:11,500 --> 01:01:18,520
And we'll say h ref equals slash
equals slash. And inside of

24147
01:01:18,520 --> 01:01:23,440
this, we would wrap this in an a
tag to make it clickable. And

24148
01:01:23,440 --> 01:01:28,450
then we could just say something
like NFT marketplace. Now if we

24149
01:01:28,450 --> 01:01:32,830
save that, we go to our front
end, we now we see have a NFT

24150
01:01:32,830 --> 01:01:35,890
marketplace button that we can
click and since we're already at

24151
01:01:35,890 --> 01:01:38,530
home, we're not going to go
anywhere. But if we copy this

24152
01:01:38,560 --> 01:01:42,820
link section, paste it below,
and we make another one for cell

24153
01:01:42,850 --> 01:01:48,940
and f t. And we title this cell
NF t. Now we save we go back to

24154
01:01:48,940 --> 01:01:52,690
our front end, we now have NFT
marketplace and sell NFT if I

24155
01:01:52,690 --> 01:01:55,630
click sell NF t we now get to
the sell page right we'll go

24156
01:01:55,630 --> 01:02:01,600
back to the homepage sell page
flip back and forth. Awesome,

24157
01:02:01,780 --> 01:02:05,380
very exciting. So now we have
have an incredibly minimalistic

24158
01:02:05,620 --> 01:02:09,820
header obviously looks terrible.
So let's do just a little bit of

24159
01:02:09,820 --> 01:02:12,820
formatting. And oftentimes
you'll do the formatting last.

24160
01:02:12,820 --> 01:02:16,210
But while we're here, we might
as well do our formatting we're

24161
01:02:16,210 --> 01:02:19,870
going to use what if you guessed
tailwind? You guessed correctly.

24162
01:02:20,350 --> 01:02:25,330
So remember, tailwind with.
Next. Jas, you can always just

24163
01:02:25,330 --> 01:02:28,240
follow along here. And we'll
grab, we'll do the exact same

24164
01:02:28,240 --> 01:02:32,410
thing we did before we'll do
yarn, add dash dash Dev, that

24165
01:02:32,410 --> 01:02:36,580
stuff right there. And then
we'll run a knit after these

24166
01:02:36,580 --> 01:02:36,880
finished

24167
01:02:36,880 --> 01:02:42,640
installing. So we'll do yarn,
and then paste that in. And

24168
01:02:42,640 --> 01:02:46,060
there we go. So now we've got
our post CSS config, we've got

24169
01:02:46,060 --> 01:02:50,200
our tailwind config. We're going
to grab tailwind.config.js.

24170
01:02:50,470 --> 01:02:54,400
Paste it in here. And then we're
going to grab Global's dot css

24171
01:02:54,430 --> 01:02:58,930
and open up Global's dot css,
paste that in there, and cool.

24172
01:02:58,960 --> 01:03:01,690
Now we have tailwind in here.
Now that we have tailwind, we

24173
01:03:01,690 --> 01:03:05,560
can do some tailwind stuff to
our header here. Let's let's

24174
01:03:05,560 --> 01:03:09,490
create a div for all of these
for everything here, we'll

24175
01:03:09,490 --> 01:03:12,160
create a little div for all the
stuff here, we'll make like a

24176
01:03:12,160 --> 01:03:15,910
big section for almost like a
big sign saying, Hey, you're at

24177
01:03:15,910 --> 01:03:20,170
the NFC marketplace, h1, which
stands for header one, and we'll

24178
01:03:20,170 --> 01:03:26,770
give it a class name of padding
y of form. Padding x of four,

24179
01:03:26,800 --> 01:03:33,070
we'll do font bold text will be
three XL, and then it'll just

24180
01:03:33,070 --> 01:03:36,940
say NFT marketplace. Now we have
this NFT marketplace, which is

24181
01:03:36,940 --> 01:03:40,150
nice bolt. Awesome. If you're on
your server you're going to kill

24182
01:03:40,150 --> 01:03:43,270
it's going to kill it with Ctrl
C, and then we're going to

24183
01:03:43,270 --> 01:03:46,780
restart it. And that's going to
pull in all the tailwind stuff.

24184
01:03:46,810 --> 01:03:51,370
And now if we refresh our local
main, we should now see okay,

24185
01:03:51,400 --> 01:03:56,530
and if T and F c, r gets place,
right, we now see this and big

24186
01:03:56,530 --> 01:03:59,020
and bold, which looks a lot
better. So let's keep going.

24187
01:03:59,260 --> 01:04:03,790
Let's give our whole nav a class
name. Equals we'll give it

24188
01:04:03,790 --> 01:04:12,880
padding of five, border bottom
to flex flex row justify just if

24189
01:04:13,390 --> 01:04:19,150
between n items center. We'll
see how that looks. Haha, looks

24190
01:04:19,150 --> 01:04:22,450
a lot better. We're now kind of
like setting this up with a

24191
01:04:22,450 --> 01:04:25,960
bottom border kind of stick and
some stuff like this, that looks

24192
01:04:25,990 --> 01:04:29,500
much much nicer already. Let's
go down here. Let's make our

24193
01:04:29,500 --> 01:04:36,970
buttons have a class name equals
lax lax row items center. And

24194
01:04:36,970 --> 01:04:40,720
like I said, this is not a
styling class. So we're not

24195
01:04:40,720 --> 01:04:43,270
really going to go over exactly
how we're styling this. And that

24196
01:04:43,270 --> 01:04:46,300
is okay. But that's going to
move that over make that look a

24197
01:04:46,300 --> 01:04:51,490
little nicer. We'll give our
link here, a class name equals

24198
01:04:51,550 --> 01:04:56,710
Mr. For P six. And we'll give
both of these the same class

24199
01:04:56,710 --> 01:05:00,040
name both these links, give them
some padding, so they moved away

24200
01:05:00,040 --> 01:05:02,320
from each other some margin to
the right, so they're away from

24201
01:05:02,320 --> 01:05:06,760
each other. And oh, I forgot to
do this Morales off equals

24202
01:05:07,840 --> 01:05:11,110
false. We need Morales auth
equals false so that we don't

24203
01:05:11,110 --> 01:05:13,510
automatically connect to a
Morales database or try to

24204
01:05:13,510 --> 01:05:15,730
connect to Morales database,
when we connect, we want to just

24205
01:05:15,730 --> 01:05:18,940
connect with our Metamask. And
we'll change this to home

24206
01:05:19,540 --> 01:05:21,940
instead of the marketplace. But
otherwise, that looks pretty

24207
01:05:21,940 --> 01:05:25,480
good home selling of T Connect
button. And we can adjust the

24208
01:05:25,480 --> 01:05:28,180
formatting of this to make it
look a little different. But I

24209
01:05:28,180 --> 01:05:29,980
think for the most part, this
looks much better,

24210
01:05:29,980 --> 01:05:35,320
right? Alright, cool, much, much
better looking header. Here, we

24211
01:05:35,320 --> 01:05:38,650
have our app.js setup with the
mouse provider headers

24212
01:05:38,650 --> 01:05:43,510
components. Let's now move on to
our index. Let's now move on to

24213
01:05:43,600 --> 01:05:47,770
showing these NF T's showing all
the NF T's in our marketplace.

24214
01:05:47,890 --> 01:05:51,280
And here's where it's going to
already start to heat up and get

24215
01:05:51,280 --> 01:05:53,830
really interesting. And actually
one more thing, we're going to

24216
01:05:53,830 --> 01:05:57,580
grab this headpiece in the index
if you haven't. And we're just

24217
01:05:57,580 --> 01:06:01,960
going to have it be in the app
JSX. So yeah, and our app.js

24218
01:06:02,080 --> 01:06:05,170
we're going to put that header
up at the top, and just put a

24219
01:06:05,170 --> 01:06:11,980
little, little div, Div. div,
like so wrapping around this

24220
01:06:11,980 --> 01:06:16,270
whole thing. This goes here. And
this way, no matter what page

24221
01:06:16,270 --> 01:06:19,030
we're on, we're always going to
have this as our header. And we

24222
01:06:19,030 --> 01:06:21,520
don't have to define it each one
of our little our things here.

24223
01:06:21,580 --> 01:06:25,720
So we'll do a refresh. And it
says head is not defined. Sorry,

24224
01:06:25,720 --> 01:06:28,000
that's because we're going to
need to copy import head from

24225
01:06:28,000 --> 01:06:32,470
next slash head. Paste it into
our app that Jas import head

24226
01:06:32,470 --> 01:06:35,680
from next head. And now we can
see we're going to empty

24227
01:06:35,680 --> 01:06:37,720
marketplace no matter what page
we're on, because we're defining

24228
01:06:37,720 --> 01:06:40,360
it at our app level. We have the
header in here, we have this

24229
01:06:40,360 --> 01:06:44,530
stuff in here, index almost has
nothing in it now. Let's do

24230
01:06:44,530 --> 01:06:48,340
this. So what do we want to do?
We want the homepage aka our

24231
01:06:48,340 --> 01:06:52,870
index to show recently listed
NFT. So the question is, how do

24232
01:06:52,870 --> 01:06:57,970
we show the recently listed NF
Ts. How do we do that? Well,

24233
01:06:58,000 --> 01:07:02,410
let's go back to our contract.
We go back to our hard hat NFT

24234
01:07:02,410 --> 01:07:05,110
marketplace So we're looking at
at the marketplace, what do we

24235
01:07:05,110 --> 01:07:08,800
have in here? How do we actually
see where NFT is stored? Well,

24236
01:07:08,800 --> 01:07:12,460
they're stored in this listings
mapping. However, how do we see

24237
01:07:12,490 --> 01:07:15,730
all of the listings that are in
here? Well, this is a mapping,

24238
01:07:15,760 --> 01:07:18,850
which means we have every single
address on the planet in here,

24239
01:07:18,850 --> 01:07:21,340
we can't loop through the
mapping, we'd have to loop

24240
01:07:21,340 --> 01:07:25,060
through every single address on
the planet, which is some

24241
01:07:25,120 --> 01:07:28,480
insanely large number that you
and I could never fathom how

24242
01:07:28,480 --> 01:07:31,360
many addresses there are. So
what are some solutions that we

24243
01:07:31,360 --> 01:07:34,510
can take to this problem, right?
Because we're obviously not

24244
01:07:34,510 --> 01:07:37,540
going to loop through
everything. So what do we do?

24245
01:07:37,780 --> 01:07:40,180
What's what's kind of the first
approach, one of the first

24246
01:07:40,180 --> 01:07:42,520
approaches would be like,
alright, Patrick, well, why

24247
01:07:42,520 --> 01:07:46,720
don't we just create an array,
an array of listings instead,

24248
01:07:46,810 --> 01:07:49,570
and this might be a good
approach. But what if then later

24249
01:07:49,570 --> 01:07:52,180
on, we also want to get some
other weird data, maybe we want

24250
01:07:52,180 --> 01:07:57,880
to get all the NF t's a user
owns NF t's a user owns, there's

24251
01:07:57,880 --> 01:08:01,000
no array of NF T's that a user
owns. Again, that's just a

24252
01:08:01,000 --> 01:08:04,480
mapping. But what if we want to
query some other weird data, or

24253
01:08:04,480 --> 01:08:10,300
query some other weird data, or
what if an array will be very

24254
01:08:10,330 --> 01:08:13,630
gas expensive, which it is, if
we make this an array to loop

24255
01:08:13,630 --> 01:08:16,330
through, it'll be incredibly gas
expensive. So we don't want to

24256
01:08:16,330 --> 01:08:19,690
have to go back and change. So
I'm going to I'm going to type

24257
01:08:19,690 --> 01:08:22,390
this out. Because this is
important. We don't want to

24258
01:08:22,390 --> 01:08:28,210
change our protocol for just the
website, we don't want to change

24259
01:08:28,210 --> 01:08:31,570
our protocol for just the
website, or we don't want to

24260
01:08:31,570 --> 01:08:34,510
much change our protocol for the
website. Because if we were to

24261
01:08:34,510 --> 01:08:37,360
make this an array, it would
become incredibly gas

24262
01:08:37,360 --> 01:08:40,300
inefficient. And it would become
much harder to use this NFT

24263
01:08:40,300 --> 01:08:43,150
marketplace because it would be
so much more expensive. And as

24264
01:08:43,150 --> 01:08:46,570
you build more and more complex
protocols, you're going to

24265
01:08:46,570 --> 01:08:50,590
realize that having an array for
every single mapping you have

24266
01:08:50,920 --> 01:08:54,910
isn't feasible. This is one of
the reasons where these events

24267
01:08:54,940 --> 01:09:00,550
come into play. So every single
time we list an NF t, we call

24268
01:09:00,550 --> 01:09:04,840
this list item function. And we
omit item listed, this item

24269
01:09:04,840 --> 01:09:09,190
listed event is stored in a data
structure that's still on chain,

24270
01:09:09,220 --> 01:09:12,460
but just smart contracts can
access it. However, guess what

24271
01:09:12,460 --> 01:09:16,510
can't access it off chain
services can access these

24272
01:09:16,510 --> 01:09:21,520
events. So what we do in this
case, is what we're going to do

24273
01:09:21,520 --> 01:09:27,880
is we will index the events off
chain and then read from our

24274
01:09:27,880 --> 01:09:30,400
database. So what we're
literally going to do is we're

24275
01:09:30,400 --> 01:09:34,120
going to set up a server to
listen for those events to be

24276
01:09:34,120 --> 01:09:39,310
fired, fired. And we will add
them to a database to query. So

24277
01:09:39,310 --> 01:09:43,960
yes, we're literally going to
take every single time an item

24278
01:09:43,960 --> 01:09:47,770
is listed, we're going to index
it in a database for ourself.

24279
01:09:47,950 --> 01:09:51,610
And then we're going to call our
centralized database to start

24280
01:09:51,640 --> 01:09:53,770
and we're going to call that
database to do that. Now the

24281
01:09:53,770 --> 01:09:58,150
question then becomes Whoa,
isn't that centralized? Hey,

24282
01:09:58,150 --> 01:10:00,700
Patrick, we're talking isn't
that centralized? What the

24283
01:10:00,700 --> 01:10:04,420
Hickety heck, and the answer to
that is, it's not necessarily.

24284
01:10:04,630 --> 01:10:08,200
So the graph is a protocol that
does exactly this. It's a

24285
01:10:08,200 --> 01:10:13,030
protocol that indexes events off
chain, and sticks them into this

24286
01:10:13,060 --> 01:10:16,960
the Graph Protocol. And it does
it in a decentralized way,

24287
01:10:17,230 --> 01:10:20,650
Morales, the way we're going to
show you first does it in a

24288
01:10:20,650 --> 01:10:23,950
centralized way, Morales is
going to do it in a centralized

24289
01:10:23,950 --> 01:10:27,370
way, which might be the route
that you want to go for speed

24290
01:10:27,460 --> 01:10:30,190
for extra bells and whistles, so
that you can do local

24291
01:10:30,190 --> 01:10:32,920
development, which is what we're
going to be focusing on here, or

24292
01:10:32,950 --> 01:10:35,710
any of the other functionality
that Morales comes with. Because

24293
01:10:35,710 --> 01:10:38,410
Morales does a lot more than
just that. That's something to

24294
01:10:38,410 --> 01:10:41,230
keep in mind too, is even though
we are adding a centralized

24295
01:10:41,230 --> 01:10:45,670
component, or logic, our smart
contracts, the real bulk of this

24296
01:10:45,670 --> 01:10:49,300
application is decentralized.
And you can verify all your

24297
01:10:49,300 --> 01:10:51,760
interactions are working with
this decentralized smart

24298
01:10:51,760 --> 01:10:54,820
contract, we've actually been
using a lot of protocols that

24299
01:10:54,820 --> 01:10:58,840
are centralized, like ether
scan, like open see, and some of

24300
01:10:58,840 --> 01:11:01,690
these centralized protocols are
really important to this space.

24301
01:11:01,750 --> 01:11:04,360
So we're showing you Morales to
get you familiar with working

24302
01:11:04,360 --> 01:11:06,880
with one of these centralized
servers, in case you optionally

24303
01:11:06,880 --> 01:11:10,120
want to make an application that
provides a centralized service.

24304
01:11:10,390 --> 01:11:12,820
And there's a ton of tools in
the space like opens up and

24305
01:11:12,820 --> 01:11:17,410
defender tenderly and more, that
are centralized, but give us

24306
01:11:17,440 --> 01:11:20,500
massive, massive benefits. We as
a community are bringing more

24307
01:11:20,500 --> 01:11:22,960
and more things to being
decentralized. And sometimes we

24308
01:11:22,960 --> 01:11:25,300
need some training wheels to get
there. And then the graph is

24309
01:11:25,300 --> 01:11:27,820
going to be the decentralized
way, which is a bit of a longer

24310
01:11:27,820 --> 01:11:30,640
process to go main net, but
we'll explain all that when we

24311
01:11:30,640 --> 01:11:33,820
get there. Let's learn how we
can list the most recently

24312
01:11:33,820 --> 01:11:37,360
listed NF T's and Morales in the
graph. Both have some really

24313
01:11:37,360 --> 01:11:40,300
solid videos, I'm going to leave
some links in the GitHub repo

24314
01:11:40,300 --> 01:11:42,340
associated with this. So if you
want to learn more, you should

24315
01:11:42,340 --> 01:11:44,590
definitely watch both of those
because they are absolutely

24316
01:11:44,590 --> 01:11:48,670
fantastic and will help you
understand this event stuff

24317
01:11:48,700 --> 01:11:51,580
better. So normally, when we
read from the blockchain, we do

24318
01:11:51,580 --> 01:11:55,990
something like contract dot get,
get listing, you know, and then

24319
01:11:55,990 --> 01:11:59,620
we put it whatever our input
parameters are. Contract double

24320
01:11:59,620 --> 01:12:02,830
blah, so instead, so we're going
to read from a database that

24321
01:12:02,830 --> 01:12:05,680
houses All the mappings and an
easier to read data structure.

24322
01:12:05,740 --> 01:12:07,960
Both Morales and the graph do
this.

24323
01:12:11,080 --> 01:12:13,870
We've been using the morass,
open source packages and tools.

24324
01:12:13,900 --> 01:12:17,260
However, Morales also comes
optionally with a server back

24325
01:12:17,260 --> 01:12:20,440
end to give your web three
applications more functionality.

24326
01:12:20,560 --> 01:12:23,050
However, there's a ton of stuff
that we're not going to cover

24327
01:12:23,200 --> 01:12:25,390
that Morales can do to help
build your web three

24328
01:12:25,390 --> 01:12:28,300
applications. So instead of me
continuing to talk about

24329
01:12:28,300 --> 01:12:31,630
Morales, and what it can do, we
have Ivan here to give a brief

24330
01:12:31,630 --> 01:12:34,300
overview of some of the other
things that Morales can do take

24331
01:12:34,300 --> 01:12:34,960
it away, and

24332
01:12:34,990 --> 01:12:38,170
my name is Ivan, I'm from
rallis. And I'm here to tell you

24333
01:12:38,170 --> 01:12:41,320
how you can speed up your
development by 10 times and I'm

24334
01:12:41,320 --> 01:12:43,630
not over exaggerating, when
you're building something, you

24335
01:12:43,630 --> 01:12:47,500
want to ensure that is scalable,
because your DAP may go global,

24336
01:12:47,620 --> 01:12:51,610
it may get viral, it may go
mainstream, it can happen. And

24337
01:12:51,640 --> 01:12:55,240
if it happens, you don't want to
start from scratch, you want to

24338
01:12:55,240 --> 01:12:59,470
use tools and services that
allow you to go fast, and also

24339
01:12:59,470 --> 01:13:02,860
to go big. And that's exactly
what mirallas provides. At

24340
01:13:02,860 --> 01:13:06,190
mirallas. We create tools, we
create infrastructure for

24341
01:13:06,190 --> 01:13:11,200
developers in a way that you
have a single workflow, and they

24342
01:13:11,200 --> 01:13:13,240
will soon explain what it means
because this is what saves you

24343
01:13:13,240 --> 01:13:16,690
time. If you have a single
workflow for doing things. And

24344
01:13:16,690 --> 01:13:20,410
workflow in web three really
means that you have to have a

24345
01:13:20,410 --> 01:13:23,200
smart contract, whether it's a
token, the game, some kind of

24346
01:13:23,200 --> 01:13:25,960
staking some kind of
marketplace, some kind of defy,

24347
01:13:26,740 --> 01:13:29,800
it will be on chain, but at the
same time, you have to connect

24348
01:13:29,800 --> 01:13:32,500
it to your back end. Because
when something happens on chain,

24349
01:13:32,740 --> 01:13:35,650
you need to monitor that. So you
can create web hooks, you can

24350
01:13:35,650 --> 01:13:39,760
create email, you can create a
push notification, you can run

24351
01:13:39,760 --> 01:13:43,180
some custom code, you can run
some calculation, you can save

24352
01:13:43,180 --> 01:13:45,520
something to the database,
everything on chain at the end

24353
01:13:45,520 --> 01:13:49,180
of the day needs to go into our
back end. And when something is

24354
01:13:49,180 --> 01:13:51,370
in your back end, it needs to go
to the front end. So for

24355
01:13:51,370 --> 01:13:54,970
example, you change the UI when
something happens on chain or

24356
01:13:55,270 --> 01:13:58,660
you change the UI. If your user
receives a transfer there is

24357
01:13:58,660 --> 01:14:02,530
above a specific threshold. Or
if your user has this NFC, you

24358
01:14:02,530 --> 01:14:06,070
can allow them access into some
kind of chat or some kind of

24359
01:14:06,430 --> 01:14:09,490
exclusive piece of content. So
at Morales, we provide you with

24360
01:14:09,490 --> 01:14:13,870
a full stack suite of tools that
is used by over 100,000

24361
01:14:13,870 --> 01:14:17,380
developers, it's really becoming
one of the most adopted tech

24362
01:14:17,380 --> 01:14:21,040
stacks in web three. And it all
starts with Morales identity,

24363
01:14:21,280 --> 01:14:24,340
which ensures that you get one
piece of code, you write one

24364
01:14:24,340 --> 01:14:26,920
piece of code and you can log in
your users across different

24365
01:14:26,920 --> 01:14:30,010
blockchains across different
wallets. And in your morale is

24366
01:14:30,010 --> 01:14:33,580
dashboard, you will get the user
profile, and you will get a web

24367
01:14:33,580 --> 01:14:36,910
session. So mirallas allows you
to manage identities because a

24368
01:14:36,910 --> 01:14:39,220
user profile can have many
different wallets from many

24369
01:14:39,220 --> 01:14:42,820
different chains connected to
it. And all of the transactions

24370
01:14:42,820 --> 01:14:45,700
will be synced from that user,
all the real time transactions

24371
01:14:45,700 --> 01:14:50,440
will be synced about that user.
And also, you have established

24372
01:14:50,440 --> 01:14:53,080
web session between your front
end whether it is a game,

24373
01:14:53,260 --> 01:14:58,450
whether it is a web website, we
ensure that you have secure

24374
01:14:58,480 --> 01:15:01,510
authenticated web sessions, and
we provide you with session

24375
01:15:01,510 --> 01:15:04,480
management. So in case you have
your own bike, and then you have

24376
01:15:04,480 --> 01:15:07,810
mirallas session identity
management, you can invalidate

24377
01:15:07,810 --> 01:15:10,600
sessions, you can log in users
and do all of that great, all of

24378
01:15:10,600 --> 01:15:13,240
these great things with one line
of code. That's very important.

24379
01:15:13,600 --> 01:15:17,020
Number two is Morales real time
I already mentioned a bit of it.

24380
01:15:17,020 --> 01:15:19,390
But basically when you have a
user, you know exactly what's

24381
01:15:19,390 --> 01:15:22,630
going on in real time. You can
run custom code, whenever a user

24382
01:15:22,630 --> 01:15:26,110
does a transaction, you can run
custom code or do a web hook or

24383
01:15:26,140 --> 01:15:29,080
email or push notification
whenever a user interacts with a

24384
01:15:29,080 --> 01:15:32,890
smart contracts or when a smart
contract simply emits an event.

24385
01:15:33,040 --> 01:15:38,140
This can be an trade in an NFC
marketplace, this can be ERC 20

24386
01:15:38,140 --> 01:15:42,190
transfer, you can be very
flexible by setting filters. So

24387
01:15:42,190 --> 01:15:46,810
you can say only give me alerts
only give me web hooks when the

24388
01:15:46,840 --> 01:15:50,860
user transfers more than 10
NFCs. Or when this token

24389
01:15:50,860 --> 01:15:54,850
transfer is above $1,000, and so
on so forth. This is morale is

24390
01:15:54,850 --> 01:15:59,920
real time very, very powerful
things. Next are mirallas SDKs.

24391
01:15:59,950 --> 01:16:02,350
So whether you're building a
website, whether you're building

24392
01:16:02,350 --> 01:16:05,140
a game where full integration
with game engines, whether

24393
01:16:05,140 --> 01:16:09,640
you're building for some other
platform, we have extensive SDKs

24394
01:16:09,640 --> 01:16:13,420
that are easy to use that allow
you to do all of this that allow

24395
01:16:13,420 --> 01:16:16,690
you to connect to Morales and do
this very, very easily. And if

24396
01:16:16,690 --> 01:16:19,090
you go to our documentation,
which I highly recommend you to

24397
01:16:19,090 --> 01:16:23,080
do, you go to Morales, Doc's dot
morales.io, if you go to Doc's

24398
01:16:23,080 --> 01:16:26,200
dot, Marisa Yo, you will first
and foremost understand what

24399
01:16:26,200 --> 01:16:28,930
mirallas is in depth. So you can
think of it kind of like

24400
01:16:28,930 --> 01:16:31,570
Firebase, but for crypto,
basically, it's a managed

24401
01:16:31,660 --> 01:16:35,110
backend, that you can connect
your front end. Also, you can

24402
01:16:35,110 --> 01:16:38,170
connect it to your own back end
using no GS SDK, it's very, very

24403
01:16:38,170 --> 01:16:41,860
easy. But what I wanted to show
you here is cross platform. So

24404
01:16:41,890 --> 01:16:44,980
for each thing we have, let's
say you want to get nfts for

24405
01:16:44,980 --> 01:16:47,860
your user, we'll show you how to
do it in simple JavaScript,

24406
01:16:47,890 --> 01:16:51,610
vanilla JavaScript, how to do it
and react, how to do it using a

24407
01:16:51,610 --> 01:16:54,850
web request. Let's say that you
just want to use a raw web

24408
01:16:54,850 --> 01:16:57,760
request. Let's say you're using
some kind of language that we

24409
01:16:57,760 --> 01:17:00,880
don't have SDK for you still can
use Morales just that you have

24410
01:17:00,880 --> 01:17:04,270
to call the raw HTTP request.
And we'll also show you how to

24411
01:17:04,270 --> 01:17:07,570
do it in Unity using C sharp in
Unity game engine. So we're

24412
01:17:07,570 --> 01:17:12,160
very, very clear cross platform.
And we are cross chain. So this

24413
01:17:12,160 --> 01:17:15,460
means for example, when you log
in the user, you can create the

24414
01:17:15,460 --> 01:17:19,600
user profile where you have the
lambda address, let's say your

24415
01:17:19,600 --> 01:17:22,780
user uses Solana then they can
easily connect Aetherium, they

24416
01:17:22,780 --> 01:17:25,840
can easily connect Binus chain,
the end, we're gonna add more

24417
01:17:25,840 --> 01:17:28,780
chain soon, they can easily
connect L Ron, to one user

24418
01:17:28,780 --> 01:17:31,270
profile. And then you have all
kinds of different wallets,

24419
01:17:31,270 --> 01:17:34,570
different chains, and you have
one single user profile one

24420
01:17:34,570 --> 01:17:37,900
single user ID. This is, by the
way, how it will look like in

24421
01:17:37,900 --> 01:17:42,220
your database. As you can see,
you're going to have a user user

24422
01:17:42,430 --> 01:17:45,490
table right here, you're going
to have all of their accounts.

24423
01:17:45,490 --> 01:17:48,850
So in this case, I only have
eath. But if I have Solana, if I

24424
01:17:48,850 --> 01:17:52,450
have other types of blockchains,
it will all be right here. And

24425
01:17:52,450 --> 01:17:56,050
this is a database that also has
all my transactions. This is a

24426
01:17:56,050 --> 01:18:00,970
database where I can set up
different listen events or smart

24427
01:18:00,970 --> 01:18:04,240
contracts. So for example, open
see I can watch open see smart

24428
01:18:04,240 --> 01:18:06,730
contracts or something else. And
it's very, very variable,

24429
01:18:06,730 --> 01:18:10,540
because this is MongoDB. This is
MongoDB, you can run MongoDB

24430
01:18:10,540 --> 01:18:13,780
queries, it's very, very
variable. So in that sense,

24431
01:18:13,810 --> 01:18:16,750
mirallas gives gives you a nice,
nice dashboard with everything

24432
01:18:16,750 --> 01:18:18,850
you need to know about your
users, their sessions, their

24433
01:18:18,850 --> 01:18:21,340
permissions, and so on, so
forth. And of course, you can

24434
01:18:21,340 --> 01:18:25,180
connect to your own back end
using the Node js SDK. So this

24435
01:18:25,180 --> 01:18:29,200
is Morales SDKs. And finally,
when we're speaking about the

24436
01:18:29,200 --> 01:18:32,650
workflow, the final thing is the
API's, which I also already

24437
01:18:32,650 --> 01:18:36,310
showed you, but the API is that
you can do RAW requests from any

24438
01:18:36,310 --> 01:18:39,850
programming language from any
kind of architecture. So using

24439
01:18:39,850 --> 01:18:42,970
this workflow, you can easily
achieve anything you want very,

24440
01:18:42,970 --> 01:18:46,570
very quickly. You really have to
try Morales it is it will change

24441
01:18:46,570 --> 01:18:49,630
your life. I can explain here
all I want, I have limited time.

24442
01:18:49,630 --> 01:18:53,020
But as you can already see, by
this presentation, you're very

24443
01:18:53,020 --> 01:18:56,200
curious, as you already can see,
by this presentation, you want

24444
01:18:56,200 --> 01:18:59,440
to try this as you already feel
by watching me here, you are

24445
01:18:59,440 --> 01:19:04,060
very, very excited. We have to
get your hands dirty. So go,

24446
01:19:04,270 --> 01:19:07,870
number one, two dogs, authorize
the sale, and go here getting

24447
01:19:07,870 --> 01:19:12,250
started connector SDK in vanilla
or react and go through all of

24448
01:19:12,250 --> 01:19:14,620
this. See the magic for
yourself. And if you want

24449
01:19:14,620 --> 01:19:17,650
practicalities, go to youtube
channel and go to morality Oh,

24450
01:19:17,650 --> 01:19:21,880
slash projects, guys, you all in
the community. Using Morales,

24451
01:19:21,880 --> 01:19:25,480
you will succeed using rallies,
you will achieve your goal. And

24452
01:19:25,480 --> 01:19:28,810
you're going to do sooner than
you expect yourself. You're

24453
01:19:28,810 --> 01:19:32,140
gonna surprise yourself. But
don't let yourself down. Go to

24454
01:19:32,140 --> 01:19:34,720
morales.io sign up, get started,

24455
01:19:34,750 --> 01:19:41,020
you guys. Now that I've
explained all of that, what does

24456
01:19:41,020 --> 01:19:42,970
this look like? Well, this is
where we're actually going to

24457
01:19:42,970 --> 01:19:46,360
start using mirallas with its
server capabilities. And we're

24458
01:19:46,360 --> 01:19:48,340
going to sign up for a server
here. And we're going to use

24459
01:19:48,340 --> 01:19:52,630
Morales as our back end for our
application. So to get set up

24460
01:19:52,630 --> 01:19:55,510
with Morales, we go to
morales.io. We can go ahead and

24461
01:19:55,510 --> 01:19:59,020
sign up for free. We'll put our
email in, we'll create some

24462
01:19:59,020 --> 01:20:03,280
password. Why are you here?
Other please specify Patrick's

24463
01:20:03,430 --> 01:20:06,940
amazing hardhat video, you don't
have to write that. But if you

24464
01:20:06,940 --> 01:20:09,640
want to write that you can. What
did you hear about Morales for

24465
01:20:09,640 --> 01:20:12,010
the first time? Well, you all
heard about it on YouTube,

24466
01:20:12,160 --> 01:20:14,290
because you heard it from me,
and then pick your roll, I'm

24467
01:20:14,290 --> 01:20:16,660
going to be a developer, we'll
hit next, I don't want to

24468
01:20:16,660 --> 01:20:19,540
subscribe. But I'm going to not
be a robot and create your

24469
01:20:19,540 --> 01:20:22,330
account. And it even gives us a
little property or create your

24470
01:20:22,330 --> 01:20:26,740
first server. So our back end is
going to use a server to do any

24471
01:20:26,740 --> 01:20:30,430
stuff on the back. So we'll
create a server. And if we were

24472
01:20:30,430 --> 01:20:32,710
going to do a main net or a
testament, we choose one of

24473
01:20:32,710 --> 01:20:35,650
those. But for now we're going
to do a local dev chain server.

24474
01:20:35,920 --> 01:20:38,680
And again, this is one of the
advantages of Morales is it

24475
01:20:38,680 --> 01:20:42,730
allows us to work with our local
dev chain. For indexing events,

24476
01:20:42,760 --> 01:20:46,270
we can actually index our events
from our local hard hat node,

24477
01:20:46,300 --> 01:20:48,760
which is incredibly, incredibly
powerful here, so check your

24478
01:20:48,760 --> 01:20:51,340
email, and we'll have an
activate my account thing,

24479
01:20:51,460 --> 01:20:54,520
email, we'll hit activate your
account. And it'll bring us back

24480
01:20:54,520 --> 01:20:56,800
here and we'll recreate and
we'll do local dev chain.

24481
01:20:56,920 --> 01:20:59,380
Alright, so now we're going to
create a new local dev chain

24482
01:20:59,380 --> 01:21:04,360
server. So we're going to call
this NFT marketplace, we're

24483
01:21:04,360 --> 01:21:06,640
going to select the region,
whatever region you want, I'm in

24484
01:21:06,640 --> 01:21:08,830
the eastern United States. So
I'm going to choose New York.

24485
01:21:08,860 --> 01:21:11,500
But whatever location works for
you, we're gonna do local dev

24486
01:21:11,500 --> 01:21:13,720
chain, and we're going to do
eath, local dev chain. And

24487
01:21:13,720 --> 01:21:15,970
again, if you're building for
polygon, if you're building for

24488
01:21:15,970 --> 01:21:17,980
avalanche, if you're building
for Phantom, if you're building

24489
01:21:17,980 --> 01:21:21,010
for any of these EVM compatible
chains, again, your eath local

24490
01:21:21,010 --> 01:21:23,200
dev chain, it's going to work
exactly the same. So we're going

24491
01:21:23,200 --> 01:21:26,290
to add instance now. And we're
going to create a new

24492
01:21:26,290 --> 01:21:30,100
application here. So we're going
to close now we have the server

24493
01:21:30,100 --> 01:21:32,350
here, and it says ganache, but
it's really hard hat. Don't

24494
01:21:32,350 --> 01:21:34,870
worry about that. Now that we
have our server up, we can go to

24495
01:21:34,870 --> 01:21:38,710
the Morales documentation, what
we're looking for is events,

24496
01:21:38,740 --> 01:21:41,650
we're looking to sync with
events. So we can even do a

24497
01:21:41,650 --> 01:21:45,370
little search in here for
events. And we see smart

24498
01:21:45,370 --> 01:21:48,610
contract events platform
Automatic Sync, and even tells

24499
01:21:48,610 --> 01:21:50,710
us a little bit more about why
do we need to sync and watch

24500
01:21:50,710 --> 01:21:53,710
smart contract events. So
basically, this server our

24501
01:21:53,710 --> 01:21:56,560
database is going to be looking
for these events to be emitted.

24502
01:21:56,590 --> 01:21:59,110
But before we can do that, we
need to hook up our application

24503
01:21:59,110 --> 01:22:02,590
to our server and if you go to
the React Morales GitHub right

24504
01:22:02,590 --> 01:22:05,230
at the top And you'll probably
see saw this before, when you

24505
01:22:05,230 --> 01:22:08,140
have this Morales provider in
their docks, they actually pass

24506
01:22:08,140 --> 01:22:11,560
an app ID and a server URL. And
this is how we can actually

24507
01:22:11,560 --> 01:22:16,390
connect directly to our servers
on mirallas. So what we're gonna

24508
01:22:16,390 --> 01:22:19,810
do is right, now we're gonna go
back to our app that Jas and

24509
01:22:19,840 --> 01:22:22,300
originally we've been saying
initialize on Mount equals

24510
01:22:22,300 --> 01:22:25,240
false. When we say this, we're
saying, Hey, we're not going to

24511
01:22:25,240 --> 01:22:28,150
use a morale server, we're just
going to use the open source

24512
01:22:28,150 --> 01:22:31,780
morass tools that y'all provide.
Now, we actually do want to use

24513
01:22:31,780 --> 01:22:33,880
their server, right, we do want
to use all these bells and

24514
01:22:33,880 --> 01:22:35,950
whistles that Morales comes with
out of the box. So we're going

24515
01:22:35,950 --> 01:22:38,530
to change that. So instead of
saying initialize on Mount

24516
01:22:38,530 --> 01:22:40,960
equals false, we're just getting
ready with the app ID and the

24517
01:22:40,960 --> 01:22:43,900
server URL. So we're going to
delete this. And just like it

24518
01:22:43,900 --> 01:22:46,210
says, in the documentation,
we're gonna give it an app ID

24519
01:22:46,270 --> 01:22:49,810
and a server URL. So we're gonna
say app ID equals, and this is

24520
01:22:49,810 --> 01:22:52,930
where as a string, we'll put our
app ID. So if we go back to our

24521
01:22:52,930 --> 01:22:56,860
Morales database, we can go to
view details. And we see all

24522
01:22:56,860 --> 01:23:00,220
this information in here. And we
can grab our application ID, we

24523
01:23:00,220 --> 01:23:04,810
can copy it, paste it in here.
And then we'll want to grab our

24524
01:23:04,810 --> 01:23:09,490
server URL, which is at the top.
So this is the URL of our unique

24525
01:23:09,490 --> 01:23:14,260
custom morale server. So we'll
say server, URL equals and then

24526
01:23:14,260 --> 01:23:16,390
paste that in there like that.
Now, if you've been following

24527
01:23:16,390 --> 01:23:18,610
along with these tutorials, you
might be thinking oh, we're

24528
01:23:18,640 --> 01:23:20,890
we're kind of just hard coding
that stuff right in there like

24529
01:23:20,890 --> 01:23:24,040
that, how that seems kind of
that seems kind of bad. Well, if

24530
01:23:24,040 --> 01:23:27,250
that's your intuition, that is
fantastic. So instead, we're

24531
01:23:27,250 --> 01:23:29,860
actually going to put these into
environment variables. So we're

24532
01:23:29,860 --> 01:23:34,120
going to create a new file, a
dot env file. And this is where

24533
01:23:34,120 --> 01:23:36,910
we're going to put all of our
environment variables. Now next,

24534
01:23:36,910 --> 01:23:39,640
Jas comes with built in support
for environment variables, which

24535
01:23:39,640 --> 01:23:43,000
allow you to do the following
use dot env, dot local to load

24536
01:23:43,030 --> 01:23:45,700
environment variables or those
environment variables to the

24537
01:23:45,700 --> 01:23:48,730
browser by prefixing. It with
next underscore public. So

24538
01:23:48,730 --> 01:23:50,680
there's a couple of different
environment variable paths we

24539
01:23:50,680 --> 01:23:53,440
can use. We can do dot env, dot
local, we can do dot env, dot

24540
01:23:53,440 --> 01:23:55,330
this dot that that the other
thing, we're just going to do

24541
01:23:55,330 --> 01:23:58,960
dot env, to keep it simple here.
But in order for our front ends,

24542
01:23:58,990 --> 01:24:01,810
to read environment variables
from our dot env file, we have

24543
01:24:01,810 --> 01:24:06,130
to do next underscore public
underscore, and next Jas will

24544
01:24:06,130 --> 01:24:09,460
look into our dot env file for
variables that start with this

24545
01:24:09,550 --> 01:24:12,970
and only stick these environment
variables into our application.

24546
01:24:13,060 --> 01:24:16,450
If we were to just do like
Morales server equals blah,

24547
01:24:16,450 --> 01:24:19,840
blah, blah, it has no idea what
this is because we need to do

24548
01:24:20,140 --> 01:24:24,190
next underscore public
underscore. And if we do that,

24549
01:24:24,220 --> 01:24:28,540
and we'll do a console dot log,
look here, process dot env. Next

24550
01:24:28,570 --> 01:24:31,660
public morale server and we
actually need to kill it and

24551
01:24:31,660 --> 01:24:34,390
restart it. And then we go back,
we do a little refresh here,

24552
01:24:34,450 --> 01:24:37,510
it'll say Look here as a do bla
bla bla, because that's what is

24553
01:24:37,510 --> 01:24:41,470
in the dot env file with that
next public. So we'll grab our

24554
01:24:41,470 --> 01:24:47,470
app ID, we'll copy it. And then
our dot env will do next public

24555
01:24:48,550 --> 01:24:52,780
app ID equals and we'll paste
that in there. We'll grab our

24556
01:24:52,780 --> 01:24:57,430
server URL, we'll go back to
here. We'll do next public

24557
01:24:57,760 --> 01:25:02,170
server URL equals, we'll paste
that like that. And now at the

24558
01:25:02,170 --> 01:25:09,940
top, we'll say const. App ID
equals process dot E and V dot

24559
01:25:10,330 --> 01:25:16,810
next, public app ID. And then
we'll say const. Server URL

24560
01:25:16,840 --> 01:25:23,290
equals process dot E and V dot
next public server URL. Now that

24561
01:25:23,290 --> 01:25:26,230
we've had these variables, we'll
stick them in like this.

24562
01:25:28,180 --> 01:25:32,620
So this is how we can connect
our application to our morale

24563
01:25:32,620 --> 01:25:35,500
server. Now, of course, we
haven't done anything yet. But

24564
01:25:35,530 --> 01:25:37,120
we're getting started, right?
This is how we're going to

24565
01:25:37,120 --> 01:25:40,150
connect to it. Now that we've
signed in, well, I told you that

24566
01:25:40,150 --> 01:25:43,090
our morale server was going to
be indexing our events. And if

24567
01:25:43,090 --> 01:25:46,210
you go to this Dashboard button,
this is our entire database.

24568
01:25:46,240 --> 01:25:49,120
Everything in this browser tab
is what's in our database right

24569
01:25:49,120 --> 01:25:51,490
now. And as you can see, right
now, there's not a whole lot of

24570
01:25:51,490 --> 01:25:55,150
anything, if we had any events
data in here, it would be in

24571
01:25:55,150 --> 01:25:58,540
here. So we need to tell our
server, hey, you need to start

24572
01:25:58,540 --> 01:26:01,570
listening for events. So we can
show the most recently listed

24573
01:26:01,570 --> 01:26:04,960
entities. So morale server, you
need to start listening, you

24574
01:26:04,960 --> 01:26:07,660
need to create a database entry
for every single one of these

24575
01:26:07,660 --> 01:26:11,800
item listed events. And whenever
somebody buys an item, right,

24576
01:26:11,800 --> 01:26:14,650
whenever somebody buys that
item, or cancels an item, you

24577
01:26:14,650 --> 01:26:17,740
need to remove that from your
database. How do we start

24578
01:26:17,740 --> 01:26:20,170
telling Morales to start
listening to our events? Well,

24579
01:26:20,170 --> 01:26:22,720
first off, well, first off,
we're gonna need to connect it

24580
01:26:22,750 --> 01:26:26,020
back to to our blockchain. And
then we're going to say, which

24581
01:26:26,020 --> 01:26:30,280
contract which events and what
to do when it hears those

24582
01:26:30,280 --> 01:26:32,590
events. So we need to connect it
and then we need to tell it what

24583
01:26:32,590 --> 01:26:35,170
to do when it hears those
events. So how do we connect our

24584
01:26:35,170 --> 01:26:38,800
mirallas server to our hard hat
blockchain? And right now, we're

24585
01:26:38,800 --> 01:26:41,770
not running one. But let's go
ahead and we'll start up our

24586
01:26:41,800 --> 01:26:45,670
hard hat, our local host
blockchain. So in one terminal,

24587
01:26:45,670 --> 01:26:48,190
we're running the front end and
another terminal will see the

24588
01:26:48,190 --> 01:26:52,630
download directory. We'll cd
into our hard hat NFT

24589
01:26:52,630 --> 01:26:56,350
marketplace dot Free Code Camp
or Free Code Camp, and we'll do

24590
01:26:56,500 --> 01:27:00,910
yarn hard hat node. And if we've
done everything correctly, it'll

24591
01:27:00,910 --> 01:27:03,970
deploy our NFT marketplace.
It'll deploy our Basic NFT and

24592
01:27:03,970 --> 01:27:07,300
then it'll start local HTTP web
socket at blah, blah, blah. So

24593
01:27:07,300 --> 01:27:09,670
that's good. So now that we have
that Node running, what we can

24594
01:27:09,670 --> 01:27:14,320
do is we can go to view details,
and go to dev chain proxy

24595
01:27:14,320 --> 01:27:18,130
server. So this dev chain proxy
server is going to be how we

24596
01:27:18,130 --> 01:27:22,420
actually tell Morales to listen
to our locally running hard hat

24597
01:27:22,420 --> 01:27:25,420
node. Now, to do this, what
you're going to need to do is

24598
01:27:25,420 --> 01:27:28,330
we're going to need to download
this what's called a reverse

24599
01:27:28,330 --> 01:27:32,290
proxy. And I have a link to this
in the GitHub as well, depending

24600
01:27:32,290 --> 01:27:35,200
on what computer you're running
on will tell you which one of

24601
01:27:35,200 --> 01:27:37,210
these we actually need to
download. And then there's some

24602
01:27:37,210 --> 01:27:40,450
troubleshooting tips down here
if you ever get lost, and if

24603
01:27:40,450 --> 01:27:46,450
you're really, really confused,
what we can do what Morales FRP

24604
01:27:46,480 --> 01:27:50,890
to download, do a quick search
on this. We even come right to

24605
01:27:50,890 --> 01:27:54,370
the documentation, connecting
ganache to Morales note for Mac

24606
01:27:54,370 --> 01:27:58,090
users download FRP dot Darwin
dot bla bla bla for the nosh

24607
01:27:58,090 --> 01:28:01,120
proxy server. So I'm on a Mac.
So I'm going to download this

24608
01:28:01,120 --> 01:28:05,170
Darwin AMD 64. And for look at
the releases, that's the first

24609
01:28:05,170 --> 01:28:08,590
one at the top, Darwin AMD 64.
So this is the one that I'm

24610
01:28:08,590 --> 01:28:09,520
going to go ahead and download.

24611
01:28:10,900 --> 01:28:13,840
I'm gonna click it, I'm going to
download it. Once I have it

24612
01:28:13,840 --> 01:28:16,090
downloaded, we're going to open
it up, and we're gonna get a

24613
01:28:16,090 --> 01:28:18,850
folder and we're gonna get a
folder that looks like this. The

24614
01:28:18,850 --> 01:28:23,530
main things that we need are
going to be f RP and FRP C dot

24615
01:28:23,530 --> 01:28:27,010
ini. F RPC is going to be the
executable it's going to be what

24616
01:28:27,010 --> 01:28:31,000
we're going to run to connect
our blockchain node to Morales,

24617
01:28:31,030 --> 01:28:34,930
and F RPC dot ini is going to be
basically the config file to do

24618
01:28:34,930 --> 01:28:38,470
this. Now, again, this is one of
the sections where downloading

24619
01:28:38,470 --> 01:28:40,510
this is going to be one of the
hardest steps here. So if you

24620
01:28:40,510 --> 01:28:43,180
get lost, please ask questions
in the GitHub, please ask

24621
01:28:43,180 --> 01:28:46,060
questions in the Morales forum,
there is a Morales forum as

24622
01:28:46,060 --> 01:28:48,550
well, where you can ask a ton of
different questions. And please

24623
01:28:48,580 --> 01:28:51,400
check out the troubleshooting as
well. But what I'm going to do

24624
01:28:51,460 --> 01:28:54,490
is I'm going to create a new
folder in here new folder called

24625
01:28:55,150 --> 01:28:58,930
F R P. And I'm doing it in here
just to make it a little easier.

24626
01:28:58,930 --> 01:29:01,330
But you could really put this
wherever you want, and then

24627
01:29:01,330 --> 01:29:03,640
always refer back to it. And
what I'm going to do is I'm

24628
01:29:03,640 --> 01:29:07,210
going to take I'm going to copy
these two files, and place it

24629
01:29:07,210 --> 01:29:12,340
into this FRP folder. So now I
have FRP C, and F RPC that ini

24630
01:29:12,430 --> 01:29:15,490
if you click on the F RPC, it's
going to be like, hey, it's

24631
01:29:15,490 --> 01:29:18,280
binary, you can't really look at
this, don't click that, it'll

24632
01:29:18,280 --> 01:29:21,310
just be a whole bunch of
nonsense, but the F RPC dot ini

24633
01:29:21,340 --> 01:29:24,910
looks like a pretty typical
config file. And this is what

24634
01:29:24,910 --> 01:29:28,270
we're going to adjust. If we
even go back to our morale

24635
01:29:28,270 --> 01:29:32,140
server, it'll give you what you
need down here. And we're using

24636
01:29:32,140 --> 01:29:36,220
hard hat. So we're going to copy
everything here. We're gonna go

24637
01:29:36,220 --> 01:29:40,210
back to our F RPC dot ini, and
then just paste whatever is in

24638
01:29:40,210 --> 01:29:43,570
there in here. And that's how
we're going to tell this F RPC

24639
01:29:43,570 --> 01:29:46,720
thing that we need to connect. I
haven't tried this out for users

24640
01:29:46,720 --> 01:29:50,410
using WsL. So if you're using
WsL, let us know in the full

24641
01:29:50,410 --> 01:29:53,410
blockchain solidity course, Jas,
make a new discussion, if you

24642
01:29:53,410 --> 01:29:56,860
haven't seen it already, saying,
Hey, I'm using WsL for the F

24643
01:29:56,860 --> 01:29:59,920
RPC. And here's what you need to
use. And then at the bottom, it

24644
01:29:59,920 --> 01:30:03,490
says, run and enjoy. I'm running
on a Mac OS, which runs Linux

24645
01:30:03,490 --> 01:30:06,130
commands, so I can just copy
this, I'll create a new

24646
01:30:06,130 --> 01:30:09,790
terminal. And what I'm going to
do is I'm going to cd into that

24647
01:30:09,790 --> 01:30:14,710
FRP folder. And I'm going to
paste that thing that I just

24648
01:30:14,770 --> 01:30:17,380
that I just copied from Ross. So
we're running that F RPC

24649
01:30:17,380 --> 01:30:22,960
executable dash c, which is dash
config, F RPC dot ini. If I hit

24650
01:30:22,960 --> 01:30:27,670
Enter, it's gonna say log into
server success, get run ID,

24651
01:30:27,670 --> 01:30:30,580
blah, blah, server, UDP port,
and then a whole bunch of other

24652
01:30:30,580 --> 01:30:33,970
stuff. If you're seeing success
stuff here, that means you did

24653
01:30:33,970 --> 01:30:37,810
it right. And you can hit CTRL C
to cancel because we're not

24654
01:30:37,810 --> 01:30:40,720
going to keep running it. Now,
if you want to just run this,

24655
01:30:40,750 --> 01:30:43,390
you absolutely can. But I'm
going to show you another way to

24656
01:30:43,390 --> 01:30:48,220
do this. And this is using the
Morales admin CLI. So everything

24657
01:30:48,220 --> 01:30:50,770
that we're doing here, all these
buttons that we're pressing,

24658
01:30:50,890 --> 01:30:53,740
Morales actually comes with this
thing called the Morales admin

24659
01:30:53,740 --> 01:30:57,100
CLI or the command line
interface. So this is a way for

24660
01:30:57,100 --> 01:30:59,530
us to connect and run all these
buttons and stuff that we're

24661
01:30:59,530 --> 01:31:02,950
pressing right from our terminal
and right from our shell. So I'm

24662
01:31:02,950 --> 01:31:05,740
going to show you a couple of
commands on how to work with the

24663
01:31:05,740 --> 01:31:08,590
admin CLI. And we're going to be
working with a lot of admin CLI

24664
01:31:08,590 --> 01:31:11,500
commands. But all we're going to
do is npm install dash g

24665
01:31:11,500 --> 01:31:15,130
Morales, admin CLI or for us
yarn Global Add. So we're going

24666
01:31:15,130 --> 01:31:20,410
to grab that will do yarn,
Global Add routes, admin CLI

24667
01:31:20,440 --> 01:31:25,270
like that. And now we should be
able to run Morales admin CLI

24668
01:31:26,200 --> 01:31:28,420
and see a whole bunch of stuff
like that. And if you ran

24669
01:31:28,420 --> 01:31:32,530
routes, admin CLI, we have all
this stuff. And one of the big

24670
01:31:32,530 --> 01:31:34,390
ones, one of the important ones
that we're going to be working

24671
01:31:34,390 --> 01:31:39,250
with is this connect local dev
chain. So running this F RPC

24672
01:31:39,250 --> 01:31:43,600
dash c dash f RPC ini. That's
going to be the same as running

24673
01:31:43,600 --> 01:31:47,530
this connect local dev chain.
Now what I like to do is jump

24674
01:31:47,530 --> 01:31:51,010
into our package dot JSON. And
we'll create an additional

24675
01:31:51,010 --> 01:31:55,090
script in here for us to just
run yarn, whatever the name is

24676
01:31:55,090 --> 01:31:57,850
that we want, and just to do
that, and just to make it a lot

24677
01:31:57,880 --> 01:32:01,570
easier for us to connect our
local dev chain so underneath

24678
01:32:01,570 --> 01:32:04,420
lint, I'm going to do a calm
Ma'am, I'm going to create a new

24679
01:32:04,420 --> 01:32:09,310
command. I'm gonna say Morales
sync. And we're going to run the

24680
01:32:09,310 --> 01:32:14,230
Morales admin CLI version of
this f RPC dash c thing. So what

24681
01:32:14,230 --> 01:32:16,960
we're going to do in here is
we're going to say mirallas

24682
01:32:17,590 --> 01:32:27,010
admin CLI, connect local dev
chain, dash dash chain, hard

24683
01:32:27,010 --> 01:32:32,560
hat, dash dash mirallas. Capital
sub domain.

24684
01:32:33,760 --> 01:32:36,100
This is where we're going to put
the subdomain of a morale

24685
01:32:36,100 --> 01:32:40,900
server, which if we go to, we go
back to our routes, admin data

24686
01:32:40,900 --> 01:32:44,050
servers, we can go back to
server details. So it's going to

24687
01:32:44,050 --> 01:32:47,200
be not the HTTPS, it's just
going to be from here all the

24688
01:32:47,200 --> 01:32:51,100
way to the.com. So not even the
port, we're going to grab that

24689
01:32:51,220 --> 01:32:54,730
we're going to paste that there.
And then we're going to do space

24690
01:32:54,760 --> 01:33:04,570
dash dash f RPC path is going to
be dot slash F RPC, slash FRP

24691
01:33:04,570 --> 01:33:07,810
slash F RPC. Now if we save
this, and we run it, it's not

24692
01:33:07,810 --> 01:33:11,350
going to work though. So if I
run yarn with our new script,

24693
01:33:11,620 --> 01:33:14,770
Morales sync, it's gonna say
specify Morales API key, it's

24694
01:33:14,770 --> 01:33:18,400
going to give us this prompt.
And in our dashboard, we have

24695
01:33:18,400 --> 01:33:21,820
our API key, which we can copy,
we can paste it, and then API

24696
01:33:21,820 --> 01:33:24,580
secret, we can copy and then
paste it. And then we'll say

24697
01:33:24,580 --> 01:33:27,460
starting connection to hard hat,
which is great. But that's

24698
01:33:27,460 --> 01:33:29,980
really annoying. And I don't
want to have to do that. So

24699
01:33:29,980 --> 01:33:31,960
we're going to Ctrl C, we're
going to kill that. And what we

24700
01:33:31,960 --> 01:33:36,940
can do is we can go into our dot
env. And we can actually add

24701
01:33:36,970 --> 01:33:40,750
those as environment variables
that Morales is expecting. So

24702
01:33:40,780 --> 01:33:44,380
when we run this Morales admin
CLI, it'll check our dot env

24703
01:33:44,380 --> 01:33:50,530
file for Morales API key, which
we can copy right here. And then

24704
01:33:50,680 --> 01:33:57,040
Morales API secret, which we can
copy, and paste right here. Now,

24705
01:33:57,040 --> 01:33:59,920
the reason that these aren't
capital and doing next public,

24706
01:33:59,950 --> 01:34:03,670
these are not going to be part
of our front end piece. These

24707
01:34:03,670 --> 01:34:06,760
are keys that we're using on the
back end to test and for our

24708
01:34:06,760 --> 01:34:10,240
local dev chain connection. So
we don't need to do next public,

24709
01:34:10,240 --> 01:34:12,520
we're just going to leave it
like this. But now if I hit up

24710
01:34:12,670 --> 01:34:15,700
and run yarn Morales sync,
again, it's not going to prompt

24711
01:34:15,700 --> 01:34:18,640
me this time, it's just gonna
say starting connection to hard

24712
01:34:18,640 --> 01:34:21,730
hat. And if you see this, this
starting connection to hard hat

24713
01:34:21,730 --> 01:34:24,940
bit, we can come back to our
servers, we'll go to dev chain

24714
01:34:24,940 --> 01:34:28,930
proxy servers, we'll hit this
disconnected button and refresh.

24715
01:34:29,020 --> 01:34:32,530
And if you see connected, you've
successfully connected our heart

24716
01:34:32,530 --> 01:34:37,060
add node, which is running here
to our Morales server, which is

24717
01:34:37,090 --> 01:34:40,570
awesome. And in fact, if you sit
on your heart had no terminal,

24718
01:34:40,960 --> 01:34:45,520
you'll see the actual RPC calls
to our blockchain here. And

24719
01:34:45,520 --> 01:34:49,000
you'll see Morales is
consistently calling f block

24720
01:34:49,030 --> 01:34:55,780
number to make sure it's up to
date with what it has. So how do

24721
01:34:55,780 --> 01:34:59,440
we tell a morale server to start
listening for events? Well,

24722
01:34:59,470 --> 01:35:02,470
there are two ways we can do
this. The first way is with the

24723
01:35:02,470 --> 01:35:06,370
user interface. So we can go to
view details, we'll go to sync.

24724
01:35:06,520 --> 01:35:09,670
And right now it says no sync
services installed. So we'll hit

24725
01:35:09,700 --> 01:35:14,170
Add a new sync. And we can see
sync and watch address and sync

24726
01:35:14,170 --> 01:35:16,540
and watch contract events, we
can watch the address for

24727
01:35:16,540 --> 01:35:20,590
transactions or we can watch
some address for any events. And

24728
01:35:20,590 --> 01:35:23,050
we can manually add all our
information here, you can select

24729
01:35:23,050 --> 01:35:26,380
the chain description, decide if
we want to optionally sync

24730
01:35:26,380 --> 01:35:29,680
historical, we could put the
topic of the event, the ABI of

24731
01:35:29,680 --> 01:35:32,110
the event, the address of the
event filter, and then a table

24732
01:35:32,110 --> 01:35:34,990
name. Or we could do all this
programmatically, which is what

24733
01:35:34,990 --> 01:35:37,360
we're going to do, we'll create
a little script that we can run,

24734
01:35:37,390 --> 01:35:40,450
tell our morale server to watch
for those scripts. And we'll see

24735
01:35:40,450 --> 01:35:44,740
our database get upgraded to
listen for those events. So back

24736
01:35:44,740 --> 01:35:48,340
in our code, we're going to
create a new file called add

24737
01:35:48,490 --> 01:35:52,900
events that Jas now we have one
terminal that's running our

24738
01:35:52,930 --> 01:35:55,300
front end one terminal that's
running our blockchain one

24739
01:35:55,300 --> 01:35:58,120
terminal that syncing our
blockchain with morass. And now

24740
01:35:58,120 --> 01:36:00,340
we're going to do another
terminal. For anything else we

24741
01:36:00,340 --> 01:36:02,650
want to do like run little
scripts become the Morales

24742
01:36:02,650 --> 01:36:05,950
docks, and you click connect
with SDK, there's a ton of

24743
01:36:05,950 --> 01:36:08,260
different ways we can actually
connect with the SDK, we've

24744
01:36:08,290 --> 01:36:10,990
already learned how to connect
with react by using React

24745
01:36:10,990 --> 01:36:14,140
Morales. Now we're going to
connect with no JS since we're

24746
01:36:14,140 --> 01:36:17,350
going to run a little Morales
script. And here's like a little

24747
01:36:17,350 --> 01:36:20,020
example of what it looks like in
the documentation. But I'm gonna

24748
01:36:20,020 --> 01:36:25,600
go ahead, so I'm gonna say const
Morales, equals require oralis

24749
01:36:25,630 --> 01:36:29,410
slash node. And we're going to
import the node extension of the

24750
01:36:29,410 --> 01:36:33,100
Morales package into our script
here, we're going to require dot

24751
01:36:33,100 --> 01:36:33,640
env

24752
01:36:34,930 --> 01:36:39,040
dot config, which means we're
going to need to install dot env

24753
01:36:39,160 --> 01:36:44,350
yarn add dash dash dev dot env.
And now we have to tell our

24754
01:36:44,350 --> 01:36:47,170
morale server all the same
information that we would need

24755
01:36:47,170 --> 01:36:49,270
to tell it on the user
interface. So one of the first

24756
01:36:49,270 --> 01:36:51,850
things that we're going to need
is the address of our contract.

24757
01:36:51,880 --> 01:36:55,450
We're gonna need to say const
contract address equals and this

24758
01:36:55,450 --> 01:36:58,360
is where we go oh, well, how do
we how do we get that contract

24759
01:36:58,360 --> 01:37:01,810
address? The easy way to do this
is we just go back where we're

24760
01:37:01,810 --> 01:37:05,350
running the blockchain And we'd
grab where that NFC marketplace

24761
01:37:05,350 --> 01:37:09,100
is deployed. And similar to our
smart contract lottery where we

24762
01:37:09,100 --> 01:37:11,590
created an update front end
script, we're gonna do the exact

24763
01:37:11,590 --> 01:37:15,250
same thing here. So back in our
heart hat, NFT marketplace, and

24764
01:37:15,250 --> 01:37:18,940
if T code, we go to our deploy
script or deploy folder, we're

24765
01:37:18,940 --> 01:37:25,510
gonna create a new file called
99 Dash update, front end dot j

24766
01:37:25,510 --> 01:37:27,970
s, and we're gonna create a
little bit of our deploy process

24767
01:37:27,970 --> 01:37:31,060
that will automatically update
our front end. So we can just

24768
01:37:31,060 --> 01:37:34,660
grab the network address from a
file that is programmatically

24769
01:37:34,660 --> 01:37:38,920
created. So we're gonna do
module dot exports equals async

24770
01:37:38,920 --> 01:37:44,080
function. And now we'll say if
process dot EMV that update

24771
01:37:44,140 --> 01:37:53,620
front end, then console dot log,
updating front end so that in

24772
01:37:53,620 --> 01:37:57,700
our dot EMV, we have update
front end equals true. And that

24773
01:37:57,700 --> 01:38:00,250
will be how we decide whether or
not we actually want to update

24774
01:38:00,250 --> 01:38:03,250
the front end. And then we'll
create a function called up date

24775
01:38:03,250 --> 01:38:07,960
contract addresses, which we
will await. And this will update

24776
01:38:07,960 --> 01:38:10,300
the contract addresses of our
front end. So let's make that

24777
01:38:10,300 --> 01:38:16,450
function. Do async function
update contract addresses, make

24778
01:38:16,450 --> 01:38:20,680
sure those are spelled the same.
So we'll say const NFT, market

24779
01:38:21,640 --> 01:38:27,160
place equals await ethers dot
get contract. And then yes, we

24780
01:38:27,160 --> 01:38:30,070
need to import const ethers
equals require hardhat, we'll

24781
01:38:30,070 --> 01:38:34,450
grab the NFT market place. And
then we're going to want to

24782
01:38:34,450 --> 01:38:39,130
write our files in here to
someplace in our front end code

24783
01:38:39,160 --> 01:38:43,540
for us, we're going to do in a
new folder constants. And we're

24784
01:38:43,540 --> 01:38:47,950
going to create a new file in
here called network mapping dot

24785
01:38:48,700 --> 01:38:52,150
JSON. And we'll have this just
be a JSON object which keeps

24786
01:38:52,150 --> 01:38:56,050
track of all of our deployments.
So if we deploy something to

24787
01:38:56,290 --> 01:38:59,410
rink V chain will keep a list
will keep a list of it will say

24788
01:38:59,410 --> 01:39:03,940
NFT marketplace will keep a list
of all the addresses of the IoT

24789
01:39:03,940 --> 01:39:08,980
marketplace, comma basic NF T,
right, and then I list of all

24790
01:39:08,980 --> 01:39:11,470
those right now we don't have
anything deployed. So we'll just

24791
01:39:11,470 --> 01:39:15,880
have it be an empty JSON object.
Now back in our deploy script in

24792
01:39:15,880 --> 01:39:19,360
the hard hat NFT marketplace
project, we're going to keep

24793
01:39:19,360 --> 01:39:22,120
track of that location. So right
at the top, we're gonna say

24794
01:39:22,120 --> 01:39:29,230
const. Front, and contracts file
equals, and we'll place where it

24795
01:39:29,230 --> 01:39:34,630
is according to your file setup.
So if I do cd dot dot slash,

24796
01:39:35,260 --> 01:39:39,820
next JS NFT, marketplace, free
code, Camp constants, network

24797
01:39:39,820 --> 01:39:42,760
mapping dot JSON, this is where
mine is. So you're going to want

24798
01:39:42,760 --> 01:39:46,780
to put it wherever your location
is in relation to your heart at

24799
01:39:46,780 --> 01:39:49,570
Mt marketplace Free Code Camp,
it's my front end contract file,

24800
01:39:49,600 --> 01:39:51,520
it's going to be right here. Now
that we have all that we're

24801
01:39:51,520 --> 01:39:55,120
going to get the chain ID. So
we're gonna say const, chain ID

24802
01:39:55,600 --> 01:40:01,690
equals network dot config dot
chain, id.to string. And we're

24803
01:40:01,690 --> 01:40:05,740
going to need to import network
from hard hat as well. And then

24804
01:40:05,770 --> 01:40:08,590
we're going to want to read from
this network mapping file to see

24805
01:40:08,590 --> 01:40:13,420
what's currently in there. So
we'll say const. Contract

24806
01:40:13,570 --> 01:40:19,510
addresses equals and we're gonna
do a JSON dot parse Fs dot read

24807
01:40:19,540 --> 01:40:28,660
file sync, front, and front and
contracts. File comma UTF,

24808
01:40:28,660 --> 01:40:33,010
eight. Now here's what we're
gonna say, if chain ID is in

24809
01:40:33,010 --> 01:40:38,080
contract. addresses, let's say
if this list of contract

24810
01:40:38,080 --> 01:40:41,860
addresses doesn't include the
marketplace, then added on,

24811
01:40:42,010 --> 01:40:46,540
we're gonna say if contract
addresses of chain ID of the

24812
01:40:46,570 --> 01:40:55,600
NFT. Marketplace will say dot
includes NF T, market, Mar get

24813
01:40:56,020 --> 01:41:02,290
place dot address, then so we'll
say contract address says chain

24814
01:41:02,290 --> 01:41:11,920
ID NFT marketplace, dot push NFT
marketplace dot address else

24815
01:41:12,010 --> 01:41:13,420
we're gonna say contract

24816
01:41:14,440 --> 01:41:20,860
address says of chain ID of NFT
marketplace, which is going to

24817
01:41:20,860 --> 01:41:27,610
be a new entry now equals NFT.
Market market place dot address.

24818
01:41:28,300 --> 01:41:31,630
So now we've updated our
contract addresses object and we

24819
01:41:31,630 --> 01:41:34,540
just need to write it back to
the network mapping. So now

24820
01:41:34,540 --> 01:41:39,820
we're gonna say Fs dot right
file sync front and contracts

24821
01:41:39,970 --> 01:41:47,050
file comma JSON dot string five
contract addresses and then at

24822
01:41:47,050 --> 01:41:51,580
the bottom we'll do module dot
exports dot tags equals and

24823
01:41:51,580 --> 01:41:56,800
we'll say all or front end. Now
what we can do is we can run

24824
01:41:56,830 --> 01:42:02,110
just this update front end
script with yarn hardhat deploy

24825
01:42:02,620 --> 01:42:07,480
dashed dash, network localhost.
And we only want to do this

24826
01:42:07,510 --> 01:42:11,680
update front end script. So we
say dash dash tags front end,

24827
01:42:11,860 --> 01:42:15,790
and we run this, and I ran into
an error FS is not defined, oh,

24828
01:42:15,790 --> 01:42:22,300
I forgot to do const Fs equals
require Fs stride again, cannot

24829
01:42:22,300 --> 01:42:26,080
set properties of undefined NFT
marketplace. Oops. And that's

24830
01:42:26,080 --> 01:42:30,790
because this line is off instead
of this line, sorry. Basically,

24831
01:42:30,790 --> 01:42:32,890
right now, what it's saying is,
it's saying, hey, this NFT

24832
01:42:32,890 --> 01:42:36,670
marketplace thing doesn't exist.
So we need to make it exists. So

24833
01:42:36,670 --> 01:42:41,650
now we'll say contract addresses
of chain ID equals a new entry

24834
01:42:41,830 --> 01:42:45,550
of NFT marketplace and adds its
first parameter, it's going to

24835
01:42:45,550 --> 01:42:52,180
be NF T, Mark gets placed dot
address, like that. Now we can

24836
01:42:52,180 --> 01:42:56,110
run it, and updating front end
looks like it's done. So if we

24837
01:42:56,110 --> 01:42:59,620
go back to our front end, we now
see we have an entry for

24838
01:42:59,620 --> 01:43:03,040
localhost with NFC marketplace
with the address in our network

24839
01:43:03,040 --> 01:43:05,620
mapping dot JSON. So if you did
that correctly, you should get

24840
01:43:05,620 --> 01:43:08,620
this. If not, if you're having a
hard time with that you can, of

24841
01:43:08,620 --> 01:43:10,960
course, just go ahead and hard
coded in but I do highly

24842
01:43:10,960 --> 01:43:12,880
recommend you do it
programmatically, because your

24843
01:43:12,880 --> 01:43:14,890
life is going to be a lot
better. So cool. We have this

24844
01:43:14,890 --> 01:43:17,980
update front end script that
works now, so we can put this

24845
01:43:17,980 --> 01:43:21,370
back off to the side. And let's
keep going. So we now have this

24846
01:43:21,370 --> 01:43:24,640
network mapping file with
contract addresses based off of

24847
01:43:24,640 --> 01:43:27,820
the chain ID. So what we can do
is we can pull that in as well,

24848
01:43:28,150 --> 01:43:35,170
we'll say const contract,
address says equals require dot

24849
01:43:35,170 --> 01:43:41,530
slash constants, slash network
mapping dot JSON. And now we can

24850
01:43:41,530 --> 01:43:44,740
get the contract address based
off the chain ID. So we'll say

24851
01:43:44,770 --> 01:43:54,040
chain ID equals process dot E
and V dot chain ID, or 31337. So

24852
01:43:54,040 --> 01:43:59,020
in our data and V, we'll make a
new entry called Chain ID. And

24853
01:43:59,020 --> 01:44:03,250
for now, we'll do 31337. And now
we can get the contract address

24854
01:44:03,310 --> 01:44:07,930
by saying contract address
equals contract addresses at the

24855
01:44:07,930 --> 01:44:15,310
chain ID of n, f t, Mark get
place of zero. So we're going to

24856
01:44:15,310 --> 01:44:18,940
go into that network mapping, go
to the chain, Id go to the NFT

24857
01:44:18,940 --> 01:44:21,880
marketplace and get the most
recently deployed NFT

24858
01:44:21,880 --> 01:44:24,520
marketplace boom. So now we have
the contract address contract

24859
01:44:24,520 --> 01:44:28,120
address says Excuse me. Now in
our add events, we'll create a

24860
01:44:28,120 --> 01:44:31,390
new function kind of similar to
what we're doing, we'll do async

24861
01:44:31,930 --> 01:44:35,290
function main. And this will be
our main function. And then of

24862
01:44:35,290 --> 01:44:38,440
course, we're going to copy
paste that main script thing

24863
01:44:38,440 --> 01:44:42,400
we've been doing this whole time
domain dot then catch blah,

24864
01:44:42,400 --> 01:44:45,310
blah, blah, we go back to the
morass documentation, though, we

24865
01:44:45,310 --> 01:44:48,940
can see we're going to need to
grab our server URL, app ID

24866
01:44:49,000 --> 01:44:52,090
master key, and then start it
up. So we're gonna do the exact

24867
01:44:52,090 --> 01:44:55,120
same thing. So once again,
sorry, before we even get into

24868
01:44:55,120 --> 01:44:56,980
our main, you can do it in your
main function, if you want.

24869
01:44:57,160 --> 01:45:02,200
We'll say const server URL
equals, and we can just grab

24870
01:45:02,200 --> 01:45:07,210
this once again, from our web.
So we'll say process web dot

24871
01:45:07,240 --> 01:45:14,860
next public Morales server URL,
we'll get the app ID equals

24872
01:45:14,860 --> 01:45:21,070
process Studien v dot next
public Morales app ID, and then

24873
01:45:21,070 --> 01:45:25,990
we'll say const, master key
equals process study v dot

24874
01:45:26,080 --> 01:45:30,310
master key. So we don't have a
master key in here yet. So we'll

24875
01:45:30,310 --> 01:45:34,480
create a new one called master
key. We'll go back to our

24876
01:45:34,870 --> 01:45:38,350
Morales front end, we'll close
out of this, we'll hit View

24877
01:45:38,350 --> 01:45:42,400
Details. And we'll grab that
master key. So we'll copy that,

24878
01:45:42,460 --> 01:45:45,460
go back to our code editor and
paste it in. And now we have a

24879
01:45:45,460 --> 01:45:49,600
master key in our web as well.
We don't want our master key on

24880
01:45:49,600 --> 01:45:52,420
our front end. So we're not
going to put next public like

24881
01:45:52,420 --> 01:45:54,820
that. Now, the first thing we're
going to do in our main function

24882
01:45:55,060 --> 01:45:59,950
is we're going to do await
Morales dot start server URL,

24883
01:46:00,970 --> 01:46:05,380
app ID and master key as the
input parameters for this will

24884
01:46:05,380 --> 01:46:11,140
do a little console dot log,
working with contract address,

24885
01:46:11,500 --> 01:46:15,820
contract address. Now we're
gonna go ahead and add all those

24886
01:46:15,910 --> 01:46:18,880
same pieces that we see on the
UI. So what are the events we

24887
01:46:18,880 --> 01:46:23,110
want to listen for? Well, if we
go back to our code here, so we

24888
01:46:23,110 --> 01:46:27,010
have our NFT marketplace, where
just type in event we have item

24889
01:46:27,010 --> 01:46:30,190
listed item bought an item
cancelled. So we have three

24890
01:46:30,190 --> 01:46:33,550
events we want to listen and a
Morales, they have this add new

24891
01:46:33,550 --> 01:46:35,590
events synced from code, which
we're basically going to be

24892
01:46:35,590 --> 01:46:38,620
following. To do this, we need
to obviously start and then

24893
01:46:38,620 --> 01:46:42,940
create our options for the
event. We have the chain address

24894
01:46:43,000 --> 01:46:47,650
topic, abi elimite, table name
and sync historical and then we

24895
01:46:47,650 --> 01:46:51,940
just do Morales dot Cloud dot
run, watch cloud event options

24896
01:46:51,940 --> 01:46:54,040
use master key. And that's
pretty much it. So we're going

24897
01:46:54,040 --> 01:46:57,250
to follow these documents here
to do our code. So let's start

24898
01:46:57,250 --> 01:47:00,610
with item listed. Let's create
some options for our IDed listed

24899
01:47:00,640 --> 01:47:04,750
event. So we'll say let item
listed options, or we could do

24900
01:47:05,140 --> 01:47:08,410
const if we want to, but I'm
just gonna do let item listed

24901
01:47:08,410 --> 01:47:12,340
options equals. And first we're
gonna need the chain ID, which

24902
01:47:12,340 --> 01:47:16,180
we have, because we're getting
it from Morales. Now the first

24903
01:47:16,180 --> 01:47:20,620
thing to point out about chain
ID is that ralis understands a

24904
01:47:20,620 --> 01:47:25,930
local chain is 1337. So even if
you're on 31337, if you're doing

24905
01:47:25,930 --> 01:47:29,740
a local development, you got to
switch it to 1337. So we're

24906
01:47:29,740 --> 01:47:33,640
going to make another variable
called Morales chain ID. And

24907
01:47:33,640 --> 01:47:40,750
we're just going to say, let
Morales chain ID equals chain ID

24908
01:47:41,770 --> 01:47:52,150
equals 31337. Question mark
311337. Otherwise, chain ID but

24909
01:47:52,150 --> 01:47:55,840
we're saying since Morales
understands that any local Dev

24910
01:47:55,840 --> 01:48:01,210
is going to be 1337, we're going
to say if chain ID equals 31337.

24911
01:48:01,480 --> 01:48:06,580
Then have Morales chain ID equal
1337. Otherwise have an equal

24912
01:48:06,580 --> 01:48:10,090
whatever whatever our chain
ideas and in our dot env we can

24913
01:48:10,090 --> 01:48:14,320
decide okay, if we want to do
rink B, localhost main net, etc.

24914
01:48:14,350 --> 01:48:17,470
We're gonna say Okay, chain ID
morass will do your Morales

24915
01:48:17,470 --> 01:48:20,650
chain ID, comma, we'll say what
else do we need? We did the

24916
01:48:20,650 --> 01:48:24,220
chain ID, we're gonna skip
description, a sync historical.

24917
01:48:24,250 --> 01:48:27,880
So hit sync historical allows
the node to go back throughout

24918
01:48:27,880 --> 01:48:30,910
the blockchain, grab all the
events ever emitted by that

24919
01:48:30,910 --> 01:48:34,990
contract. Since this is a very
small local blockchain will just

24920
01:48:34,990 --> 01:48:40,120
say sync historical is true.
Like that. Okay, what else do we

24921
01:48:40,120 --> 01:48:43,450
need? Okay, we need the topic,
the topic is going to be your

24922
01:48:43,570 --> 01:48:47,020
event information. So to get the
topic, go back to our event

24923
01:48:47,020 --> 01:48:49,180
code, and the topic is just
gonna be the name of the event,

24924
01:48:49,660 --> 01:48:52,780
plus the type of the parameters.
So we're gonna go back to our

24925
01:48:52,780 --> 01:48:56,110
code, we're gonna go back to
here, we're gonna say, topic is

24926
01:48:56,110 --> 01:49:00,910
going to be item listed, and it
takes an address, an address, an

24927
01:49:00,910 --> 01:49:06,700
address, you went to 56, and a
UNT 256, address address, you

24928
01:49:06,700 --> 01:49:10,060
interviewed six, YouTube and
six. Those problems seem like

24929
01:49:10,060 --> 01:49:13,990
that, we also need the API of
just the event, which again, we

24930
01:49:13,990 --> 01:49:18,340
can find we go back to our hard
hat project, we go to artifacts,

24931
01:49:18,550 --> 01:49:22,840
we go to contracts. And if the
marketplace dot soul NFT

24932
01:49:22,840 --> 01:49:26,590
marketplace dot JSON, our ABI
starting from here is going to

24933
01:49:26,590 --> 01:49:29,620
be the ABI of the whole
contract. And we just want that

24934
01:49:29,830 --> 01:49:33,340
item listed event. So we did
Ctrl F, and we found it here.

24935
01:49:33,400 --> 01:49:36,460
And we're going to grab from
right after it says type event,

24936
01:49:36,520 --> 01:49:39,940
we're going to copy we're going
to scroll up to write up to

24937
01:49:39,970 --> 01:49:43,780
anonymous false, right, so this
bit describes the ABI of the

24938
01:49:43,780 --> 01:49:47,110
event. So we have internal type,
address, name, seller type,

24939
01:49:47,110 --> 01:49:50,950
address, and if T address token
ID price item listed, right, so

24940
01:49:50,950 --> 01:49:54,010
this is going to be the ABI of
our just our item listed event,

24941
01:49:54,040 --> 01:49:57,310
we can take that and we just
stick it in here, hit save, and

24942
01:49:57,310 --> 01:49:59,620
mine auto format it to get rid
of the parentheses. Okay, what

24943
01:49:59,620 --> 01:50:03,070
else do we need, we have the
topic, we have the ABI, we

24944
01:50:03,070 --> 01:50:05,650
already have the address, we're
not going to do a filter. And

24945
01:50:05,650 --> 01:50:08,230
then we need a table name. So
we're going to do a new line,

24946
01:50:08,230 --> 01:50:12,400
we'll say table name, it's going
to be item listed. And this is

24947
01:50:12,400 --> 01:50:15,670
going to be the name of the
table that we update in our

24948
01:50:15,670 --> 01:50:18,760
database. So we're gonna get a
new table in here called item

24949
01:50:18,760 --> 01:50:21,400
listed, and it's just gonna be
filled with information about

24950
01:50:21,400 --> 01:50:23,740
the item listed event. And
that's it right and we would hit

24951
01:50:23,740 --> 01:50:26,500
confirm if we were doing this on
the UI. And since we're doing

24952
01:50:26,500 --> 01:50:29,200
here, we'll just hit save, this
is one of our events, we want to

24953
01:50:29,200 --> 01:50:32,500
do this for all of our events.
Let's do it now for item bought.

24954
01:50:32,530 --> 01:50:37,060
So we'll say let's, item bought
options, equals and we'll repeat

24955
01:50:37,060 --> 01:50:39,700
the process, some of the stuff
at the top is gonna be the same,

24956
01:50:39,730 --> 01:50:41,950
the chain it is gonna be the
same sync historical is gonna be

24957
01:50:41,950 --> 01:50:44,920
the same. So we can just grab
those two, paste them down here

24958
01:50:44,920 --> 01:50:48,160
for item, but the topic is going
to be different. The topic is

24959
01:50:48,160 --> 01:50:51,820
going to be item bot is the name
of the event, it's going to take

24960
01:50:51,820 --> 01:50:59,380
an address, an address, a un 256
and a un 256. The ABI is going

24961
01:50:59,380 --> 01:51:02,680
to be different. Once again,
we're gonna go to our Hardhead

24962
01:51:02,680 --> 01:51:06,370
NFT marketplace, we'll look for
a bot, you'd find this event

24963
01:51:06,370 --> 01:51:10,420
here. We'll copy this, go back,
we'll paste it in here, we now

24964
01:51:10,420 --> 01:51:16,300
have item bot, we'll give it a
table name of item bot. And then

24965
01:51:16,300 --> 01:51:24,310
one more then we have let item
cancelled options equals and

24966
01:51:24,310 --> 01:51:29,890
we'll do chain ID that's going
to be rouse chain ID gonna be

24967
01:51:29,890 --> 01:51:34,120
the same boilerplate from the
top address. Contract address

24968
01:51:34,300 --> 01:51:37,210
topic is going to be different.
The topic for this it's called

24969
01:51:37,240 --> 01:51:42,550
item cancelled, and it takes an
address, an address and a UNT

24970
01:51:42,580 --> 01:51:48,700
256 will say sync. Historical
will be true, historical is

24971
01:51:48,700 --> 01:51:52,810
true. And then we need the ABI.
Once again we can go back to our

24972
01:51:52,810 --> 01:51:56,620
hard hat, compile information we
can look for item cancelled,

24973
01:51:57,370 --> 01:52:02,650
grab that ABI of that event.
Copy that. Come back to our

24974
01:52:03,040 --> 01:52:06,460
running code pasted in. Oops and
I didn't give item canceled.

24975
01:52:06,460 --> 01:52:07,750
Let's give item canceled the

24976
01:52:08,530 --> 01:52:14,350
table name, which will be item
canceled. So now if I zoom out

24977
01:52:14,350 --> 01:52:17,560
just a hair, I now have item
cancelled options, item bought

24978
01:52:17,560 --> 01:52:21,580
options. And item listed options
are telling Ross Hey, listen for

24979
01:52:21,580 --> 01:52:25,660
these events, whenever you hear
an item canceled event, stick

24980
01:52:25,660 --> 01:52:28,750
all this stuff into a database.
Whenever you hear an item bought

24981
01:52:28,780 --> 01:52:31,360
event, stick all this in a
database, whenever it emits an

24982
01:52:31,360 --> 01:52:34,090
item listed, stick all this in
in a database so that we can

24983
01:52:34,090 --> 01:52:36,850
read from it. So we're indexing
these events so that we can

24984
01:52:36,850 --> 01:52:40,720
query them much easier. Now to
send them up to our our server

24985
01:52:40,840 --> 01:52:48,340
will say const listed response
equals await or Alice or Alice

24986
01:52:48,460 --> 01:52:55,750
dot Cloud dot run, watch
contract event will pass the

24987
01:52:55,780 --> 01:53:01,480
item listed options. And then
one more comma, and then we pass

24988
01:53:01,480 --> 01:53:05,500
an object in here where we're
just gonna say use master key is

24989
01:53:05,500 --> 01:53:08,080
going to be true. And we'll do
the same thing we'll say const

24990
01:53:08,410 --> 01:53:13,810
bot response or passing the bot
item options. So we'll say bot

24991
01:53:13,810 --> 01:53:19,960
response equals await or else
dot Cloud dot run, watch

24992
01:53:19,960 --> 01:53:28,180
contract, event, comma, item
bought options. Comma, use

24993
01:53:28,180 --> 01:53:34,060
master key that's going to be
true. And then finally Kant's

24994
01:53:34,150 --> 01:53:42,130
canceled response equals await
oralis dot Cloud dot run, watch

24995
01:53:42,130 --> 01:53:50,620
contract event, comma, item
canceled options, comma use

24996
01:53:50,620 --> 01:53:54,820
master key is going to be true.
Now this Morales dot Cloud dot

24997
01:53:54,820 --> 01:53:58,390
run API call to our server that
we're making is going to return

24998
01:53:58,480 --> 01:54:00,700
a response. And let's look at
the docs to actually see what

24999
01:54:00,700 --> 01:54:03,460
that response looks like if it
worked out. Well. In the

25000
01:54:03,460 --> 01:54:07,990
terminal, you'll see success
true. So this is the return

25001
01:54:08,020 --> 01:54:11,140
we're getting from the API. So
just to make sure everything

25002
01:54:11,140 --> 01:54:17,050
goes well, I'll do an if listed.
response dot success, we're

25003
01:54:17,050 --> 01:54:20,800
getting that success object from
the rails server, we'll just do

25004
01:54:20,800 --> 01:54:28,000
a console dot log success
database updated with watching

25005
01:54:29,020 --> 01:54:35,260
events. And then else we'll say
console dot log, something went

25006
01:54:35,530 --> 01:54:39,160
wrong with a duck. And of
course, we're not just looking

25007
01:54:39,160 --> 01:54:43,180
for let's say response dot
success to be true. We also want

25008
01:54:44,200 --> 01:54:49,690
canceled response that success
and bots response

25009
01:54:50,770 --> 01:54:55,030
is successful. Then say hey, you
did it. Otherwise say hey,

25010
01:54:55,030 --> 01:54:57,070
something went wrong. So this is
how we're going to

25011
01:54:57,070 --> 01:55:01,660
programmatically tell our server
our database to listen for

25012
01:55:01,690 --> 01:55:04,510
events. So we just do await
Murata Clodagh, run, watch

25013
01:55:04,510 --> 01:55:07,870
contract events, we pass it this
object with all these parameters

25014
01:55:07,870 --> 01:55:10,390
and flags in there. And then
that's it. And then we can send

25015
01:55:10,390 --> 01:55:14,380
them is because I put next
public Morales server URL. And

25016
01:55:14,380 --> 01:55:17,350
in my DMV, I just have next
public server URL. So let's

25017
01:55:17,350 --> 01:55:20,860
change the name here. Looks like
our server URL was wrong. And

25018
01:55:20,860 --> 01:55:24,070
our app ID name is also wrong.
So let's fix that next public

25019
01:55:24,070 --> 01:55:28,060
app ID master key looks correct.
Okay, cool. So let's know things

25020
01:55:28,060 --> 01:55:32,590
right? More Alice, like cada
run, Rasta cloud run, when we

25021
01:55:32,590 --> 01:55:36,640
run this in our database, if we
hit refresh, right now, we don't

25022
01:55:36,640 --> 01:55:41,140
see those tables in here. But
once we run this, add events.js,

25023
01:55:41,170 --> 01:55:44,140
we should call our server and we
should tell it hey, you need to

25024
01:55:44,140 --> 01:55:46,150
add these tables. And you need
to start listening for those

25025
01:55:46,150 --> 01:55:49,630
events. So in a new terminal,
we're going to run this add

25026
01:55:49,630 --> 01:55:53,110
events such as, so I'm going to
make the terminal nice big. And

25027
01:55:53,110 --> 01:55:55,540
this is where if something goes
wrong, it can be a little

25028
01:55:55,540 --> 01:55:58,660
frustrating to figure it out how
to fix this. So if you run into

25029
01:55:58,660 --> 01:56:01,480
an issue here, if something's
not working as expected, please

25030
01:56:01,480 --> 01:56:04,480
use the GitHub repo associated
with this course. And also the

25031
01:56:04,480 --> 01:56:08,260
Morales forum is here for you,
and Stack Exchange Etherium. So

25032
01:56:08,260 --> 01:56:13,660
we're going to run Node, add
events, dot j s, and we'll hit

25033
01:56:13,660 --> 01:56:17,410
enter. Okay, boom, now we see
success database updated with

25034
01:56:17,410 --> 01:56:20,830
watching events. Now, if you ran
into an issue, and you rerun it,

25035
01:56:20,860 --> 01:56:24,010
and it gets something went
wrong, there's a chance that it

25036
01:56:24,010 --> 01:56:27,370
could still be correct, right,
because it returns false. It

25037
01:56:27,370 --> 01:56:30,940
returns that there's an issue if
any of these already have the

25038
01:56:30,940 --> 01:56:34,870
table in there. So if we go back
to our database here, and we hit

25039
01:56:34,870 --> 01:56:38,770
refresh, I can now see item
bought, item canceled and item

25040
01:56:38,770 --> 01:56:40,990
listed in my database. And
again, you can see them by

25041
01:56:40,990 --> 01:56:44,560
hitting the drop down on your
server and hitting dashboard. We

25042
01:56:44,560 --> 01:56:48,670
also see event Sync Status. And
this is how our database knows

25043
01:56:48,670 --> 01:56:51,910
that it needs to be listening
for some events, and it's got

25044
01:56:51,910 --> 01:56:55,420
all the information about how to
listen for our events in here.

25045
01:56:55,510 --> 01:56:58,660
So cool. So now we are listening
for events. This is fantastic.

25046
01:56:58,690 --> 01:57:03,280
So now what this means is our
database is now listening To our

25047
01:57:03,280 --> 01:57:06,790
blockchain node, and it's
listening for events in here

25048
01:57:06,790 --> 01:57:09,460
it's listening for these item
listed item bought item,

25049
01:57:09,460 --> 01:57:12,820
cancelled events. So let's go
ahead and test this back in our

25050
01:57:12,820 --> 01:57:16,480
hardhat NFT marketplace Free
Code Camp window. We have some

25051
01:57:16,480 --> 01:57:20,380
scripts in here. One of them is
mint and list. So we went to New

25052
01:57:20,380 --> 01:57:24,160
NFT. And we listed on the
marketplace when we list an NF

25053
01:57:24,160 --> 01:57:28,390
T, well, our mirallas database
should hear that item listed

25054
01:57:28,390 --> 01:57:32,380
event and go ahead and stick it
into this item listed table that

25055
01:57:32,380 --> 01:57:35,710
it made. So for us to test this
out, let's open up our terminal

25056
01:57:35,740 --> 01:57:39,730
in our Hardhead NFT marketplace
repo. And we'll run Minton list

25057
01:57:39,760 --> 01:57:44,230
for our localhost before we
actually run it, just be sure

25058
01:57:44,260 --> 01:57:48,460
that our hard hat node is synced
up with our Morales server in

25059
01:57:48,460 --> 01:57:51,790
order for your database to
actually grab that event. Your

25060
01:57:51,820 --> 01:57:55,210
local hard hat node needs to be
connected. So we'll do yarn,

25061
01:57:55,510 --> 01:58:01,030
hard hat run scripts, mint and
list.js dash dash, network

25062
01:58:01,090 --> 01:58:05,500
localhost. Let's enter. Okay,
minting, approving listing

25063
01:58:05,500 --> 01:58:11,350
listed now if we flip back to
our database, after a quick

25064
01:58:11,350 --> 01:58:15,610
refresh, what do you know, we
see that there's an indeed an

25065
01:58:15,610 --> 01:58:18,700
item listed events in our
database, we can see information

25066
01:58:18,700 --> 01:58:21,880
about a tool we can see there's
a block hash, a timestamp, we

25067
01:58:21,880 --> 01:58:24,790
see the token ID that was
listed, we see the price of the

25068
01:58:24,790 --> 01:58:29,350
listing the transaction hash, we
see all this information about

25069
01:58:29,380 --> 01:58:32,740
our event. And now it's in this
database for us to query. So if

25070
01:58:32,740 --> 01:58:35,770
you have reached this point, you
have successfully set up an

25071
01:58:35,800 --> 01:58:38,140
indexer with the Morales
database. And you should be

25072
01:58:38,140 --> 01:58:40,720
super pumped because this is
really powerful. And now we're

25073
01:58:40,720 --> 01:58:43,270
getting advanced, we're starting
to do some advanced stuff. So if

25074
01:58:43,270 --> 01:58:46,030
you've made it this far, huge
congrats. This is already really

25075
01:58:46,030 --> 01:58:51,700
cool. Now, some other
troubleshooting help here that

25076
01:58:51,700 --> 01:58:54,730
I've run into many times myself,
let's say I've left this

25077
01:58:54,730 --> 01:58:57,460
project, and I've killed my
heart hit note, I'm going to

25078
01:58:57,460 --> 01:59:00,580
kill it right now. If I stopped,
my heart had node and I come

25079
01:59:00,580 --> 01:59:04,270
back to my Morales admin, I'm
going to view details dev chain

25080
01:59:04,270 --> 01:59:06,940
proxy server, I'm now
disconnected. And if I hit this

25081
01:59:06,940 --> 01:59:09,850
little refresh, I'm disconnected
of course, because I'm not

25082
01:59:09,850 --> 01:59:13,090
running my heart headnote
anymore. If I restart my node,

25083
01:59:13,750 --> 01:59:16,990
my note is now restarted. My
connects local dev chain command

25084
01:59:16,990 --> 01:59:20,380
is still running. If I re fresh
it, it'll now say connected,

25085
01:59:20,560 --> 01:59:24,880
which is great. However, if I go
back to my blockchain, or if I

25086
01:59:24,880 --> 01:59:28,210
go back to my hard hat, NFC
marketplace script, I run yarn,

25087
01:59:28,210 --> 01:59:31,540
hard hat script, mint and list
again, network localhost, I go

25088
01:59:31,540 --> 01:59:35,800
back to my database now, and I
do a refresh, we don't see that

25089
01:59:35,800 --> 01:59:39,940
item listed in here. So our
mirallas server is looking to

25090
01:59:39,940 --> 01:59:42,760
make sure that that the
blockchain we're working with is

25091
01:59:42,760 --> 01:59:46,630
the same one. So if we reset our
blockchain, like we did, right,

25092
01:59:46,630 --> 01:59:50,020
we canceled it and we reset it,
our database is gonna get really

25093
01:59:50,020 --> 01:59:53,830
confused. So what we have to do
is we have to hit reset local

25094
01:59:53,830 --> 01:59:57,970
chain, reset local chain, we
want to make sure that our new

25095
01:59:58,030 --> 02:00:01,030
local chain is running, and that
we're connected here. So we'll

25096
02:00:01,030 --> 02:00:04,090
hit reset local chain, and this
will tell them Ross, hey, we

25097
02:00:04,090 --> 02:00:07,510
reset the chain, it's okay,
please continue doing so. And

25098
02:00:07,510 --> 02:00:10,090
once we hit reset local chain,
we're not going to see that item

25099
02:00:10,090 --> 02:00:16,030
listed in here. However, if we
go back, and we rerun mint and

25100
02:00:16,030 --> 02:00:21,220
list network, local host with
this reset local chain. Now, if

25101
02:00:21,220 --> 02:00:24,880
we go back to our Morales
database, we hit refresh, we now

25102
02:00:24,880 --> 02:00:27,850
see that new one has gotten in
anytime you stopped your hard

25103
02:00:27,850 --> 02:00:31,120
hat note, anytime you reset your
hard hat node, the takeaway is

25104
02:00:31,120 --> 02:00:33,940
you're going to need to go to
View Details dev chain proxy

25105
02:00:33,940 --> 02:00:36,490
server and reset local chain.
Now you can do that

25106
02:00:36,490 --> 02:00:38,860
programmatically as well, we're
not going to go over how to

25107
02:00:38,890 --> 02:00:40,900
programmatically do that. But
that might be something you want

25108
02:00:40,900 --> 02:00:44,050
to add to your hard hat deploy.
The other thing to note is that

25109
02:00:44,050 --> 02:00:47,530
it didn't clear out our last
event, right, the last event.

25110
02:00:47,740 --> 02:00:52,330
And if I go one minute and list
again, after completes, we'll

25111
02:00:52,330 --> 02:00:53,740
have another event in here.

25112
02:00:56,590 --> 02:01:00,490
Okay, this is great. So all of
this is being said, the reason

25113
02:01:00,490 --> 02:01:03,280
we're doing all this in the
first place is so that in our

25114
02:01:03,280 --> 02:01:06,940
index.js we can start listening
for events. How do we show the

25115
02:01:06,940 --> 02:01:10,150
recent listen entity. So now we
have a database of listed

25116
02:01:10,150 --> 02:01:13,330
entities. So what we could do,
we could just query this item

25117
02:01:13,330 --> 02:01:16,990
listed table right and grab
everything in here. However, we

25118
02:01:16,990 --> 02:01:19,660
have an issue here, what happens
if someone buys an NFT, if

25119
02:01:19,660 --> 02:01:22,600
someone buys an NF T, the item
listed event will still be in

25120
02:01:22,600 --> 02:01:25,780
our database. But technically it
won't be on the marketplace

25121
02:01:25,780 --> 02:01:29,020
anymore. It'll be gone, it won't
be listed. So what can we do,

25122
02:01:29,080 --> 02:01:30,910
there's a number of
architectural choices we can

25123
02:01:30,910 --> 02:01:33,490
make to get around this problem
to solve this problem. But one

25124
02:01:33,490 --> 02:01:36,490
of the things we can do is
actually we can use mirallas

25125
02:01:36,490 --> 02:01:40,390
Cloud Functions. So Morales
cloud functions allow us to just

25126
02:01:40,390 --> 02:01:44,170
really add anything we want our
front end to do from the morale

25127
02:01:44,170 --> 02:01:46,660
server. And these are functions.
These are scripts that are going

25128
02:01:46,660 --> 02:01:49,570
to run on a morale server
whenever we want them to. So we

25129
02:01:49,570 --> 02:01:52,570
go to our server hit the little
drop down and we hit Cloud

25130
02:01:52,570 --> 02:01:56,320
Functions. Now this is where we
can write somewhere else stuff

25131
02:01:56,350 --> 02:02:00,430
to run on our server whenever we
want. And we are going to set up

25132
02:02:00,460 --> 02:02:03,400
our Cloud Functions in our IDE
by hitting this little drop done

25133
02:02:03,520 --> 02:02:07,510
to actually sync up our Visual
Studio code with our Cloud

25134
02:02:07,510 --> 02:02:10,690
Functions, we can just run this
command here, and it will add

25135
02:02:10,690 --> 02:02:14,920
whatever cloud functions we have
in some cloud folder to here. So

25136
02:02:14,920 --> 02:02:18,610
what we can do back in our VS
code, let's make a new folder,

25137
02:02:18,700 --> 02:02:22,960
new folder called Cloud
Functions. And in here, we'll

25138
02:02:22,960 --> 02:02:29,170
create a new file called Update,
active items.js. So in here, if

25139
02:02:29,170 --> 02:02:32,920
we were to write something like
console dot log, hi, we can

25140
02:02:32,920 --> 02:02:36,460
actually have this automatically
saved on a morale server. And

25141
02:02:36,460 --> 02:02:39,490
the way that we do this is by
running this command. Now, we

25142
02:02:39,490 --> 02:02:42,100
want to make it so that it's a
lot easier for us to run this

25143
02:02:42,100 --> 02:02:45,550
command than just always having
to run this massive thing. So

25144
02:02:45,550 --> 02:02:47,650
what we're going to do is we're
going to open up our package

25145
02:02:47,680 --> 02:02:50,680
json, and we're going to make
another Morales script here,

25146
02:02:50,860 --> 02:02:53,350
right below here, we're going to
make another Morales script,

25147
02:02:53,410 --> 02:02:57,670
we're gonna say Morales Morales
cloud, and we're going to have

25148
02:02:57,670 --> 02:03:02,470
it, run this command. So we're
going to copy this command here,

25149
02:03:03,010 --> 02:03:06,820
paste it into our package json.
So it's going to be Morales

25150
02:03:06,820 --> 02:03:11,290
admin CLI, watch cloud folder,
we don't need the Morales API

25151
02:03:11,290 --> 02:03:13,750
key, because it'll grab that
from our environment variables.

25152
02:03:13,930 --> 02:03:16,840
We don't need them rouse secret,
because it'll grab that from our

25153
02:03:16,840 --> 02:03:20,050
environment variables, we do
need the morale subdomain

25154
02:03:20,380 --> 02:03:24,340
autosave one. And then the
Morales cloud folder is going to

25155
02:03:24,340 --> 02:03:29,980
be that new Cloud Functions bid
that we made that slash cloud

25156
02:03:30,010 --> 02:03:35,920
functions, functions. Now, in a
new terminal, if I run yarn,

25157
02:03:36,610 --> 02:03:40,390
more Alice cloud, which is going
to be same as running this huge

25158
02:03:40,390 --> 02:03:44,320
function here, I hit enter,
it'll say compile, you know,

25159
02:03:44,320 --> 02:03:47,560
version, blah, blah, compiling,
blah, blah, changes uploaded

25160
02:03:47,560 --> 02:03:51,250
correctly. And if we go back to
our front end, we can see this

25161
02:03:51,250 --> 02:03:54,100
console dot log ky and our front
end being updated. And if we

25162
02:03:54,100 --> 02:03:57,250
continue to run this in our
update active items at Jas, we

25163
02:03:57,250 --> 02:04:02,350
could also write console dot
log, you'll save it. And if this

25164
02:04:02,350 --> 02:04:05,050
is still running, it'll
automatically upload it. And now

25165
02:04:05,050 --> 02:04:08,530
we can see if we do a little
refresh on our front end Cloud

25166
02:04:08,530 --> 02:04:11,410
Functions, we can see it's been
uploaded here. Now at this

25167
02:04:11,410 --> 02:04:14,740
point, if you have a ton of this
stuff running, you might see CPU

25168
02:04:14,740 --> 02:04:18,190
100 percent, you might see this little
thing pop up and the server

25169
02:04:18,190 --> 02:04:20,920
might start going a little bit
slower, we're starting to use a

25170
02:04:20,920 --> 02:04:26,830
lot of network activity here. So
I'm going to close my yarn

25171
02:04:26,830 --> 02:04:29,920
Morales cloud for now. And I'm
just going to upload it once

25172
02:04:29,920 --> 02:04:32,530
when I need to. Because we're
connected, we have it listening

25173
02:04:32,530 --> 02:04:35,560
to events, we're having it doing
more and more stuff here. And it

25174
02:04:35,560 --> 02:04:38,590
can start to put a lot of load
onto the server. So we're just

25175
02:04:38,590 --> 02:04:41,290
gonna go ahead and we're going
to cancel that out. And now the

25176
02:04:41,290 --> 02:04:44,590
CPU is a lot lower. But if we go
back to Cloud Functions, we can

25177
02:04:44,590 --> 02:04:48,160
see it's still in here. And
anytime we update our Cloud

25178
02:04:48,160 --> 02:04:50,680
Functions, it'll update our
server with those cloud

25179
02:04:50,680 --> 02:04:53,350
functions. And we'll just run
that darn morass cloud once

25180
02:04:53,350 --> 02:04:56,020
we're all done here. Anyways, so
right now we're trying to figure

25181
02:04:56,020 --> 02:04:59,050
out, Okay, we have item listed,
but if someone buys an item,

25182
02:04:59,110 --> 02:05:04,030
technically, it won't be listed
anymore. But our item listed

25183
02:05:04,030 --> 02:05:06,850
table will still have it listed.
So what we can do is we can

25184
02:05:06,850 --> 02:05:09,760
create a Cloud Function that
runs whenever we want. And like

25185
02:05:09,760 --> 02:05:12,070
I said, we can have these run
whenever we want. We can call

25186
02:05:12,070 --> 02:05:14,230
these whenever we want. But
we're going to create a Cloud

25187
02:05:14,230 --> 02:05:17,680
Function that only runs.
Whenever one of these events are

25188
02:05:17,680 --> 02:05:20,530
synced item listed item
cancelled or item bought, we're

25189
02:05:20,530 --> 02:05:24,040
going to create a new table
called active item, an active

25190
02:05:24,040 --> 02:05:27,520
item is going to say, okay,
anytime it's listed, it will be

25191
02:05:27,520 --> 02:05:30,280
active, but when it's bought or
cancelled will remove it from

25192
02:05:30,280 --> 02:05:33,880
the active item list. So we're
going to create a new table. So

25193
02:05:33,880 --> 02:05:36,490
let's go ahead and do that. We
started off with more Alice

25194
02:05:36,490 --> 02:05:40,120
thought. And then if you're IT
auditors that you don't need

25195
02:05:40,120 --> 02:05:43,660
this, we don't need to import
Morales here, because we're

25196
02:05:43,660 --> 02:05:46,540
going to upload it as a Cloud
Function. And our server already

25197
02:05:46,540 --> 02:05:49,570
just automatically injects
mirallas into our scripts. So

25198
02:05:49,570 --> 02:05:53,920
we're gonna say Morales dot
cloud, that after save, and

25199
02:05:53,920 --> 02:05:57,040
there's a whole bunch of stuff
you can do with your Morales

25200
02:05:57,070 --> 02:06:00,010
cloud. And again, you can find
these all in the documentation.

25201
02:06:00,130 --> 02:06:03,670
The after save keyword means
that anytime something gets

25202
02:06:03,670 --> 02:06:06,880
saved on a table that we
specify, we'll do something. And

25203
02:06:06,880 --> 02:06:10,780
it takes two parameters. So it
takes what table that we want to

25204
02:06:10,780 --> 02:06:13,450
do something after it's saved.
And we're gonna say item listed.

25205
02:06:13,540 --> 02:06:15,760
So we're saying anytime
something is saved to the item

25206
02:06:15,760 --> 02:06:18,520
listed table, we'll run some
async function.

25207
02:06:20,110 --> 02:06:23,830
And we'll put request in here.
Because anytime something gets

25208
02:06:23,830 --> 02:06:27,400
saved, it comes with a request.
So anytime an item listed

25209
02:06:27,400 --> 02:06:31,810
happens, we want to add it to
our active items list. And our

25210
02:06:31,810 --> 02:06:35,200
requests come with this is
flagged called confirmed. So

25211
02:06:35,200 --> 02:06:38,020
we'll say const confirmed
because every request, every

25212
02:06:38,020 --> 02:06:41,290
event actually gets triggered
twice. So once a transaction

25213
02:06:41,290 --> 02:06:45,550
goes through, it triggers a save
and then once again, once that

25214
02:06:45,550 --> 02:06:48,430
transaction is actually
confirmed, we actually only want

25215
02:06:48,430 --> 02:06:51,280
to update our active item when
the transaction is actually

25216
02:06:51,280 --> 02:06:54,670
confirmed. So we'll say const
confirmed equals request dot

25217
02:06:54,700 --> 02:07:00,220
object dot get confirmed.
Screening, get the confirmed

25218
02:07:00,220 --> 02:07:03,220
attribute from that request. And
then we're also going to make A

25219
02:07:03,220 --> 02:07:09,130
logger will say const logger
equals oralis dot Cloud dot get

25220
02:07:09,130 --> 02:07:12,460
logger. And you'll see why in a
second, we can actually write

25221
02:07:12,460 --> 02:07:17,530
logs to our Morales database
with this logs thing. So any

25222
02:07:17,530 --> 02:07:20,410
logs we can add into here, and
I'll show you that in a minute.

25223
02:07:20,440 --> 02:07:23,710
So console logger Morales dot
cloud, get logger. And then

25224
02:07:23,710 --> 02:07:25,330
we'll just do logger dot info.

25225
02:07:26,950 --> 02:07:31,600
Looking for confirmed x, and we
can actually test this right

25226
02:07:31,600 --> 02:07:35,680
now. Right, we can actually test
this right now. In our logs. We

25227
02:07:35,680 --> 02:07:40,120
should see looking for confirmed
TX Once an item listed and saved

25228
02:07:40,150 --> 02:07:42,880
now to test this out just to
test that our logger is actually

25229
02:07:42,880 --> 02:07:47,980
working. Let's run yarn, yarn
Ross cloud just update active

25230
02:07:47,980 --> 02:07:50,980
items to our to our morale
server changes uploaded

25231
02:07:50,980 --> 02:07:54,730
correctly. Okay, we'll kill it
now. And now in our where we

25232
02:07:54,730 --> 02:07:59,020
have our Minton, lists script.
Let's run Minton list. And we

25233
02:07:59,020 --> 02:08:02,470
should see on our server we
should get those logs. Now if we

25234
02:08:02,470 --> 02:08:05,740
go to our server, we do a little
refresh here. And if we look at

25235
02:08:05,740 --> 02:08:10,030
our logs now we can now see
looking for confirmed TX in our

25236
02:08:10,030 --> 02:08:13,990
server logs. Now in our logs.
Here we see we only see that

25237
02:08:13,990 --> 02:08:18,010
looking for confirmed TX once
and I just told you, it actually

25238
02:08:18,010 --> 02:08:21,730
triggers twice once when the
transaction is first sent. And

25239
02:08:21,730 --> 02:08:25,150
then once when the transaction
is confirmed, aka has block

25240
02:08:25,150 --> 02:08:28,960
confirmations. And additionally,
if we look in our database at

25241
02:08:28,960 --> 02:08:32,020
the item listed, and we scroll
all the way to the right, we can

25242
02:08:32,020 --> 02:08:36,610
see confirmed equals false. So
we only want to count this item

25243
02:08:36,610 --> 02:08:41,260
listed event interactive items
when confirmed is true. So what

25244
02:08:41,260 --> 02:08:44,170
we want to do actually is we
want to update our scripts to

25245
02:08:44,200 --> 02:08:47,650
add one block confirmation on
top of our local Hardhead

25246
02:08:47,650 --> 02:08:51,550
blockchain so that these can be
changed to confirmed now to get

25247
02:08:51,550 --> 02:08:55,510
around this. What I usually will
do in my mentalist script is

25248
02:08:55,510 --> 02:08:58,870
I'll add a new utility. So I'll
go to my utils, I'll do new

25249
02:08:58,870 --> 02:09:04,480
file, and I'll create a move
blocks.js. And this will be a

25250
02:09:04,480 --> 02:09:09,220
utility that I use to actually
move the blocks. So when we run

25251
02:09:09,220 --> 02:09:11,830
our own heart hat node, we
actually have complete control

25252
02:09:11,830 --> 02:09:14,650
over what we want our heart hat
node to do. So what we can do is

25253
02:09:14,650 --> 02:09:17,950
we can actually manually mine
nodes and actually move blocks

25254
02:09:17,950 --> 02:09:21,040
ahead so that Morales knows Oh,
okay, this transaction is

25255
02:09:21,040 --> 02:09:22,990
confirmed, right, because we're
mining the block with the

25256
02:09:22,990 --> 02:09:26,950
transaction. And that's it, and
Ross is just going to forever be

25257
02:09:26,950 --> 02:09:29,260
waiting for the next block. So
we want to add some

25258
02:09:29,260 --> 02:09:32,650
functionality to our scripts,
where we just mine a block after

25259
02:09:32,650 --> 02:09:35,920
it's done. Now, keep in mind
that if we mined like 1000

25260
02:09:35,920 --> 02:09:38,680
blocks or a ton of blocks really
quickly, Moorehouse might have a

25261
02:09:38,680 --> 02:09:41,410
hard time indexing that. So we
really want to just mined one at

25262
02:09:41,410 --> 02:09:44,350
a time and give me enough time
to index each block that we

25263
02:09:44,350 --> 02:09:47,080
mined. So we're actually going
to build a little script, we're

25264
02:09:47,080 --> 02:09:52,180
going to manually mine using
this EVM mine RPC method that

25265
02:09:52,180 --> 02:09:54,460
comes with our heart hat
blockchain. So we have this new

25266
02:09:54,460 --> 02:09:57,340
move blocks script. And let's go
ahead and make this. So instead

25267
02:09:57,340 --> 02:10:00,520
of this being our script, we're
going to have like a main

25268
02:10:00,520 --> 02:10:02,080
function at the bottom, we're
just gonna have this be a

25269
02:10:02,080 --> 02:10:05,020
utility that we're going to
import into other scripts. So

25270
02:10:05,020 --> 02:10:07,810
we're not going to need a main
function here, we're just going

25271
02:10:07,810 --> 02:10:11,140
to need to make this an async
function. And we'll call it move

25272
02:10:11,140 --> 02:10:14,080
blocks. And then we'll say
amount, which is going to be the

25273
02:10:14,080 --> 02:10:18,190
number of blocks, we want to
move, we'll also put a sleep

25274
02:10:18,190 --> 02:10:22,330
amount and default it to zero,
this sleep amount is going to be

25275
02:10:22,330 --> 02:10:26,260
an optional parameter. If we
want to move blocks and sleep

25276
02:10:26,290 --> 02:10:30,880
maybe a second between blocks to
resemble a real blockchain, we

25277
02:10:30,880 --> 02:10:34,120
can have that in here too. So we
can have it resemble a real

25278
02:10:34,120 --> 02:10:37,600
blockchain by sleeping every
time a block is moved or just

25279
02:10:37,600 --> 02:10:40,360
kind of waiting every time a
block has moved. So in our move

25280
02:10:40,360 --> 02:10:44,620
block scripts, we'll do console
dot log, moving blocks, dot that

25281
02:10:44,620 --> 02:10:49,300
dot, and we'll say for let index
equals zero, and we'll do a for

25282
02:10:49,300 --> 02:10:53,980
loop around the amount and call
that EVM. Mine in this for loop

25283
02:10:54,040 --> 02:10:59,410
index is less than amount index
plus plus a weight network. And

25284
02:10:59,410 --> 02:11:02,740
then we got to import network
oops, we got to import network

25285
02:11:02,770 --> 02:11:06,730
from hard hat here, await
network dot provider dot

25286
02:11:06,760 --> 02:11:13,630
request. And then we're going to
request the method e v, mime,

25287
02:11:13,720 --> 02:11:17,980
comma params are going to be
empty. And this is actually the

25288
02:11:17,980 --> 02:11:20,770
same way we can make raw calls
to our blockchain nodes. We

25289
02:11:20,770 --> 02:11:23,620
don't do a lot of this because
ethers abstract this under the

25290
02:11:23,620 --> 02:11:27,160
hood, but we're making a raw
call to EVM mine. Obviously, you

25291
02:11:27,160 --> 02:11:30,370
can't call EVM mine on a real
blockchain because you can't

25292
02:11:30,370 --> 02:11:34,120
just tell a blockchain node to
mine the next block. Since this

25293
02:11:34,120 --> 02:11:37,480
is our local hard hat node, we
can call the VM now we're gonna

25294
02:11:37,480 --> 02:11:42,940
say if sleep amount is greater
than zero, or just if sleep

25295
02:11:42,940 --> 02:11:47,050
mount, then we're also going to
have this script sleep or wait a

25296
02:11:47,050 --> 02:11:49,300
short duration. So up at the
top, we're actually going to

25297
02:11:49,300 --> 02:11:53,680
create a new function called
sleep, which is going to input a

25298
02:11:53,680 --> 02:11:58,030
time in milliseconds. And this
is going to return a new

25299
02:11:58,030 --> 02:12:01,030
promise, right? Because
remember, in order for us to

25300
02:12:01,090 --> 02:12:04,030
wait for some time we got to use
promises, which we've learned

25301
02:12:04,030 --> 02:12:07,780
before. And this promise is
going to take a function with

25302
02:12:07,780 --> 02:12:12,250
resolve as an input parameter.
And we're just going to say, set

25303
02:12:12,550 --> 02:12:18,220
timeout is going to be resolve,
comma, time in Ms. So the way we

25304
02:12:18,220 --> 02:12:21,580
can sleep in JavaScript is we
return a new promise. And we

25305
02:12:21,580 --> 02:12:24,040
just call this set timeout
function, which basically just

25306
02:12:24,040 --> 02:12:25,990
weights the time in
milliseconds. Now to actually

25307
02:12:25,990 --> 02:12:31,960
sleep. We'll say console dot
log, sleeping for sleep amount.

25308
02:12:32,950 --> 02:12:37,240
And then we'll do await, sleep,
sleep amount, and this is going

25309
02:12:37,240 --> 02:12:41,080
to be in milliseconds. So since
sleep returns a promise, we can

25310
02:12:41,080 --> 02:12:44,770
call it with await to say, okay,
wait for this sleep function to

25311
02:12:44,770 --> 02:12:48,340
finish. And the sleep function
is only going to finish when the

25312
02:12:48,340 --> 02:12:52,150
time in MS in time in
milliseconds finishes. So now we

25313
02:12:52,150 --> 02:12:55,060
have a function called move
blocks, which will actually

25314
02:12:55,060 --> 02:12:58,180
mined blocks on our local
blockchain, so that Morales can

25315
02:12:58,180 --> 02:13:00,850
get that block confirmation that
it's looking for now at the

25316
02:13:00,850 --> 02:13:05,500
bottom, we'll just do module dot
exports, move blocks, move

25317
02:13:05,500 --> 02:13:08,650
blocks, and then we'll also
export sleep as well, because

25318
02:13:08,650 --> 02:13:12,580
why not? Equals like that. Now,
what we can do back in our

25319
02:13:12,580 --> 02:13:17,710
Minton list, up at the top,
we'll say const, move blocks

25320
02:13:17,830 --> 02:13:24,520
equals require dot dot slash
utils slash move blocks. And

25321
02:13:24,520 --> 02:13:28,360
then we'll also import network
from ethers network. And the

25322
02:13:28,360 --> 02:13:32,440
down in our script. Just right
at the bottom, we'll just say if

25323
02:13:32,920 --> 02:13:38,950
network dot config, that chain
ID equals equals 31337 await,

25324
02:13:39,460 --> 02:13:43,030
move blocks, we'll say we'll
move to blocks and then we'll

25325
02:13:43,030 --> 02:13:47,680
also do sleep amount equals
1000. We'll wait one millisecond

25326
02:13:47,680 --> 02:13:50,380
between each block that we
mined. So sleep mount equals

25327
02:13:50,380 --> 02:13:53,860
1000, which is going to be one
millisecond. Now let's even just

25328
02:13:53,860 --> 02:13:57,310
comment all this out for a
second. We'll just run this

25329
02:13:57,340 --> 02:14:01,150
script with only this live.
Right we'll pull this up the

25330
02:14:01,150 --> 02:14:06,580
yarn hard hat, run scripts,
mentalist dash dash network,

25331
02:14:07,900 --> 02:14:12,610
local host, we'll just move the
blocks move back to our front

25332
02:14:12,610 --> 02:14:15,970
end, we'll refresh, we'll go
look at item listed. We'll

25333
02:14:15,970 --> 02:14:18,550
scroll all the way to the right,
and now we see confirmed is

25334
02:14:18,550 --> 02:14:21,850
true. And now if we were to look
in our logs, we would see that

25335
02:14:21,880 --> 02:14:25,150
logging item happened twice.
Alright, so Let's uncomment this

25336
02:14:25,270 --> 02:14:29,440
and continue. Now that we have
this now that we're learning

25337
02:14:29,440 --> 02:14:32,200
about logging, now that we're
doing all this stuff, we can say

25338
02:14:32,200 --> 02:14:35,230
If confirmed, we're going to do
some stuff. If confirmed, we're

25339
02:14:35,230 --> 02:14:37,660
going to create a table called
active item and add this to the

25340
02:14:37,660 --> 02:14:40,030
active item table. So we're
going to do a little logger dot

25341
02:14:40,030 --> 02:14:45,640
info bound item. And we'll
create a new table and a new

25342
02:14:45,670 --> 02:14:50,320
entry in this table. So we'll
say const active item equals

25343
02:14:50,740 --> 02:14:58,120
more Alice dot object dot extend
ACC active item. This we're

25344
02:14:58,120 --> 02:15:02,620
saying if active item exists,
great grab it if not create it.

25345
02:15:02,650 --> 02:15:05,560
So we're going to create this
active item table if it doesn't

25346
02:15:05,560 --> 02:15:08,230
exist, if it does exist, great,
grab it. And we're going to say

25347
02:15:08,740 --> 02:15:13,690
const active item equals new,
active item. So we're going to

25348
02:15:13,690 --> 02:15:16,150
create a new entry in this
active item table that we're

25349
02:15:16,150 --> 02:15:22,390
creating. And we'll say active
item dot set. And we can set any

25350
02:15:22,390 --> 02:15:25,780
of the columns we want for this
new table that we're creating.

25351
02:15:25,960 --> 02:15:28,930
So let's give it a marketplace
address column. So we'll say

25352
02:15:28,930 --> 02:15:35,950
market place address. And this
will come from the request dot

25353
02:15:35,980 --> 02:15:41,140
object dot get address all of
these requests from events come

25354
02:15:41,140 --> 02:15:43,630
with the address that they're
coming from, which for us is

25355
02:15:43,630 --> 02:15:46,330
going to be the marketplace
address, we'll do active item

25356
02:15:46,330 --> 02:15:52,660
that set and if T address which
these events saved come with all

25357
02:15:52,660 --> 02:15:56,440
the parameters of our event. So
we'll say request that object

25358
02:15:57,400 --> 02:16:02,440
dot get NFT address will get the
price will say active item dot

25359
02:16:02,440 --> 02:16:09,280
set price is going to be request
dot object dot get price will

25360
02:16:09,280 --> 02:16:14,890
get the token IDs will say
active item dot set token ID

25361
02:16:15,550 --> 02:16:21,850
request dot object dot get token
ID and then we'll get the seller

25362
02:16:22,000 --> 02:16:27,160
will say active item dot set
seller is going to be request

25363
02:16:27,250 --> 02:16:34,570
that object dot get seller. So
we're getting all of this

25364
02:16:34,570 --> 02:16:39,040
information from our event. And
this event update from Ross

25365
02:16:39,040 --> 02:16:41,410
automatically always comes with
the address that the event was

25366
02:16:41,410 --> 02:16:43,600
omitted from. So we're gonna
grab all that we're going to

25367
02:16:43,600 --> 02:16:46,660
create this active item table.
We're going to add all these

25368
02:16:46,660 --> 02:16:49,120
rows. We're going to add this
one row with all these columns

25369
02:16:49,120 --> 02:16:53,140
in it. Awesome. Now we'll just
do logger dot info just to do a

25370
02:16:53,140 --> 02:16:56,890
little print out. We'll say
adding address. We'll do a

25371
02:16:56,890 --> 02:17:01,180
little string interpolation
we'll say request dot object dot

25372
02:17:01,180 --> 02:17:05,800
get address period token ID with

25373
02:17:07,180 --> 02:17:14,380
request dot object dot get token
ID. And I need to close this off

25374
02:17:14,380 --> 02:17:18,940
here, better. And then outside
of the logger dot info, we'll

25375
02:17:18,940 --> 02:17:24,370
just say logger dot info,
saving. And then we just run

25376
02:17:24,400 --> 02:17:30,820
await active item dot save. And
now we have cloud function

25377
02:17:30,820 --> 02:17:34,240
that's going to create a new
entry in a new table called

25378
02:17:34,240 --> 02:17:39,250
active item anytime item listed
happens. So after item is called

25379
02:17:39,280 --> 02:17:41,500
the trigger for our cloud
function, and there are a whole

25380
02:17:41,500 --> 02:17:44,140
bunch of different triggers for
different Ross Cloud Functions.

25381
02:17:44,590 --> 02:17:48,880
If you go to the Morales docs,
we look for trigger, we can find

25382
02:17:48,880 --> 02:17:51,520
a list of all these different
triggers in here, like after

25383
02:17:51,520 --> 02:17:58,420
save for Save. After save,
before delete, after delete,

25384
02:17:58,480 --> 02:18:01,150
before save file, there's all
these different triggers to

25385
02:18:01,150 --> 02:18:04,180
trigger this cloud code. Now, if
we upload this new script to our

25386
02:18:04,180 --> 02:18:07,180
morale server with yarn morass,
cloud changes uploaded

25387
02:18:07,180 --> 02:18:09,820
correctly, okay, great, we'll
kill it. Let's go to our cloud

25388
02:18:09,820 --> 02:18:13,390
server, do a little refresh just
to make sure that it's not still

25389
02:18:13,390 --> 02:18:16,480
processing that update. Okay,
CPUs low enough. Okay, great.

25390
02:18:16,570 --> 02:18:19,570
Now in our database, we don't
see an active item table in

25391
02:18:19,570 --> 02:18:24,460
here. But if we go back to our
Hardhead script, and we call

25392
02:18:24,700 --> 02:18:29,140
mint and list, since now we have
a Cloud Function that says okay,

25393
02:18:29,170 --> 02:18:33,700
anytime an item listed event
happens, update that active item

25394
02:18:33,700 --> 02:18:37,450
table, we should see active item
update. So let's run this. And

25395
02:18:37,450 --> 02:18:40,330
remember for all of this, we
need to have our heart head node

25396
02:18:40,330 --> 02:18:43,870
running connected to Hardhat.
And if we reset our local chain,

25397
02:18:43,870 --> 02:18:46,570
we need to click that reset
local chain button. So we went

25398
02:18:46,570 --> 02:18:50,530
ahead, we ran this. Now if we go
back to our database, we give it

25399
02:18:50,530 --> 02:18:53,890
a little refresh. And right now
I actually don't see anything.

25400
02:18:53,980 --> 02:18:58,570
So if I go to my logs go to
info, I can see any errors or

25401
02:18:58,600 --> 02:19:01,810
issues in here. So it looks like
after save failed for item

25402
02:19:01,810 --> 02:19:04,840
listed for user bla bla bla,
looks like there is an issue

25403
02:19:04,870 --> 02:19:07,870
cannot read properties of
undefined reading extend. And

25404
02:19:07,870 --> 02:19:11,140
that's also in the info, I made
an issue. I didn't quite write

25405
02:19:11,140 --> 02:19:15,220
all my code, right. And if we go
back to our update active item,

25406
02:19:15,340 --> 02:19:18,970
I can see where I messed up. It
should be Morales dot object

25407
02:19:19,000 --> 02:19:22,780
with a capital O dot extent. So
what I'm going to do, then run

25408
02:19:22,780 --> 02:19:26,200
yarn morass cloud again, now
that I have this correct, we're

25409
02:19:26,200 --> 02:19:28,660
going to cancel that, we're
gonna run our mminton list

25410
02:19:28,660 --> 02:19:33,490
again, now that we've fixed our
script. And now that we've fixed

25411
02:19:33,490 --> 02:19:36,640
our script, go back to our
database, we'll give it a little

25412
02:19:36,640 --> 02:19:40,150
refresh, I can now see we have
an active item entry in

25413
02:19:40,150 --> 02:19:44,650
here. Now at this point, there
are going to be times when you

25414
02:19:44,650 --> 02:19:46,960
don't want to leave and go get a
coffee, right, or go to the

25415
02:19:46,960 --> 02:19:49,600
bathroom or go get some food.
And you're going to want to stop

25416
02:19:49,630 --> 02:19:52,510
your terminals from running. So
let's actually practice

25417
02:19:52,540 --> 02:19:55,210
restarting everything and re
getting into this local

25418
02:19:55,240 --> 02:19:57,460
development environment. Because
it can be a little weird and a

25419
02:19:57,460 --> 02:20:01,210
little tricky. So let's practice
this. So once again, let's come

25420
02:20:01,210 --> 02:20:04,480
over here. And what do we need
to do? Well, we're going to Ctrl

25421
02:20:04,480 --> 02:20:08,290
C, we're going to kill our
blockchain Ctrl C, we're going

25422
02:20:08,290 --> 02:20:11,320
to kill our connection to our
Morales server. And if we're

25423
02:20:11,320 --> 02:20:14,590
running a front end Ctrl C, that
too, now if we go to our server,

25424
02:20:14,710 --> 02:20:19,480
we go to view details. Dev chain
proxy server, if we hit status,

25425
02:20:19,510 --> 02:20:22,480
this reset button here will
still we will be disconnected

25426
02:20:22,480 --> 02:20:25,420
now. And now everything has been
disconnected. Now if we want to

25427
02:20:25,420 --> 02:20:28,420
restart everything, if we're on
our heart hat NFT marketplace

25428
02:20:28,450 --> 02:20:31,600
will run yarn Hardhead node, and
that will spin everything up

25429
02:20:31,600 --> 02:20:36,970
again, we'll run yarn Morales
sync to sync back with our

25430
02:20:37,000 --> 02:20:40,060
routes connection, we can go
back to our server will do view

25431
02:20:40,060 --> 02:20:43,300
details and we should be
connected now. Connected. Since

25432
02:20:43,300 --> 02:20:46,450
we restarted our local
blockchain, we now need to

25433
02:20:46,450 --> 02:20:49,240
remember to do reset local
chain, we'll go ahead and run

25434
02:20:49,240 --> 02:20:53,350
that. Great. If we want to
restart our front end, we can

25435
02:20:53,350 --> 02:20:57,100
restart our front end like so
now the thing is, our database

25436
02:20:57,100 --> 02:21:00,160
will still have even when we
refresh it even though we reset

25437
02:21:00,160 --> 02:21:02,620
the local blockchain, it'll
still have all this stuff in it.

25438
02:21:02,650 --> 02:21:06,730
Now these entries in here are
entries from a blockchain that

25439
02:21:06,730 --> 02:21:10,240
no longer exists. So what I
often will do is I'll click this

25440
02:21:10,240 --> 02:21:13,690
button up here, and we'll just
delete all rows in this class.

25441
02:21:14,050 --> 02:21:18,250
To confirm we do active item,
read the name of the table. And

25442
02:21:18,250 --> 02:21:21,640
let's do it for item listed too.
We'll select that edit, delete

25443
02:21:21,640 --> 02:21:26,050
all rows, item listed. Yes,
delete. We'll do a little

25444
02:21:26,050 --> 02:21:29,650
refresh. Now everything is
zeroed out here. Now we have an

25445
02:21:29,650 --> 02:21:32,890
empty database for these events
in our after save here. And now

25446
02:21:32,890 --> 02:21:35,590
that we've added that little
weight in our script, let's go

25447
02:21:35,590 --> 02:21:40,180
back to our hard hat NFT
marketplace, we'll run yarn, RT

25448
02:21:40,180 --> 02:21:48,640
hat, run scripts, mint and list
dot j s dash dash network, local

25449
02:21:48,640 --> 02:21:54,070
host. This will mint it approve
it listed and then we mined two

25450
02:21:54,070 --> 02:21:57,880
blocks to give Morales time to
index our event and then on a

25451
02:21:57,880 --> 02:22:01,330
morale server. We go ahead and
refresh we now see item listed

25452
02:22:01,330 --> 02:22:05,740
as one and active item is One
all at the same time. So that is

25453
02:22:05,740 --> 02:22:09,280
how we're going to make sure
that Morales always indexes

25454
02:22:09,280 --> 02:22:11,410
whenever we call a function,
we're just going to mind one

25455
02:22:11,410 --> 02:22:15,370
additional block to tell Morales
Hey, that transaction has indeed

25456
02:22:15,400 --> 02:22:18,400
been confirmed. So really
exciting. And we got to practice

25457
02:22:18,400 --> 02:22:21,910
closing and restarting and doing
all that good stuff, too. So now

25458
02:22:21,910 --> 02:22:26,740
this is fantastic. Now that we
have this additional

25459
02:22:26,740 --> 02:22:29,080
functionality to make it a lot
easier for someone else over

25460
02:22:29,110 --> 02:22:31,780
okay, awesome, we can check
active item. Well, we're not

25461
02:22:31,780 --> 02:22:35,530
quite done yet, right? Because
what if somebody buys an NFT, or

25462
02:22:35,530 --> 02:22:38,980
sells an entity we should have
active item be removed? Right,

25463
02:22:38,980 --> 02:22:41,650
right now there's one item
listed in one active item. But

25464
02:22:41,650 --> 02:22:45,520
if we buy an item, active item
will still show that that item

25465
02:22:45,520 --> 02:22:49,270
is active. So let's go ahead and
let's update our cloud function

25466
02:22:49,420 --> 02:22:53,950
to also say, okay, anytime an
item is bought, we remove that

25467
02:22:53,980 --> 02:22:57,730
item from being active. So let's
create another after save. Let's

25468
02:22:57,730 --> 02:22:59,980
first built this for canceling
the item. And then we'll build

25469
02:22:59,980 --> 02:23:03,340
one for buying the item. So to
make another after save to make

25470
02:23:03,340 --> 02:23:07,300
another trigger, we'll say
mirallas dot Cloud dot after

25471
02:23:07,750 --> 02:23:11,500
save, we'll say item cancelled.
And this will be an async

25472
02:23:11,500 --> 02:23:15,160
function that takes the request
as an input parameter again, and

25473
02:23:15,160 --> 02:23:16,960
we're going to do the same
thing. We're gonna say const

25474
02:23:16,960 --> 02:23:24,580
confirmed equals request that
object dot get confirmed, we'll

25475
02:23:24,580 --> 02:23:29,800
say const. Logger equals routes
dot Cloud dot get logger, like

25476
02:23:29,800 --> 02:23:34,750
so. And then we'll do logger.
Oops, lowercase L. And then

25477
02:23:34,750 --> 02:23:39,730
we'll do logger dot info,
marketplace, the little pipe

25478
02:23:40,390 --> 02:23:46,000
object and then just request dot
object. And then we'll do the

25479
02:23:46,000 --> 02:23:49,390
same thing. If confirmed. If
this transaction is confirmed

25480
02:23:49,390 --> 02:23:53,020
after one block, we're going to
remove it from active item. And

25481
02:23:53,020 --> 02:23:56,200
we're going to be using a query
to first find that active item

25482
02:23:56,200 --> 02:23:58,330
that's getting cancelled. And
you can learn more about basic

25483
02:23:58,330 --> 02:24:00,730
queries in the Morales
documentation here. So we're

25484
02:24:00,730 --> 02:24:05,230
going to get that table by
saying const active item equals

25485
02:24:05,320 --> 02:24:09,910
more outlets that object for the
capital O object dot extend

25486
02:24:10,750 --> 02:24:13,690
active item. And we're going to
create a new query. So we're

25487
02:24:13,690 --> 02:24:16,930
going to query our table before
we actually set or save

25488
02:24:16,930 --> 02:24:21,700
anything. So we're gonna say
const, query, query equals new

25489
02:24:21,970 --> 02:24:26,440
Morales dot query of active
item. So we're going to query

25490
02:24:26,440 --> 02:24:30,280
our Morales database to find an
active item that's in there,

25491
02:24:30,280 --> 02:24:33,040
that's going to match the
request here, so we can cancel

25492
02:24:33,040 --> 02:24:35,980
it. So we'll say query dot equal
to

25493
02:24:37,000 --> 02:24:43,300
marketplace address, comma
request that object dot get

25494
02:24:44,380 --> 02:24:47,290
address, we're looking for an
active item where the

25495
02:24:47,290 --> 02:24:50,950
marketplace address is going to
be the same as the address of

25496
02:24:50,980 --> 02:24:56,800
the item cancelled. We'll say
query dot equal to NF T address,

25497
02:24:57,970 --> 02:25:05,740
comma request dot object dot get
an F T address will say query

25498
02:25:05,740 --> 02:25:14,710
dot equal to token ID, comma
request dot object dot get token

25499
02:25:14,710 --> 02:25:18,640
ID. And that should be it right?
So let's look again at our

25500
02:25:18,670 --> 02:25:22,120
contract here. And what is the
item canceled give us it gives

25501
02:25:22,120 --> 02:25:25,870
us a seller NFC address and a
token ID seller and ft address

25502
02:25:25,870 --> 02:25:28,570
and a token ID. And we're
looking for NFT address and the

25503
02:25:28,570 --> 02:25:31,150
token ID, we don't need to look
for the seller, we just need to

25504
02:25:31,150 --> 02:25:33,610
look for these two. And then of
course, the marketplace address.

25505
02:25:33,820 --> 02:25:36,940
So great. So now that we have
those two, we can say logger dot

25506
02:25:36,970 --> 02:25:42,130
info, and then we'll just print
out marketplace type query. And

25507
02:25:42,130 --> 02:25:45,880
then we'll just print out this
query that we're running. And

25508
02:25:45,880 --> 02:25:51,400
then we can say const, cancelled
item equals await query dot

25509
02:25:51,400 --> 02:25:54,310
first, we're going to find the
first active item in the

25510
02:25:54,310 --> 02:25:57,040
database that has the same
marketplace address and a T

25511
02:25:57,040 --> 02:26:00,280
address and token ID that just
got cancelled. So we're going to

25512
02:26:00,280 --> 02:26:02,710
find that first cancelled item.
We'll do a little bit more

25513
02:26:02,710 --> 02:26:06,970
logger information, we'll say
logger dot info, marketplace,

25514
02:26:08,020 --> 02:26:11,140
pipe, cancelled item. And then
we'll just do some string

25515
02:26:11,140 --> 02:26:13,540
interpolation. And we'll print
out that canceled item.

25516
02:26:14,650 --> 02:26:20,110
Cancelled item and we'll say if
cancelled item. So if the query

25517
02:26:20,110 --> 02:26:23,230
doesn't find anything, it'll
return undefined. So we're

25518
02:26:23,230 --> 02:26:26,860
saying if cancelled item which
will return true if it found

25519
02:26:26,860 --> 02:26:31,060
something. So if cancelled item,
then we're gonna say logger dot

25520
02:26:31,060 --> 02:26:38,770
info. Deleting and then we'll do
request dot object dot get token

25521
02:26:38,770 --> 02:26:46,810
ID at address, request dot
object dot get address address

25522
02:26:47,230 --> 02:26:51,550
space since it was canceled, so
we're going to do a little print

25523
02:26:51,760 --> 02:26:55,330
little logging here. Take the
leading that thing since it was

25524
02:26:55,330 --> 02:27:00,430
canceled and then we're going to
run a wait canceled item dot

25525
02:27:00,460 --> 02:27:03,040
destroy and that's when we
remove it from the active item.

25526
02:27:03,040 --> 02:27:09,490
And then we'll just say else.
Logger dot info, no item found

25527
02:27:09,880 --> 02:27:18,970
with address, request dot object
dot get address, and token, Id

25528
02:27:19,270 --> 02:27:24,820
request dot object, dot get
token ID. So cool. So now we

25529
02:27:24,820 --> 02:27:27,910
have this after save here, it
looks like my terminal

25530
02:27:27,910 --> 02:27:31,990
automatically added this require
in here, which we don't want. So

25531
02:27:31,990 --> 02:27:34,360
I'm just gonna go ahead delete
that. We can upload this to our

25532
02:27:34,360 --> 02:27:38,470
Morales server by running yarn,
Morales cloud and great changes

25533
02:27:38,470 --> 02:27:41,530
uploaded correctly. And now to
test this test that this is

25534
02:27:41,530 --> 02:27:45,700
working, let's create a new
script in our hard hat NFT

25535
02:27:45,700 --> 02:27:49,270
marketplace called cancel item.
So we'll go to scripts right now

25536
02:27:49,270 --> 02:27:52,720
we have mentioned list, we'll do
new file, we'll call it cancel

25537
02:27:53,350 --> 02:27:59,950
dot Jas. We'll do cancel item,
Jas. And this will be a script.

25538
02:27:59,980 --> 02:28:02,620
So we're going to use that that
main thing here, but we're going

25539
02:28:02,620 --> 02:28:08,200
to call our function cancel. So
we'll do async function cancel,

25540
02:28:08,320 --> 02:28:12,820
and then at the top, we'll say
const token ID equals Now let's

25541
02:28:12,820 --> 02:28:17,350
go to our active item list. And
let's find a token ID that's in

25542
02:28:17,350 --> 02:28:21,340
here. Okay, token ID zero. And
so we'll use this as the token

25543
02:28:21,340 --> 02:28:26,830
ID that we want to delete. So
we'll use token ID zero. So in

25544
02:28:26,830 --> 02:28:30,700
our cancel item.js script, we'll
say const token ID equals zero

25545
02:28:30,730 --> 02:28:34,660
and let's cancel it. So we'll
say const NFT. Marketplace

25546
02:28:34,780 --> 02:28:39,880
equals await ethers dot get
contract. And yes, const ethers

25547
02:28:39,880 --> 02:28:45,340
equals require hardhat. And ft
marketplace will say const basic

25548
02:28:45,400 --> 02:28:54,130
NF t equals await ethers dot get
gets contract. Basic NF team do

25549
02:28:54,130 --> 02:29:01,360
const TX equals await NF T
marketplace dot cancel listing

25550
02:29:02,800 --> 02:29:10,600
basic NF T dot address token ID.
And we're going to call cancel

25551
02:29:10,600 --> 02:29:14,650
item should be cancelled listing
we call the cancel listing. So

25552
02:29:14,830 --> 02:29:19,150
cancelled listing Yep, like
that. And it takes the address

25553
02:29:19,150 --> 02:29:23,020
of the NFT and the token ID. So
the basic NF T dot address and

25554
02:29:23,020 --> 02:29:26,710
the token D Okay, great. And
then we'll do a weight TX dot

25555
02:29:26,710 --> 02:29:31,480
weight one. And then we'll do
console dot log NFT cancelled.

25556
02:29:32,950 --> 02:29:39,940
And then we'll say if network
dot config dot chain ID equals

25557
02:29:39,940 --> 02:29:46,990
equals 31337. We'll go ahead and
we'll do a wait move blocks to

25558
02:29:47,020 --> 02:29:52,000
two and then we'll say sleep.
Mount equals 1000. And then

25559
02:29:52,000 --> 02:29:57,370
we'll just say const. Move
blocks equals require dot dot

25560
02:29:57,370 --> 02:30:00,940
slash utils slash move blocks.
Okay, cool. That looks really

25561
02:30:00,940 --> 02:30:04,750
good. So let's go ahead and run
this yarn hardhat run scripts

25562
02:30:04,780 --> 02:30:10,240
cancel item.js dash dash
network, local host and ft

25563
02:30:10,240 --> 02:30:14,200
cancelled moving blocks
sleeping. Okay, great. Our node

25564
02:30:14,200 --> 02:30:17,740
is running. Awesome. We're
connected to our mirallas we've

25565
02:30:17,770 --> 02:30:21,520
uploaded our cloud function with
yarn Morales cloud. Now if we go

25566
02:30:21,520 --> 02:30:27,850
back to our database, do a
little refresh. Looks like I

25567
02:30:27,850 --> 02:30:31,480
have an issue here. I go to my
info it says after save failed

25568
02:30:31,480 --> 02:30:34,780
for item Cancel for user blah
blah, blah. Here's the login

25569
02:30:34,780 --> 02:30:38,740
information. Morales dot cloud
apt get latar is not a function.

25570
02:30:38,860 --> 02:30:43,780
Uh huh. Well, that makes a lot
of sense. Get water. Let's do

25571
02:30:44,320 --> 02:30:48,640
let's make this get logger.
Shall we get logger to let's re

25572
02:30:48,640 --> 02:30:52,510
upload them. Changes uploaded
correctly. And now I'm going to

25573
02:30:52,510 --> 02:30:55,330
have to manually go to active
item I'm gonna have to manually

25574
02:30:55,330 --> 02:30:58,930
delete this one will have a
delete this row. Yes, delete, do

25575
02:30:58,930 --> 02:31:01,570
a refresh. And the reason I have
to do that is because it's

25576
02:31:01,570 --> 02:31:05,380
already been saved. And we're
doing an after save. So because

25577
02:31:05,380 --> 02:31:08,140
I messed up. If you spelt that
right, you probably did, right.

25578
02:31:08,140 --> 02:31:10,570
But because I messed up, we're
gonna have to rebuild a new one.

25579
02:31:10,810 --> 02:31:14,410
And then delete that new one.
I'm going to run yarn, hard hat

25580
02:31:14,410 --> 02:31:17,890
run scripts, mint and list
network localhost. And we just

25581
02:31:17,890 --> 02:31:20,440
meant to add a new one. Let me
check the Morales database,

25582
02:31:20,470 --> 02:31:24,190
we'll do a refresh. I can see it
in here, I can see it an item

25583
02:31:24,190 --> 02:31:26,980
listed. It has a token ID of
one. So let's go ahead and

25584
02:31:26,980 --> 02:31:30,160
cancel that now. So I'm going to
change my token ID and cancel

25585
02:31:30,160 --> 02:31:34,390
item to one. And now we'll run
that script Barnhardt at run

25586
02:31:34,390 --> 02:31:38,680
scripts cancel item, network,
local host run this NFT

25587
02:31:38,680 --> 02:31:41,710
cancelled moving blocks. Now
we'll go to the front end, we'll

25588
02:31:41,710 --> 02:31:44,290
do a refresh. And we can see
it's been removed from active

25589
02:31:44,290 --> 02:31:47,170
item programmatically, which is
great. So this is where these

25590
02:31:47,170 --> 02:31:50,860
logs can be really helpful. Now
it can be a little scary to do

25591
02:31:50,860 --> 02:31:54,250
things wrong on purpose, but
learning how to use information

25592
02:31:54,250 --> 02:31:56,950
like the logging and learning
how to debug effectively is

25593
02:31:56,950 --> 02:31:59,410
going to make you a lot faster
of a coder because guess what,

25594
02:31:59,440 --> 02:32:01,720
you're not going to be perfect.
You're going to run into issues

25595
02:32:01,810 --> 02:32:04,390
understanding how to use The Log
Understanding how to read the

25596
02:32:04,390 --> 02:32:07,330
errors is going to make you much
faster developer. So now we have

25597
02:32:07,330 --> 02:32:09,730
something for cancelled item,
we're also going to need

25598
02:32:09,730 --> 02:32:12,550
something for what? Well, you
guessed it for buying the item.

25599
02:32:12,730 --> 02:32:15,250
So let's make another one of
these murales to cloud that

25600
02:32:15,250 --> 02:32:19,240
after save. And we're going to
be using most of this same exact

25601
02:32:19,240 --> 02:32:23,110
code for item bought that we use
for item cancelled, we probably

25602
02:32:23,110 --> 02:32:25,810
should turn it all into a
function. But for practice,

25603
02:32:25,840 --> 02:32:28,090
we're just going to go ahead and
do it one more time, we'll do

25604
02:32:28,360 --> 02:32:32,740
Morales dot cloud. And then my
VS code keeps sticking this in

25605
02:32:32,740 --> 02:32:37,960
for some reason. I'm going to
undo that Morales dot Cloud dot

25606
02:32:37,960 --> 02:32:42,910
after save. Item bot is the
event. There'll be an async

25607
02:32:42,940 --> 02:32:49,810
request little arrow function
here, say const confirmed equals

25608
02:32:50,410 --> 02:32:55,330
request that object dot get
confirmed will get whether this

25609
02:32:55,330 --> 02:32:58,960
transaction is confirmed. We'll
get the logger I'm just going to

25610
02:32:58,960 --> 02:33:01,990
copy paste so I get it right
this time. So I'm going to copy

25611
02:33:01,990 --> 02:33:05,500
and paste those two lines const
logger equals Morales dot Cloud

25612
02:33:05,560 --> 02:33:12,130
dot get logger logger dot info.
And we'll say If confirmed const

25613
02:33:12,550 --> 02:33:19,450
active item equals Morales dot
object dot extend active item

25614
02:33:20,020 --> 02:33:24,280
const query and for this query,
I'm actually just going to copy

25615
02:33:24,280 --> 02:33:26,770
these lines because this is
going to be exactly the same.

25616
02:33:26,860 --> 02:33:29,590
We're going to look for the NFT
address and the token ID and the

25617
02:33:29,590 --> 02:33:33,280
marketplace address. And if we
look in our NFT dot soul and up

25618
02:33:33,280 --> 02:33:36,820
to marketplace dot som alright
and bot event as the NFT

25619
02:33:36,820 --> 02:33:40,600
address. And the token ID which
is what we want to find are

25620
02:33:40,600 --> 02:33:44,950
listed and of team. So we'll run
that query. We'll do const bots

25621
02:33:44,980 --> 02:33:50,380
item equals await query dot
first, and we'll do exactly what

25622
02:33:50,380 --> 02:33:57,610
we did before. If bots item then
logger dot info, deleting

25623
02:33:57,850 --> 02:34:06,220
request dot object dot get
object ID await bought item dot

25624
02:34:06,220 --> 02:34:16,150
destroy logger dot info deleted
item with Open ID request dot

25625
02:34:16,150 --> 02:34:24,370
object dot get open ID at
address request dot object dot

25626
02:34:24,370 --> 02:34:24,880
get

25627
02:34:26,140 --> 02:34:30,910
address. And then if we don't
find it will say else. Logger

25628
02:34:30,940 --> 02:34:38,680
dot info, no item found with
address request that object dot

25629
02:34:38,680 --> 02:34:45,910
get address and token, Id
request that object dot get

25630
02:34:46,600 --> 02:34:50,470
token ID. Cool. So that looks
good. Let's go ahead and upload

25631
02:34:50,470 --> 02:34:56,200
this to the cloud. So do yarn
oralis Cloud changes uploaded

25632
02:34:56,200 --> 02:34:59,200
correctly. Let's go make sure it
looks good on our server. So

25633
02:34:59,200 --> 02:35:03,400
we'll give a morale server a
little refresh. Go to Cloud

25634
02:35:03,400 --> 02:35:06,970
Functions here. I can see the
item cancelled in here still.

25635
02:35:07,180 --> 02:35:11,020
And now I can see the item
bought after save perfect. Looks

25636
02:35:11,020 --> 02:35:14,020
like I'm at 100 percent capacity. So
we're gonna give it a second

25637
02:35:14,020 --> 02:35:17,470
just to cool down thinking give
it a little refresh and looks

25638
02:35:17,470 --> 02:35:19,960
like we're back down after our
cloud function has been

25639
02:35:19,960 --> 02:35:22,990
uploaded. Okay, cool. To test
out that this part is working.

25640
02:35:23,020 --> 02:35:26,230
Let's go ahead we'll write
another script here. Do new file

25641
02:35:26,740 --> 02:35:31,990
by item dot j s. And we'll do
the same thing right now. On our

25642
02:35:31,990 --> 02:35:35,350
database. We don't have any
active items. So we'll just run

25643
02:35:35,350 --> 02:35:40,060
real quick. We're on mint and
list. Mint a new one. We'll go

25644
02:35:40,060 --> 02:35:43,420
check our database we'll do a
little refresh. Looks like

25645
02:35:43,420 --> 02:35:47,110
active vitamins in here with a
token ID of two now. So we'll do

25646
02:35:47,140 --> 02:35:52,450
is we'll buy that token ID so
we'll say const ethers network

25647
02:35:53,260 --> 02:36:01,840
equals require arhats const move
blocks equals require dot slash

25648
02:36:01,870 --> 02:36:09,460
utils slash move blocks const
token ID equals to async

25649
02:36:09,520 --> 02:36:19,600
function by item const NFT
marketplace equals await ethers

25650
02:36:19,600 --> 02:36:26,650
dot get contract NF T
marketplace const basic NF t

25651
02:36:26,680 --> 02:36:36,280
equals await ethers dot get
contract basic NFT coms listing

25652
02:36:36,370 --> 02:36:43,000
equals await and ft market place
dot get listing basic NF T dot

25653
02:36:43,000 --> 02:36:51,580
address and the token ID will
say const price equals listing

25654
02:36:51,610 --> 02:36:56,230
that price that to string and
we'll say const Tx and this is

25655
02:36:56,230 --> 02:36:59,950
us going to actually buy it
equals await and ft marketplace

25656
02:37:00,280 --> 02:37:10,150
dot buy item basic n f t dot
address, token ID, comma. And

25657
02:37:10,150 --> 02:37:13,600
then the value of course is
going to be the price. Do await

25658
02:37:13,630 --> 02:37:21,400
TX dot wait one, console dot log
bots NF t. And then if network

25659
02:37:21,400 --> 02:37:31,000
dot config dot chain ID equals
31337, then await move blocks to

25660
02:37:31,030 --> 02:37:37,060
comma, sleep amount equals 1000.
And then this is a script of

25661
02:37:37,060 --> 02:37:39,550
course, so we're going to use
the same stuff we're using for

25662
02:37:39,550 --> 02:37:42,550
cancel. But instead of
cancelled, it's going to be

25663
02:37:42,550 --> 02:37:47,680
called by item. So we have the
item inactive item here, we run

25664
02:37:47,680 --> 02:37:54,730
yarn, art hat run scripts by
item.js Dash network, localhost.

25665
02:37:55,090 --> 02:37:59,080
Now we can test buying this
item. Okay, Bob, the NFT looping

25666
02:37:59,080 --> 02:38:02,260
blocks, we'll do a little
refresh on our database, and

25667
02:38:02,260 --> 02:38:06,340
boom, we can see the active item
is gone. And we can see, the

25668
02:38:06,340 --> 02:38:10,300
item has now been bought.
Awesome. We're almost done

25669
02:38:10,300 --> 02:38:14,050
keeping our active item, just a
table of active items. But

25670
02:38:14,050 --> 02:38:16,750
there's one more thing we should
do. We're not going to test this

25671
02:38:16,750 --> 02:38:19,960
here. But if you want to test
it, we can we actually in our

25672
02:38:19,960 --> 02:38:23,500
NFT marketplace, go to
marketplace dot Sol, we actually

25673
02:38:23,500 --> 02:38:27,850
have an update listing function
as well, that also admits an

25674
02:38:27,850 --> 02:38:32,410
item listed. So we also want to
check to see if item listed is

25675
02:38:32,410 --> 02:38:37,120
coming from update listening. So
back in our item listed Cloud

25676
02:38:37,120 --> 02:38:41,320
Function, before we actually
start saving stuff, we want to

25677
02:38:41,320 --> 02:38:45,580
check to see if it already
exists. So we're gonna say so

25678
02:38:45,670 --> 02:38:52,600
we'll say const query equals new
mirallas dot query. And sorry, I

25679
02:38:52,600 --> 02:38:56,740
keep sticking the sin of active
item. And we're going to do

25680
02:38:56,740 --> 02:38:59,650
exactly what we've been doing.
We're gonna say query dot equal

25681
02:38:59,650 --> 02:39:03,970
to NFT. Address, we're gonna
look for the NFT address request

25682
02:39:04,000 --> 02:39:10,090
dot object dot get and ft
address, query dot equal to

25683
02:39:11,260 --> 02:39:18,850
token ID, request that object
dot get token ID, query dot

25684
02:39:18,880 --> 02:39:26,410
equal to marketplace, address,
comma request dot object dot get

25685
02:39:26,830 --> 02:39:35,620
address query dot equal to
seller requests dot object dot

25686
02:39:35,620 --> 02:39:42,310
get seller will say const
already listed item equals await

25687
02:39:42,700 --> 02:39:46,840
query dot first. And then we'll
say if this item has already

25688
02:39:47,230 --> 02:39:51,700
been listed. Then we'll go ahead
and say logger dot info.

25689
02:39:52,060 --> 02:39:59,890
Deleting already listed request
dot object dot get object ID.

25690
02:40:00,220 --> 02:40:06,520
And we'll do a weight already
listed item dot destroy. And

25691
02:40:06,520 --> 02:40:16,120
then do logger dot info, deleted
item with token ID request dot

25692
02:40:16,120 --> 02:40:24,820
object dot get token ID at
address request dot object dot

25693
02:40:24,820 --> 02:40:31,510
get address since it's already
been listed, if the object has

25694
02:40:31,540 --> 02:40:33,940
already been listed, we know
that it's coming from this

25695
02:40:33,970 --> 02:40:37,240
update listing function. So
we're going to delete it first,

25696
02:40:37,270 --> 02:40:40,960
and then we'll resave it with
its new price. So and let's just

25697
02:40:40,960 --> 02:40:45,640
go ahead, and let's upload this
to the cloud yarn Morales cloud.

25698
02:40:46,630 --> 02:40:49,660
upload this to our server
changes uploaded correctly.

25699
02:40:50,560 --> 02:40:54,490
Let's go check our server, give
it a little refresh. We'll go

25700
02:40:54,490 --> 02:41:00,130
check Cloud Functions. And it
looks like our item listed query

25701
02:41:00,280 --> 02:41:04,630
for deleting is now in here. But
with all that, we now have a way

25702
02:41:04,810 --> 02:41:09,430
to constantly have this active
item table only be the items

25703
02:41:09,430 --> 02:41:12,040
that are actively on our
marketplace without having to

25704
02:41:12,040 --> 02:41:15,400
spend any additional gas in our
application. And this is going

25705
02:41:15,400 --> 02:41:18,040
to be way better for user
experience because they're not

25706
02:41:18,040 --> 02:41:21,850
going to have to pay extra gas
to keep all these entities and

25707
02:41:21,850 --> 02:41:24,760
maybe an array or some more data
structures. If you've made it

25708
02:41:24,760 --> 02:41:28,120
this far. This is easily one of
the hardest parts of this

25709
02:41:28,120 --> 02:41:30,760
course, because we're working
with a ton of technologies.

25710
02:41:31,210 --> 02:41:33,700
We're working with a smart
contract, we're working with

25711
02:41:33,790 --> 02:41:37,540
Cloud Functions, we're working
with a back end database. Now if

25712
02:41:37,540 --> 02:41:40,540
you've made it this far, you
should be incredibly incredibly

25713
02:41:40,540 --> 02:41:45,970
proud. So now let's just go
ahead, let's mint and list one

25714
02:41:45,970 --> 02:41:50,170
more NFT. So we'll do we'll run
yarn heart at run scripts, mint

25715
02:41:50,170 --> 02:41:53,440
and list network local hosts
will meant it will list it or

25716
02:41:53,440 --> 02:41:56,950
sleeping. Let's go check our
database. We'll do a refresh. We

25717
02:41:56,950 --> 02:42:01,660
see the active item in here. And
now let's learn how to call all

25718
02:42:01,660 --> 02:42:06,430
of the objects in In our active
item database here, let's do it.

25719
02:42:06,520 --> 02:42:09,550
And remember, if you ever reset
your local blockchain, you're

25720
02:42:09,550 --> 02:42:12,520
gonna have to come in here and
delete all the rows in the

25721
02:42:12,520 --> 02:42:13,660
support tables.

25722
02:42:16,330 --> 02:42:20,770
With all that being said, it's
time to finally come back to our

25723
02:42:20,770 --> 02:42:25,720
front end, and come back to our
index dot J. S and answer this

25724
02:42:25,720 --> 02:42:30,040
question. How do we show the
recently listed NF Ts, we only

25725
02:42:30,040 --> 02:42:33,490
want to show the active NF t's
on the marketplace. And now we

25726
02:42:33,490 --> 02:42:38,140
have a system for getting only
the active ones, only the ones

25727
02:42:38,200 --> 02:42:41,170
that are currently on the
market, because we're indexing

25728
02:42:41,170 --> 02:42:43,810
these events. Now, I'm going to
delete all these comments here.

25729
02:42:44,080 --> 02:42:47,410
And let's do this. So what we're
going to do is we're going to do

25730
02:42:47,410 --> 02:42:50,770
this thing called use Morales
query. So if we go to the React

25731
02:42:50,770 --> 02:42:55,090
Morales docks, there is a hook
called use Morales query. And

25732
02:42:55,090 --> 02:42:59,290
this allows us to fetch and make
queries to our database in a

25733
02:42:59,290 --> 02:43:03,790
React context. Back in here,
we're going to say, import, use

25734
02:43:03,820 --> 02:43:09,490
Morales query from react
mirallas. Now, if you look in

25735
02:43:09,490 --> 02:43:14,680
the docs here, use mouse query
returns data error is loading.

25736
02:43:14,890 --> 02:43:18,520
And this will automatically run
this query the instant our index

25737
02:43:18,520 --> 02:43:22,600
pops up. So to get the data from
the query to get all of our

25738
02:43:22,600 --> 02:43:26,170
active items from our database,
we'll say const data, and we'll

25739
02:43:26,170 --> 02:43:31,150
rename data to listed and fts.
And then we'll also check to see

25740
02:43:31,210 --> 02:43:35,890
if this query is still fetching.
So we'll say is fetching and

25741
02:43:35,890 --> 02:43:41,830
then we'll rename that to
fetching listed NF t is equals

25742
02:43:42,190 --> 02:43:46,420
use Morales query. And inside
here, this takes two input

25743
02:43:46,420 --> 02:43:49,930
parameters, it takes the table
name to do the search on and

25744
02:43:49,930 --> 02:43:54,070
then it also takes a function or
the query. So the table name

25745
02:43:54,070 --> 02:43:56,110
that we're going to be looking
for is going to be active item.

25746
02:43:57,040 --> 02:44:01,150
And then the function for the
query is going to be we're going

25747
02:44:01,150 --> 02:44:06,790
to say query dot, we'll limit it
just to 10. So we'll say only

25748
02:44:06,790 --> 02:44:12,280
the first 10, we'll do it in dot
descending order, based off the

25749
02:44:12,280 --> 02:44:16,150
token ID. And then if we wanted
to do different pages, we could

25750
02:44:16,150 --> 02:44:20,200
do this thing called dot skip
with page numbers, we're not

25751
02:44:20,200 --> 02:44:22,480
going to do page numbers here.
So we're just going to leave it

25752
02:44:22,480 --> 02:44:25,000
like this for now. And that's
it. So we're saying, okay,

25753
02:44:25,000 --> 02:44:29,530
great, grab from our database on
the active item table, grab just

25754
02:44:29,530 --> 02:44:33,250
the first 10 in descending order
of the token ID. Now it's going

25755
02:44:33,250 --> 02:44:38,170
to save the result of this to
this listed NF TS section. Now

25756
02:44:38,170 --> 02:44:42,640
to see if this is working. Let's
just do a little console dot log

25757
02:44:43,150 --> 02:44:47,710
listed NF t's just to see what
this using Ross query actually

25758
02:44:47,710 --> 02:44:50,500
returns for us. And now we have
our local blockchain Node

25759
02:44:50,500 --> 02:44:54,250
running, we have our connection
to our Morales server, and we

25760
02:44:54,250 --> 02:44:57,310
have our front end running. So
let's go to our front end, we'll

25761
02:44:57,310 --> 02:45:00,280
do a little refresh here, we'll
right click and hit Inspect,

25762
02:45:00,370 --> 02:45:04,480
we'll go to the console. And we
see we have this array being

25763
02:45:04,480 --> 02:45:08,530
spit out here. Now the first
time it console dot logs, it's

25764
02:45:08,530 --> 02:45:13,060
empty. This is because when it
initially loads listed out of

25765
02:45:13,060 --> 02:45:15,520
T's hasn't returned yet. And
it's so it's actually just going

25766
02:45:15,520 --> 02:45:18,250
to be an empty array. But when
it finishes loading, we're going

25767
02:45:18,250 --> 02:45:21,100
to get an array of size one, we
get an array of size one,

25768
02:45:21,100 --> 02:45:24,550
because active item only has one
enter right now. So we get this

25769
02:45:24,550 --> 02:45:28,840
array of size one, and we can
see it index zero, we have class

25770
02:45:28,840 --> 02:45:32,260
name active item, we have the
item ID, we have all these

25771
02:45:32,260 --> 02:45:35,410
attributes, which are going to
be created at the marketplace

25772
02:45:35,410 --> 02:45:38,410
address. And if the address the
price, the seller and the token

25773
02:45:38,410 --> 02:45:43,150
ID this is exactly what we see
in our database here. So

25774
02:45:43,150 --> 02:45:46,240
Perfect. That's exactly what we
want to be able to show these NF

25775
02:45:46,240 --> 02:45:50,170
t's on the front end. So how do
we actually show this NFT and

25776
02:45:50,170 --> 02:45:53,560
list this NF T. For people who
aren't developers and aren't

25777
02:45:53,560 --> 02:45:55,810
going to go into the console dot
log? Well, what we're going to

25778
02:45:55,810 --> 02:46:00,280
be doing is in this return here,
we'll put some parentheses

25779
02:46:00,310 --> 02:46:03,820
around this. First, we should
check to see if we are fetching

25780
02:46:03,820 --> 02:46:07,330
those listed NF T's. So we'll do
some JavaScript stuff. And we'll

25781
02:46:07,330 --> 02:46:11,830
say fetching listed NF T's and
we'll do a ternary operator. So

25782
02:46:11,830 --> 02:46:15,130
we're gonna say if we are
fetching those NF T's, let's add

25783
02:46:15,130 --> 02:46:19,000
like a little div div that just
says loading that that done,

25784
02:46:19,210 --> 02:46:22,840
we'll put a little colon here.
And if we're not fetching, we'll

25785
02:46:22,840 --> 02:46:29,890
do we'll say listed NF TS dot
map. So dot map basically loops

25786
02:46:29,890 --> 02:46:35,080
through and does some function
on all of the listed entities in

25787
02:46:35,080 --> 02:46:37,600
the function we're going to want
ours to do. And it's going to

25788
02:46:37,600 --> 02:46:41,080
take each NF t as input
parameters. So we say we're

25789
02:46:41,080 --> 02:46:44,380
going to basically loop through
each NF T. And we're going to

25790
02:46:44,380 --> 02:46:50,200
say, console dot log and F T dot
attribute attributes with an S.

25791
02:46:50,410 --> 02:46:54,730
And then inside of these inside
of this attributes are the

25792
02:46:54,730 --> 02:46:56,980
different pieces that we want.
So we're going to get those

25793
02:46:56,980 --> 02:47:01,120
pieces we'll say const we want
to show the price. The NFT

25794
02:47:01,120 --> 02:47:05,560
address, the token ID in the
marketplace address, which of

25795
02:47:05,560 --> 02:47:07,990
course is just gonna be this
one, and then the seller, that's

25796
02:47:08,020 --> 02:47:10,150
all this information that we're
going to want to show on the

25797
02:47:10,150 --> 02:47:15,130
front end will say that equals
NF T dot attributes. So we're

25798
02:47:15,130 --> 02:47:19,360
going to pull these out, and we
can see price seller token ID,

25799
02:47:19,360 --> 02:47:22,570
etc. We're going to pull those
out of NF T dot attributes. And

25800
02:47:22,570 --> 02:47:26,440
we can show those by in this
function here, we'll say return.

25801
02:47:26,560 --> 02:47:30,970
And then we'll return some HTML,
we'll do like div div. And then

25802
02:47:30,970 --> 02:47:33,610
we can say like price, price,
price,

25803
02:47:34,660 --> 02:47:44,050
period, and f t address and ft
address, token ID, token ID

25804
02:47:44,230 --> 02:47:48,610
seller, then added this for some
reason. So I'm going to delete

25805
02:47:48,610 --> 02:47:52,270
that add $1 signs before all
these for some reason, delete

25806
02:47:52,270 --> 02:47:56,650
those, save. Now if I go to the
front end, I can now see

25807
02:47:56,680 --> 02:48:01,060
information about our NFT from
our database is listed here.

25808
02:48:01,090 --> 02:48:04,510
That's fantastic. We see the
price we see the address, we see

25809
02:48:04,510 --> 02:48:08,110
the token ID we see the seller.
Now if we go back to our NFT

25810
02:48:08,110 --> 02:48:11,290
marketplace, our little our
little hard hat MC marketplace,

25811
02:48:11,320 --> 02:48:15,760
let's mint another one. Yarn
hard hat run scripts mentalist

25812
02:48:15,790 --> 02:48:19,480
Dash network localhost, we're
going to run that it's going to

25813
02:48:19,480 --> 02:48:23,890
mint one more. If we go back to
our Morales database, we do a

25814
02:48:23,890 --> 02:48:27,580
little refresh on that active
item table, we now have a new

25815
02:48:27,580 --> 02:48:31,210
item in here. So if we go back
to our front end, we give this a

25816
02:48:31,210 --> 02:48:35,770
little refresh. And boom, now we
have two items in here. So this

25817
02:48:35,770 --> 02:48:38,680
is awesome, we now have a way to
actually show the most recently

25818
02:48:38,680 --> 02:48:41,590
listed NF t's on our
marketplace, plus ah.

25819
02:48:44,380 --> 02:48:46,630
Now, of course, you might be
saying to yourself, hey,

25820
02:48:46,630 --> 02:48:51,370
Patrick, that's cool and all.
But that looks really ugly. And

25821
02:48:51,400 --> 02:48:55,300
I would agree with you. But 100 percent
agree with you. So we should

25822
02:48:55,300 --> 02:48:59,980
come up with a component to show
our listed entities that looks a

25823
02:48:59,980 --> 02:49:02,920
lot nicer. So when instead of
returning and just printing out

25824
02:49:02,920 --> 02:49:05,680
the raw information, we probably
want to show the image, right,

25825
02:49:05,680 --> 02:49:08,020
we want to show the image, we
want to make everything look a

25826
02:49:08,020 --> 02:49:10,720
lot nicer. So we're going to
create a new component that

25827
02:49:10,720 --> 02:49:13,780
we're going to return in here to
format all of our NF T's

25828
02:49:13,780 --> 02:49:17,380
appropriately. So we're gonna go
to components, we'll do new

25829
02:49:17,380 --> 02:49:21,640
file, and we're going to call NF
T box dot j s. And this is where

25830
02:49:21,640 --> 02:49:24,880
we're going to grab all the
information on how to show what

25831
02:49:24,880 --> 02:49:27,520
our NFT actually looks like. So
let's get started working on our

25832
02:49:27,520 --> 02:49:30,100
entity box, we're gonna set this
up, the way we've been setting

25833
02:49:30,100 --> 02:49:35,170
all these up would do export
default function, and ft box.

25834
02:49:35,770 --> 02:49:38,710
Now something that's a little
bit different for this one,

25835
02:49:38,710 --> 02:49:42,850
though, is that in our index, we
have all this information. So

25836
02:49:42,850 --> 02:49:47,110
we're gonna need to pass all
these variables to our NFT Box

25837
02:49:47,110 --> 02:49:50,650
component. So to do that, we'll
add them as input parameters for

25838
02:49:50,650 --> 02:49:54,580
our component here. So we'll say
price, and if the address, token

25839
02:49:54,580 --> 02:50:00,160
ID, marketplace, address, and
seller. So right now on our

25840
02:50:00,160 --> 02:50:02,530
front end, we just have a whole
bunch of text, and we even have

25841
02:50:02,530 --> 02:50:04,630
this gross warning, we're gonna
get rid of that tip. And as we

25842
02:50:04,630 --> 02:50:08,950
know, tokens have their token
URI, which points to an image

25843
02:50:08,950 --> 02:50:13,090
URI or an image URL of what the
actual token looks like. So what

25844
02:50:13,090 --> 02:50:16,360
we're going to want to do is
we're going to want to call that

25845
02:50:16,360 --> 02:50:20,920
token URI, and then call the
image URI to show the image. So

25846
02:50:20,920 --> 02:50:24,310
we're going to actually have to
wait those two API requests to

25847
02:50:24,310 --> 02:50:28,210
get the actual image. And we're
going to save that image as a

25848
02:50:28,210 --> 02:50:32,350
state variable on this component
here. So as you already know,

25849
02:50:32,380 --> 02:50:34,990
we're going to work with use
state to keep track of that

25850
02:50:34,990 --> 02:50:40,870
image URI. So we'll do import,
use state from react like this.

25851
02:50:41,260 --> 02:50:48,370
And in here, we'll say const,
image, Uri, comma set image, URI

25852
02:50:48,610 --> 02:50:53,710
equals use state. And we'll
start it off as a blank string.

25853
02:50:53,830 --> 02:50:57,310
Now let's create a function,
we're going to call it update UI

25854
02:50:57,340 --> 02:51:01,720
to update our UI and grab this
token URI and the image URI. So

25855
02:51:01,720 --> 02:51:06,250
we'll create an async function
called Update UI. And in order

25856
02:51:06,250 --> 02:51:10,780
to get the image first, we're
gonna need to get the token URI,

25857
02:51:10,810 --> 02:51:17,260
and then using the image ag from
the token URI gets the image. So

25858
02:51:17,260 --> 02:51:20,770
first thing we're gonna have to
do is get the token URI. So we

25859
02:51:20,770 --> 02:51:24,160
know how to do this with use web
three contract. So we'll do

25860
02:51:24,160 --> 02:51:29,320
import, use web three contract
from react Morales. And as we

25861
02:51:29,320 --> 02:51:31,540
know, use web through contracts
is going to need some

25862
02:51:31,540 --> 02:51:38,200
parameters. So we'll say const
run contract function, get token

25863
02:51:38,200 --> 02:51:44,050
URI, equals, use web through
contract. First, we need the ABI

25864
02:51:44,200 --> 02:51:48,520
of the NFT because we're gonna
need to call token URI. So to

25865
02:51:48,520 --> 02:51:51,790
get the ABI we're gonna need to
once again update our front end.

25866
02:51:51,820 --> 02:51:54,700
So let's comment this part out.
We'll go back to our hard hat

25867
02:51:54,700 --> 02:51:58,420
piece. And let's look in our
deploy scripts. We have this

25868
02:51:58,420 --> 02:52:03,010
update front end right now. All
this is doing is updating calm

25869
02:52:03,040 --> 02:52:05,710
object addresses. Well, that's
good. We're also going to want

25870
02:52:05,710 --> 02:52:09,400
to add API's to our front end as
well. So let's create another

25871
02:52:09,400 --> 02:52:12,970
function in here called Update
API. And we'll pass the API's as

25872
02:52:12,970 --> 02:52:17,890
well. So we'll do async function
update API. And we'll give it

25873
02:52:17,890 --> 02:52:22,540
both the basic NFT API and the
NFT marketplace API, because

25874
02:52:22,540 --> 02:52:25,510
we're going to need both of
them. So we'll say const NF T,

25875
02:52:25,960 --> 02:52:31,990
marketplace equals await ethers
dot get contract. And f t

25876
02:52:32,470 --> 02:52:35,860
marketplace, we're going to
write the ABI to the front end

25877
02:52:35,860 --> 02:52:39,610
API location, we have the front
end contracts file. So let's

25878
02:52:39,610 --> 02:52:46,960
also do a const. Front and ABI
location equals, and we'll do

25879
02:52:46,960 --> 02:52:54,070
dot dot slash next, Jas, and if
T marketplace dash FCC slash

25880
02:52:54,070 --> 02:52:56,890
constants, and instead of
actually just giving the file

25881
02:52:56,890 --> 02:53:00,580
name, we can just give it the
front end API location. And then

25882
02:53:00,580 --> 02:53:03,100
we'll actually have it generate
that file for us because we're

25883
02:53:03,100 --> 02:53:06,940
just going to overwrite the ABI
file anytime we work with it. So

25884
02:53:06,940 --> 02:53:09,130
now that we have the
marketplace, we'll just do Fs

25885
02:53:09,130 --> 02:53:16,900
dot right file sync, and we'll
do front and ABI location, and

25886
02:53:16,900 --> 02:53:26,140
ft marketplace, dot JSON. And ft
marketplace, dot interface that

25887
02:53:26,140 --> 02:53:33,400
format ethers dot utils dot
format types dot JSON. So we're

25888
02:53:33,400 --> 02:53:35,830
also going to want to do that
for the basic NF t. So we'll say

25889
02:53:35,830 --> 02:53:41,680
const basic NF t equals await
ethers dot get contract basic NF

25890
02:53:41,680 --> 02:53:47,560
T Fs dot right? file sync, it's
going to be that exact same

25891
02:53:47,560 --> 02:53:50,980
place right here. Except for
it's going to be a different

25892
02:53:50,980 --> 02:53:55,480
location, it's going to be basic
NFT dot JSON. And of course,

25893
02:53:55,480 --> 02:54:00,580
we're gonna do a comma basic NF
T, that interface dot format

25894
02:54:00,820 --> 02:54:05,920
ethers dot utils, dot format,
types dot JSON, you can find

25895
02:54:05,920 --> 02:54:08,590
this NFT marketplace that
interface in the Hardhead

25896
02:54:08,590 --> 02:54:11,530
documentation. And you can find
this in the ethers

25897
02:54:11,530 --> 02:54:15,250
documentation. So now we have
this update ABI function. Let's

25898
02:54:15,280 --> 02:54:19,690
also add this to our module that
exports so we'll do a weight up

25899
02:54:19,690 --> 02:54:21,850
the ABI like that.

25900
02:54:23,140 --> 02:54:25,450
There's a hyphen here that
shouldn't be here. And we'll run

25901
02:54:25,480 --> 02:54:30,970
just this part of our hardhat
front end, run yarn, hard hat,

25902
02:54:31,030 --> 02:54:36,100
deploy dash, dash dash tags, the
tag here is front end, front

25903
02:54:36,100 --> 02:54:39,430
end. And now it's had nothing to
compile updating front end, it's

25904
02:54:39,430 --> 02:54:42,970
done. So if we go back to our
front end, now, we go to our

25905
02:54:42,970 --> 02:54:46,450
constants, we now see two
objects in here, which are going

25906
02:54:46,450 --> 02:54:50,350
to be API's, the basic NFT, and
the NFT. Marketplace. Awesome.

25907
02:54:50,380 --> 02:54:54,040
So now that we have that, we can
import those into our front end.

25908
02:54:54,130 --> 02:55:00,490
So we can say import, and if T
marketplace, abi from dot dot

25909
02:55:00,490 --> 02:55:07,150
slash constants slash NF T,
marketplace dot JSON. And we can

25910
02:55:07,150 --> 02:55:12,790
also get the NF T API. So we'll
do import NF T, abi from that

25911
02:55:12,790 --> 02:55:18,370
the slash constants slash basic
NF T dot JSON. Now in our run

25912
02:55:18,370 --> 02:55:23,350
contract function, our token URI
function is part of the NFT API.

25913
02:55:23,380 --> 02:55:27,340
So the API will be the NFT, abi,
the contract address

25914
02:55:29,110 --> 02:55:32,080
is going to be the address of
the NFT, which we're passing in

25915
02:55:32,230 --> 02:55:36,430
as a parameter. So we'll pass an
NF T address, the function name

25916
02:55:36,550 --> 02:55:41,290
is going to be token URI, and
the params are going to be the

25917
02:55:41,290 --> 02:55:45,940
token ID, which is getting
passed as an input parameter to

25918
02:55:45,940 --> 02:55:49,570
this function to this component.
Right. And we can double check.

25919
02:55:49,780 --> 02:55:53,230
We're good to our basic NF T dot
soul, right? We scroll down, we

25920
02:55:53,230 --> 02:55:55,690
have this token URI that we're
overriding. And this is the

25921
02:55:55,690 --> 02:55:59,110
function we want to call takes
the token ID. So this the

25922
02:55:59,110 --> 02:56:02,530
function we want to call takes
the token ID. Okay, great. So in

25923
02:56:02,530 --> 02:56:07,960
our update UI, first, we'll say
const, token URI equals await

25924
02:56:08,680 --> 02:56:13,390
token URI. Now let's do a little
console dot log token your eye,

25925
02:56:13,690 --> 02:56:16,510
just to see what this returns to
make sure that update UI is

25926
02:56:16,510 --> 02:56:20,170
called, we'll add it to a use
effect, we'll say use effect.

25927
02:56:20,320 --> 02:56:23,770
And this takes an input
parameter of a function to do,

25928
02:56:23,920 --> 02:56:28,450
we'll just say Update UI. And
then we'll only have this run

25929
02:56:28,540 --> 02:56:33,160
anytime is web three enabled
changes. So we want to run

25930
02:56:33,190 --> 02:56:36,790
update UI, but we want it to be
dependent on is web three

25931
02:56:36,790 --> 02:56:40,750
enabled. And then we'll say if
it's web three enabled, then

25932
02:56:41,380 --> 02:56:44,980
update UI. So we need to add use
effect as well. So we're using

25933
02:56:44,980 --> 02:56:49,210
use state, we'll do comma, use
effect. And now we should at

25934
02:56:49,210 --> 02:56:52,360
least be reading our token URI
off the blockchain. We're not

25935
02:56:52,360 --> 02:56:54,010
going to set the image yet,
right, because we're going to

25936
02:56:54,010 --> 02:56:58,840
get the image URI from the token
neuron. Let's add this NFT box

25937
02:56:58,870 --> 02:57:02,800
to our index to see if it's
working well so far back in our

25938
02:57:02,800 --> 02:57:09,070
index Next, up at the top, we
will import NF T box from dot

25939
02:57:09,070 --> 02:57:14,920
dot slash components slash NF T
box. And down here, while we're

25940
02:57:14,920 --> 02:57:18,370
returning this will add our NF T
box component will make sure to

25941
02:57:18,370 --> 02:57:21,970
pass in all the parameters it
takes. So the price is going to

25942
02:57:21,970 --> 02:57:27,100
equal that JavaScript price. And
ft address is going to equal the

25943
02:57:27,100 --> 02:57:31,510
JavaScript entity address. The
token ID is going to equal the

25944
02:57:31,510 --> 02:57:39,040
token ID, marketplace address is
going to be marketplace address

25945
02:57:39,580 --> 02:57:43,510
seller is going to be the
seller. And you saw that warning

25946
02:57:43,510 --> 02:57:45,490
where it's saying, hey, all the
components need to all the

25947
02:57:45,490 --> 02:57:49,120
things in the mapping need to
have their unique key. So we'll

25948
02:57:49,120 --> 02:57:52,330
say key, we'll give these all a
key as well. We'll say key

25949
02:57:52,330 --> 02:57:55,060
equals this, we'll do some
string interpolation, we'll just

25950
02:57:55,060 --> 02:57:59,410
say the NFT address, combined
with the token ID can be the

25951
02:57:59,410 --> 02:58:03,280
key. So if we save that, go back
to our front end here, do a

25952
02:58:03,280 --> 02:58:08,650
little refresh marketplace
address is not defined market

25953
02:58:08,860 --> 02:58:11,650
place address. So let's make
sure we spell things right,

25954
02:58:11,680 --> 02:58:14,470
let's go back to the front end,
we'll give it a refresh is what

25955
02:58:14,470 --> 02:58:17,740
three enabled is not defined.
Oops, excuse me in the NFT box,

25956
02:58:17,980 --> 02:58:20,860
we need to grab that from us
Morales, so we'll import use

25957
02:58:20,890 --> 02:58:26,890
Morales. And in our ponents here
we'll say const is web three

25958
02:58:27,040 --> 02:58:33,040
enabled equals use Morales.
We'll save that. And one thing I

25959
02:58:33,040 --> 02:58:36,250
noticed actually is this needs
to be wrapped in squigglies.

25960
02:58:36,280 --> 02:58:39,220
Sorry, I forgot to do that. Our
component actually just takes a

25961
02:58:39,220 --> 02:58:42,310
props, props input parameter.
And we would need to do like

25962
02:58:42,340 --> 02:58:46,990
props that token ID to get token
ID. But instead, we just extract

25963
02:58:46,990 --> 02:58:50,170
it out by doing putting the
little squiggly brackets here.

25964
02:58:50,230 --> 02:58:52,990
So put the squiggly brackets
there. Great, we'll do a little

25965
02:58:52,990 --> 02:58:56,170
console dot log token, your eye,
or index.js has everything

25966
02:58:56,170 --> 02:59:00,430
updated. Here. Let's do a little
save. And we can even say if is

25967
02:59:00,430 --> 02:59:05,620
web three enabled up the UI.
Like that we'll save we'll go to

25968
02:59:05,620 --> 02:59:07,840
the front end, we'll do a little
refresh. We'll see if

25969
02:59:07,840 --> 02:59:10,360
everything's working as
expected. And as long as we're

25970
02:59:10,360 --> 02:59:13,450
on that hard had localhost and
our meta mask. And again, you

25971
02:59:13,450 --> 02:59:16,360
can ignore this error, this
warning that's up here for now.

25972
02:59:16,480 --> 02:59:20,410
And if you click this, and you
have your IPFS and brave or your

25973
02:59:20,410 --> 02:59:24,640
IPFS companion, we can now see
we're getting our token URI,

25974
02:59:24,670 --> 02:59:27,640
which is perfect. The piece that
we want now is this image bid.

25975
02:59:27,700 --> 02:59:30,760
And for this one that I'm using
it is an HTTPS, which

25976
02:59:30,760 --> 02:59:33,130
technically isn't decentralized,
right, we would need it to come

25977
02:59:33,130 --> 02:59:37,600
from instead of HTTPS, we would
need to come from IPFS colon

25978
02:59:37,600 --> 02:59:42,640
slash slash but but actually
having it as HTTPS ipfs.io. For

25979
02:59:42,640 --> 02:59:45,940
now was good, we'll explain why
in just a second. Now that we

25980
02:59:45,940 --> 02:59:50,860
are getting the token URI, we
can call this URL, and we can

25981
02:59:50,860 --> 02:59:54,730
get back the image that we want
to actually show on the front

25982
02:59:54,730 --> 02:59:58,060
end. So in here, we'll do a
little console dot log, the

25983
02:59:58,150 --> 03:00:04,270
token, URI is string
interpolation, like this, and

25984
03:00:04,270 --> 03:00:08,050
then we'll say if token URI,
we're going to need to now grab

25985
03:00:08,050 --> 03:00:12,010
this token URI, and get the
image from it. And this is where

25986
03:00:12,010 --> 03:00:14,110
we're going to get a little bit
funky. And we're going to cheat

25987
03:00:14,110 --> 03:00:17,800
a little bit. Now for our
application, not everybody is

25988
03:00:17,800 --> 03:00:22,630
going to have IPFS companion,
not every browser is IPFS

25989
03:00:22,660 --> 03:00:26,110
compatible. So we're gonna have
to actually cheat a little bit

25990
03:00:26,110 --> 03:00:29,740
here, we're actually going to
change the token Uriah from its

25991
03:00:29,770 --> 03:00:34,990
IPFS edition to an H HTTPS
edition. And this is known as

25992
03:00:34,990 --> 03:00:42,430
using an IPFS gateway, which is
a server that will return IPFS

25993
03:00:42,460 --> 03:00:47,140
files from a normal URL. So
we're going to use an IPFS

25994
03:00:47,140 --> 03:00:52,150
gateway, which we can just make
regular HTTPS calls to, and it

25995
03:00:52,150 --> 03:00:55,720
will return those IPFS files. So
technically, are we making the

25996
03:00:55,720 --> 03:00:59,740
centralized doing this? Yes. And
is that ideal? No. However,

25997
03:00:59,830 --> 03:01:02,980
until the world adopt IPFS, and
until the world adopts the

25998
03:01:02,980 --> 03:01:05,350
standards, it's kind of what we
have to do right now. Because

25999
03:01:05,350 --> 03:01:07,810
otherwise, the front end will
just show up as blank to them.

26000
03:01:07,870 --> 03:01:10,780
And we can't have that we don't
want that. So we're gonna say

26001
03:01:10,780 --> 03:01:18,580
const request URL equals token
URI dot replace IPFS, slash

26002
03:01:18,580 --> 03:01:22,240
slash with HTTP s, HTTPS.

26003
03:01:25,210 --> 03:01:28,450
slash slash ipfs.io/ipfs/so.
We're saying, if you have a

26004
03:01:28,450 --> 03:01:32,530
token URI that starts with IPFS,
that's great. But we're going to

26005
03:01:32,530 --> 03:01:35,800
switch it to using an IPFS
gateway. It's really use the

26006
03:01:35,830 --> 03:01:41,350
IPFS gateway provided by the
team that builds IPFS. So pretty

26007
03:01:41,350 --> 03:01:44,920
reliable gateway is is kind of a
cop out. Yes. Are our files

26008
03:01:44,920 --> 03:01:48,970
still on? IPFS? Yes. So it's not
the end of the world. But this

26009
03:01:48,970 --> 03:01:52,240
is just going to make calling
these API's a lot easier for us.

26010
03:01:52,390 --> 03:01:59,290
And we're going to say const
token URI. Response equals

26011
03:01:59,590 --> 03:02:02,380
await. And this is going to be a
little weird. We're going to do

26012
03:02:02,380 --> 03:02:10,690
two awaits. await a weight fetch
request, URL dot JSON. So fetch

26013
03:02:10,720 --> 03:02:15,340
is a keyword you can use in
JavaScript to fetch or get a URL

26014
03:02:15,370 --> 03:02:18,370
fetch keyword is essentially
doing the same thing as pasting

26015
03:02:18,370 --> 03:02:22,210
this into the browser, like so.
And getting this JSON response.

26016
03:02:22,240 --> 03:02:25,960
So we await to get the response.
And then we await to convert the

26017
03:02:25,960 --> 03:02:29,230
response to JSON. And that's how
we get the toggle response. So

26018
03:02:29,230 --> 03:02:33,820
we now have this object in our
JavaScript, which is perfect

26019
03:02:33,820 --> 03:02:37,120
because this object has this
image attribute that we want. So

26020
03:02:37,150 --> 03:02:39,700
we're gonna do the same thing we
did here, we're gonna use the

26021
03:02:39,700 --> 03:02:44,470
IPFS gateway, this one's already
using HTTPS that ipfs.io. But if

26022
03:02:44,470 --> 03:02:46,870
it wasn't, we would still want
to convert it. So now we're

26023
03:02:46,870 --> 03:02:53,770
gonna say const. Image URI
equals token you are i response

26024
03:02:53,770 --> 03:02:58,210
dot image. So we're gonna get
the image tag of this response

26025
03:02:58,210 --> 03:03:04,120
here. And then we're going to
say const. Image URI URL, is

26026
03:03:04,120 --> 03:03:06,520
going to equal to, and we're
gonna do the exact same thing

26027
03:03:06,520 --> 03:03:10,150
that we did up here, we're going
to use the gateway image URI dot

26028
03:03:10,150 --> 03:03:19,750
replace IPFS, colon slash slash
with HTTPS ipfs.io/ipfs. And

26029
03:03:19,930 --> 03:03:24,670
now, and that's how we get this
URL right here. And so we can

26030
03:03:24,670 --> 03:03:32,110
finally do set image URI, to
that image URL. And now we have

26031
03:03:32,140 --> 03:03:35,230
our image URI is going to be
that image right here. Now, is

26032
03:03:35,230 --> 03:03:38,560
this a little bit wonky? Yes.
Are there better ways that we

26033
03:03:38,560 --> 03:03:40,870
can do this? Yes, there's
actually a number of better ways

26034
03:03:40,870 --> 03:03:43,420
that we could do some of this,
we could actually, since we're

26035
03:03:43,420 --> 03:03:47,830
using Morales, we could render
image on our server and just

26036
03:03:47,830 --> 03:03:51,220
call our server, what else could
we do well, or test nets and

26037
03:03:51,220 --> 03:03:53,650
maintenance routes actually
comes with a bunch of hooks like

26038
03:03:53,650 --> 03:03:58,060
us NFT balance that will show us
an F TS show us how many NF T's

26039
03:03:58,060 --> 03:04:02,170
shows all this information about
NF T's but it only works on test

26040
03:04:02,170 --> 03:04:05,290
nets and main net, we'd have the
world adopt IPFS. So we don't

26041
03:04:05,290 --> 03:04:08,230
have to do this wrapping.
Unfortunately, it doesn't yet so

26042
03:04:08,260 --> 03:04:11,050
such as life. But now that we're
setting the image, alright, we

26043
03:04:11,050 --> 03:04:14,290
have this image URI, we have
what this actually looks like,

26044
03:04:14,290 --> 03:04:17,530
we're going to have this and if
we click on this, we use this in

26045
03:04:17,530 --> 03:04:21,520
our browser, it returns this
dog. So now we have the image

26046
03:04:21,520 --> 03:04:25,810
URI in our website, we can
finally use it to show what this

26047
03:04:25,810 --> 03:04:29,320
is going to look like. So
finally, we can create a return

26048
03:04:29,320 --> 03:04:33,190
in here. So down below, we'll do
return to a little div. And then

26049
03:04:33,190 --> 03:04:36,130
we'll do another div just
because I want to. And we can do

26050
03:04:36,130 --> 03:04:39,760
some JavaScript, we can say if
if that image array exists,

26051
03:04:39,940 --> 03:04:43,330
we'll do some stuff. Otherwise,
we'll do some other stuff. So if

26052
03:04:43,330 --> 03:04:47,860
it doesn't exist, maybe we'll do
a div for now. div that just

26053
03:04:47,860 --> 03:04:52,660
says loading dot the dot. And if
it does exist, for now, we'll

26054
03:04:52,660 --> 03:04:57,400
just say, just do a little div,
close the div. And we'll just

26055
03:04:57,400 --> 03:05:01,090
say found it. Now if we go back
to our front end, let's see if

26056
03:05:01,090 --> 03:05:02,200
we're good here.

26057
03:05:03,310 --> 03:05:07,090
Uh huh. If I do a refresh, we
see found it for both of these

26058
03:05:07,090 --> 03:05:12,040
NF T's. Okay, cool. So how do we
actually show these NF T's, we

26059
03:05:12,040 --> 03:05:15,460
finally have the URL that we can
use to show the NF T's. But we

26060
03:05:15,460 --> 03:05:18,820
want to actually use them next.
Jas actually comes with a

26061
03:05:18,820 --> 03:05:21,910
component called the image
component that we can use to

26062
03:05:21,940 --> 03:05:26,260
render images really easily just
by using a URI. Now, because

26063
03:05:26,260 --> 03:05:28,570
we're going to use this image
tag, and because it does some

26064
03:05:28,570 --> 03:05:31,540
optimizations on the back end,
that means that this website

26065
03:05:31,570 --> 03:05:36,100
won't be able to be deployed to
a static to a static site, like

26066
03:05:36,100 --> 03:05:40,030
IPFS. Because now our website
requires a server technically,

26067
03:05:40,240 --> 03:05:43,150
requires a server just because
we have Morales. So that might

26068
03:05:43,150 --> 03:05:46,000
be another reason, we might not
want to, since we're using this

26069
03:05:46,000 --> 03:05:49,510
image tag, we can't deploy this
statically to something like

26070
03:05:49,510 --> 03:05:54,010
IPFS is we're going to up at the
top, we're going to import image

26071
03:05:54,640 --> 03:05:59,440
from next slash image. And we're
gonna down here we're going to

26072
03:05:59,440 --> 03:06:04,570
say, instead of founded, we're
gonna go Image, we're gonna

26073
03:06:04,570 --> 03:06:08,950
close it off here, too, we're
gonna give a loader of just a

26074
03:06:08,950 --> 03:06:12,520
blank function that just gives
us the image URI. Don't worry

26075
03:06:12,520 --> 03:06:15,850
too much about loader. For now,
we're gonna say the source of

26076
03:06:15,850 --> 03:06:18,880
the image is going to be the
image URI. And then we'll give

26077
03:06:18,880 --> 03:06:23,530
it a height of maybe 200. And
then we'll give it a width of

26078
03:06:23,530 --> 03:06:27,100
also maybe 200. And if we did
this right, after we save, we

26079
03:06:27,100 --> 03:06:30,940
should see the image on our UI.
So we'll go back to our website,

26080
03:06:30,940 --> 03:06:35,080
and oh, my goodness, we can see
the dogs holy cow. This is

26081
03:06:35,080 --> 03:06:37,840
getting really exciting. We can
see the puppies, we can see the

26082
03:06:37,840 --> 03:06:40,660
images, we're definitely doing
something right here, which is

26083
03:06:40,660 --> 03:06:43,870
really exciting. Now I know I
said this before that this isn't

26084
03:06:43,900 --> 03:06:47,290
a CSS. This isn't a formatting
tutorial, because that's

26085
03:06:47,290 --> 03:06:50,440
definitely not my expertise.
However, let's make this look a

26086
03:06:50,440 --> 03:06:53,740
little bit nicer. And we're
going to use once again, the web

26087
03:06:53,740 --> 03:06:56,650
three UI kit, because the web
three UI kit has a whole bunch

26088
03:06:56,650 --> 03:06:59,650
of tools that are really, really
helpful for us to use. So if we

26089
03:06:59,650 --> 03:07:02,890
go to the web three UI kit, we
can go to that live storybook

26090
03:07:03,040 --> 03:07:07,660
Another interactive bit, and we
can scroll down to the section

26091
03:07:07,660 --> 03:07:10,450
that has called card. Or we can
make these little clickable

26092
03:07:10,450 --> 03:07:14,080
cards and we can display some
information about our nfts. So

26093
03:07:14,110 --> 03:07:20,320
let's go ahead and at the top,
we'll do import import card from

26094
03:07:20,740 --> 03:07:24,370
web three UI kit. And now
instead of just showing the

26095
03:07:24,370 --> 03:07:29,560
image, we'll wrap the image in a
card like this. We'll save that.

26096
03:07:29,860 --> 03:07:34,540
Now back on our front end, give
it a little refresh. Now we've

26097
03:07:34,540 --> 03:07:37,420
got this kind of clickable
section that looks a little bit

26098
03:07:37,420 --> 03:07:40,630
nicer. We'll even label it. And
we can even label it with a

26099
03:07:40,630 --> 03:07:43,420
title and description. Now we
can grab the title and the

26100
03:07:43,420 --> 03:07:48,100
description from the token URI
response. So up at the top,

26101
03:07:48,130 --> 03:07:51,250
let's go ahead, let's grab the
title and the description of the

26102
03:07:51,250 --> 03:07:56,170
token UI as a state variable. So
we'll say const, token name, set

26103
03:07:56,200 --> 03:08:02,110
token name, equals use state,
start off as blank, the const

26104
03:08:02,290 --> 03:08:09,070
token description, that token
description, equals use state.

26105
03:08:10,060 --> 03:08:14,410
Start off as blank to download,
we do this update UI bit, we'll

26106
03:08:14,410 --> 03:08:21,430
call set token name. So we'll
say name is token, your response

26107
03:08:21,460 --> 03:08:26,470
dot name, we'll say set token
description, which will be

26108
03:08:26,740 --> 03:08:30,880
token, your response dot
description. And then we'll use

26109
03:08:30,880 --> 03:08:33,970
those descriptions and title in
the cart. So we'll say title

26110
03:08:34,480 --> 03:08:43,360
equals token name, description
equals token description. Save

26111
03:08:43,360 --> 03:08:46,840
that. We'll look at our front
end here. Give it a little

26112
03:08:46,840 --> 03:08:50,200
refresh. Oh, and now we have the
name of the NFT. And its

26113
03:08:50,200 --> 03:08:52,870
description on our front end.
Okay, cool. Let's keep going.

26114
03:08:52,900 --> 03:08:55,840
What else do we want on this?
Well, we probably want who it's

26115
03:08:55,840 --> 03:08:59,860
owned by. So we'll put a little
div inside the card, say div,

26116
03:08:59,890 --> 03:09:02,500
maybe we'll even put the token
ID we'll do a little number.

26117
03:09:02,950 --> 03:09:03,970
With the token ID.

26118
03:09:05,260 --> 03:09:08,050
We'll do another little div, and
then we'll make this italic.

26119
03:09:08,080 --> 03:09:13,000
We'll say class name equals
italic. And then text is going

26120
03:09:13,000 --> 03:09:17,590
to be small. And we'll say owned
by, and this is where we can get

26121
03:09:17,590 --> 03:09:20,650
the seller that we're passing in
as an input parameter. And then

26122
03:09:20,650 --> 03:09:23,710
maybe underneath the image, we
want to put the price. We'll do

26123
03:09:23,710 --> 03:09:27,610
a little div here. And then
we'll say price like this.

26124
03:09:27,640 --> 03:09:30,310
However, we're probably don't
want it in way we want it in

26125
03:09:30,310 --> 03:09:34,510
human readable units. So we'll
import ethers, we'll say import

26126
03:09:35,440 --> 03:09:40,390
ethers from ethers. And then
instead of just showing the

26127
03:09:40,390 --> 03:09:44,020
price, we'll do a little, little
JavaScript and here we'll do

26128
03:09:44,020 --> 03:09:50,770
ethers dot utils dot format,
units, price, price and ether.

26129
03:09:50,950 --> 03:09:53,740
And then we'll do space eath.
And then we'll make this be

26130
03:09:53,740 --> 03:09:59,530
class name equals font bold, so
we can read how much it's listed

26131
03:09:59,530 --> 03:10:03,490
for on our marketplace. Let's go
back a high we can now see, this

26132
03:10:03,490 --> 03:10:07,060
is token ID number four. We can
see who it's owned by we'd see

26133
03:10:07,060 --> 03:10:10,420
the price of it and then more
information about the dog. Yay.

26134
03:10:10,560 --> 03:10:13,350
Now let's format all this stuff
in here a little bit nicer. So

26135
03:10:13,350 --> 03:10:17,760
let's wrap everything in a div
in one more div. And that will

26136
03:10:17,760 --> 03:10:20,850
say class name is going to be
flex. And this is going to help

26137
03:10:20,850 --> 03:10:25,110
format everything, we'll put
everything in a column items and

26138
03:10:25,140 --> 03:10:28,980
get to. And now if we look back
there, kind of like in a column

26139
03:10:28,980 --> 03:10:33,930
now, wrapping one more div, give
them some padding, last name

26140
03:10:33,930 --> 03:10:36,930
equals P to say a little bit
padding has been added. Okay,

26141
03:10:36,930 --> 03:10:40,380
nice. And then we'll go back to
our index, and we'll add some

26142
03:10:40,380 --> 03:10:44,160
formatting to our index here. So
our main one, we're going to

26143
03:10:44,160 --> 03:10:48,060
remove styles dot container,
we're just gonna say container.

26144
03:10:48,840 --> 03:10:55,230
MX auto, we're going to make an
h1 in here, class name, equals,

26145
03:10:55,860 --> 03:11:07,170
I form E X for font bold text to
XML. This is we're just gonna

26146
03:11:07,170 --> 03:11:12,960
say recently listed, then we're
going to do another div. Class,

26147
03:11:13,260 --> 03:11:18,690
name equals flex, flex wrap.
We're going to end this div

26148
03:11:20,070 --> 03:11:23,280
around our JavaScript here. And
let's look at our UI. And let's

26149
03:11:23,280 --> 03:11:26,250
see what that does. Okay, cool.
Let's go back to our index.

26150
03:11:26,250 --> 03:11:28,500
Let's remove all this stuff.
Since now we're adding that to

26151
03:11:28,500 --> 03:11:34,200
the card. Let's save. Now it's
looking a lot better, we finally

26152
03:11:34,200 --> 03:11:37,710
able to start listening our NF
Ts and then have them show up on

26153
03:11:37,710 --> 03:11:41,040
our marketplace like we see
here. Fantastic. Okay, if we go

26154
03:11:41,040 --> 03:11:44,580
to the readme homepage show
recently listen to empties. Oh,

26155
03:11:44,580 --> 03:11:48,180
my goodness, this is a check
we're done here. Now, and I know

26156
03:11:48,180 --> 03:11:50,340
what seemed like a lot of work,
but a lot of it was setting up

26157
03:11:50,340 --> 03:11:53,700
that morale server correctly.
And because we have our own back

26158
03:11:53,700 --> 03:11:56,310
end, now, we have some back end
services that we needed to

26159
03:11:56,340 --> 03:11:58,800
configure. But now that
everything's set up, the rest of

26160
03:11:58,800 --> 03:12:02,280
this is going to be easy St. Now
we are only going to want this

26161
03:12:02,280 --> 03:12:05,610
to show if we're connected to
web three. Right? Now, if we

26162
03:12:05,610 --> 03:12:09,720
click this, this still shows up.
So we're going to have to update

26163
03:12:09,720 --> 03:12:14,130
this a little bit. And in our
index.js, we're now we're

26164
03:12:14,130 --> 03:12:18,570
checking to see fetching.
Listen, NF T's right before

26165
03:12:18,570 --> 03:12:22,290
that, right? Before we do that
we actually want to see is web

26166
03:12:22,290 --> 03:12:25,230
three enabled. And this is going
to be a little bit of nested

26167
03:12:25,230 --> 03:12:28,980
tertiary operations. If web
three is enabled, then we're

26168
03:12:28,980 --> 03:12:31,830
going to do all this fetching,
listed NF T's stuff here. We're

26169
03:12:31,830 --> 03:12:35,790
gonna do everything in here. So
if it's not enabled, let's do

26170
03:12:35,790 --> 03:12:41,880
like a little div that says web
three, currently not enabled.

26171
03:12:42,390 --> 03:12:45,120
And of course, we're going to
need to grab is web three

26172
03:12:45,120 --> 03:12:49,380
enabled. So we're going to say,
for the top we'll do const is

26173
03:12:49,380 --> 03:12:53,370
what three enabled equals use
oralis as we've been doing, and

26174
03:12:53,370 --> 03:12:56,550
we're going to grab use Morales
from react Morales, we'll save

26175
03:12:56,550 --> 03:12:59,880
that go back to our front end,
give it a little refresh. If

26176
03:12:59,880 --> 03:13:02,940
we're connected, we'll see the
marketplace. If we disconnect,

26177
03:13:02,970 --> 03:13:05,760
we see web three currently not
enabled, which is what we want.

26178
03:13:06,150 --> 03:13:10,740
Perfect. So what is next in our
readme. If you only NFT, you can

26179
03:13:10,770 --> 03:13:13,890
update the listing. Let's first
let's figure out if somebody

26180
03:13:13,890 --> 03:13:16,230
actually is the owner of these
entities. Let's make it really

26181
03:13:16,230 --> 03:13:19,740
easy for the people on this
website. Well, first we can get

26182
03:13:19,740 --> 03:13:23,040
the person's Metamask by
grabbing the account from us

26183
03:13:23,040 --> 03:13:27,180
mouse, so we'll do a comma
account. So then we can easily

26184
03:13:27,180 --> 03:13:34,320
just do const is owned by user
equals seller equals equals

26185
03:13:34,320 --> 03:13:38,130
equals account. So the seller
we're getting from the contract,

26186
03:13:38,340 --> 03:13:41,460
the account we're getting from
whoever's connected here, if the

26187
03:13:41,460 --> 03:13:45,210
seller equals the account, there
is no seller equals equals

26188
03:13:45,240 --> 03:13:50,160
equals undefined. We'll just say
they're owned by you. And now

26189
03:13:50,160 --> 03:13:53,700
instead of saying owned by
seller, we can say const,

26190
03:13:54,390 --> 03:13:59,850
formatted seller address equals,
and we'll do the ternary

26191
03:13:59,850 --> 03:14:04,050
operator will say if it's on by
you, then we'll just say you

26192
03:14:04,110 --> 03:14:08,070
instead of seller. Otherwise,
we'll say seller. Now we'll say

26193
03:14:08,070 --> 03:14:11,970
owned by formatted seller
address like this. So if we go

26194
03:14:11,970 --> 03:14:16,080
back to our front end, we do a
little refresh. depending on

26195
03:14:16,140 --> 03:14:19,230
who's connected, you might see
owned by blah, blah, blah. Now

26196
03:14:19,230 --> 03:14:22,980
if I go to my Metamask, let me
go ahead and switch account to

26197
03:14:22,980 --> 03:14:27,060
account three, let's go ahead
and connect our account three,

26198
03:14:27,240 --> 03:14:31,740
we now see owned by you instead.
Right, and we can even switch

26199
03:14:31,740 --> 03:14:35,160
again, we'll switch accounts
again, we'll switch to account

26200
03:14:35,160 --> 03:14:38,970
one, we now see owned by blah,
blah, blah, like so since when

26201
03:14:38,970 --> 03:14:41,400
we switch back and forth, the
diameters of this actually

26202
03:14:41,400 --> 03:14:44,760
change which is really annoying.
So maybe we want to go one step

26203
03:14:44,760 --> 03:14:47,790
further. And we want to truncate
this seller address make it a

26204
03:14:47,790 --> 03:14:51,180
little bit smaller. So we want
to make a seller a little bit

26205
03:14:51,180 --> 03:14:54,570
smaller. So let's create a new
function. And we can create this

26206
03:14:54,600 --> 03:14:57,840
outside of the export default
function because this is going

26207
03:14:57,840 --> 03:15:02,010
to be a function that doesn't
depend on anything inside our

26208
03:15:02,010 --> 03:15:04,260
app. It's just going to be kind
of a raw function. So we're

26209
03:15:04,260 --> 03:15:08,460
going to create we'll call it
const truncate string, and this

26210
03:15:08,460 --> 03:15:13,440
is going to be a function that
takes a full string, and a

26211
03:15:13,440 --> 03:15:17,160
string length as parameters. And
we're just going to pass the

26212
03:15:17,160 --> 03:15:20,220
seller address and how long we
want to make this string. So

26213
03:15:20,220 --> 03:15:22,050
this is going to be an arrow
function we're going to do here,

26214
03:15:22,590 --> 03:15:27,240
and we're gonna say, if all
string dot length is less than

26215
03:15:27,240 --> 03:15:32,880
or equal to str Lang, return
full str. Otherwise, we'll say

26216
03:15:32,880 --> 03:15:37,920
concept ra torx equals three
little dots. And we'll say,

26217
03:15:38,070 --> 03:15:46,290
Let's separate Tor length equals
Sep. Ra Tor dot length. To make

26218
03:15:46,290 --> 03:15:52,410
con separator length, we'll say
const chars to show is going to

26219
03:15:52,410 --> 03:15:58,560
be the the string length minus
the separator length, we'll say

26220
03:15:58,560 --> 03:16:03,390
const. Front chars or front
characters is going to equal

26221
03:16:03,840 --> 03:16:10,410
math dot ceiling chars to show
divided by two const back chars

26222
03:16:10,500 --> 03:16:15,420
is going to equal math dot
floor, chars to show divided by

26223
03:16:15,420 --> 03:16:18,450
two. And if you don't understand
this math here, don't worry

26224
03:16:18,450 --> 03:16:21,210
about it. And then we're gonna
say return full string

26225
03:16:22,680 --> 03:16:31,500
substring of zero to front chars
plus the SEP IRA tour plus full

26226
03:16:31,500 --> 03:16:38,280
STR dot substring. of full STR
dot length, minus back chars.

26227
03:16:38,400 --> 03:16:41,880
And now what we can do is we can
grab this truncate STR this

26228
03:16:41,910 --> 03:16:45,630
truncate string and for is
formatted seller will say if

26229
03:16:45,630 --> 03:16:49,680
it's you will still do you but
otherwise we'll do truncate

26230
03:16:49,680 --> 03:16:54,150
string of seller or blank if
there's no seller, and we'll

26231
03:16:54,150 --> 03:16:57,570
have it be size 15. And now if
we save that, go back to our

26232
03:16:57,570 --> 03:17:00,750
front end, if it's owned by you,
it's still gonna say on by you.

26233
03:17:01,170 --> 03:17:05,310
But if we switch accounts, and
now says owned by, you know,

26234
03:17:05,310 --> 03:17:07,950
blah, blah, blah, dot the dot
blah, blah, blah with a

26235
03:17:07,950 --> 03:17:10,860
truncated address. And then
these sizes don't actually

26236
03:17:10,860 --> 03:17:13,500
change, which is a lot nicer
than them getting bigger and

26237
03:17:13,500 --> 03:17:16,980
smaller. So awesome. So now we
have this formatted even better.

26238
03:17:17,400 --> 03:17:23,400
Okay, now what do we want to do?
Well, now that we know who owns

26239
03:17:23,400 --> 03:17:27,270
the NFT, NF T, and it's
formatted pretty nicely, we need

26240
03:17:27,270 --> 03:17:30,420
to figure out a way to update
the listing. So what we want to

26241
03:17:30,420 --> 03:17:34,440
do is, once again, if it's owned
by us, and we can switch back to

26242
03:17:34,440 --> 03:17:37,230
the account, it's owned by if
it's owned by us, when we click

26243
03:17:37,230 --> 03:17:40,140
on it, we want to be able to
update the listing on the

26244
03:17:40,140 --> 03:17:43,770
marketplace. So to do this,
we're going to create a new

26245
03:17:43,770 --> 03:17:48,330
component called Update listing
ngModel. So we're gonna create a

26246
03:17:48,330 --> 03:17:56,010
new component, new file, update,
listing ngmodel.js. A ngModel is

26247
03:17:56,010 --> 03:17:58,260
something that like pops up. So
for example,

26248
03:18:00,000 --> 03:18:03,030
this little pop up here is known
as a modal. And this is what we

26249
03:18:03,030 --> 03:18:06,090
want to build. If it's owned by
us, when we click this, we want

26250
03:18:06,090 --> 03:18:09,840
it to pop up this modal thing.
So to get started, we'll do the

26251
03:18:09,840 --> 03:18:11,970
same thing we've been doing for
all of our components here,

26252
03:18:12,180 --> 03:18:18,060
we'll do export default,
function, update, listing

26253
03:18:18,060 --> 03:18:22,140
ngModel, like so. And we're
probably going to want to pass

26254
03:18:22,140 --> 03:18:25,530
it these parameters from the
entity box, probably gonna want

26255
03:18:25,530 --> 03:18:29,820
to pass these parameters. So the
ngModel knows what function it

26256
03:18:29,820 --> 03:18:32,970
needs to call in our NFT
marketplace. The way we're going

26257
03:18:32,970 --> 03:18:35,700
to update listing is we're going
to call this update listing

26258
03:18:35,700 --> 03:18:38,670
function where we need the
address token ID and then some

26259
03:18:38,670 --> 03:18:41,880
new price. So we're going to at
least need those. So we're going

26260
03:18:41,880 --> 03:18:46,110
to need the NFT address, and at
least the token ID to make this

26261
03:18:46,110 --> 03:18:48,450
little pop up, we're not going
to code it ourselves, we're

26262
03:18:48,450 --> 03:18:51,840
going to once again, use the web
three UI kit, web three UI Kit

26263
03:18:51,840 --> 03:18:55,980
has this nice pop up section,
where it has some code to work

26264
03:18:55,980 --> 03:18:59,400
with a modal. So we're going to
import that will do import

26265
03:18:59,730 --> 03:19:04,290
ngModel from web three UI kit,
like so here's what it looks

26266
03:19:04,290 --> 03:19:08,490
like we have modal and then we
have all this stuff on working

26267
03:19:08,490 --> 03:19:12,420
with the modal. So we'll do our
return, do a little modal, like

26268
03:19:12,420 --> 03:19:15,960
this. One of the key things in a
ngModel is whether or not it

26269
03:19:15,960 --> 03:19:19,950
should be visible. So it has an
is visible tag, which we're

26270
03:19:19,950 --> 03:19:22,020
actually gonna have to grab,
we're actually gonna have to

26271
03:19:22,020 --> 03:19:25,650
grab from the empty box. So
we're going to pass a little is

26272
03:19:25,650 --> 03:19:30,360
visible here as well, in our NFT
box, we need to tell our ngModel

26273
03:19:30,360 --> 03:19:33,000
when it's visible. So we'll
we'll make that code in a little

26274
03:19:33,000 --> 03:19:35,670
bit. Right now, it'll just be
blank. And inside of our

26275
03:19:35,670 --> 03:19:38,820
ngModel, we're going to want to
give an input field for how to

26276
03:19:38,820 --> 03:19:41,730
update it. So I know we've done
some regular inputs before,

26277
03:19:41,910 --> 03:19:44,130
since we've been working with
web through UI kit, let's just

26278
03:19:44,130 --> 03:19:47,520
use the input that it has as
well. So we'll do a little comma

26279
03:19:47,910 --> 03:19:51,180
input here. And inside of the
ngModel we'll create a new

26280
03:19:51,180 --> 03:19:55,170
input. So on our input field,
we'll give this a label which is

26281
03:19:55,170 --> 03:19:59,610
going to be update listing price
in L one currency. And we'll

26282
03:19:59,610 --> 03:20:03,180
just do eath. For now we'll just
hard coded as eath name will be

26283
03:20:03,480 --> 03:20:10,560
new listing price, and type is
going to equal a number we'll do

26284
03:20:10,560 --> 03:20:13,230
Little backslash here, oops,
we'll do a little backslash

26285
03:20:13,230 --> 03:20:16,770
instead of like that. So cool.
So when this modal pops up, it's

26286
03:20:16,770 --> 03:20:19,650
gonna have this input in here.
And we can actually test to see

26287
03:20:19,680 --> 03:20:24,330
if this is working. We can
import this into our NFT box,

26288
03:20:24,360 --> 03:20:30,060
we'll do import, update, listing
ngModel. From that slash,

26289
03:20:30,090 --> 03:20:32,730
update, listing ngModel oops,
and sorry, this doesn't need

26290
03:20:32,730 --> 03:20:36,720
parentheses, and at the top of
our return here, right before

26291
03:20:36,720 --> 03:20:39,390
our card will add it in. So
we'll just add another div

26292
03:20:39,390 --> 03:20:43,350
though. So that these two can be
in the same react. But we'll add

26293
03:20:43,350 --> 03:20:47,700
another div, we'll say Update
listing ngModel, like so with a

26294
03:20:47,700 --> 03:20:51,240
little backslash here. And right
now we just have to pass is

26295
03:20:51,240 --> 03:20:55,170
visible. And then for now, we're
just going to say true. So now

26296
03:20:55,170 --> 03:20:58,620
with this listing ngModel on our
front end, we do a little

26297
03:20:58,620 --> 03:21:01,500
refresh. And we get this little
box like this update listing

26298
03:21:01,500 --> 03:21:04,560
price and one currency. And we
have to close two of them.

26299
03:21:04,560 --> 03:21:08,280
Because technically we right now
both modalities are true, right.

26300
03:21:08,280 --> 03:21:11,370
So if we do a refresh, we get
this little input pop up this

26301
03:21:11,370 --> 03:21:14,730
little modal and we close it
twice, because we have two NF

26302
03:21:14,730 --> 03:21:17,280
T's if you have a ton of NF T's
here, you will have to close a

26303
03:21:17,280 --> 03:21:20,940
ton of those. So we change it to
false, we go back to the front

26304
03:21:20,940 --> 03:21:25,170
end, we do a little refresh, and
boom, now it's false. So true,

26305
03:21:25,530 --> 03:21:30,840
save, run, and it's there.
Gross, delete, delete, false,

26306
03:21:31,140 --> 03:21:34,770
save front end, it's not there
anymore. Okay, cool. So we're

26307
03:21:34,770 --> 03:21:38,040
gonna have to tell this ngModel
only to pop up when somebody

26308
03:21:38,040 --> 03:21:41,730
clicks this and have tea that
they own. So to actually toggle

26309
03:21:41,730 --> 03:21:44,580
this and actually make this
work, we're going to update our

26310
03:21:44,580 --> 03:21:48,540
card. So whenever we click our
card, we're going to create a

26311
03:21:48,540 --> 03:21:51,900
function called handle card
click that handle card click is

26312
03:21:51,900 --> 03:21:54,870
going to update a variable for
whether or not we should show

26313
03:21:54,870 --> 03:21:59,040
this ngModel. So we're going to
do is we're gonna say on click

26314
03:21:59,400 --> 03:22:03,270
of the card, aka, once we click
our dog, we're going to call

26315
03:22:03,270 --> 03:22:07,590
some function. So we're gonna
say on click, equals handle

26316
03:22:07,590 --> 03:22:11,340
card, click, animal card, click,
and we're going to make this a

26317
03:22:11,340 --> 03:22:15,870
function, we're gonna say const,
handle card click equals a

26318
03:22:15,870 --> 03:22:19,260
function, we'll use some Arrow
stuff here. And then we'll just

26319
03:22:19,260 --> 03:22:25,440
say, if it's is owned by user,
if it's on by user, we'll show

26320
03:22:25,440 --> 03:22:30,510
the ngModel. Else, we will call
the by item function, since we

26321
03:22:30,510 --> 03:22:35,220
want our whole UI to rerender.
Once we change, once we change

26322
03:22:35,220 --> 03:22:37,680
the variable to show the
ngModel, we're going to do this

26323
03:22:37,680 --> 03:22:42,750
as a US state. So we'll say
const, show ngModel. Come a set,

26324
03:22:43,020 --> 03:22:47,790
show ngModel equals use state.
And then we're going to start it

26325
03:22:47,790 --> 03:22:51,150
off being defaulted to false. So
by default, we are not going to

26326
03:22:51,150 --> 03:22:53,850
show them on down which is what
we want. But if it's owned by

26327
03:22:53,850 --> 03:22:59,460
the user, we're gonna say Set
Show ngModel to be true. And

26328
03:22:59,460 --> 03:23:03,990
then else right now we'll just
put console dot log, let's buy

26329
03:23:04,200 --> 03:23:06,690
will actually update this to
bind the item a little bit

26330
03:23:06,690 --> 03:23:10,260
later. So now instead of having
is visible be false, we'll have

26331
03:23:10,290 --> 03:23:13,380
is visible equal to show
ngModel. Or show ngModel.

26332
03:23:13,380 --> 03:23:16,950
Variable. Okay, great. So now if
we save that, we go back to our

26333
03:23:16,950 --> 03:23:21,090
UI, we right click, we hit
Inspect, if we own it, and we

26334
03:23:21,090 --> 03:23:24,090
click it, the ngModel will pop
up, and we can click it out,

26335
03:23:24,120 --> 03:23:28,170
click another one, but that will
pop up if we don't own it. So if

26336
03:23:28,170 --> 03:23:32,370
we switch accounts, Connect will
switch. We click it, nothing

26337
03:23:32,370 --> 03:23:36,240
happens. And if we go to
inspect, we go to the console,

26338
03:23:36,630 --> 03:23:40,140
we click it, we should see let's
buy pop up, which is what we do

26339
03:23:40,140 --> 03:23:44,040
see, we'll do a little refresh
here. Click we see let's buy pop

26340
03:23:44,040 --> 03:23:48,000
up, click again, let's buy click
let's pilots pilots, why? Great,

26341
03:23:48,090 --> 03:23:51,270
cool. So now we have a word for
that ngModel. To actually show

26342
03:23:51,270 --> 03:23:54,630
up correctly, let's switch back
to the person who actually owns

26343
03:23:54,630 --> 03:23:58,740
this NFT we click it, we want to
be able to when we hit OK, or

26344
03:23:58,740 --> 03:24:02,220
submit, we want to send a
transaction to update the price

26345
03:24:02,280 --> 03:24:05,580
of our NFT here, so what we can
do is in our input will have a

26346
03:24:05,580 --> 03:24:09,120
label called on change equals
and this is the function that

26347
03:24:09,120 --> 03:24:12,300
will call whenever this updates.
So we're gonna say on change

26348
03:24:12,540 --> 03:24:17,100
event is going to be a function.
And we're going to create a

26349
03:24:17,100 --> 03:24:22,530
function called set price to
update listing listing with

26350
03:24:22,590 --> 03:24:27,840
event dot target dot value. So
we want to keep track of

26351
03:24:27,840 --> 03:24:30,180
whatever we've put in here. So
when we call the function to

26352
03:24:30,180 --> 03:24:32,850
update the price, it'll just
already automatically have it.

26353
03:24:32,970 --> 03:24:36,120
So we'll create this function
and event dot target dot value

26354
03:24:36,150 --> 03:24:39,600
is going to be whatever's in
this input box here. So we'll

26355
03:24:39,600 --> 03:24:43,950
create this set price to update
listing with will have this be a

26356
03:24:43,950 --> 03:24:46,650
use date because we are going to
want to change the UI based off

26357
03:24:46,650 --> 03:24:52,920
this so we'll say const price to
up date listing with comma set

26358
03:24:52,920 --> 03:24:58,470
price to update listing with
equals use state and then we'll

26359
03:24:58,470 --> 03:25:03,270
have this be zero to start or
blank. And so now, whatever is

26360
03:25:03,270 --> 03:25:06,810
in here is going to get updated
with this. So now I can do like

26361
03:25:06,810 --> 03:25:11,400
our console dot log price update
listing with Get back to the

26362
03:25:11,400 --> 03:25:16,410
front end, oops, we need to
import use state import, use

26363
03:25:16,410 --> 03:25:21,060
state from react. Go back to the
front end, we click this, we

26364
03:25:21,060 --> 03:25:22,440
right click Inspect.

26365
03:25:23,760 --> 03:25:27,990
By type one, we can see 114, we
see 14. So let's remove the

26366
03:25:27,990 --> 03:25:31,410
console dot log now. Now what we
can do in here is we can create

26367
03:25:31,410 --> 03:25:34,290
field called on okay, this is
going to be the function that we

26368
03:25:34,290 --> 03:25:37,590
call when we hit this, okay
here, so on. Okay, it's going to

26369
03:25:37,590 --> 03:25:40,260
be equal to a function, we're
going to use a little arrow

26370
03:25:40,260 --> 03:25:43,830
notation, and we're going to
call that update listing

26371
03:25:44,250 --> 03:25:47,460
function on the blockchain,
we're going to need to grab that

26372
03:25:47,460 --> 03:25:50,640
function so we can use it. So
once again, to use that

26373
03:25:50,640 --> 03:25:54,990
function, we're going to import
use web three contract from

26374
03:25:55,050 --> 03:26:00,060
react mirallas. And as a new
hook, we'll say const run

26375
03:26:00,060 --> 03:26:06,510
contract function called Update
listing, equals use web three

26376
03:26:06,570 --> 03:26:09,780
contract. And this is going to
be a function that we're going

26377
03:26:09,780 --> 03:26:14,880
to call on our NFT marketplace.
So ABI is going to be the NFT

26378
03:26:15,270 --> 03:26:20,730
marketplace API, which we can
get by doing an import, similar

26379
03:26:20,730 --> 03:26:24,600
to what we did over here. And we
actually just copy paste from

26380
03:26:24,600 --> 03:26:30,840
our NFT box. So we'll do import
NFT marketplace API from dot dot

26381
03:26:30,840 --> 03:26:33,990
constant send it to marketplace
that JSON, we're gonna need the

26382
03:26:33,990 --> 03:26:38,430
contract address, which is going
to be an input parameter to our

26383
03:26:38,520 --> 03:26:43,050
update listing ngModel. So we
can even do a comma market place

26384
03:26:43,290 --> 03:26:48,270
address, copy this place that
here, that means in our NFT box,

26385
03:26:48,570 --> 03:26:51,330
pretty soon, we're going to have
to pass all these variables to

26386
03:26:51,330 --> 03:26:54,090
it, but we'll save that in just
a second. So NFT marketplace

26387
03:26:54,090 --> 03:26:57,540
address marketplace address
function name, is going to be

26388
03:26:57,540 --> 03:27:02,370
what it's called Update, listing
in our smart contract, and then

26389
03:27:02,370 --> 03:27:06,930
the params. So if we go to this,
we have update listing takes the

26390
03:27:06,930 --> 03:27:11,460
NFT address token ID and new
price do NFT address, which will

26391
03:27:11,460 --> 03:27:16,290
be NFT address, we'll say token
ID is going to be token ID and

26392
03:27:16,290 --> 03:27:20,040
the new price your price will
get from price to update listing

26393
03:27:20,040 --> 03:27:25,230
with but will convert it from
human readable to ethers. So

26394
03:27:25,230 --> 03:27:33,180
we'll import ethers from ethers.
And the new price will be ethers

26395
03:27:33,240 --> 03:27:39,870
dot utils dot parse ethers or
ether price to update listing

26396
03:27:39,870 --> 03:27:44,340
with or just in case it's blank,
we'll just say or zero. So we

26397
03:27:44,340 --> 03:27:48,330
have the NFT address the token
ID marketplace address in our

26398
03:27:48,330 --> 03:27:51,030
NFT box, we're gonna have to
pass those parameters in here.

26399
03:27:51,210 --> 03:27:54,870
So we have is visible, we're
also going to have token ID,

26400
03:27:54,900 --> 03:27:59,730
which is going to equal token
ID, marketplace address is going

26401
03:27:59,730 --> 03:28:05,550
to equal the marketplace
address. And the NFT address is

26402
03:28:05,550 --> 03:28:10,260
going to equal the NFT address.
And as we code and test this

26403
03:28:10,260 --> 03:28:12,330
something that's going to be
really annoying, because it's

26404
03:28:12,330 --> 03:28:15,480
really annoying for me right now
let's refresh our website. And

26405
03:28:15,480 --> 03:28:18,450
if we click it, this thing pops
up. But when I hit X, and I

26406
03:28:18,450 --> 03:28:22,170
click this, again, nothing shows
up. That's because technically

26407
03:28:22,200 --> 03:28:25,110
show ngModel is still true right
now, even though we've exited

26408
03:28:25,110 --> 03:28:30,030
out. So what we want to do in
the NFT box is in our update

26409
03:28:30,030 --> 03:28:33,810
listing ngModel we're also going
to pass it in on close, and

26410
03:28:33,810 --> 03:28:37,320
we're going to pass it a hide
ngModel variable that we're

26411
03:28:37,320 --> 03:28:41,670
going to create, and right under
Show ngModel Set Show ngModel

26412
03:28:41,850 --> 03:28:46,290
we're going to create const Eid
ngModel. And this is just going

26413
03:28:46,290 --> 03:28:51,360
to be a function, that's just
going to say set, show modal. to

26414
03:28:51,360 --> 03:28:56,550
false, we're going to pass this
function to our update modal

26415
03:28:56,550 --> 03:29:01,230
listing. So we're going to do
comma on Close. And in our modal

26416
03:29:01,230 --> 03:29:07,800
here, we're going to say, on
Close. On, cancel, we're going

26417
03:29:07,800 --> 03:29:12,840
to do, we're going to call that
on close function, or on Close

26418
03:29:13,350 --> 03:29:17,190
button pressed, we're also going
to call that on close function.

26419
03:29:17,430 --> 03:29:22,470
Now if we refresh our website,
click this modal pops up, we

26420
03:29:22,470 --> 03:29:25,890
click X, click it again, it'll
pop back up, because now we're

26421
03:29:25,890 --> 03:29:29,070
properly setting it to false and
then resetting it to true. Now

26422
03:29:29,100 --> 03:29:32,640
to actually send this update
listing function, we're going to

26423
03:29:32,640 --> 03:29:36,510
pass this another thing, another
variable, we're going to pass it

26424
03:29:37,140 --> 03:29:40,710
on Okay, which is going to be a
function as well. It's just

26425
03:29:40,710 --> 03:29:44,370
going to call update listing
that we just created. Now, it's

26426
03:29:44,370 --> 03:29:48,840
always a good idea to add an On
error. We'd say on error, take

26427
03:29:48,840 --> 03:29:52,650
that error as a function and
console dot log.

26428
03:29:54,090 --> 03:29:58,620
The error and this needs to be
in squiggly brackets like that,

26429
03:29:58,920 --> 03:30:04,080
but contract address is wrong.
So we'll make this contract, con

26430
03:30:04,860 --> 03:30:11,490
tract address and spell that
correctly. Spelled correctly.

26431
03:30:11,550 --> 03:30:14,310
Now let's go back to the UI,
we'll give it a little refresh.

26432
03:30:14,400 --> 03:30:19,530
Click, this will add one. And we
see Metamask pop up. So this is

26433
03:30:19,530 --> 03:30:22,170
working out perfectly. Now I'm
going to cancel it, and our apps

26434
03:30:22,170 --> 03:30:24,600
gonna freak out and stuff. But
that's okay, we are doing

26435
03:30:24,630 --> 03:30:28,080
fantastically okay app popped up
like that, which is good. We

26436
03:30:28,080 --> 03:30:30,900
have this little error handling,
which I like to add for all of

26437
03:30:30,900 --> 03:30:35,040
these run contract functions.
Let's also do an on success. So

26438
03:30:35,070 --> 03:30:37,950
let's say when this does go
through successfully, we'll call

26439
03:30:37,950 --> 03:30:43,020
a function called handle update,
listing success. And this will

26440
03:30:43,020 --> 03:30:45,450
be a function that we'd call
when this goes through

26441
03:30:45,450 --> 03:30:47,970
correctly. So at the top, let's
make this new function, we'll

26442
03:30:47,970 --> 03:30:51,450
say const. Handle update,
listening success is going to be

26443
03:30:51,450 --> 03:30:55,680
a new function using the arrow
syntax here. And we'll have this

26444
03:30:55,710 --> 03:31:00,570
setup a new notification for a
web application. So for us to do

26445
03:31:00,600 --> 03:31:03,780
notifications, we're going to
use web three UI Kits use

26446
03:31:03,780 --> 03:31:06,600
notification, this is going to
be that same notification

26447
03:31:06,600 --> 03:31:10,050
service that we used in our last
one. So up at the top here,

26448
03:31:10,320 --> 03:31:14,340
we'll import it, use
notification. And then we'll

26449
03:31:14,340 --> 03:31:18,660
say, right in our component,
we'll say const, dispatch equals

26450
03:31:18,660 --> 03:31:23,010
use notification. And since
we're using notifications back

26451
03:31:23,010 --> 03:31:27,210
on our app.js, we have to import
it in here. So we'll do import

26452
03:31:27,780 --> 03:31:33,330
notification provider from web
three UI kit. And inside of our

26453
03:31:33,330 --> 03:31:37,080
Morales provider, we'll add the
notification provider around our

26454
03:31:37,080 --> 03:31:40,290
header and our component, so
that we have context for this.

26455
03:31:44,670 --> 03:31:49,200
Now in our handle update listing
success, inside this function

26456
03:31:49,350 --> 03:31:54,420
will say dispatch, say type is
going to be success. message

26457
03:31:54,420 --> 03:32:01,950
will be listing updated, title
will be listing updated, please

26458
03:32:01,950 --> 03:32:10,500
refresh, please refresh and move
blocks. And then position. Top

26459
03:32:10,530 --> 03:32:17,400
right. And then we'll do on
clothes, and on clothes. And

26460
03:32:17,400 --> 03:32:23,430
we'll say set price to update
listing with back to zero. I

26461
03:32:23,430 --> 03:32:25,800
also I'm editing this a little
bit in the future. And I

26462
03:32:25,800 --> 03:32:29,790
realized that I actually forgot
to add the TX to a lot of these

26463
03:32:29,970 --> 03:32:33,810
handle functions. So on these,
whenever we call one of these

26464
03:32:33,810 --> 03:32:36,450
run contract functions, like
we've been saying they have this

26465
03:32:36,450 --> 03:32:40,980
on error in this onsuccess. Now
this onsuccess automatically

26466
03:32:40,980 --> 03:32:45,840
passes the result of the call to
whatever callback function is

26467
03:32:45,840 --> 03:32:50,490
there. So for example, up the
listing returns a transaction,

26468
03:32:50,550 --> 03:32:54,210
and we'll pass that transaction
to whatever you add to the

26469
03:32:54,210 --> 03:32:58,560
onsuccess. So now in here, you
can actually have it have a

26470
03:32:58,560 --> 03:33:00,780
transaction as an input
parameter. And this would be the

26471
03:33:00,780 --> 03:33:03,330
transaction that's going to go
on the blockchain to you know,

26472
03:33:03,330 --> 03:33:07,530
update the price. So we actually
want to change it from a regular

26473
03:33:07,650 --> 03:33:11,490
function to an async function.
So we can actually do await TX

26474
03:33:11,490 --> 03:33:14,910
dot Wait, one, because we don't
want to say, hey, success, you

26475
03:33:14,910 --> 03:33:17,520
know, listing has been updated
before the transaction actually

26476
03:33:17,520 --> 03:33:19,950
goes through. So we want the
transaction to go through first.

26477
03:33:20,250 --> 03:33:23,580
And then we want to pop the
dispatch up saying, hey, it's

26478
03:33:23,580 --> 03:33:26,910
gone through so and then
additionally, when we actually

26479
03:33:26,910 --> 03:33:31,380
call these modells on the on,
okay, on the onsuccess, we pass

26480
03:33:31,380 --> 03:33:34,620
them in just by referencing the
name of the function. So we

26481
03:33:34,620 --> 03:33:40,380
don't do this arrow syntax,
anymore like this, we just say,

26482
03:33:40,380 --> 03:33:44,070
hey, the onsuccess is going to
be this, go ahead and pass your

26483
03:33:44,070 --> 03:33:48,210
results to it. So that's how we
actually call it down here. If

26484
03:33:48,210 --> 03:33:50,820
you look at the GitHub repo
associated with this, you go to

26485
03:33:50,820 --> 03:33:54,720
components, and we go into
these. So in this video, I

26486
03:33:54,720 --> 03:33:58,440
forgot to add the await TX dot
wait one. But in the GitHub

26487
03:33:58,440 --> 03:34:01,950
repo, we have these. And when
I'm demoing things in the video

26488
03:34:01,950 --> 03:34:05,010
here, the dispatch, it's gonna
pop up before the transaction

26489
03:34:05,010 --> 03:34:07,560
actually finishes going through.
So just want to let you know,

26490
03:34:07,590 --> 03:34:11,250
and back to the video. So now we
have a little success thing

26491
03:34:11,250 --> 03:34:14,370
that'll pop up when we're
successful. And the other thing

26492
03:34:14,370 --> 03:34:18,660
is, when we call this, we are
going to omit an item listed

26493
03:34:18,870 --> 03:34:23,340
inside of our Morales dashboard,
the price should actually update

26494
03:34:23,370 --> 03:34:27,300
in our active item because of
our Cloud Functions. So we're

26495
03:34:27,300 --> 03:34:30,690
going to put this all together
now. So we're on the front end.

26496
03:34:31,050 --> 03:34:35,490
And if the marketplace owned by
you will click it. Update

26497
03:34:35,490 --> 03:34:40,860
listing to 25. We're gonna hit
OK, meta masks is gonna pop up.

26498
03:34:41,430 --> 03:34:46,260
We're gonna go ahead and confirm
and ran through an error because

26499
03:34:46,290 --> 03:34:49,260
we need to click Metamask I need
to reset my account. So I'm

26500
03:34:49,260 --> 03:34:52,770
going to do settings, advanced
reset account.

26501
03:34:54,090 --> 03:34:57,990
Okay, now let's go ahead
Metamask has popped up again,

26502
03:34:58,020 --> 03:35:03,960
we're gonna go ahead and confirm
it closed, the pop up modal, and

26503
03:35:03,960 --> 03:35:06,420
we got our little notification
there. And we can see an

26504
03:35:06,420 --> 03:35:10,020
activity we have that
transaction has indeed completed

26505
03:35:11,160 --> 03:35:14,610
So now if we go to active item,
we give it a little refresh.

26506
03:35:14,970 --> 03:35:19,470
Right now we see our item listed
event. But the issue is that

26507
03:35:19,860 --> 03:35:23,730
it's not confirmed yet. So what
we're going to need to do is

26508
03:35:23,730 --> 03:35:26,940
we're going to need to move our
blocks by one. So in our NFT

26509
03:35:26,940 --> 03:35:31,170
marketplace, we're just going to
create a new script, a new file

26510
03:35:31,200 --> 03:35:34,410
called Mind dot Jas, just to
move our blocks once, and we're

26511
03:35:34,410 --> 03:35:42,630
going to say const, move blocks,
equals require dot slash utils,

26512
03:35:42,630 --> 03:35:49,260
slash move blocks, we'll say
const blocks equals to const

26513
03:35:49,290 --> 03:35:58,560
sleep amount equals 1000 async
function mine, do await move

26514
03:35:58,560 --> 03:36:05,670
blocks will do blocks as the
parameter and then sleep sleep

26515
03:36:06,150 --> 03:36:12,120
amount will equal sleep amount.
And this will be a script. So

26516
03:36:12,120 --> 03:36:16,860
we'll add our copy paste our
that same syntax we're doing

26517
03:36:16,860 --> 03:36:20,190
here just with mine. And now we
want to just mine these two

26518
03:36:20,190 --> 03:36:27,180
blocks. So we'll run yarn, art
hat run scripts. Mind that Jas

26519
03:36:27,450 --> 03:36:33,270
dash dash network, local host.
So we're going to mine those two

26520
03:36:33,270 --> 03:36:38,220
blocks. Now if we go back to our
database, we go back to active

26521
03:36:38,220 --> 03:36:43,590
items, we can see it's been
updated because now in our item

26522
03:36:43,590 --> 03:36:50,490
listed, that 2500 event is now a
confirmed transaction, and we

26523
03:36:50,490 --> 03:36:54,060
get to confirm their excellent.
So that means since it's

26524
03:36:54,060 --> 03:36:57,870
confirmed back in our front end,
we'll give this a little

26525
03:36:57,870 --> 03:37:04,230
refresh. We can see the pup is
now worth 25 eath. Awesome. So

26526
03:37:04,230 --> 03:37:07,470
we're updating ngModel is
working perfectly. Excellent

26527
03:37:07,470 --> 03:37:10,590
job. So now let's go to the
readme. If you own the NFT, you

26528
03:37:10,590 --> 03:37:17,160
can update the listing. That's a
checkmark. Excellent. Next, what

26529
03:37:17,160 --> 03:37:20,160
do we want it to do? If you
don't own it, you can buy the

26530
03:37:20,160 --> 03:37:24,090
listing. Okay, so let's go back
to our website, let's switch

26531
03:37:24,090 --> 03:37:28,080
users to a different account,
we're probably going to want an

26532
03:37:28,080 --> 03:37:31,080
account that own some money. So
let's go ahead and send this

26533
03:37:31,080 --> 03:37:33,570
other account some money
transfer between my accounts,

26534
03:37:33,600 --> 03:37:38,070
we'll send 100 eath to account
one, confirm on our hard hat

26535
03:37:38,070 --> 03:37:41,400
chain here. Alright, great. Now
we can go ahead and switch to

26536
03:37:41,400 --> 03:37:44,550
account one, and we have 100
eath. Okay, great. As these

26537
03:37:44,550 --> 03:37:47,820
pops, each cost less than 100
eath. So that's gonna be more

26538
03:37:47,820 --> 03:37:50,730
than plenty for us to test this
out. Let's go back to this box.

26539
03:37:50,730 --> 03:37:53,400
Because I think somewhere we
said, we did a little handle

26540
03:37:53,400 --> 03:37:58,440
card click, if it's owned by the
user, have the modal pop up. If

26541
03:37:58,440 --> 03:38:02,310
not, let's do the by
functionality. So to do the by

26542
03:38:02,310 --> 03:38:04,800
functionality, we're gonna go
ahead and do another run

26543
03:38:04,800 --> 03:38:11,310
contract function. So we'll do
const run contract function,

26544
03:38:11,850 --> 03:38:17,250
we'll call this one by item. And
this will equal use web three

26545
03:38:17,280 --> 03:38:21,240
contract. And this is going to
be the ABI for the NFT

26546
03:38:21,240 --> 03:38:27,330
marketplace. API, the contract
address is going to be the

26547
03:38:27,330 --> 03:38:34,830
market place address. The
function name is going to be by

26548
03:38:34,830 --> 03:38:41,040
item, the message value is going
to be the price of the NFT.

26549
03:38:41,580 --> 03:38:44,490
Because we need to send that
amount to buy the item. And then

26550
03:38:44,490 --> 03:38:49,470
params are going to be NFT
address, which is going to be

26551
03:38:49,470 --> 03:38:54,120
the NFT address. And the token
ID, which is going to be the

26552
03:38:54,120 --> 03:38:58,500
token ID now that we have this
by item on handle card click, we

26553
03:38:58,500 --> 03:39:03,570
can say okay, said show ngModel
is true. Otherwise, we're gonna

26554
03:39:03,570 --> 03:39:09,510
call by item. And we're going to
do on air. Air is going to be a

26555
03:39:09,510 --> 03:39:12,510
function where we're just going
to console dot log the air and

26556
03:39:12,510 --> 03:39:19,320
onsuccess. It'll be a function
where we call handle by item

26557
03:39:19,320 --> 03:39:23,130
success. So we'll create a new
handler for this right

26558
03:39:23,130 --> 03:39:27,360
underneath handled cart click
the const handled by item

26559
03:39:27,360 --> 03:39:31,800
success equals a function. And
for this, we'll also have this

26560
03:39:31,800 --> 03:39:35,580
do a little notification. So
once again, we're going to

26561
03:39:35,580 --> 03:39:40,320
import we're going to import use
notification from web through UI

26562
03:39:40,320 --> 03:39:46,470
kit. We're going to say const.
Dispatch equals use

26563
03:39:46,470 --> 03:39:50,760
notification. And then in
handled by item success. We're

26564
03:39:50,760 --> 03:39:51,960
gonna say dispatch

26565
03:39:53,400 --> 03:40:04,890
type, success. Message. Item
bought. Title will also be item

26566
03:40:04,890 --> 03:40:12,690
bought. Then pole position will
be top right That's it. So

26567
03:40:12,750 --> 03:40:15,990
handle card click, if they own
it, we're going to show that

26568
03:40:16,020 --> 03:40:19,140
update listing ngModel. If they
don't already own it, someone's

26569
03:40:19,140 --> 03:40:22,170
gonna buy it. So let's go back
here. And I'm currently on an

26570
03:40:22,170 --> 03:40:25,200
account that does not own these
NF T's. Let's go ahead and click

26571
03:40:25,200 --> 03:40:30,000
it. Our Metamask does indeed
show up for 25 eath. That's

26572
03:40:30,000 --> 03:40:34,080
crazy expensive. Let's go ahead
and confirm item has been

26573
03:40:34,080 --> 03:40:37,590
bought, we'll go ahead and click
that little x, we go to our meta

26574
03:40:37,590 --> 03:40:41,040
mask, the transaction is
pending. And it's gone through.

26575
03:40:41,310 --> 03:40:45,840
This is fantastic. Okay, our
homepage is done, we can show

26576
03:40:45,840 --> 03:40:49,200
recently listed NF T's if not,
you can update the listing. If

26577
03:40:49,200 --> 03:40:52,590
not, you can buy the listing.
And now it's time for our cell

26578
03:40:52,590 --> 03:40:59,190
page. So the last thing that we
need to do is our cell page,

26579
03:40:59,400 --> 03:41:03,660
let's get this cell page, let's
get this done pages, we have our

26580
03:41:03,660 --> 03:41:07,320
cell NFT page, which right now
does a whole lot of nothing. And

26581
03:41:07,320 --> 03:41:10,830
on our front end, we go here,
there's not a whole lot here.

26582
03:41:11,100 --> 03:41:14,460
And actually, you can list your
NFT in the marketplace, we also

26583
03:41:14,460 --> 03:41:18,810
needed to add withdraw proceeds.
So I didn't add that. But that's

26584
03:41:18,810 --> 03:41:20,550
probably going to be something
we're going to want to allow

26585
03:41:20,550 --> 03:41:23,700
people to do as well. So let's
get started here. So we can

26586
03:41:23,700 --> 03:41:26,790
remove this head stuff now that
we're adding that in our main

26587
03:41:26,820 --> 03:41:31,560
page. And for us to submit a new
NFT, we're probably gonna need a

26588
03:41:31,560 --> 03:41:34,590
space to add the address of the
entity that token ID of the NFT

26589
03:41:35,130 --> 03:41:37,500
and all this other stuff. So
we're gonna need a form to do

26590
03:41:37,500 --> 03:41:41,970
this, which guess what, we can
also grab a form from the web

26591
03:41:41,970 --> 03:41:45,450
through UI kit as well. So we're
gonna go ahead in our cell NMC

26592
03:41:45,450 --> 03:41:53,820
page, we're going to import form
from web three UI kit. And we're

26593
03:41:53,820 --> 03:41:57,660
going to create a new form in
our cell page. Now, the

26594
03:41:57,660 --> 03:42:00,120
parameters we can add to our
form, again, you can find them

26595
03:42:00,120 --> 03:42:03,120
in documentation here, or we're
going to add with one of the

26596
03:42:03,120 --> 03:42:06,600
main pieces is going to be this
data piece, which is going to be

26597
03:42:06,600 --> 03:42:11,370
an object that has a list in it,
of all the different fields, we

26598
03:42:11,370 --> 03:42:14,700
can put in our form. So maybe
we'll do our first one have a

26599
03:42:14,700 --> 03:42:21,870
name of NFT address. That's
gonna be of type text, excuse

26600
03:42:21,870 --> 03:42:25,950
me, and these are all going to
be this is a list of list of

26601
03:42:26,070 --> 03:42:30,090
objects like that. Now, if we
save that, we go back to our

26602
03:42:30,090 --> 03:42:34,230
cell page, we can now see an
empty address and a little

26603
03:42:34,230 --> 03:42:37,410
Submit button. That right now
does a whole lot of nothing. So

26604
03:42:37,410 --> 03:42:40,920
we have an NFT address, it'll
take a text, maybe we'll also do

26605
03:42:41,040 --> 03:42:48,780
in foot width of 50 percent will have
the starting value be blank. And

26606
03:42:48,780 --> 03:42:52,440
the key of this will be NFT
address, what else do we need,

26607
03:42:52,500 --> 03:42:57,030
we're going to need to give it
the token ID so we'll say name,

26608
03:42:58,170 --> 03:43:04,200
token ID, type is going to be a
number value, we'll start off

26609
03:43:04,200 --> 03:43:12,240
it's blank. And then the key for
this will be token ID. Next,

26610
03:43:12,270 --> 03:43:17,790
we're going to need the price.
So we'll say name will be price.

26611
03:43:18,510 --> 03:43:25,830
In eath. type will be a number
value will be blank. And the key

26612
03:43:25,830 --> 03:43:29,310
will be price. And we don't need
to have to form tags, we'll just

26613
03:43:29,310 --> 03:43:33,180
delete that second one and have
it auto close with one tag. And

26614
03:43:33,180 --> 03:43:39,450
then in here, we'll do title
equals sell your NF T ID equals

26615
03:43:40,290 --> 03:43:44,580
main form. So cool. So now we
can take an empty address, a

26616
03:43:44,580 --> 03:43:48,690
token ID and a new price with
the title of cellular NFT.

26617
03:43:48,780 --> 03:43:51,450
Great, that looks really nice.
Right now our form doesn't do

26618
03:43:51,450 --> 03:43:54,000
anything, we probably want to
give it the functionality to

26619
03:43:54,000 --> 03:43:58,290
actually do stuff. So we'll say
on Submit, and we'll have to

26620
03:43:58,290 --> 03:44:01,380
create a new function to
actually list our NF T's. So

26621
03:44:01,380 --> 03:44:05,370
we're going to create a function
called approve and list we have

26622
03:44:05,370 --> 03:44:10,530
to approve our marketplace to
pull the NFT from our wallets.

26623
03:44:10,800 --> 03:44:14,670
So we're going to create a new
function, a sync function

26624
03:44:14,730 --> 03:44:19,110
approven list, which is going to
take a data input parameter on

26625
03:44:19,110 --> 03:44:22,560
our form, when we hit on submit,
it's automatically going to pass

26626
03:44:22,590 --> 03:44:26,190
this data object to our approved
list function. So that's how

26627
03:44:26,190 --> 03:44:29,700
we're going to get the value of
the address the value of the

26628
03:44:29,700 --> 03:44:33,360
token ID and the value of the
price. So in our async function

26629
03:44:33,360 --> 03:44:39,720
approven list, do console dot
log, approving the contract, the

26630
03:44:39,720 --> 03:44:44,130
NFT address is going to come
from this data object. So it's

26631
03:44:44,130 --> 03:44:50,040
going to be data dot data at
index zero, or zero with object

26632
03:44:50,040 --> 03:44:54,120
here is going to be our address
that input result.

26633
03:44:56,130 --> 03:45:01,650
Our token ID is going to equal
data dot data. One because

26634
03:45:01,650 --> 03:45:06,450
again, this one is going to be
our token ID that input result.

26635
03:45:07,380 --> 03:45:12,960
And then the price is going to
equal that ethers dot utils dot

26636
03:45:12,990 --> 03:45:22,170
parse units of data dot data
have to the input result, comma

26637
03:45:22,800 --> 03:45:28,920
ether.to string. So we're going
to get the price in eath. In

26638
03:45:28,920 --> 03:45:32,580
human readable form, we're going
to convert it to Aetherium

26639
03:45:32,580 --> 03:45:35,550
readable form. And then we're
going to pass it as a string

26640
03:45:35,550 --> 03:45:39,030
because this returns a big
number, which we don't want. So

26641
03:45:39,030 --> 03:45:42,180
we have the NFT address, the
token ID and the price of the

26642
03:45:42,180 --> 03:45:46,470
new listing, what we can do now
is we can say const approve

26643
03:45:46,530 --> 03:45:51,360
options equals a little function
here, the ABI which is going to

26644
03:45:51,360 --> 03:45:55,920
be our NFT abi, which we need to
import, we need to import both

26645
03:45:55,950 --> 03:46:03,090
ethers from ethers. And we also
need to import the NFT abi, for

26646
03:46:03,090 --> 03:46:07,110
its NFT ABI from dot dot
constants slash basic at A T dot

26647
03:46:07,110 --> 03:46:11,970
JSON, I just copied and pasted
from the NFT box, the contract

26648
03:46:12,360 --> 03:46:19,110
address is going to be the NFT
address, the function name is

26649
03:46:19,110 --> 03:46:27,000
going to be approve params are
going to be two, the marketplace

26650
03:46:27,000 --> 03:46:29,820
address, which we're going to
define in just a second, and

26651
03:46:29,820 --> 03:46:34,710
then the token ID will be token
ID. Now the marketplace address

26652
03:46:34,830 --> 03:46:38,790
in our NFT box, we're getting
this directly from index, an

26653
03:46:38,790 --> 03:46:42,600
index is getting it from our
database. Now we want our app to

26654
03:46:42,600 --> 03:46:46,530
be smart enough to be able to
grab the NFT marketplace itself,

26655
03:46:46,650 --> 03:46:50,070
the marketplace address. And if
we go to our constants, right

26656
03:46:50,070 --> 03:46:53,370
now, we actually have it in this
network mapping. So we're going

26657
03:46:53,370 --> 03:46:56,640
to want to grab it right up at
the top by saying const

26658
03:46:56,910 --> 03:47:02,550
marketplace address equals
network mapping, network mapping

26659
03:47:02,670 --> 03:47:07,140
of what of the chain ID of the
entity marketplace address at

26660
03:47:07,140 --> 03:47:11,160
the zero with index. So network
mapping of the chain ID, which

26661
03:47:11,160 --> 03:47:17,670
we're going to get honest chain
ID equals us Morales. Now chain

26662
03:47:17,670 --> 03:47:22,440
Id actually comes like we said
it's a wax hex form for Morales.

26663
03:47:22,470 --> 03:47:25,500
So we're gonna have to convert
the chain ID to its string

26664
03:47:25,530 --> 03:47:31,410
readable version. So we'll say
const, chain string equals chain

26665
03:47:31,410 --> 03:47:35,040
ID. And we'll do a tertiary
operator, if the chain ID

26666
03:47:35,040 --> 03:47:42,180
exists, will parse int of the
chain id.to string. So we'll

26667
03:47:42,180 --> 03:47:46,620
parse it from its hex to a more
readable version, and then do.to

26668
03:47:46,620 --> 03:47:51,000
string. And then otherwise,
we'll just say we're on 31337.

26669
03:47:51,450 --> 03:47:55,860
So chain ID string. So in the
network mapping at the chain ID

26670
03:47:55,860 --> 03:48:02,670
string, dot NFT marketplace at
index zero, that's going to be

26671
03:48:02,670 --> 03:48:05,820
our marketplace address. So we
got the marketplace address,

26672
03:48:06,060 --> 03:48:10,260
this is all we need to call the
approved function on our NFT we

26673
03:48:10,260 --> 03:48:13,680
can now call running contract
function for a proof. So we're

26674
03:48:13,680 --> 03:48:15,540
actually going to do this a
little bit differently. We're

26675
03:48:15,540 --> 03:48:23,400
just going to say const. Run
contract function equals use web

26676
03:48:23,400 --> 03:48:27,240
three contract, you could import
just run contract function, and

26677
03:48:27,240 --> 03:48:30,090
then pass all those options to
it like what we're gonna do

26678
03:48:30,090 --> 03:48:33,690
here. Now we're just gonna say
await on contract function.

26679
03:48:34,170 --> 03:48:37,350
Because this is an async
function await run contract

26680
03:48:37,350 --> 03:48:42,780
function, we're gonna say params
are going to be approve options.

26681
03:48:43,410 --> 03:48:47,700
And we're gonna say onsuccess,
we're going to do something, I'm

26682
03:48:47,700 --> 03:48:51,360
going to say on error, we're
also going to just do error,

26683
03:48:52,920 --> 03:48:59,400
little arrow function, console
dot log error. Now on success,

26684
03:48:59,430 --> 03:49:03,420
once we send this transaction,
after the Approve goes through,

26685
03:49:03,540 --> 03:49:06,390
we're going to want to call the
list function right underneath

26686
03:49:06,390 --> 03:49:13,290
this will call async async.
Function, handle approve

26687
03:49:13,320 --> 03:49:18,120
success. And this is going to
take the NFT address, the token

26688
03:49:18,120 --> 03:49:22,800
ID, and the price is it put in
parameters. So once this run

26689
03:49:22,800 --> 03:49:25,530
contract function goes through,
we're going to call

26690
03:49:26,850 --> 03:49:29,160
of handle proof success. And
we'll pass it the end of the

26691
03:49:29,160 --> 03:49:35,490
address, token ID and the price,
which will say console dot log.

26692
03:49:36,120 --> 03:49:40,830
Okay, now time to list and we'll
do the same thing. We'll do

26693
03:49:40,830 --> 03:49:45,240
const list options, equals and
this is going to be all the

26694
03:49:45,240 --> 03:49:48,030
options for calling the list
function API is going to be on

26695
03:49:48,030 --> 03:49:54,150
the marketplace this time. So
NFT market place abi, which

26696
03:49:54,150 --> 03:49:56,160
again, we're going to have to
import so I'm going to go back

26697
03:49:56,160 --> 03:50:00,270
to NFT box. We're gonna copy
that line here, paste it in the

26698
03:50:00,270 --> 03:50:04,260
top. That's going to be the API
for that contract address. It's

26699
03:50:04,260 --> 03:50:08,430
going to be the marketplace
address, which we already have.

26700
03:50:09,120 --> 03:50:14,490
function name is going to be
list item. And the params are

26701
03:50:14,490 --> 03:50:22,500
going to be NF T address of the
NFT address, token ID of token

26702
03:50:22,500 --> 03:50:28,320
ID, price of price. And now we
have those options, we can do

26703
03:50:28,320 --> 03:50:35,400
await, run contract function
with params. Of list options,

26704
03:50:35,880 --> 03:50:42,270
will say onsuccess arrow
function, handle list success,

26705
03:50:42,660 --> 03:50:45,870
which is a function we haven't
made yet. It will say on air

26706
03:50:47,130 --> 03:50:54,180
error. And we'll just say
console dot log error. Okay, so

26707
03:50:54,180 --> 03:50:58,080
let's make this handle list
success handle one spell handle

26708
03:50:58,200 --> 03:51:02,700
correctly handle the success,
this will be an async function.

26709
03:51:03,270 --> 03:51:05,670
And this is also going to call
dispatch and make a little

26710
03:51:05,670 --> 03:51:10,110
notification. So we're going to
grab that from web three UI kit,

26711
03:51:10,560 --> 03:51:16,980
use notification. We'll say
const dispatch equals use

26712
03:51:16,980 --> 03:51:21,930
notification. And now down in
handle the success say dispatch,

26713
03:51:22,650 --> 03:51:32,730
type success. Message NFT
listing, title NFT listed

26714
03:51:33,120 --> 03:51:39,090
position. top bar, and cool. And
we're also gonna have to grab us

26715
03:51:39,090 --> 03:51:46,710
Morales from react Morales. So
do import us Morales from react

26716
03:51:46,830 --> 03:51:51,480
or else. So let's import this
network mapping. Import network

26717
03:51:51,480 --> 03:51:57,000
mapping from dot dot slash
constants slash network mapping

26718
03:51:57,000 --> 03:52:00,420
dot JSON. Because I spelled
contract address wrong again,

26719
03:52:00,750 --> 03:52:03,780
good our front end we'll give it
a refresh us web three contract

26720
03:52:03,780 --> 03:52:07,710
isn't defined. Let's get that
from react moralss. Well save

26721
03:52:07,710 --> 03:52:10,980
that refresh our front end. And
tada, we're good to go here.

26722
03:52:11,460 --> 03:52:14,040
Alright, now to test this out,
we're going to want to do is

26723
03:52:14,040 --> 03:52:16,500
we're going to want to create
another script here. So we're

26724
03:52:16,500 --> 03:52:19,380
back in our heart at NFT
marketplace, we're looking at

26725
03:52:19,380 --> 03:52:22,830
our scripts. And we're going to
create a new file just called

26726
03:52:22,830 --> 03:52:27,570
mint.js. So we're not going to
list this time, we're just going

26727
03:52:27,570 --> 03:52:31,590
to mint it just going to mint an
NF t so we can list it ourselves

26728
03:52:31,620 --> 03:52:34,800
on the UI. And actually, we can
just copy our mminton list code,

26729
03:52:34,950 --> 03:52:39,840
paste it into here, and just
remove the approval and the

26730
03:52:39,840 --> 03:52:44,670
listing code. Boom, remove that,
remove this, remove this. And

26731
03:52:44,670 --> 03:52:47,040
that's all we need. And now
we'll just change the name to

26732
03:52:47,040 --> 03:52:50,850
mint. Well, we can remove price
as well. And we'll change this

26733
03:52:50,850 --> 03:52:55,590
to mint. And that's it. Now we
have a script that we can call,

26734
03:52:55,590 --> 03:52:58,470
well, we'll just mint an NFT, we
can also get rid of the NFT

26735
03:52:58,470 --> 03:53:01,950
marketplace. Actually, we will
probably want the token ID so we

26736
03:53:01,950 --> 03:53:07,860
can know what it is. So let's do
const token ID equals. So let's

26737
03:53:07,860 --> 03:53:11,790
actually get the receipt we'll
do const mint TX receipt, but

26738
03:53:11,790 --> 03:53:15,150
the receipt, I can there equals
that. And then I'm just going to

26739
03:53:15,150 --> 03:53:19,110
copy this from the mminton
receipt. Cons token ID equals

26740
03:53:19,140 --> 03:53:26,820
this, paste it into our mint.js
and then a console dot log. Got

26741
03:53:26,850 --> 03:53:32,910
token ID, string interpolates
token ID, hard hat, run scripts,

26742
03:53:33,480 --> 03:53:38,790
mins dot j s dash dash network,
local host. And we're going to

26743
03:53:38,790 --> 03:53:46,350
mint an NF T. Got token ID six
means we know m token ID six, we

26744
03:53:46,350 --> 03:53:49,080
can list this entity. Let's also
add the address. Let's do

26745
03:53:49,080 --> 03:53:56,550
console dot log NFTL. And if the
address is going to be we'll do

26746
03:53:56,550 --> 03:53:57,780
string interpolation.

26747
03:53:59,280 --> 03:54:03,570
And you know what? Let's make
this again. Mint dot j s okay

26748
03:54:03,570 --> 03:54:07,770
cool. Got token ID seven and if
the address this so what we can

26749
03:54:07,770 --> 03:54:11,670
do now we'll grab this NFT
address. So from account one,

26750
03:54:11,670 --> 03:54:13,620
let's go to Account three
because that's the account that

26751
03:54:13,620 --> 03:54:16,740
I've done my imports on now when
you switch accounts, we're going

26752
03:54:16,740 --> 03:54:22,320
to want to refresh the page as
the address seven 0.6. Submit

26753
03:54:22,650 --> 03:54:26,550
Metamask pops up. Give
permission Yes. Okay, now it's

26754
03:54:26,550 --> 03:54:31,290
time to list you now have one
pen, okay. Local host list item.

26755
03:54:31,770 --> 03:54:33,780
We can see all the data and
everything. Okay, let's go ahead

26756
03:54:33,780 --> 03:54:38,340
and confirm NFT listed Okay,
okay. Okay. Okay. So this is

26757
03:54:38,340 --> 03:54:41,850
good. Now to get Morales to
catch up to speed back in our

26758
03:54:41,850 --> 03:54:46,170
node. Let's just go ahead and
run yarn, RT hat run scripts,

26759
03:54:46,440 --> 03:54:51,690
mine dot j s dash dash network,
local host. We're going to mine

26760
03:54:51,690 --> 03:54:55,620
those two blocks. And now if we
go to our item listed, we'll

26761
03:54:55,620 --> 03:55:01,170
give this a little refresh. Go
to active item. We can see

26762
03:55:01,350 --> 03:55:05,460
there's a new item listed for
0.6 eath. In our database. This

26763
03:55:05,460 --> 03:55:09,720
is fantastic. Now that we've
listed this, if we go back to

26764
03:55:09,930 --> 03:55:13,260
now let's make And let's move on
to one more. Let's list the

26765
03:55:13,260 --> 03:55:15,930
second one, just to see that
it's actually working. Okay,

26766
03:55:15,930 --> 03:55:20,100
token ID eight. Let's grab this
address. Let's give this a

26767
03:55:20,100 --> 03:55:26,550
refresh. paste this in token ID
eight. We'll do 0.999. Let's

26768
03:55:26,550 --> 03:55:33,900
submit. we'll approve this. Yes.
Then we'll send it. Yes. Okay,

26769
03:55:34,050 --> 03:55:36,720
now let's go ahead and mine two
blocks. So I'm just going to hit

26770
03:55:36,750 --> 03:55:41,730
up and go back to mine will run
the mining, moving blocks. Okay,

26771
03:55:41,730 --> 03:55:47,970
great. Now, if we go back home,
we'll see there are three NF T's

26772
03:55:47,970 --> 03:55:51,150
now listed, we have the original
one, that we have those two that

26773
03:55:51,150 --> 03:55:56,940
we just listed eight, and seven
for 0.6 and 0.999. Listed on our

26774
03:55:56,970 --> 03:56:00,570
NFT marketplace. This is so
exciting. Our listing is working

26775
03:56:00,570 --> 03:56:03,990
correctly, okay. Now, due to the
fact that this lesson is already

26776
03:56:03,990 --> 03:56:07,200
incredibly long, actually
decided to cut the part of that

26777
03:56:07,200 --> 03:56:09,600
and then withdraw a bit, because
we don't really learn anything

26778
03:56:09,600 --> 03:56:13,440
new there. However, feel free to
jump back in to get every bit

26779
03:56:13,440 --> 03:56:16,710
associated with scores, where we
will have that withdrawal

26780
03:56:16,710 --> 03:56:20,070
functionality for you if you
want to implement it. Otherwise,

26781
03:56:20,100 --> 03:56:22,980
feel free to skip and move on
ahead. This is incredibly

26782
03:56:22,980 --> 03:56:25,920
powerful. And you should be
incredibly excited about

26783
03:56:25,920 --> 03:56:30,300
yourself. If you've made it this
far. This is awesome. You just

26784
03:56:30,300 --> 03:56:33,120
made a decentralized marketplace
and then built a front end on

26785
03:56:33,120 --> 03:56:37,350
top of it to allow anybody to
interact with your marketplace.

26786
03:56:37,860 --> 03:56:42,540
Easily. Huge, huge.
Congratulations here. Oh, this

26787
03:56:42,540 --> 03:56:45,780
is a perfect time to go take a
break and celebrate. And this is

26788
03:56:45,780 --> 03:56:48,720
a great time to ping me on
Twitter to ping me on Twitter

26789
03:56:48,720 --> 03:56:51,660
saying hey, Patrick, I just
completed the NFT marketplace.

26790
03:56:51,720 --> 03:56:55,650
Full Stack front end part of
your Free Code Camp course, I

26791
03:56:55,650 --> 03:56:59,400
now know how to build full stack
front end on top of my smart

26792
03:56:59,400 --> 03:57:02,820
contract applications. And be so
so pumped with yourself because

26793
03:57:02,820 --> 03:57:06,180
this is so awesome. I can't
understate how excited I am that

26794
03:57:06,180 --> 03:57:09,330
you've made it this far, you are
learning and working with a ton

26795
03:57:09,330 --> 03:57:12,660
of technologies, solidity smart
contracts, and front end you are

26796
03:57:12,660 --> 03:57:15,990
doing full stack you were doing
a lot of stuff here. So you

26797
03:57:15,990 --> 03:57:18,870
should be really proud of
yourself. huge congratulations,

26798
03:57:18,870 --> 03:57:22,380
be sure to absolutely give
yourself a pat on the back. And

26799
03:57:22,380 --> 03:57:24,390
then get ready to continue to
our next section.

26800
03:57:27,300 --> 03:57:31,410
Now that we've done all of this
using our Morales back end, I'm

26801
03:57:31,410 --> 03:57:34,980
about to switch it up on you,
instead of indexing all of our

26802
03:57:34,980 --> 03:57:37,980
events with a centralized
server. Now we're going to learn

26803
03:57:37,980 --> 03:57:42,240
how to build this using the
graph, which is a decentralized

26804
03:57:42,270 --> 03:57:46,110
event indexer that we can use, a
lot of the code is going to be

26805
03:57:46,110 --> 03:57:52,110
exactly the same. So instead of
us starting from a new, what

26806
03:57:52,110 --> 03:57:55,500
we're going to do, first of all
we can we can close all our

26807
03:57:55,500 --> 03:57:59,640
local stuff, we can close all of
these things, we can close all

26808
03:57:59,640 --> 03:58:03,240
of our terminals finally, which
is really exciting. And in this

26809
03:58:03,240 --> 03:58:06,000
folder, what we're going to do
is we're actually just going to

26810
03:58:06,000 --> 03:58:11,130
copy everything into a new
folder. So I'm going to CD down

26811
03:58:11,130 --> 03:58:15,990
a directory, we're going to make
a new one called next Jas. And

26812
03:58:15,990 --> 03:58:23,430
if T marketplace, the graph,
dash FCC, and all the code for

26813
03:58:23,430 --> 03:58:28,020
this section is going to be here
for front end the graph indexer

26814
03:58:28,260 --> 03:58:30,690
we're gonna have to make another
repo and we'll get to that in a

26815
03:58:30,690 --> 03:58:33,420
little bit. For all the changes,
it's going to be in this section

26816
03:58:33,420 --> 03:58:36,150
here. So what we're going to do
is we're going to make this new

26817
03:58:36,150 --> 03:58:42,720
folder, and we're going to do
copy dash R. Next, Jas and ft

26818
03:58:42,750 --> 03:58:50,580
marketplace FCC into next Jas
NFT. Marketplace, the graph FCC.

26819
03:58:51,180 --> 03:58:54,840
So we're going to copy
recursively, everything that's

26820
03:58:54,840 --> 03:58:57,930
inside that folder we just
created into this new one that

26821
03:58:57,930 --> 03:59:00,690
we're going to make a lot of
adjustments to. And this might

26822
03:59:00,690 --> 03:59:04,080
take a little bit of time to run
because we've got a lot of stuff

26823
03:59:04,080 --> 03:59:07,770
in this folder. And Alright,
once we've done that, we can cd

26824
03:59:07,770 --> 03:59:13,410
into this next Jas and ft
marketplace, the graph FCC and

26825
03:59:13,410 --> 03:59:17,910
do code period and open this up
in a new code editor. Or as

26826
03:59:17,910 --> 03:59:21,630
always, you can do File Open
folder to open it like that. Now

26827
03:59:21,630 --> 03:59:24,030
that we're in here, we're going
to learn how to do this exact

26828
03:59:24,030 --> 03:59:28,440
same project, instead of using
mirallas. But using the graph,

26829
03:59:28,470 --> 03:59:29,970
one of the things that we're
first going to do is we're

26830
03:59:29,970 --> 03:59:33,780
actually going to deploy our
contracts to rink B. So we're

26831
03:59:33,780 --> 03:59:37,620
going to grab our marketplace,
that soul, pull this over, we're

26832
03:59:37,620 --> 03:59:40,380
going to grab our hard hat
marketplace dot soul project,

26833
03:59:40,560 --> 03:59:43,350
pull it over. And first, we're
going to run our deploy script

26834
03:59:43,380 --> 03:59:46,470
on rink v. So hopefully, you've
got all your deploy stuff set up

26835
03:59:46,470 --> 03:59:49,590
correctly, so that all the
arguments can go through

26836
03:59:49,590 --> 03:59:52,170
correctly for rink v as well. So
we're gonna go ahead and run

26837
03:59:52,170 --> 03:59:58,800
this yarn, hard hat deploy dash
dash network Rinkeby. And to

26838
03:59:58,800 --> 04:00:01,050
make sure that it's going to
work for Rinkeby. Let's check

26839
04:00:01,050 --> 04:00:05,070
our hard hat config. Okay for
networks, looks like I have my

26840
04:00:05,070 --> 04:00:08,520
Rigby stuff in here for
networks. Okay, I've got my RPC

26841
04:00:08,520 --> 04:00:11,340
URL, which I'm getting from my
environment variables. If I have

26842
04:00:11,340 --> 04:00:13,950
a private key, I have a private
key, which I'm also getting from

26843
04:00:13,950 --> 04:00:17,640
environment variables, I have a
chain ID block confirmations and

26844
04:00:17,640 --> 04:00:20,640
save deployments. So let's go
ahead and run this. Now we're

26845
04:00:20,640 --> 04:00:23,670
going to go ahead and be
deploying the NFT marketplace to

26846
04:00:23,670 --> 04:00:27,150
the Rigby network. And our
deploy script also has an ID

26847
04:00:27,150 --> 04:00:30,300
some verification. So we can
verify this as well, you can't

26848
04:00:30,300 --> 04:00:33,210
really follow along with this
section without deploying a

26849
04:00:33,210 --> 04:00:36,390
marketplace to rink be here. So
deploy to rank B, or whatever

26850
04:00:36,390 --> 04:00:40,140
test net is recommended in this
lesson 15 section, and go from

26851
04:00:40,140 --> 04:00:42,780
there. Alright, great, we've
deployed our NFC marketplace.

26852
04:00:43,140 --> 04:00:46,260
Now we're gonna go ahead and
deploy our basic NFT. And once

26853
04:00:46,260 --> 04:00:48,720
these are done deploying, we can
start updating our front end

26854
04:00:48,720 --> 04:00:51,720
code to work with the graph
instead of mirallas. Okay, we've

26855
04:00:51,720 --> 04:00:54,540
verified everything to which
looks great. Now we're going to

26856
04:00:54,540 --> 04:00:58,860
verify our basic NFT. And we've
have it verified. Awesome. So

26857
04:00:58,860 --> 04:01:02,580
now we have an NFT marketplace
deployed to ring P, and a basic

26858
04:01:02,580 --> 04:01:06,450
NFT deployed to rink B. And both
of them are verified. So be sure

26859
04:01:06,450 --> 04:01:09,120
to take note of those, because
we're going to need them when

26860
04:01:09,120 --> 04:01:13,200
we're moving over to our the
graph section. So now let's grab

26861
04:01:13,200 --> 04:01:17,580
our code editor titled next Jas
and ft marketplace, the graph.

26862
04:01:17,850 --> 04:01:21,060
And let's get going. Now, we
just deployed that to rink B.

26863
04:01:21,060 --> 04:01:24,990
But we forgot to add some code
in here to update our network

26864
04:01:24,990 --> 04:01:29,190
mapping. However, if we go back
and we open back up code dot

26865
04:01:29,190 --> 04:01:36,390
dot, next Jas NFT marketplace,
FCC, in the network mapping in

26866
04:01:36,390 --> 04:01:39,930
here will now have a new entry
for rink B, if we did it

26867
04:01:39,930 --> 04:01:43,470
correctly, let's copy this
network mapping and paste it

26868
04:01:43,470 --> 04:01:47,250
over in our network, our next GS
and ft marketplace, the graph

26869
04:01:47,250 --> 04:01:50,040
section, or you can just
manually add your new entry.

26870
04:01:50,250 --> 04:01:53,370
Right. So you want to add
network ID for network

26871
04:01:53,370 --> 04:01:56,820
marketplace. And the address of
that network marketplace that

26872
04:01:56,820 --> 04:01:59,400
you just deployed, is we're
going to delete this Cloud

26873
04:01:59,400 --> 04:02:02,940
Functions bit. Goodbye, because
since we're not working with the

26874
04:02:02,940 --> 04:02:05,700
server anymore, there's not
gonna be any cloud functions or

26875
04:02:05,700 --> 04:02:08,250
any back end to run. So we're
gonna move that to trash

26876
04:02:08,250 --> 04:02:11,790
goodbye. Next, we don't need FRP
anymore, because we're not going

26877
04:02:11,790 --> 04:02:14,430
to be connecting our local
blockchain to the graph, we're

26878
04:02:14,430 --> 04:02:16,950
only going to be working with
the test net here. So let's go

26879
04:02:16,950 --> 04:02:21,570
ahead and delete that. Goodbye,
what's next in our pages, and

26880
04:02:21,570 --> 04:02:26,100
our app dot j s. Right now we're
connecting to a Morales provider

26881
04:02:26,130 --> 04:02:31,050
like this, we're going to switch
this back to initiate allies on

26882
04:02:31,050 --> 04:02:35,100
Mount, this is going to go back
to being false, we're no longer

26883
04:02:35,100 --> 04:02:38,220
going to connect to our Morales
database like this, we're just

26884
04:02:38,220 --> 04:02:41,040
going to use the hooks again.
Now with that the only thing

26885
04:02:41,040 --> 04:02:44,790
that's going to change is our
index.js. Right now, in our

26886
04:02:44,790 --> 04:02:51,270
index.js, we're getting our list
of NF TS from our Morales query.

26887
04:02:51,360 --> 04:02:54,330
So we're going to change this,
let's update our readme. So

26888
04:02:54,360 --> 04:02:58,560
we're gonna say instead of
reading the events from ralis,

26889
04:02:58,590 --> 04:03:02,610
we will first off we're going to
index them with the graph. And

26890
04:03:02,610 --> 04:03:05,790
then we're going to read from
the graph. So the question is,

26891
04:03:05,970 --> 04:03:06,960
what is the graph.

26892
04:03:09,690 --> 04:03:13,170
So the graph is going to be a
decentralized layer for storing

26893
04:03:13,440 --> 04:03:16,890
event data. So there are all
these blockchains and all these

26894
04:03:16,890 --> 04:03:19,440
different storage networks. And
the graph is and the graph is a

26895
04:03:19,440 --> 04:03:23,130
network of different nodes that
read from blockchains and index

26896
04:03:23,130 --> 04:03:27,360
this data, and it exposes an API
for us to call we can read that

26897
04:03:27,360 --> 04:03:29,850
data. Rather than just myself.
We actually have nattered

26898
04:03:29,850 --> 04:03:32,700
Abbott, who can explain it a lot
better than I can take it away.

26899
04:03:32,700 --> 04:03:33,090
And at.

26900
04:03:33,600 --> 04:03:36,390
First, I'd like to thank Patrick
for creating such a wonderful

26901
04:03:36,390 --> 04:03:38,910
educational resource and
inviting me to be a part of it.

26902
04:03:39,390 --> 04:03:42,060
My name is Nadia dabit. I'm a
developer relations engineer

26903
04:03:42,060 --> 04:03:44,400
working with the graph. The
graph is an indexing and

26904
04:03:44,400 --> 04:03:46,470
querying protocol for
decentralized networks like

26905
04:03:46,470 --> 04:03:50,250
Aetherium IPFS, dozens of other
EVM compatible networks, as well

26906
04:03:50,250 --> 04:03:53,580
as near and then the future
cosmos and Solana. Using the

26907
04:03:53,580 --> 04:03:56,430
graph developers can build and
publish open API's called

26908
04:03:56,430 --> 04:03:59,550
subgraphs that they can then use
in their applications to enable

26909
04:03:59,550 --> 04:04:02,610
better querying capabilities of
data stored on these networks,

26910
04:04:02,790 --> 04:04:05,880
including features like
filtering, sorting, relational

26911
04:04:05,880 --> 04:04:09,390
data, and full stack search.
subgraphs live in between the

26912
04:04:09,390 --> 04:04:12,180
blockchain and the UI providing
an important piece of software

26913
04:04:12,180 --> 04:04:15,330
infrastructure, a flexible
performant and decentralized API

26914
04:04:15,330 --> 04:04:19,530
layer, and the traditional tech
stack databases, servers and

26915
04:04:19,530 --> 04:04:24,270
API's query filter, sort
paginate group and join data

26916
04:04:24,270 --> 04:04:27,600
before it's returned to an
application, usually via some

26917
04:04:27,630 --> 04:04:31,350
type of HTTP request. These
types of data transformations

26918
04:04:31,350 --> 04:04:34,140
are not possible when reading
data directly from Aetherium or

26919
04:04:34,140 --> 04:04:37,380
other blockchains. Before the
graph teams had to develop and

26920
04:04:37,380 --> 04:04:40,560
operate proprietary indexing
servers. This required

26921
04:04:40,560 --> 04:04:43,260
significant engineering and
hardware resources and broke the

26922
04:04:43,260 --> 04:04:46,140
important security principles
required for decentralization,

26923
04:04:46,680 --> 04:04:49,380
how we interact with and build
on top of blockchains it's much

26924
04:04:49,380 --> 04:04:51,510
different than what we are used
to in the traditional tech

26925
04:04:51,510 --> 04:04:54,660
stack. In a blockchain data
isn't stored in a format that

26926
04:04:54,660 --> 04:04:58,410
can be easily or efficiently
consumed, or retrieved directly

26927
04:04:58,410 --> 04:05:01,440
from other applications or front
ends. The problem is that you

26928
04:05:01,440 --> 04:05:03,930
need to have the data indexed
and organized for efficient

26929
04:05:03,930 --> 04:05:07,770
retrieval. Traditionally, that's
the work that databases and web

26930
04:05:07,770 --> 04:05:10,890
servers do in this centralized
tech stack. But that in indexing

26931
04:05:10,890 --> 04:05:13,740
layer was missing in the web
three stack. Let's take a look

26932
04:05:13,740 --> 04:05:16,320
at a couple of other examples of
indexing in the real world.

26933
04:05:16,590 --> 04:05:19,500
Search engines like Google crawl
the internet indexing relevant

26934
04:05:19,500 --> 04:05:22,530
data making it available for
users to search via their web

26935
04:05:22,530 --> 04:05:25,620
interface and other API's.
Without this indexing layer,

26936
04:05:25,620 --> 04:05:28,320
it'd be hard for us to know
where and how to find relevant

26937
04:05:28,320 --> 04:05:31,890
information across the web.
Another similar analogy is a

26938
04:05:31,890 --> 04:05:35,040
library. Using an indexing
system like the Dewey Decimal

26939
04:05:35,040 --> 04:05:38,340
System, we know where to find
the book that we're looking for

26940
04:05:38,370 --> 04:05:41,040
without having to go through
book by book looking throughout

26941
04:05:41,040 --> 04:05:44,190
the entire library. The graph
serves over 2 billion queries

26942
04:05:44,190 --> 04:05:46,830
per day to many different types
of web three applications,

26943
04:05:47,010 --> 04:05:50,970
including apps in the defy
gaming and FC space. Before we

26944
04:05:50,970 --> 04:05:53,250
dig into any code, let's take a
look at how to build a sub

26945
04:05:53,250 --> 04:05:56,940
graph. To get started, you would
go to the graph.com and create a

26946
04:05:56,940 --> 04:06:00,210
new sub graph and the graph user
interface. You would then use

26947
04:06:00,210 --> 04:06:03,330
the graph CLI to scaffold out an
empty sub graph boilerplate that

26948
04:06:03,330 --> 04:06:07,290
you can then update with your
own contract information. In

26949
04:06:07,290 --> 04:06:09,870
your subgraph configuration, you
would define things like your

26950
04:06:09,870 --> 04:06:12,900
data model, the network, the
contract addresses and other

26951
04:06:12,900 --> 04:06:15,720
configurations that are specific
to the data that you would like

26952
04:06:15,720 --> 04:06:20,280
to index. For our data model, we
use Graph QL, schema definition

26953
04:06:20,280 --> 04:06:23,280
language defining top level
types as well as fields within

26954
04:06:23,280 --> 04:06:26,760
those types. When we're ready to
deploy our subgraph, so we can

26955
04:06:26,760 --> 04:06:29,760
begin testing it out and using
it in our application, we can

26956
04:06:29,760 --> 04:06:33,480
use the graph CLI running the
deploy command. Once the

26957
04:06:33,480 --> 04:06:36,150
subgraph is deployed and the
data begins to be indexed, we

26958
04:06:36,150 --> 04:06:39,090
can start testing it out using
the graphical interface directly

26959
04:06:39,090 --> 04:06:43,350
in the graph dashboard. When
we're ready to start queering,

26960
04:06:43,350 --> 04:06:45,960
our sub graph from our
application, we can use the API

26961
04:06:45,960 --> 04:06:48,990
URL that's been given to us by
the graph along with any Graph

26962
04:06:48,990 --> 04:06:53,460
QL query. If you'd like to learn
more about the graph, check out

26963
04:06:53,460 --> 04:06:57,180
the graph.com as well as Graph
Protocol, Twitter, the docs at

26964
04:06:57,180 --> 04:07:01,710
the graph.com/docs, or our
Discord at the graph.com/discord

26965
04:07:02,070 --> 04:07:04,530
Thanks matter. And now that we
have a better idea of what the

26966
04:07:04,530 --> 04:07:09,780
graph is, we can actually start
building with it. Now if we were

26967
04:07:09,780 --> 04:07:13,290
to try to run this app as it is,
it obviously would fail, right,

26968
04:07:13,290 --> 04:07:18,300
because index.js, right now is
reading from mirallas instead of

26969
04:07:18,510 --> 04:07:21,900
from the graph. So like it says
in our readme, first thing we're

26970
04:07:21,900 --> 04:07:24,090
going to need to do is we're
gonna need to index from the

26971
04:07:24,090 --> 04:07:28,140
graph, and then we can just this
project to read from the graph.

26972
04:07:28,260 --> 04:07:31,560
So let's go ahead and learn how
to build our sub graph. In order

26973
04:07:31,560 --> 04:07:35,160
for us to tell the graph network
to start indexing the events

26974
04:07:35,190 --> 04:07:39,510
from our contract, we're gonna
go to graph.com, we're gonna go

26975
04:07:39,510 --> 04:07:43,920
to products. And we're going to
go to sub graph studio, if you

26976
04:07:43,920 --> 04:07:46,380
go to products, the first thing
you see is the Graph Explorer,

26977
04:07:46,410 --> 04:07:49,440
these are already existing sub
graphs. And if you go through

26978
04:07:49,440 --> 04:07:52,320
here, you'll see a lot of
incredibly popular decentralized

26979
04:07:52,320 --> 04:07:55,560
protocols all have different sub
graphs, hosted service is going

26980
04:07:55,560 --> 04:07:57,720
to get discontinued at some
point. So we're going to skip

26981
04:07:57,720 --> 04:08:00,720
there. So let's go to sub graph
studio, this is going to help

26982
04:08:00,750 --> 04:08:03,960
enable us to create a sub graph
for other nodes to start

26983
04:08:03,960 --> 04:08:06,930
indexing our events. So we're
gonna go ahead and connect our

26984
04:08:06,930 --> 04:08:10,710
wallet with meta mask. And I'm
going to choose account one

26985
04:08:10,710 --> 04:08:15,210
here, next connect, and we're
going to want to switch off of

26986
04:08:15,210 --> 04:08:21,270
Hardhead. Local, over to the
Rinkeby test network. And I'll

26987
04:08:21,270 --> 04:08:23,970
go to Account one here. And
we're going to get a signature

26988
04:08:23,970 --> 04:08:27,540
request from the graph summary
to the website that we just

26989
04:08:27,540 --> 04:08:31,050
built. The subgraph website has
some signings functionality with

26990
04:08:31,050 --> 04:08:34,620
a database on the back end. So
we're seeing in real life,

26991
04:08:34,650 --> 04:08:38,250
exactly the methods that we just
used. So instead of signing with

26992
04:08:38,250 --> 04:08:41,010
Morales, they're just have their
own custom sign in here. So

26993
04:08:41,010 --> 04:08:44,220
we're gonna go ahead and sign in
so that the graph website knows

26994
04:08:44,250 --> 04:08:46,800
that it can interact with us.
And we can go ahead and enter

26995
04:08:46,800 --> 04:08:50,070
our email if we want. I'm gonna
go ahead and skip. And you'll

26996
04:08:50,070 --> 04:08:53,070
even get a little notification
here saying only subgraphs

26997
04:08:53,070 --> 04:08:56,160
indexing Aetherium or main net
or Rigby can be created in

26998
04:08:56,160 --> 04:09:00,600
subgraph studio. So let's go
ahead and create a subgraph. So

26999
04:09:00,630 --> 04:09:04,050
we're going to pick a cerium
Rigby and the subgraph name is

27000
04:09:04,050 --> 04:09:08,040
going to be NFT marketplace.
We'll go ahead and hit Continue.

27001
04:09:08,400 --> 04:09:11,190
Now, this is going to be our
dashboard for creating our sub

27002
04:09:11,190 --> 04:09:14,520
graph. And there's a ton of
instructions over here and

27003
04:09:14,520 --> 04:09:17,220
documentation that we can view
to get started, I'm going to add

27004
04:09:17,220 --> 04:09:20,520
this documentation to the GitHub
repo associated with this

27005
04:09:20,520 --> 04:09:24,120
course. So this NFT marketplace
sub graph is going to need its

27006
04:09:24,120 --> 04:09:27,450
own git repository itself. So
what we're going to do back in

27007
04:09:27,450 --> 04:09:30,630
here is we're going to CD down,
we're going to make a new

27008
04:09:30,630 --> 04:09:35,040
directory, and we're going to
call it graph. And if T

27009
04:09:35,670 --> 04:09:40,710
marketplace, FCC, we're going to
open that up as well. So code

27010
04:09:40,710 --> 04:09:46,110
graph NFT, marketplace, FCC, or
file open graft code marketplace

27011
04:09:46,140 --> 04:09:50,400
FCC, and in this window, we're
going to build our subgraph.

27012
04:09:50,460 --> 04:09:53,550
Locally, we're going to build
our subgraph and push it up to

27013
04:09:53,550 --> 04:09:56,700
the subgraph studio. And in
here, there's a whole bunch of

27014
04:09:56,700 --> 04:09:59,160
instructions that we can follow
along with to go ahead and

27015
04:09:59,160 --> 04:10:02,850
install. The first thing that we
need to do is install the graph

27016
04:10:02,880 --> 04:10:06,090
command line interface. And we
want to install this globally.

27017
04:10:06,630 --> 04:10:10,260
So I'm going to copy this part
here. Come back to my terminal

27018
04:10:10,560 --> 04:10:15,990
Oh, yarn, global ad and paste
that in. It's this command line

27019
04:10:15,990 --> 04:10:19,890
that's going to help us build a
graph and build instructions for

27020
04:10:19,890 --> 04:10:22,920
the graph to actually start
indexing our events. Now that

27021
04:10:22,920 --> 04:10:26,310
we've installed the globally, we
can initialize our graph code.

27022
04:10:26,460 --> 04:10:31,170
So we can copy this line. And
we'll run graph a knit dash dash

27023
04:10:31,170 --> 04:10:35,520
studio NFT marketplace and hit
enter. The protocol is going to

27024
04:10:35,520 --> 04:10:40,770
be Aetherium, or subgraph. Slug
will be NFT. marketplace. We

27025
04:10:40,770 --> 04:10:43,050
want the directory to be here,
but it's saying directory

27026
04:10:43,050 --> 04:10:46,470
already exists. So we'll just
give it NFT marketplace. And

27027
04:10:46,470 --> 04:10:49,410
then we'll move it after this.
And this is on the Rinkeby. Test

27028
04:10:49,410 --> 04:10:53,250
net. And now we want to give it
the contract address. So we want

27029
04:10:53,250 --> 04:10:56,910
to grab that address that we
just deployed. And it should be

27030
04:10:56,910 --> 04:10:59,700
now in our network mapping. So
we're going to grab that

27031
04:10:59,700 --> 04:11:03,150
contract address that we just
deployed, and paste it in here.

27032
04:11:04,140 --> 04:11:09,360
Like so. And since we've already
verified on ether scan, it

27033
04:11:09,360 --> 04:11:12,720
automatically grabs the ABI for
us from ether scan, we'll give

27034
04:11:12,720 --> 04:11:16,800
it the contract name, which is
the NFT marketplace. And it's

27035
04:11:16,800 --> 04:11:20,190
going to give us a whole bunch
of boilerplate code in this NFT

27036
04:11:20,190 --> 04:11:22,950
marketplace directory. And this
might take a couple of minutes.

27037
04:11:23,070 --> 04:11:26,820
Alright, awesome. So now that
it's done, we see subgraph NFT

27038
04:11:26,820 --> 04:11:30,180
marketplace created in NFT
marketplace. Now, I don't want

27039
04:11:30,180 --> 04:11:32,550
it to be in the seller folder.
So what I'm going to do is I'm

27040
04:11:32,550 --> 04:11:34,890
going to move it down a
directory, but you can leave it

27041
04:11:34,890 --> 04:11:38,340
where it is, if you want, I'm
going to say move, I'm going to

27042
04:11:38,340 --> 04:11:44,340
say move NFT marketplace, star
to dot slash. Now everything

27043
04:11:44,340 --> 04:11:47,340
inside of NFT marketplace will
be in this current directory.

27044
04:11:47,430 --> 04:11:50,160
And then if the marketplace will
be empty. So with that, I'm

27045
04:11:50,160 --> 04:11:53,430
gonna go ahead and delete. And
if the marketplace. Alright,

27046
04:11:53,430 --> 04:11:57,480
great. Now let me walk you
through exactly what's going on

27047
04:11:57,480 --> 04:12:00,660
here and what these files are
that we just created. So our

27048
04:12:00,660 --> 04:12:03,570
first folder is going to be
API's. In order for the graph to

27049
04:12:03,570 --> 04:12:06,810
index and read our contract
index our events, it's going to

27050
04:12:06,810 --> 04:12:11,130
need the ABI of our events. So
we've got the ABI of our entire

27051
04:12:11,130 --> 04:12:15,420
marketplace, from ether scan, if
we didn't verify an ether scan,

27052
04:12:15,450 --> 04:12:18,660
we can just create this API
folder ourself and add the NFT

27053
04:12:18,660 --> 04:12:22,650
marketplace JSON in here. Now we
have this generated folder. This

27054
04:12:22,680 --> 04:12:25,890
is an auto generated file. He
even says at the top, do not

27055
04:12:25,890 --> 04:12:29,370
edit this file directly. You can
kind of think of this as the

27056
04:12:29,370 --> 04:12:33,120
build folder, or where we
compile graph code. Node

27057
04:12:33,120 --> 04:12:35,310
modules, of course, is going to
be node modules and

27058
04:12:35,310 --> 04:12:40,050
dependencies. SRC is going to be
where we define and we tell the

27059
04:12:40,050 --> 04:12:43,560
graph, how to actually map and
how to actually work with our

27060
04:12:43,560 --> 04:12:47,580
contract. And it is a TypeScript
file. So for all of you who have

27061
04:12:47,580 --> 04:12:50,370
been just doing this in
JavaScript, I will have to teach

27062
04:12:50,370 --> 04:12:52,920
you a little bit of TypeScript
just to get through this part.

27063
04:12:53,070 --> 04:12:56,220
Then we have networks dot JSON,
which gives us all of our

27064
04:12:56,220 --> 04:12:59,130
network information about which
networks, what are the

27065
04:12:59,130 --> 04:13:01,170
addresses, and what are the
different contracts that we're

27066
04:13:01,170 --> 04:13:04,140
going to be indexing, package
dot JSON, which of course is

27067
04:13:04,140 --> 04:13:08,400
just a normal package dot JSON.
And it's got some graph scripts

27068
04:13:08,430 --> 04:13:12,240
already built in schema dot
graph. QL is going to be our

27069
04:13:12,240 --> 04:13:16,050
Graph QL schema. So this is also
going to be how we tell the

27070
04:13:16,050 --> 04:13:19,050
graph how to actually work with
our events and index our events.

27071
04:13:19,260 --> 04:13:22,380
And if you're familiar, the
schema follows the Graph QL

27072
04:13:22,380 --> 04:13:26,610
syntax. So if you've ever worked
with Graph QL, before, it's

27073
04:13:26,610 --> 04:13:30,090
going to be the exact same way,
graph. QL is a query language

27074
04:13:30,120 --> 04:13:33,030
for your API. And instead of
being kind of a relational

27075
04:13:33,030 --> 04:13:37,140
database, it can query in a more
graph type way, I'm not going to

27076
04:13:37,140 --> 04:13:40,410
go too deep into how it actually
works behind the scenes. But if

27077
04:13:40,410 --> 04:13:42,180
you want to learn more, I'm
going to leave some docs in the

27078
04:13:42,180 --> 04:13:45,210
GitHub repository associated
with this course, the sub graph

27079
04:13:45,210 --> 04:13:48,360
dot Yamo tells our subgraph how
to combine all the files

27080
04:13:48,360 --> 04:13:51,420
together. So we have data
sources, data sources, where

27081
04:13:51,420 --> 04:13:54,330
they're coming from different
addresses, different entities or

27082
04:13:54,330 --> 04:13:58,650
events, the API's where to grab
our files from different event

27083
04:13:58,650 --> 04:14:01,590
handlers, which we'll talk about
in a minute. And then the main

27084
04:14:01,590 --> 04:14:04,950
file, which is going to be our
mapping.ts, we have a TS config,

27085
04:14:04,980 --> 04:14:08,340
which is a configuration file
specific to TypeScript. And then

27086
04:14:08,340 --> 04:14:11,400
of course, we have our yarn dot
lock. With all this information

27087
04:14:11,400 --> 04:14:15,360
with all this code, we are now
going to update all this code to

27088
04:14:15,360 --> 04:14:20,130
tell the graph to start indexing
our events. So we can read our

27089
04:14:20,130 --> 04:14:22,800
events from the graph in a
decentralized context, as

27090
04:14:22,800 --> 04:14:26,460
opposed to from a centralized
database. And after we build

27091
04:14:26,460 --> 04:14:29,130
everything, we're going to run
through this off and deploy

27092
04:14:29,130 --> 04:14:32,910
code, which is to authenticate
ourselves, and then deploy our

27093
04:14:32,910 --> 04:14:36,690
code to the graph to start
indexing. So without further

27094
04:14:36,690 --> 04:14:40,710
ado, let's jump in. And let's do
this. So one of the first things

27095
04:14:40,710 --> 04:14:43,890
I'm going to do, I'm going to
add a highlighter for these dot

27096
04:14:43,890 --> 04:14:46,830
Graph QL files. So in our
extensions, we're gonna look at

27097
04:14:46,830 --> 04:14:51,210
Graph QL. And we're gonna stall
this Graph QL extension. Now

27098
04:14:51,210 --> 04:14:54,120
that we've installed it, if we
go back to schema dot graph, QL,

27099
04:14:54,570 --> 04:14:57,840
we've got it with some colors
now, which is exciting. So this

27100
04:14:57,840 --> 04:15:02,640
schema dot Graph QL is going to
define what entities we have in

27101
04:15:02,640 --> 04:15:06,060
our contract if we were to be
analogous to mirallas. These are

27102
04:15:06,060 --> 04:15:08,310
going to be how we're going to
define what our tables are going

27103
04:15:08,310 --> 04:15:10,890
to look like. And these are
going to be our events. plus

27104
04:15:10,890 --> 04:15:14,040
that active item table that we
created. So we're not going to

27105
04:15:14,040 --> 04:15:17,640
have an example entity though,
we're going to have a type

27106
04:15:18,210 --> 04:15:22,740
active item. And this is going
to be an add entity. So these

27107
04:15:22,740 --> 04:15:25,770
are the different types we have
in our graph that we can

27108
04:15:25,770 --> 04:15:27,900
actually query on, our main
thing that we're going to want

27109
04:15:27,900 --> 04:15:31,320
to query on is same as before,
it's going to be our active

27110
04:15:31,320 --> 04:15:33,840
items. And then inside of our
active items, we're going to

27111
04:15:33,840 --> 04:15:37,320
tell the graph, what parameters
each one of these active item

27112
04:15:37,320 --> 04:15:42,510
types has, well, it's going to
have an ID of type ID. So the

27113
04:15:42,510 --> 04:15:45,690
variable is ID of type ID. And
you can read more about the

27114
04:15:45,690 --> 04:15:48,510
different types in the graph
documentation. And this

27115
04:15:48,510 --> 04:15:53,310
exclamation mark means it must
have an ID. So every active item

27116
04:15:53,490 --> 04:15:56,310
needs to have and will have an
ID, we'll say there's going to

27117
04:15:56,310 --> 04:15:59,730
be a buyer, which is going to be
an address, so that's going to

27118
04:15:59,730 --> 04:16:03,150
be a byte and the buyer could be
blank, right? It could be the

27119
04:16:03,150 --> 04:16:07,920
0x 000, we're going to have all
of our active items have a

27120
04:16:08,160 --> 04:16:13,620
0000 dot.if. If no one has
bought yet, we're going to have

27121
04:16:13,620 --> 04:16:16,800
a seller, which of course is
also going to be a bytes because

27122
04:16:16,800 --> 04:16:19,560
it's going to be an address,
we're going to have an NFT

27123
04:16:19,560 --> 04:16:22,860
address. So the address of the
NFT, which will also be bytes,

27124
04:16:22,920 --> 04:16:25,530
we're going to have a token ID
which isn't going to be bytes,

27125
04:16:25,530 --> 04:16:28,050
this is going to be of type big
int, and then we're going to

27126
04:16:28,050 --> 04:16:31,980
have a price, which is also
going to be a big int. Now price

27127
04:16:32,010 --> 04:16:35,700
we're going to leave as not
required for price, we're just

27128
04:16:35,700 --> 04:16:39,090
going to have price be nullable.
So price can be null. So we have

27129
04:16:39,090 --> 04:16:42,450
an active item. Awesome. What
else are we going to need? What

27130
04:16:42,450 --> 04:16:44,940
what other tables do we have in
Morales? Well, we're going to

27131
04:16:44,940 --> 04:16:50,310
need type item listed. And this
is going to be at entity is

27132
04:16:50,310 --> 04:16:54,810
going to need an ID, it'll have
a seller. Whenever an item gets

27133
04:16:54,810 --> 04:16:57,180
listed, it's going to have a
seller right, which is going to

27134
04:16:57,180 --> 04:17:00,750
be a bytes again. And if the
address the address of the NFT,

27135
04:17:00,750 --> 04:17:05,160
which will also be bytes, the
token ID, which is going to be a

27136
04:17:05,160 --> 04:17:09,150
big int, and then the price,
which will also be a big end,

27137
04:17:09,930 --> 04:17:13,680
we're gonna need a type item
cancelled at entity

27138
04:17:15,240 --> 04:17:28,530
which will have an ID seller an
NFT address. And a token ID will

27139
04:17:28,530 --> 04:17:34,320
be a big end. And then last type
item bought will be in that

27140
04:17:34,320 --> 04:17:39,780
entity is going to have an ID
ID. It's going to be a buyer

27141
04:17:41,100 --> 04:17:41,730
bytes.

27142
04:17:43,860 --> 04:17:53,190
And then of T address a bytes
and a token ID again, and then a

27143
04:17:53,190 --> 04:17:56,580
price of beginnt. And with
Justice Information, we've

27144
04:17:56,580 --> 04:18:00,480
defined what we want our
subgraph to keep track of wants

27145
04:18:00,480 --> 04:18:03,630
to keep track of item bought
events, item, cancelled events,

27146
04:18:03,930 --> 04:18:07,050
item listed events. And then
we're going to make this new

27147
04:18:07,050 --> 04:18:10,620
active item table similar to
what we did with mirallas. And

27148
04:18:10,620 --> 04:18:13,980
it's going to be some function
of these these other three

27149
04:18:13,980 --> 04:18:17,220
events. And now we're done with
our schema dot graph. QL.

27150
04:18:17,490 --> 04:18:20,520
Awesome. So what do we do now
we're going to need to tell our

27151
04:18:20,520 --> 04:18:24,360
sub graph to actually listen for
these events. So what we can do.

27152
04:18:24,630 --> 04:18:27,090
So what we want to do to tell it
how to listen for these events,

27153
04:18:27,480 --> 04:18:33,270
is we're going to go to src
mapping.ts. It's this mapping.ts

27154
04:18:33,270 --> 04:18:37,350
file that's going to tell our
subgraph how to actually map and

27155
04:18:37,350 --> 04:18:40,770
how to actually store all the
event information that we have.

27156
04:18:40,950 --> 04:18:43,650
If you look in it right now, it
might even give you kind of a

27157
04:18:43,650 --> 04:18:47,460
sample event. So it says Export
function, handle item event.

27158
04:18:47,460 --> 04:18:49,950
This is what Maya says right
now, it takes as an input

27159
04:18:49,950 --> 04:18:54,780
parameter event item bot. So
this is saying whenever an item

27160
04:18:54,780 --> 04:18:59,520
bot event occurs, do this handle
item bot function. So anytime

27161
04:18:59,550 --> 04:19:02,910
item bot happens do this handle
item bot. And we're actually

27162
04:19:02,910 --> 04:19:07,620
getting this item bot from our
generated NFT marketplace from

27163
04:19:07,620 --> 04:19:12,000
some generated code. In the
graph. If we run graph code Gen.

27164
04:19:12,900 --> 04:19:16,290
This graph code Gen command
grabs all the stuff we have in

27165
04:19:16,290 --> 04:19:20,430
the schema dot Graph QL and puts
it in this generated file. Now

27166
04:19:20,430 --> 04:19:23,250
that I've run graph code Gen,
you'll see in here there's an

27167
04:19:23,250 --> 04:19:27,000
item bot class, you see there's
a schema, that type script. And

27168
04:19:27,000 --> 04:19:31,410
actually we can even find that
new active item class that we

27169
04:19:31,410 --> 04:19:35,400
created in our schema. So
anytime you update schema dot

27170
04:19:35,400 --> 04:19:39,180
Graph QL, you're always going to
want to run graph code Gen, so

27171
04:19:39,180 --> 04:19:42,150
you can update those types. And
if this failed, it means that

27172
04:19:42,150 --> 04:19:45,000
you messed up something in your
schema dot Graph QL. Now in our

27173
04:19:45,000 --> 04:19:48,990
mapping.ts, we're actually
importing item bought item

27174
04:19:48,990 --> 04:19:52,830
cancelled item listed from
generated and if the marketplace

27175
04:19:53,010 --> 04:19:56,250
and if the marketplace from our
generated code. These are going

27176
04:19:56,250 --> 04:19:59,160
to be our events. And we're not
going to need to do anything

27177
04:19:59,160 --> 04:20:01,710
with the NFT marketplace. We're
just going to need our event

27178
04:20:01,710 --> 04:20:04,740
information. For now. Let's go
ahead and just delete everything

27179
04:20:04,740 --> 04:20:08,430
inside our handle item bot or
whatever sample is given to you.

27180
04:20:09,450 --> 04:20:13,620
So we're importing a or events
from our generated code. And

27181
04:20:13,620 --> 04:20:16,080
then we have this line here,
which we're going to change in a

27182
04:20:16,080 --> 04:20:19,260
second. So again, we have these
three functions handle item

27183
04:20:19,260 --> 04:20:22,860
bought, handle item canceled and
handle item listed. Whenever we

27184
04:20:22,860 --> 04:20:25,350
get an item bought event, we're
going to do this function.

27185
04:20:25,770 --> 04:20:27,810
Whenever we get an item canceled
event, we're going to do this

27186
04:20:27,810 --> 04:20:32,580
function. And all this code is
defined in our sub graph dot

27187
04:20:32,580 --> 04:20:35,910
Yamo. You can see the different
entities here in a bot item

27188
04:20:35,910 --> 04:20:39,930
cancelled item listed, and the
event handlers. So it says,

27189
04:20:39,960 --> 04:20:45,360
okay, anytime this specific
event gets fired with an index

27190
04:20:45,360 --> 04:20:49,080
address, an index address index,
YouTube 36 in YouTube had six

27191
04:20:49,470 --> 04:20:52,890
call handle item bought, which
again, we're getting in here

27192
04:20:52,950 --> 04:20:56,340
handle item. But so that's
exactly how this works. So let's

27193
04:20:56,340 --> 04:21:00,030
figure out what to do when an
item bought event triggers. And

27194
04:21:00,030 --> 04:21:03,090
I think that item bought item
cancelled item lists it is a

27195
04:21:03,090 --> 04:21:07,650
little confusing. So I like to
change this to item bought as

27196
04:21:08,160 --> 04:21:16,110
item bought event item cancelled
as item cancelled event item

27197
04:21:16,110 --> 04:21:22,800
listed as item listed event. So
I'm just changing the names of

27198
04:21:22,800 --> 04:21:26,190
these three that are imported
from NFT marketplace. And now

27199
04:21:26,190 --> 04:21:30,180
I'm going to change event item
bot to item bought event. Event

27200
04:21:30,180 --> 04:21:33,660
item cancelled to item cancelled
event and event item listed to

27201
04:21:33,960 --> 04:21:37,470
item listed event. Okay, great.
And we're just going to remove

27202
04:21:37,470 --> 04:21:39,960
this line for now. And we also
don't need this line at the top

27203
04:21:39,960 --> 04:21:42,420
at the beginning, we will in a
minute, but we'll delete it for

27204
04:21:42,420 --> 04:21:46,710
now. So here's our minimalistic
code here. So whenever we list

27205
04:21:46,710 --> 04:21:50,580
an item, what do we need to do?
Well, we need to save that event

27206
04:21:50,880 --> 04:21:54,870
in our in our graph. And then we
also need to update our active

27207
04:21:54,870 --> 04:21:58,500
item, exactly as we did with
Morales. So first thing that

27208
04:21:58,500 --> 04:22:01,830
we're going to need to do is
either get or create an item

27209
04:22:01,830 --> 04:22:04,680
listed object. And something
that we need to know is that

27210
04:22:04,710 --> 04:22:09,660
each item needs a unique ID. And
we actually need to create that

27211
04:22:09,660 --> 04:22:12,600
ID. So one of the first things
I'm going to do is going to

27212
04:22:12,600 --> 04:22:18,120
create a function called Get ID
from event params. And it's

27213
04:22:18,120 --> 04:22:20,820
going to take a token ID and
here's where TypeScript comes

27214
04:22:20,820 --> 04:22:23,640
into play a little bit. In
TypeScript, we actually need to

27215
04:22:23,640 --> 04:22:26,820
define the types of our
different parameters. So token

27216
04:22:26,820 --> 04:22:31,110
ID is going to be a big int. And
we'll also take an NFT address,

27217
04:22:31,500 --> 04:22:35,160
which will take in a type of
address. And we also need to say

27218
04:22:35,160 --> 04:22:38,700
what return type or function is
going to give, which we're going

27219
04:22:38,700 --> 04:22:42,330
to return a string, we're going
to create an ID from event

27220
04:22:42,330 --> 04:22:45,060
params. And it's just going to
be a combination of the token ID

27221
04:22:45,240 --> 04:22:48,210
and the NFT address. The
combination of these two will

27222
04:22:48,210 --> 04:22:52,110
give a unique ID for each one of
these types of event. So we're

27223
04:22:52,110 --> 04:22:56,220
just gonna say return token ID,
and token ID has a function

27224
04:22:56,220 --> 04:23:03,540
called to x string, I'm gonna
say plus, and if T address.to X

27225
04:23:03,570 --> 04:23:08,100
string, like so. And big int an
address, we need to import from

27226
04:23:08,100 --> 04:23:11,970
at Graph Protocol slash graph
TX. It already imported big

27227
04:23:11,970 --> 04:23:15,000
enough for me. So I'm just going
to add address in here is the

27228
04:23:15,000 --> 04:23:17,220
two special types that come from
the graph. And then string is

27229
04:23:17,220 --> 04:23:20,670
built into TypeScript. Now that
we have a way to get a special

27230
04:23:20,670 --> 04:23:25,110
ID for each item in our function
here, we have to now either get

27231
04:23:25,110 --> 04:23:30,330
or create a new item listed. Now
right now we have an item. But

27232
04:23:30,390 --> 04:23:34,320
event we don't have an item
bought object. So the item

27233
04:23:34,320 --> 04:23:38,250
bought object is going to be
what we save, the item bought

27234
04:23:38,250 --> 04:23:42,870
event is just the raw event. So
we have to create an item bought

27235
04:23:42,870 --> 04:23:46,620
object from our item bought
event. And in TypeScript, these

27236
04:23:46,620 --> 04:23:49,140
are going to be two different
types. So we have to import

27237
04:23:49,140 --> 04:23:53,460
these item by objects. So those
actually get auto created from

27238
04:23:53,460 --> 04:23:57,600
generated schema. In here we
have active item, we have item,

27239
04:23:57,810 --> 04:24:02,160
we have an item bought class, we
have an item cancelled, etc. So

27240
04:24:02,160 --> 04:24:05,370
we're gonna have to import those
types from there. So we can say,

27241
04:24:05,850 --> 04:24:12,510
import, item listed, comma,
active item, item bought an item

27242
04:24:12,510 --> 04:24:18,420
cancelled from dot slash,
generated slash schema. Let's go

27243
04:24:18,420 --> 04:24:22,800
ahead and get or create an item
bot object. So we'll say let

27244
04:24:23,010 --> 04:24:30,150
item bot equals item bot dot
load. And this is how we load an

27245
04:24:30,150 --> 04:24:34,110
item we load its unique ID by
calling this get ID from event

27246
04:24:34,110 --> 04:24:41,970
params dot load, get ID from
event params. And we can pass

27247
04:24:42,000 --> 04:24:45,270
event dot params. That token ID

27248
04:24:46,800 --> 04:24:50,130
because an item bot event is
going to have a token ID and

27249
04:24:50,160 --> 04:24:55,530
event that params.nf T address.
Now I know we probably should

27250
04:24:55,530 --> 04:24:58,530
have done handle item listed
first but we're doing item bot

27251
04:24:58,530 --> 04:25:02,340
first. Since we're buying an
item, we probably will also have

27252
04:25:02,400 --> 04:25:05,070
an active item as well, right?
We haven't made yet an item

27253
04:25:05,070 --> 04:25:07,440
listed. But this is going to be
similar to what we did with

27254
04:25:07,440 --> 04:25:11,340
Morales. So we know that every
time we live Certain items will

27255
04:25:11,340 --> 04:25:16,950
also list an active item. So
we'll say let active item equals

27256
04:25:17,550 --> 04:25:21,960
active item that load. And we're
going to do this exact same

27257
04:25:21,960 --> 04:25:25,170
thing. So I'm just going to copy
paste it into here. And even

27258
04:25:25,170 --> 04:25:28,530
though these are going to have
the exact same ID, it doesn't

27259
04:25:28,530 --> 04:25:33,000
matter because they're the same
ID across different types. Now

27260
04:25:33,000 --> 04:25:37,920
we're gonna say, if there is no
item bot, we'll say item bot

27261
04:25:38,490 --> 04:25:45,750
equals a new item bot object.
And we'll give it an ID, which

27262
04:25:45,780 --> 04:25:49,440
is going to be exactly our ID
giving parameter here, get ID

27263
04:25:49,440 --> 04:25:52,140
from events, and pass that
there. So we're going to create

27264
04:25:52,140 --> 04:25:55,110
a new item bought here. And now
we're going to update all its

27265
04:25:55,110 --> 04:25:59,370
parameters. So back in our
schema dot graph, QL. An item

27266
04:25:59,370 --> 04:26:03,870
bought has an ID, buyer address,
token ID and price. So we're

27267
04:26:03,870 --> 04:26:10,200
gonna say, item bought, that
buyer equals event dot params

27268
04:26:10,290 --> 04:26:18,030
dot buyer, item bought.nf T
address equals event.params.nf T

27269
04:26:18,030 --> 04:26:25,050
address, item bot, dot token ID
equals event dot params dot

27270
04:26:25,050 --> 04:26:28,980
token ID. And that looks good.
And our active item will be from

27271
04:26:28,980 --> 04:26:32,250
item listed, and item listed
should give it all these

27272
04:26:32,250 --> 04:26:35,490
parameters, except for it won't
have a buyer. So we just need to

27273
04:26:35,490 --> 04:26:39,660
update the buyer on our active
item. So we'll say active item,

27274
04:26:40,470 --> 04:26:43,230
dot buyer, we'll do a little
exclamation mark. This is some

27275
04:26:43,230 --> 04:26:46,290
TypeScript stuff, saying we will
have an active item. Don't worry

27276
04:26:46,290 --> 04:26:48,750
too much about it if you're
unfamiliar with TypeScript. And

27277
04:26:48,750 --> 04:26:53,160
we'll say that equals event dot
params dot buyer. And now

27278
04:26:53,190 --> 04:26:58,680
similar to Morales, we're gonna
do item bot dot save and active

27279
04:26:58,680 --> 04:27:02,250
item with an exclamation mark
again, that save and this is how

27280
04:27:02,250 --> 04:27:06,240
we're going to save this item
bought event as an object in our

27281
04:27:06,240 --> 04:27:09,570
the Graph Protocol. And also,
we're going to update our active

27282
04:27:09,570 --> 04:27:13,260
item. So this is our full
function of handle item bought.

27283
04:27:13,620 --> 04:27:16,800
Whenever somebody buys an item,
we update a new item bought

27284
04:27:16,800 --> 04:27:21,810
object, and we update our active
item to be a new buyer, we're

27285
04:27:21,810 --> 04:27:24,690
not going to delete it from our
active items list, we're just

27286
04:27:24,690 --> 04:27:27,360
going to update it with a new
buyer. And we'll just say if it

27287
04:27:27,360 --> 04:27:30,870
has a buyer, that means it's
been bought. If it doesn't have

27288
04:27:30,870 --> 04:27:34,320
a buyer, that means it's still
on the market. Awesome. So now

27289
04:27:34,320 --> 04:27:37,380
that we've done our handle item
bot, let's now do our handle

27290
04:27:37,410 --> 04:27:39,960
item listed, which will
hopefully make our handle item

27291
04:27:39,960 --> 04:27:42,990
bot a little bit easier to
understand. So for handle item

27292
04:27:42,990 --> 04:27:45,450
listed, we're going to do the
same piece here. So we're going

27293
04:27:45,450 --> 04:27:51,900
to say let item listed equals
item listed dot load. And we're

27294
04:27:51,900 --> 04:27:55,110
gonna do the exact same thing as
what we did for all these will

27295
04:27:55,110 --> 04:27:59,760
do get ID from event params.
Like so, get a different event

27296
04:27:59,760 --> 04:28:03,660
params. And we're gonna say let
active item. And this line is

27297
04:28:03,660 --> 04:28:07,110
going to be exactly the same as
up here. So I'm just going to

27298
04:28:07,110 --> 04:28:11,040
copy paste. So we're saying,
okay, great, grab our item

27299
04:28:11,040 --> 04:28:14,640
listed, and grab our active
item, see if those objects

27300
04:28:14,670 --> 04:28:18,120
already exist. I will say if
there is no item listed, which

27301
04:28:18,120 --> 04:28:20,220
there shouldn't be, we'll go
ahead and create a new one,

27302
04:28:20,520 --> 04:28:21,630
we'll say item listed

27303
04:28:23,490 --> 04:28:28,920
equals new item listed. And its
ID is going to be from this

27304
04:28:28,920 --> 04:28:32,880
function that we created are
unique IDs. Now, unlike what we

27305
04:28:32,880 --> 04:28:36,930
did above, we're also going to
say, if there is no active item,

27306
04:28:37,110 --> 04:28:39,480
then we're going to create a new
active item, right? Because

27307
04:28:39,480 --> 04:28:42,660
we're listing an item, it
shouldn't be an active item. Now

27308
04:28:42,660 --> 04:28:44,430
this functionality is going to
make a lot more sense here,

27309
04:28:44,430 --> 04:28:47,850
right? Because if we're updating
the price of an item, active

27310
04:28:47,850 --> 04:28:51,720
item will already exist. If it's
a brand new listing, though,

27311
04:28:51,990 --> 04:28:55,410
active item will not exist. So
we'll say okay, if it doesn't

27312
04:28:55,410 --> 04:28:58,320
exist, okay, that means it's a
brand new listing, we'll say

27313
04:28:58,320 --> 04:29:03,510
item listed equals new item
listed, and then we'll give it

27314
04:29:03,510 --> 04:29:08,700
an ID. That's the same ID
methodology, paste that in. So

27315
04:29:08,700 --> 04:29:12,990
now all we got to do is update
these new objects. So I will say

27316
04:29:13,020 --> 04:29:19,380
item listed that seller equals
event dot params dot seller. And

27317
04:29:19,380 --> 04:29:22,470
I'm just going to copy paste
this line. Because this is just

27318
04:29:22,470 --> 04:29:27,540
gonna be active item dot seller
now. Oops, see me and then it'll

27319
04:29:27,540 --> 04:29:31,200
make this active item. active
item instead of item listed. And

27320
04:29:31,200 --> 04:29:33,810
what else comes with item
listed? Well, let's go to the

27321
04:29:33,810 --> 04:29:38,700
schema item listed has an NFT
address, token ID and a price.

27322
04:29:38,820 --> 04:29:44,700
So okay, so let's add those.
item listed dot NFT address

27323
04:29:45,210 --> 04:29:50,610
equals event.params.nf T
address. Copy paste this line

27324
04:29:50,640 --> 04:29:55,650
because it's gonna be the be the
exact same for active item. Now

27325
04:29:55,740 --> 04:30:01,440
item listed that token ID equals
event dot params dot token ID.

27326
04:30:02,040 --> 04:30:07,680
Copy paste this line. Same thing
for active item. Item listed dot

27327
04:30:07,680 --> 04:30:12,870
price equals event dot params
dot At price, copy, paste this

27328
04:30:12,870 --> 04:30:17,400
line for active item. And then
we just say those two. So item

27329
04:30:17,400 --> 04:30:24,930
listed that save active item.
Save. So in our protocol here,

27330
04:30:25,020 --> 04:30:28,890
if it's already been, if there
already is an active item, then

27331
04:30:28,890 --> 04:30:31,650
we just go ahead and we get that
active item. This would be for a

27332
04:30:31,650 --> 04:30:35,550
listing that we're updating. If
not, we make a new one. We

27333
04:30:35,580 --> 04:30:38,700
update it with whatever came in
through the event. And then we

27334
04:30:38,700 --> 04:30:42,330
save it to our graph protocol.
Okay, perfect. Now we only have

27335
04:30:42,330 --> 04:30:45,660
one left, item cancelled. So
let's figure out how to do item

27336
04:30:45,660 --> 04:30:48,690
cancelled, it's going to look
really similar to item bought.

27337
04:30:48,720 --> 04:30:55,620
So we'll say let item cancelled
equals item cancelled that load.

27338
04:30:55,860 --> 04:30:58,920
Again, we're going to do this
exact same Id get our that we're

27339
04:30:58,920 --> 04:31:03,480
doing for everything, we'll say
let active item equals, and I'm

27340
04:31:03,480 --> 04:31:08,430
going to zoom out a little bit
less active item equals active

27341
04:31:08,460 --> 04:31:14,790
item dot load. Or do this exact
same thing here. Boom. And then

27342
04:31:14,790 --> 04:31:20,190
we're gonna say, if not item
cancelled, which there shouldn't

27343
04:31:20,190 --> 04:31:22,680
be because this should be the
only item canceled event here.

27344
04:31:23,340 --> 04:31:30,030
We'll say item cancelled, equals
new item cancelled. And we're

27345
04:31:30,030 --> 04:31:33,810
gonna give it an ID using the
same ID methodology we've been

27346
04:31:33,810 --> 04:31:36,600
using. Now this is going to look
a little bit different. We're

27347
04:31:36,600 --> 04:31:41,310
gonna say item canceled, that
seller equals event dot params

27348
04:31:41,340 --> 04:31:46,830
dot seller. So far, so good.
Item canceled dot NFT address

27349
04:31:47,520 --> 04:31:52,680
equals event dot params dot NFT
Address item canceled dot token

27350
04:31:52,680 --> 04:31:58,230
ID equals event dot params dot
token ID. And then finally, we

27351
04:31:58,230 --> 04:32:00,990
are going to change the active
item a little bit different than

27352
04:32:00,990 --> 04:32:04,560
what we've seen. active item
exclamation mark again, ignore

27353
04:32:04,560 --> 04:32:08,040
if you're confused by that dot
buyer. And we're going to update

27354
04:32:08,040 --> 04:32:12,570
the buyer to equal address dot
from string.

27355
04:32:13,830 --> 04:32:16,710
We're going to give it what's
called the Dead address. And

27356
04:32:16,710 --> 04:32:22,170
that's this right here.
0x 1-234-567-8910 1112 1314

27357
04:32:22,170 --> 04:32:25,860
producing 718 1920 21 to two to
three to 45 to 67 to

27358
04:32:25,860 --> 04:32:33,870
8930 3130 230-334-3536 zeros
lowercase d, uppercase E,

27359
04:32:34,050 --> 04:32:38,730
lowercase A uppercase D, this is
known as the dead address. And

27360
04:32:38,730 --> 04:32:41,910
this is how we're going to
decide if an item is still on

27361
04:32:41,910 --> 04:32:45,330
the marketplace or not. Or if an
item has been bought or not. If

27362
04:32:45,330 --> 04:32:49,320
we have the dead address as its
buyer, that's going to mean that

27363
04:32:49,320 --> 04:32:51,900
the item has been cancelled. And
that's how we are going to be

27364
04:32:51,900 --> 04:32:54,810
able to tell that an item is on
the marketplace or not dead

27365
04:32:54,810 --> 04:32:57,960
address means it's been
cancelled. An empty address,

27366
04:32:58,050 --> 04:33:01,200
which is what will happen for
handle item listed means it's on

27367
04:33:01,200 --> 04:33:05,070
the market. And an actual real
address means that it's actually

27368
04:33:05,070 --> 04:33:07,170
been bought by somebody. So the
way we can tell if it's on the

27369
04:33:07,170 --> 04:33:12,060
market is it's 0x 0000000.
Because the data address is

27370
04:33:12,060 --> 04:33:15,780
obviously going to be different
than than all zeros. The data

27371
04:33:15,780 --> 04:33:18,390
address is a commonly used
address kind of as a burner

27372
04:33:18,390 --> 04:33:22,230
address that nobody owns, then
we can just say, item cancelled

27373
04:33:22,980 --> 04:33:28,740
that save an active item that
say active item, exclamation

27374
04:33:28,740 --> 04:33:33,000
mark dot save and perfect. Our
mapping file is now completed.

27375
04:33:33,330 --> 04:33:36,540
We now have three different
functions to define how to

27376
04:33:36,540 --> 04:33:39,840
handle when items are bought
events, how to handle when items

27377
04:33:39,840 --> 04:33:43,020
are cancelled event and item
listed events. And if you're

27378
04:33:43,020 --> 04:33:46,440
confused, remember all the code
for this is available on this

27379
04:33:46,470 --> 04:33:49,530
the graph section of my GitHub.
So you can just follow along

27380
04:33:49,530 --> 04:33:52,680
with the code here, if you ever
get lost or need help. And with

27381
04:33:52,680 --> 04:33:55,860
that, we're almost ready to tell
our subgraph to start listening

27382
04:33:55,860 --> 04:33:58,980
to our contracts, there's just
at least one more thing that we

27383
04:33:58,980 --> 04:34:03,240
want to do. So in our sub graph
dot Yamo, we'll see source

27384
04:34:03,270 --> 04:34:06,600
address blah, blah, blah, this
is telling us to start indexing

27385
04:34:06,600 --> 04:34:10,260
events since the beginning of
Aetherium. Now we don't really

27386
04:34:10,260 --> 04:34:13,710
want it to do that, because it
will take a really long time, we

27387
04:34:13,710 --> 04:34:15,900
want to tell our subgraph Hey,
you don't just start from

27388
04:34:15,900 --> 04:34:19,380
beginning of time, you just need
to start from right before our

27389
04:34:19,380 --> 04:34:22,170
contract was deployed. So we can
add what's called our start

27390
04:34:22,170 --> 04:34:26,460
block to tell it what block
number to start deploying. Now

27391
04:34:26,460 --> 04:34:30,300
if we have our address, which we
do right here, we can copy it,

27392
04:34:30,540 --> 04:34:35,130
we can paste it on to the rink
fee, ether scan, paste it in

27393
04:34:35,130 --> 04:34:38,280
here, or really any block
Explorer, and we'll see what

27394
04:34:38,280 --> 04:34:42,300
block number our contract was
deployed. And it looks like it

27395
04:34:42,300 --> 04:34:46,860
was this block. So I'm going to
copy that address, go back to my

27396
04:34:46,860 --> 04:34:50,220
code and say starting block,
it's going to be right here.

27397
04:34:50,550 --> 04:34:55,020
Starting block is going to be
when it was deployed, minus one.

27398
04:34:55,050 --> 04:34:58,680
So we're gonna go right before
we deployed our contract, we're

27399
04:34:58,680 --> 04:35:02,640
going to start reading any event
that is indexed from it. Now if

27400
04:35:02,640 --> 04:35:05,160
you just deployed this, it might
not have any events in it at

27401
04:35:05,160 --> 04:35:08,070
all, which we're going to fix in
just a minute so don't worry,

27402
04:35:08,100 --> 04:35:10,530
but with that all the
instructions for how to build

27403
04:35:10,560 --> 04:35:14,010
Our sub graphs are ready to be
deployed to the graph, start our

27404
04:35:14,010 --> 04:35:16,650
indexing and start working with
our instructions in a

27405
04:35:16,650 --> 04:35:22,620
decentralized context. So what
we can do now is back in the

27406
04:35:22,620 --> 04:35:27,390
graph, we actually have the auth
and deploy code right here, we

27407
04:35:27,390 --> 04:35:32,010
can copy this, this graph auth
dash dash studio, which is our

27408
04:35:32,040 --> 04:35:35,400
deploy key on how to deploy. And
we can run this in our code

27409
04:35:35,400 --> 04:35:39,240
editor. So we're going to paste
that in here, graph off dash

27410
04:35:39,240 --> 04:35:43,380
studio, hit enter. And we're
gonna say deploy key set for the

27411
04:35:43,380 --> 04:35:46,440
graph. So this is just setting
us up so that whenever we push

27412
04:35:46,440 --> 04:35:49,980
our code, it's going to push it
to this sub graph configuration

27413
04:35:49,980 --> 04:35:52,950
that we've made on their site to
help us deploy automatically.

27414
04:35:52,980 --> 04:35:55,860
Now we can do, we don't need to
enter the subgraph, because

27415
04:35:55,860 --> 04:35:59,280
we've already moved stuff down,
is we'll build the sub graph,

27416
04:35:59,400 --> 04:36:03,390
we'll run graph code Gen, we can
just run graph kojem,

27417
04:36:04,830 --> 04:36:07,950
which again, is just going to
make sure our schema dot Graph

27418
04:36:07,950 --> 04:36:10,770
QL looks good. And then we're
going to run our graph build.

27419
04:36:11,340 --> 04:36:15,240
And this graph build command is
going to compile and run all of

27420
04:36:15,240 --> 04:36:18,660
our sub graph stuff, everything
in mapping that JSON all our

27421
04:36:18,660 --> 04:36:21,450
generated code. And it's going
to put this into a real build

27422
04:36:21,450 --> 04:36:24,390
folder, the generated folder has
kind of like a pseudo build

27423
04:36:24,390 --> 04:36:27,510
folder. And then we have a real
build folder. So the generated

27424
04:36:27,510 --> 04:36:30,810
is just to build some typings
for our TypeScript. And it's

27425
04:36:30,810 --> 04:36:33,780
this build folder, this real
build folder, is what we're

27426
04:36:33,780 --> 04:36:36,630
going to actually be deploying
and sending to the graph. And we

27427
04:36:36,630 --> 04:36:40,230
can actually deploy our
subgraph. Now, with graph deploy

27428
04:36:40,290 --> 04:36:43,140
dash s studio. And if the
marketplace, which we're going

27429
04:36:43,140 --> 04:36:46,290
to run right now, now is going
to give us a version label

27430
04:36:46,290 --> 04:36:51,000
option, which we're going to
give it the 0.0 point one, since

27431
04:36:51,000 --> 04:36:54,840
this is our first version, and
it goes ahead and starts

27432
04:36:54,840 --> 04:36:58,680
deploying it to the graph, we
also get to upload our sub graph

27433
04:36:58,680 --> 04:37:02,340
to IPFS. And we have a little
hash right here for IPFS for a

27434
04:37:02,340 --> 04:37:05,970
subgraph that we could look at.
But now if you're successful, we

27435
04:37:05,970 --> 04:37:09,150
now have this build completed
thing. And we have these sub

27436
04:37:09,150 --> 04:37:12,540
graph endpoints for queries and
subscriptions. So we can

27437
04:37:12,540 --> 04:37:16,500
actually start querying and
subscribing to our sub graph.

27438
04:37:16,530 --> 04:37:20,760
But if we go back to our site
here now and we hit refresh, we

27439
04:37:20,760 --> 04:37:24,360
can now see status deployed, we
can see that we're sinking. And

27440
04:37:24,360 --> 04:37:28,380
now we have some nodes that are
listening for our events to be

27441
04:37:28,380 --> 04:37:31,140
emitted here, which is
incredibly exciting. We can go

27442
04:37:31,140 --> 04:37:34,680
to logs to see if anything went
wrong. And right now it's just

27443
04:37:34,710 --> 04:37:37,620
indexing, it's listening. It's
going through all the different

27444
04:37:37,620 --> 04:37:40,770
blocks in the blockchain,
listening for our events. And

27445
04:37:40,770 --> 04:37:43,950
then we have a playground here
where we can run some queries to

27446
04:37:43,950 --> 04:37:46,860
see different events and the
different responses from our

27447
04:37:46,860 --> 04:37:50,220
Graph QL, which right now, it's
totally blank, because we

27448
04:37:50,220 --> 04:37:53,670
haven't done anything yet. So
once again, let's pull up our

27449
04:37:53,700 --> 04:37:57,060
hard hat and ft marketplace
code, or open it up in a new

27450
04:37:57,060 --> 04:38:00,690
terminal, whatever you want to
do. And let's go ahead, and

27451
04:38:00,690 --> 04:38:05,400
let's run our mminton list
script. But for rink B, so we'll

27452
04:38:05,400 --> 04:38:11,730
do yarn, hard hat, run scripts,
mint, and list item dash dash

27453
04:38:11,730 --> 04:38:16,020
network Rinkeby. So we're going
to mint an NF T, right, this is

27454
04:38:16,020 --> 04:38:17,820
going to be to transaction, so
we're gonna have to wait a

27455
04:38:17,820 --> 04:38:20,430
little bit, and then we're going
to approve the NFT. And then

27456
04:38:20,430 --> 04:38:22,830
we're going to list it on our
marketplace. And once it's

27457
04:38:22,830 --> 04:38:26,310
listed, it's going to emit an
item listed event. And we should

27458
04:38:26,310 --> 04:38:30,750
see now we have an active item
and an item listed data in our

27459
04:38:30,750 --> 04:38:34,500
Graph QL. Now you can learn more
about now what you see here on

27460
04:38:34,500 --> 04:38:37,620
the left hand side is what's
known as a Graph QL query. Now,

27461
04:38:37,620 --> 04:38:39,630
we're not going to go over how
to do these, but I'm going to

27462
04:38:39,630 --> 04:38:42,150
leave some links in the GitHub
repository. If you want to learn

27463
04:38:42,150 --> 04:38:44,760
how to do more of these queries,
these are going to be similar to

27464
04:38:44,760 --> 04:38:47,250
what we saw with Morales. But
instead of them being kind of

27465
04:38:47,250 --> 04:38:50,730
regular table lookups. They're
in Graph QL syntax, and the

27466
04:38:50,730 --> 04:38:53,820
results of our query, end up
being over here, we can see more

27467
04:38:53,820 --> 04:38:56,460
information about our schema all
the way to the right over here.

27468
04:38:56,520 --> 04:39:00,690
But if we look at our code, now,
we've made the NFT approved it

27469
04:39:00,720 --> 04:39:04,410
we've listed it on our
marketplace. So now if we go

27470
04:39:04,410 --> 04:39:09,570
back to the graph, and we run
this query, and we do a little

27471
04:39:09,570 --> 04:39:12,360
refresh on our NFT marketplace,
we might have to wait a few

27472
04:39:12,360 --> 04:39:15,810
minutes for the graph to index
these new blocks. But in our

27473
04:39:15,810 --> 04:39:19,230
playground, we should see the
show up as a query. If you don't

27474
04:39:19,260 --> 04:39:22,860
automatically get these you can
pause the video to write these

27475
04:39:22,860 --> 04:39:26,880
into your Graph QL playground,
right? So after a few minutes,

27476
04:39:27,240 --> 04:39:30,780
refresh on ether scan, I can see
that list item transaction has

27477
04:39:30,780 --> 04:39:34,620
gone through. This means we've
emitted a new event. So if I

27478
04:39:34,620 --> 04:39:38,400
come back to my playground, and
I hit play here, oh my goodness,

27479
04:39:38,430 --> 04:39:42,210
we can see we have active items.
And we see we have item listed.

27480
04:39:42,510 --> 04:39:46,320
This is fantastic. That means in
a decentralized context, we have

27481
04:39:46,320 --> 04:39:49,980
a off chain service that is
indexing our events for our

27482
04:39:49,980 --> 04:39:52,860
contract so that we can update
our front end and we can update

27483
04:39:52,860 --> 04:39:56,160
people in a decentralized way.
This is so exciting.

27484
04:39:59,040 --> 04:40:01,950
Awesome, so now that we have
this all set up, we can finally

27485
04:40:01,950 --> 04:40:07,560
go back to our next JS project
or next Jas NFT marketplace the

27486
04:40:07,560 --> 04:40:11,610
graph FCC. The reason we did all
this is because right Now in our

27487
04:40:11,610 --> 04:40:15,510
code base for our next Jas NFT
Marketplace application, we're

27488
04:40:15,510 --> 04:40:18,450
reading from a Morales database,
which we're not going to do

27489
04:40:18,450 --> 04:40:21,600
anymore. Instead of reading from
a Morales database, we're going

27490
04:40:21,600 --> 04:40:24,960
to read from the graph, let's go
ahead and learn how to update

27491
04:40:24,960 --> 04:40:29,160
our code our index dot j, s to
read from the graph instead. So

27492
04:40:29,220 --> 04:40:31,830
to highlight this, to show this,
we're actually going to create a

27493
04:40:31,830 --> 04:40:34,980
new page, a new file, and we're
just going to call it graph,

27494
04:40:35,490 --> 04:40:39,660
example, dot j, s. And we're
just gonna make this a really

27495
04:40:39,660 --> 04:40:43,770
minimalistic page to show you
how to do a graph query. So

27496
04:40:43,800 --> 04:40:49,650
similar to index dot j, s, we're
gonna do export default graph

27497
04:40:49,680 --> 04:40:53,760
example. It's going to be a
function, or default function,

27498
04:40:54,000 --> 04:40:57,000
graph example. And we're gonna
use this tool called Apollo

27499
04:40:57,000 --> 04:41:00,660
client, copy, paste it over. And
we're going to add it with yarn,

27500
04:41:00,660 --> 04:41:07,710
add dash dash dev at a P O ll O,
slash, client, or excuse me, not

27501
04:41:07,710 --> 04:41:11,250
Dev, because we do need this on
the front end. So yarn add at

27502
04:41:11,250 --> 04:41:16,560
Apollo slash client. Oh, sorry,
we also need to do yarn, add

27503
04:41:16,560 --> 04:41:20,190
Graph QL, we need to add both of
those. And it's this Apollo

27504
04:41:20,190 --> 04:41:23,670
slash client, which is how we're
going to make queries to our

27505
04:41:23,910 --> 04:41:28,620
newly created graph. QL. So
we're gonna say import the use

27506
04:41:28,620 --> 04:41:34,680
query hook, from this package we
just installed from at a P, O,

27507
04:41:34,740 --> 04:41:39,960
ll o slash client. And we'll
also import G QL. So to create a

27508
04:41:39,960 --> 04:41:47,670
new query, we'll say const, get
active item equals g QL. And

27509
04:41:47,670 --> 04:41:51,600
we'll add this backtick here.
And we'll add all of our Graph

27510
04:41:51,600 --> 04:41:54,810
QL stuff in here, this is gonna
be equivalent to this, this is

27511
04:41:54,810 --> 04:41:57,900
Graph QL. Syntax. And we're
gonna be putting this Graph QL

27512
04:41:57,900 --> 04:42:01,860
syntax into our code base here.
But we only want to get the

27513
04:42:01,860 --> 04:42:04,830
active items. So how are we
going to get the active items?

27514
04:42:04,890 --> 04:42:08,100
Well, we can actually build it
over here on our playground

27515
04:42:08,100 --> 04:42:12,420
first, and then add it to our
code base. So we'll say we want

27516
04:42:12,420 --> 04:42:19,050
to grab the active items, we'll
grab the first five, and then

27517
04:42:19,050 --> 04:42:28,500
we'll say where the buyer is
going to be 0x 12345678. We're

27518
04:42:28,500 --> 04:42:31,380
saying where the buyer is empty.
So we're grabbing the active

27519
04:42:31,380 --> 04:42:35,190
items where there is no buyer,
and then we're going to do and

27520
04:42:35,190 --> 04:42:42,990
then we're going to get the ID,
the buyer, the seller, the NFT

27521
04:42:42,990 --> 04:42:51,210
address, token, ID and the price
from that. And if we hit run, we

27522
04:42:51,210 --> 04:42:55,320
get our active item here. So we
see here, the buyer is this

27523
04:42:55,350 --> 04:43:02,850
exact 0x 12345678 Because it
gets defaulted to zero when

27524
04:43:02,850 --> 04:43:05,700
there is no buyer. And this is
why for item cancelled, we

27525
04:43:05,700 --> 04:43:08,760
updated the buyer to be that
dead address. So if it's bought,

27526
04:43:08,970 --> 04:43:11,580
it won't be active anymore. And
if it's cancelled, it also won't

27527
04:43:11,580 --> 04:43:15,720
be active anymore. Now we can
copy this query and paste it

27528
04:43:16,050 --> 04:43:21,000
into our code. And now we have a
Graph QL query that we can use

27529
04:43:21,090 --> 04:43:24,390
for our graph example. Now in
our graph example, we'll use

27530
04:43:24,390 --> 04:43:27,930
this query with this use query
hook. So in export default

27531
04:43:27,930 --> 04:43:31,800
function, graph example, we can
say const. And it comes with a

27532
04:43:31,800 --> 04:43:35,910
whole bunch of stuff like
loading error, and then the data

27533
04:43:35,910 --> 04:43:41,310
returned equals, use query. And
then we'll just pass it this Get

27534
04:43:41,310 --> 04:43:45,420
active item, or get active
items, let's put an S on it, get

27535
04:43:45,420 --> 04:43:50,160
active items. And then we can
just return return a little div.

27536
04:43:51,420 --> 04:43:54,150
And we'll say hi in the div, and
then we'll just do console dot

27537
04:43:54,150 --> 04:43:59,100
log data. And then now we'll go
back to our app.js, where we're

27538
04:43:59,100 --> 04:44:02,010
wrapping everything in a Morales
provider, we also need to wrap

27539
04:44:02,010 --> 04:44:05,040
everything in an Apollo
provider. And we need to

27540
04:44:05,040 --> 04:44:08,580
initialize it kind of similar to
how we initialize connecting to

27541
04:44:08,610 --> 04:44:11,370
our morale server, but we're
going to initialize connecting

27542
04:44:11,370 --> 04:44:18,450
to our Graph QL. So we're gonna
say import a P O ll o provider,

27543
04:44:18,960 --> 04:44:29,550
a P O ll o client, and in mem
ory, cache from at a P O ll o

27544
04:44:29,550 --> 04:44:33,180
slash client, like that, and
then we'll have to initialize

27545
04:44:33,180 --> 04:44:36,600
this so we can delete the morale
stuff. We'll initialize this

27546
04:44:36,600 --> 04:44:43,380
client by saying const client
equals new a P O LL. O client,

27547
04:44:43,560 --> 04:44:46,470
and we'll give it the parameters
here. And you can find this all

27548
04:44:46,470 --> 04:44:49,590
in the Apollo client
documentation will say there's

27549
04:44:49,590 --> 04:44:52,710
going to be a cache to help when
we do refreshes and stuff we'll

27550
04:44:52,710 --> 04:44:54,180
say new in

27551
04:44:55,770 --> 04:45:01,170
memory cache, and we'll say
comma URI, a que where we're

27552
04:45:01,170 --> 04:45:03,660
going to be connecting. And this
is where we're going to add the

27553
04:45:03,660 --> 04:45:08,130
API for our sub graph. So if we
go back to details, we can see

27554
04:45:08,130 --> 04:45:12,180
temporary query URL and this is
a rate limited temporary query,

27555
04:45:12,270 --> 04:45:15,540
because this is just a test net,
and we're going to copy this, go

27556
04:45:15,540 --> 04:45:17,970
back to our code. And we're just
going to paste it in here. So

27557
04:45:17,970 --> 04:45:21,060
whatever you have for temporary
query URL, and your sub graph

27558
04:45:21,060 --> 04:45:24,120
studio, that's where you're
gonna paste in here. Now, this

27559
04:45:24,150 --> 04:45:28,740
client tells our Graph QL, where
it should be making those

27560
04:45:28,740 --> 04:45:31,530
queries. And we're gonna make it
to here. Now, this starts with

27561
04:45:31,530 --> 04:45:35,550
HTTPS. So is this centralized?
Yes, because we are directly

27562
04:45:35,550 --> 04:45:40,050
calling the graph website.
However, all the data is still

27563
04:45:40,050 --> 04:45:43,560
gonna be stored in this
decentralized graph indexer. And

27564
04:45:43,560 --> 04:45:46,140
kind of similar to what we did
with IPFS, we're doing this kind

27565
04:45:46,140 --> 04:45:49,410
of as a gateway to make it a lot
easier for us to connect and

27566
04:45:49,410 --> 04:45:53,370
read the data from the graph
studio. However, in the future,

27567
04:45:53,460 --> 04:45:55,980
as more protocols and more
browsers adopt the graph, and

27568
04:45:55,980 --> 04:45:59,970
IPFS, this will become a lot
easier inside of our Morales

27569
04:45:59,970 --> 04:46:03,480
provider, but outside of our
notifications provider, we're

27570
04:46:03,480 --> 04:46:10,020
gonna say a P O ll o provider,
and then client equals client.

27571
04:46:11,130 --> 04:46:15,300
And then we're going to copy the
closing tag, and put it around

27572
04:46:15,300 --> 04:46:18,450
the notification provider and
press Save. Now I'm gonna save

27573
04:46:18,450 --> 04:46:20,400
our front end, now we're going
to try to run our front end. And

27574
04:46:20,400 --> 04:46:22,530
we're gonna have to change some
stuff in here because it's going

27575
04:46:22,530 --> 04:46:27,720
to freak out. So we're gonna run
yarn Dev, for new front end. So

27576
04:46:27,720 --> 04:46:30,990
we're gonna go to our localhost
3000. And it's going to totally

27577
04:46:30,990 --> 04:46:33,300
freak out, because we still have
some morale stuff in here. And

27578
04:46:33,300 --> 04:46:36,180
that's totally okay. We, of
course, we don't need a hard hat

27579
04:46:36,180 --> 04:46:38,280
Node running. Because we're on a
test net, we don't need to be

27580
04:46:38,280 --> 04:46:41,460
synched with Morales, we don't
need to be doing any of that

27581
04:46:41,460 --> 04:46:44,010
stuff. Because we're working
with a test net, right now, it's

27582
04:46:44,010 --> 04:46:47,670
actually not freaking out, which
is great. But it shows obviously

27583
04:46:47,670 --> 04:46:50,670
nothing for recently listed. So
what we're going to do now is

27584
04:46:50,670 --> 04:46:56,130
we're gonna do slash, graph
example, and hit enter. And we

27585
04:46:56,130 --> 04:47:01,590
can see Hi, show up. But if we
go to inspect, and we go to

27586
04:47:01,740 --> 04:47:07,260
console, a console here, we can
see an object here of active

27587
04:47:07,260 --> 04:47:12,300
items, which is returned from
the graph with buyer ID, NFT,

27588
04:47:12,300 --> 04:47:15,060
address price and all this stuff
in the air. This is fantastic.

27589
04:47:15,420 --> 04:47:19,200
So okay, okay. Okay. So all we
have to do now is we just have

27590
04:47:19,200 --> 04:47:22,110
to update. So let's go ahead,
we'll kill our server. For now,

27591
04:47:22,500 --> 04:47:26,790
all we have to do is update,
instead of use mirallas query,

27592
04:47:27,330 --> 04:47:29,820
we're going to delete this. And
we're just going to query from

27593
04:47:29,880 --> 04:47:33,840
Apollo query from our Graph QL.
And everything else stays the

27594
04:47:33,840 --> 04:47:37,170
same, right? Because our NFT
box, and all the rest of the

27595
04:47:37,170 --> 04:47:40,680
code that we worked with, will
still work exactly the same. So

27596
04:47:40,680 --> 04:47:42,240
first, we just got to get our
address. So we're gonna say

27597
04:47:42,240 --> 04:47:46,260
import, same as Sell, sell NFT,
import the network mapping, so

27598
04:47:46,260 --> 04:47:48,930
I'm actually just going to copy
it. So we're going to import

27599
04:47:49,290 --> 04:47:52,740
network mapping from constants,
network mapping dot JSON. And

27600
04:47:52,740 --> 04:47:59,460
now we can say const.
Marketplace, address equals, and

27601
04:47:59,460 --> 04:48:01,770
we're going to get the exact
same way we did this and sell

27602
04:48:01,770 --> 04:48:05,280
NFT to, so we're going to grab
this line getting the chain

27603
04:48:05,280 --> 04:48:08,760
string, we'll paste that in
here, which means we're going to

27604
04:48:08,760 --> 04:48:12,780
need to get chain ID from user
Morales. And then we're gonna

27605
04:48:12,780 --> 04:48:15,420
get the marketplace address like
this. So we're going to copy

27606
04:48:15,420 --> 04:48:18,870
that line, paste it in here.
Okay, great. Now we have the

27607
04:48:18,870 --> 04:48:21,840
marketplace address. So now
we're just going to do const.

27608
04:48:23,310 --> 04:48:29,190
Loading error data, which we can
do listed. And if T is again,

27609
04:48:29,820 --> 04:48:35,820
equals, use query, and we can do
that get active items. So what

27610
04:48:35,820 --> 04:48:39,360
I'm going to do is I'm going to
create a new file and constants,

27611
04:48:39,570 --> 04:48:42,120
we're going to pass that get
active items thing in their new

27612
04:48:42,120 --> 04:48:46,560
file, we're just going to call
it sub graph queries, dot j, s.

27613
04:48:47,160 --> 04:48:53,160
And then here, we're gonna say
import G QL. From at a Apollo

27614
04:48:53,160 --> 04:48:59,940
slash client. And we'll say
const, get active items, equals

27615
04:49:00,390 --> 04:49:05,070
g QL backtick. And exactly what
we did in that great, let's go

27616
04:49:05,070 --> 04:49:07,920
back to the graph example, we'll
just copy that whole line

27617
04:49:07,920 --> 04:49:13,380
actually pasted in here. And now
we'll just do export default,

27618
04:49:14,160 --> 04:49:20,460
get active items. And we'll
import this query from sub graph

27619
04:49:20,460 --> 04:49:26,460
queries into our index dot j s.
So we'll say import, get active

27620
04:49:26,700 --> 04:49:31,860
queries are skimming apt get
active items from dot dot slash

27621
04:49:31,860 --> 04:49:37,020
constants slash sub graph
queries. And now in our use

27622
04:49:37,020 --> 04:49:41,070
query will pass Get active
items, which should return are

27623
04:49:41,070 --> 04:49:46,950
listed NF Ts. So now, we'll
change this from fetching listed

27624
04:49:46,950 --> 04:49:54,300
NF Ts to loading, loading, or we
don't have listed NF Ts. So if

27625
04:49:54,300 --> 04:49:58,350
it's loading or we don't have
listen if TS then do loading,

27626
04:49:58,800 --> 04:50:02,910
otherwise, we're going to do
another mapping, but the return

27627
04:50:02,940 --> 04:50:06,330
of the Graph QL is going to be a
little bit different. So instead

27628
04:50:06,330 --> 04:50:09,690
of listing MTS dot map, it's
going to be listed NF T's dot AQ

27629
04:50:10,260 --> 04:50:15,510
two have items, dot map and f t,
and then we're going to get

27630
04:50:15,510 --> 04:50:19,110
price. And if the address token
ID, we're not going to get

27631
04:50:19,110 --> 04:50:22,620
marketplace address, but we'll
get seller from NFT. And it's

27632
04:50:22,620 --> 04:50:25,170
not going to be returned with
attributes. So we can just do

27633
04:50:25,170 --> 04:50:29,130
console dot log NFT instead. And
then we just pass all that stuff

27634
04:50:29,130 --> 04:50:32,730
normally to, to that NFT box
exactly the way that we did

27635
04:50:32,730 --> 04:50:35,340
before. So really, we're all
we're doing is we're swapping

27636
04:50:35,340 --> 04:50:38,610
out the query methodology here,
price is going to be from price

27637
04:50:38,640 --> 04:50:41,280
price is going to be from the
query, and ft address is going

27638
04:50:41,280 --> 04:50:44,130
to be from the query token ID
from the query marketplace

27639
04:50:44,130 --> 04:50:46,140
address, that's also gonna be
slightly different, we're going

27640
04:50:46,140 --> 04:50:49,080
to get that from our own config
seller is going to be from the

27641
04:50:49,080 --> 04:50:52,590
query, and then the key is going
to be from the query as well. So

27642
04:50:52,590 --> 04:50:57,210
now if we save that, if we
restart our website, with yarn

27643
04:50:57,210 --> 04:51:00,450
Dev, and we go back to our
homepage, we should see

27644
04:51:00,480 --> 04:51:04,440
everything exactly the same,
except for the images being

27645
04:51:04,440 --> 04:51:08,730
pulled from the graph, instead
of being pulled from her Alice.

27646
04:51:08,940 --> 04:51:11,460
Let's go back to our front end,
we'll give it a nice refresh,

27647
04:51:11,580 --> 04:51:15,810
close out the console. And we'll
go to our homepage. And I forgot

27648
04:51:15,810 --> 04:51:21,810
to do use query. So let's import
use query, import, use query

27649
04:51:22,650 --> 04:51:27,870
from at a Paulo slash client.
Let's save and let's go back and

27650
04:51:27,870 --> 04:51:33,420
give that a refresh. And oh, my
goodness, we now have updated to

27651
04:51:33,420 --> 04:51:36,600
get our events from a
decentralized data structure.

27652
04:51:38,430 --> 04:51:43,380
That's freaking awesome. Now
let's talk about hosting this

27653
04:51:43,380 --> 04:51:47,040
real quickly, we are using the
image tag in here in our NFT

27654
04:51:47,040 --> 04:51:51,330
box, we are using the image tag
in here from next Jas, which

27655
04:51:51,330 --> 04:51:54,480
comes with some pre processing.
So it's a little hard to use on

27656
04:51:54,480 --> 04:51:57,990
IPFS. So we would need to update
the way we do images in order to

27657
04:51:57,990 --> 04:52:01,590
host this on IPFS. But we still
can do that. Some other options

27658
04:52:01,590 --> 04:52:04,920
we have actually are Morales, we
can actually even host our apps

27659
04:52:04,920 --> 04:52:08,100
on Morales, if we want. We can
also use things like for cell or

27660
04:52:08,100 --> 04:52:11,640
Netlify, or etc, or really any
other traditional centralized

27661
04:52:11,640 --> 04:52:14,730
hosting service. Now, if you
want to, I challenge you to

27662
04:52:14,730 --> 04:52:18,960
update this code to make it be
able to be hosted on IPFS. So

27663
04:52:18,960 --> 04:52:21,510
that you'll have an end to end
decentralized. And if the

27664
04:52:21,510 --> 04:52:24,300
marketplace first wanted to make
a PR to this code, so that it

27665
04:52:24,300 --> 04:52:28,140
can be successfully hosted
completely end to end on IPFS

27666
04:52:28,260 --> 04:52:31,950
wins and empty for me. But wow.
And with that we are done with

27667
04:52:31,950 --> 04:52:35,880
less than 15. This is an
absolutely monstrous

27668
04:52:35,880 --> 04:52:38,100
accomplishment. And if you
finish this, if you've

27669
04:52:38,100 --> 04:52:40,350
understood everything, if you've
gotten through everything so

27670
04:52:40,350 --> 04:52:43,710
far, you should feel incredibly
proud of yourself. Because this

27671
04:52:43,710 --> 04:52:46,950
is our last full stack section,
our front end section and you're

27672
04:52:46,950 --> 04:52:50,580
a full stack monster at this
point. huge congratulations, you

27673
04:52:50,580 --> 04:52:54,210
should be super, super, super
proud. And definitely take a

27674
04:52:54,210 --> 04:52:58,110
break, go get a coffee, and get
ready for the final stretch of

27675
04:52:58,110 --> 04:53:01,590
lessons 1617 and 18. Those are
gonna go by a little bit

27676
04:53:01,590 --> 04:53:04,800
quicker. I'm very excited for
you take a break, and I'll see

27677
04:53:04,800 --> 04:53:05,220
you there.

27678
04:53:13,980 --> 04:53:18,480
Right, welcome to Lesson Six
tene, where we're going to be

27679
04:53:18,480 --> 04:53:23,850
going into even more low level
code here. The hard hat upgrades

27680
04:53:23,880 --> 04:53:27,930
of course, per usual, our entire
GitHub repository is located

27681
04:53:27,930 --> 04:53:30,630
here. And additionally, we have
an optional video that you can

27682
04:53:30,630 --> 04:53:33,420
watch. If you want to learn
more, we're actually going to

27683
04:53:33,420 --> 04:53:36,300
watch a slice of that video that
explains upgradable smart

27684
04:53:36,300 --> 04:53:39,150
contracts. So let's jump in. Now
I'm editing this video much

27685
04:53:39,150 --> 04:53:42,540
later after I filmed that, hence
why I have a beard so I'll be

27686
04:53:42,540 --> 04:53:45,390
jumping in from time to time
updating some of the sections.

27687
04:53:45,870 --> 04:53:48,300
When deploying your smart
contracts on chain. We all know

27688
04:53:48,300 --> 04:53:51,270
that those smart contracts are
immutable or unchangeable. But

27689
04:53:51,270 --> 04:53:53,970
what if I told you that they
were immutable?

27690
04:53:55,500 --> 04:53:58,020
Well, technically, that wouldn't
be correct. However, smart

27691
04:53:58,020 --> 04:54:01,200
contracts actually can change
all the time. When people

27692
04:54:01,200 --> 04:54:04,200
transfer tokens when people
stake in a contract or really do

27693
04:54:04,200 --> 04:54:07,140
any type of functionality. Those
smart contracts have to update

27694
04:54:07,140 --> 04:54:09,600
their balances and update their
mappings and update their

27695
04:54:09,600 --> 04:54:12,780
variables to reflect this. The
reason that they're immutable is

27696
04:54:12,780 --> 04:54:15,630
that the logic itself never
changes and will be on chain

27697
04:54:15,630 --> 04:54:18,300
like that forever. So
technically, yes, once they are

27698
04:54:18,300 --> 04:54:20,520
deployed, they are immutable.
And this is actually one of the

27699
04:54:20,520 --> 04:54:22,590
major benefits of smart
contracts in the first place

27700
04:54:22,590 --> 04:54:25,290
that nobody can tamper with or
screw with our smart contracts

27701
04:54:25,290 --> 04:54:27,810
once we deploy them. However,
this can be an issue if, for

27702
04:54:27,810 --> 04:54:30,510
example, we want to upgrade our
smart contract or protocol to do

27703
04:54:30,510 --> 04:54:34,050
more things, or want to fix some
glaring bug or issue that we

27704
04:54:34,050 --> 04:54:37,110
have. Now even though we can't
change the specific code that's

27705
04:54:37,110 --> 04:54:39,480
been deployed to an address, we
can actually do a lot more than

27706
04:54:39,480 --> 04:54:41,640
you think. And in this video,
we're going to explain the

27707
04:54:41,640 --> 04:54:44,400
different methodologies behind
upgrading your smart contracts.

27708
04:54:44,610 --> 04:54:47,070
And then we're going to show you
how to do it with hard hat and

27709
04:54:47,070 --> 04:54:49,770
open Zeppelin huge shout out to
a lot of open Zeppelin and

27710
04:54:49,770 --> 04:54:52,800
trilobites articles that helped
me put this video together and a

27711
04:54:52,800 --> 04:54:55,680
number of other sources as well
links in the description. So

27712
04:54:55,680 --> 04:54:58,320
let's get to it. Now at first
glance, you might be thinking,

27713
04:54:59,190 --> 04:55:01,920
if you can upgrade your smart
contracts, then they're not

27714
04:55:01,950 --> 04:55:07,020
really immutable that in a way
you'd be right. So when

27715
04:55:07,020 --> 04:55:09,270
explaining kind of the different
philosophies and patterns that

27716
04:55:09,270 --> 04:55:12,360
we can use here, we do need to
keep Behind the philosophies and

27717
04:55:12,360 --> 04:55:15,030
decentralization implications
that each one of these patterns

27718
04:55:15,030 --> 04:55:17,430
have, as they do all have
different advantages and

27719
04:55:17,430 --> 04:55:21,210
disadvantages. And yes, some of
the disadvantages here are going

27720
04:55:21,210 --> 04:55:23,940
to affect the centrality. So we
need to keep that in mind. And

27721
04:55:23,940 --> 04:55:26,460
this is why it's so important
that before you go ahead and

27722
04:55:26,460 --> 04:55:29,340
jump in and start deploying
upgradable smart contracts, you

27723
04:55:29,340 --> 04:55:31,920
understand the trade offs. So
we're going to talk about three

27724
04:55:31,920 --> 04:55:34,770
different ways to upgrade your
smart contracts. The first one

27725
04:55:34,770 --> 04:55:38,520
being the not really slash
Paramor ties way to upgrade your

27726
04:55:38,520 --> 04:55:41,880
smart contracts, the social
migration method, and then the

27727
04:55:41,880 --> 04:55:44,520
method that you probably have
heard about, which is proxies,

27728
04:55:44,820 --> 04:55:47,310
which have a ton of
subcategories, like metamorphic

27729
04:55:47,310 --> 04:55:50,070
contracts, transparent
upgradable, proxies, and

27730
04:55:50,070 --> 04:55:53,070
universal upgradable proxies. So
let's talk about the not really

27731
04:55:53,070 --> 04:55:55,740
upgrading method, or the
parameterization method, or

27732
04:55:55,740 --> 04:55:58,590
whatever you want to call it.
This is the simplest way to

27733
04:55:58,590 --> 04:56:01,260
think about upgrading your smart
contracts. And it really isn't

27734
04:56:01,320 --> 04:56:04,290
upgrading our smart contracts.
Because we can't really change

27735
04:56:04,290 --> 04:56:06,720
the logic of the smart contract,
whatever logic that we've

27736
04:56:06,720 --> 04:56:09,540
written, is there, we also can
add new storage or state

27737
04:56:09,540 --> 04:56:12,840
variables. So this is really not
really upgrading. But it is

27738
04:56:12,870 --> 04:56:16,110
something to think about
upgrades is just parameterizing,

27739
04:56:16,140 --> 04:56:18,960
everything, whatever logic that
we've deployed is there, and

27740
04:56:18,960 --> 04:56:21,120
that's what we're interacting
with this function means we just

27741
04:56:21,120 --> 04:56:23,250
have a whole bunch of setter
functions. And we can update

27742
04:56:23,250 --> 04:56:26,610
certain parameters. Like maybe
we have a reward parameter that

27743
04:56:26,730 --> 04:56:30,630
gives out a token at 1 percent, every
year or something like that.

27744
04:56:30,990 --> 04:56:33,240
Maybe we have a setter function
that says, hey, update that to

27745
04:56:33,240 --> 04:56:36,990
2 percent, or update that to 4 percent. It's
just a setter function that

27746
04:56:36,990 --> 04:56:40,080
changes some variable. Now, the
advantages here, obviously, this

27747
04:56:40,080 --> 04:56:43,740
is really simple to implement.
The disadvantage is that if you

27748
04:56:43,740 --> 04:56:46,620
didn't think of some logic or
some functionality, the first

27749
04:56:46,620 --> 04:56:49,860
time you deployed their smart
contract, that's too bad, you're

27750
04:56:49,860 --> 04:56:52,920
stuck with it, you can't update
the logic or really update

27751
04:56:52,920 --> 04:56:55,770
anything with the
parameterization, aka, not

27752
04:56:55,770 --> 04:56:57,660
really method. And the other
thing you have to think about is

27753
04:56:57,930 --> 04:57:01,080
who the admins are, who has
access to these setter functions

27754
04:57:01,080 --> 04:57:04,950
to these updating functions. If
it's a single person, guess

27755
04:57:04,950 --> 04:57:07,440
what, you have a centralized
smart contract. Now of course,

27756
04:57:07,440 --> 04:57:09,870
you can add a governance
contract to be the admin

27757
04:57:09,870 --> 04:57:12,720
contract of your protocol. And
that would be a decentralized

27758
04:57:12,720 --> 04:57:14,940
way of doing this. So just keep
that in mind, you can do this

27759
04:57:14,940 --> 04:57:17,880
method just need a governance
protocol to do so another

27760
04:57:17,880 --> 04:57:20,340
example of this might be a
contract registry. And this is

27761
04:57:20,340 --> 04:57:23,100
something actually that early
versions of ABA used before you

27762
04:57:23,100 --> 04:57:25,800
call a function, you actually
check some contract registry

27763
04:57:25,800 --> 04:57:28,860
that is updated as a parameter
by somebody and you get routed

27764
04:57:28,860 --> 04:57:31,290
to the contract, and you do your
call there. Again, this really

27765
04:57:31,290 --> 04:57:33,690
doesn't allow us to have the
full functionality of upgrades

27766
04:57:33,690 --> 04:57:36,930
here, you can argue that this
registry is a mix of one of the

27767
04:57:36,930 --> 04:57:39,690
later versions. But for all
intents and purposes, this

27768
04:57:39,690 --> 04:57:41,550
doesn't really give us that
flexibility that we want for

27769
04:57:41,550 --> 04:57:44,400
upgrades. But some people might
even think that upgrading your

27770
04:57:44,400 --> 04:57:47,220
smart contract is ruining the
decent reality. And one of the

27771
04:57:47,220 --> 04:57:49,590
things that makes smart
contracts so potent is that they

27772
04:57:49,620 --> 04:57:51,930
are immutable, and that this is
one of the benefits that they

27773
04:57:51,930 --> 04:57:54,780
have. So there are some people
who think that you shouldn't add

27774
04:57:54,780 --> 04:57:57,840
any customization or any
upgradability, you should deploy

27775
04:57:57,840 --> 04:58:00,840
your contract. And then that's
it. trilobites has actually

27776
04:58:00,840 --> 04:58:04,080
argued that if you deploy your
contract, knowing that it can't

27777
04:58:04,080 --> 04:58:07,590
be changed later, you take a
little bit extra time, making

27778
04:58:07,590 --> 04:58:09,780
sure you get everything right.
And there are often less

27779
04:58:09,780 --> 04:58:12,750
security vulnerabilities because
you're just setting it

27780
04:58:12,750 --> 04:58:15,510
forgetting it and not looking at
it again. Now, if I wanted to

27781
04:58:15,510 --> 04:58:18,360
upgrade a smart contract with
this philosophy in mind, the

27782
04:58:18,360 --> 04:58:20,820
philosophy that I do want to
keep my smart contracts

27783
04:58:20,850 --> 04:58:24,660
immutable, we can instead use
the social migration method,

27784
04:58:24,660 --> 04:58:27,990
which I previously called the
Eat method. And now I think it's

27785
04:58:27,990 --> 04:58:30,420
less funny. So we're just gonna
stick with social migration, the

27786
04:58:30,420 --> 04:58:33,630
social eating method, or the
migration method is just when

27787
04:58:33,630 --> 04:58:36,330
you deploy your new contract,
not connected to the old

27788
04:58:36,330 --> 04:58:39,570
contract in any way. And by
social convention, you tell

27789
04:58:39,570 --> 04:58:42,660
everybody, hey, hey, this new
contract, this new one that we

27790
04:58:42,660 --> 04:58:45,390
just deployed? Yeah, this is the
real one now. And it's just by

27791
04:58:45,390 --> 04:58:49,020
convention of people migrating
over into using this new one,

27792
04:58:49,050 --> 04:58:51,750
that the upgrade is done, hence
my slang name of social yeet.

27793
04:58:51,750 --> 04:58:55,500
Because you use the first one
out of the way and move to the

27794
04:58:55,500 --> 04:58:56,130
second one.

27795
04:58:58,620 --> 04:59:01,890
I think I'm funny. Yeah, this
has the advantage of truly

27796
04:59:01,920 --> 04:59:04,890
always saying, Hey, this is our
immutable smart contract. And

27797
04:59:04,890 --> 04:59:07,230
this is our new one. This is
really the truest definition of

27798
04:59:07,230 --> 04:59:11,040
immutable, because since you
give it no way of being upgraded

27799
04:59:11,040 --> 04:59:15,060
in place, than if somebody calls
that contract in 50,000 years in

27800
04:59:15,060 --> 04:59:18,990
the future, it will respond
exactly the same. Another huge

27801
04:59:18,990 --> 04:59:21,330
disadvantage here is that you
have to have a totally new

27802
04:59:21,330 --> 04:59:25,020
contract address. So if you're
an ERC 20 token, for example,

27803
04:59:25,020 --> 04:59:28,470
you have to go convince all the
exchanges to list your new

27804
04:59:28,470 --> 04:59:31,410
contract address as the actual
address. Keep in mind that when

27805
04:59:31,410 --> 04:59:34,770
we do this, we do have to move
the state of the first one over

27806
04:59:34,770 --> 04:59:37,950
to the second one. So for
example, if you're an ERC token

27807
04:59:37,950 --> 04:59:41,070
moving to a new version of that
ERC token, you do, you have to

27808
04:59:41,070 --> 04:59:44,100
have a way to take all those
mappings from the first contract

27809
04:59:44,310 --> 04:59:46,680
and move it to the second one.
Obviously, there are ways to do

27810
04:59:46,680 --> 04:59:49,470
this, since everything is on
chain. But if you have a million

27811
04:59:49,470 --> 04:59:51,660
transfer calls, I don't want to
have to write the script that

27812
04:59:51,690 --> 04:59:53,940
updates everyone's balance and
figures out what everyone's

27813
04:59:53,940 --> 04:59:56,040
balance is just so I can migrate
to my new version of the

27814
04:59:56,040 --> 04:59:59,430
contract. So there's a ton of
social convention work here to

27815
04:59:59,430 --> 05:00:02,250
do. trilobites has actually
written a fantastic blog on

27816
05:00:02,280 --> 05:00:07,290
upgrading from a v1 to v2 or
etc. With this eat methodology

27817
05:00:07,320 --> 05:00:09,570
and they give a lot of steps for
moving your storage and your

27818
05:00:09,570 --> 05:00:12,120
state variables over To the new
contract. So link in the

27819
05:00:12,120 --> 05:00:14,010
description if you want to read
that. Now let's get to our big

27820
05:00:14,010 --> 05:00:16,890
ticket item. So in order to have
a really robust upgrading

27821
05:00:16,890 --> 05:00:20,130
mentality or philosophy, we need
to have some type of methodology

27822
05:00:20,130 --> 05:00:23,700
or framework that can update our
state, keep our contract address

27823
05:00:23,700 --> 05:00:27,420
and allow us to update any type
of logic in our smart contracts

27824
05:00:27,450 --> 05:00:30,780
in a easy way, which leads us to
our big ticket item is the

27825
05:00:30,780 --> 05:00:33,450
proxies. What's our big ticket
item?

27826
05:00:36,480 --> 05:00:40,920
proxies, proxies. Proxies are
the truest form of upgrades,

27827
05:00:41,130 --> 05:00:43,740
since a user can keep
interacting with the protocols

27828
05:00:43,770 --> 05:00:46,560
through these proxies, and not
even notice that anything

27829
05:00:46,560 --> 05:00:49,440
changed or even got updated.
Now, these are also the places

27830
05:00:49,470 --> 05:00:52,680
where you can screw up the
easiest. Proxies use a lot of

27831
05:00:52,680 --> 05:00:56,400
low level functionality. And the
main one being the delegate call

27832
05:00:56,400 --> 05:00:59,640
functionality. Delegate call is
a low level function where the

27833
05:00:59,640 --> 05:01:04,170
code in the target contract is
executed in the context of the

27834
05:01:04,170 --> 05:01:07,530
calling contract. And message
dot sender and message dot value

27835
05:01:07,530 --> 05:01:09,810
also don't change. So you
understand what delegate call

27836
05:01:09,810 --> 05:01:12,780
means. Now, right? Great. And in
English, this means if I

27837
05:01:12,810 --> 05:01:17,610
delegate call a function in
contract B from contract a, I

27838
05:01:17,610 --> 05:01:22,410
will do contracts B's logic in
contract a. So if contract B has

27839
05:01:22,410 --> 05:01:26,220
a function that says hey, store
this value in a variable up top,

27840
05:01:26,400 --> 05:01:30,210
I'm going to store that variable
in contract a, this is the

27841
05:01:30,210 --> 05:01:33,120
powerhouse. And this combined
with the fallback function

27842
05:01:33,360 --> 05:01:37,710
allows us to delegate all calls
through a proxy contract address

27843
05:01:38,070 --> 05:01:41,730
to some other contract, this
means that I can have one proxy

27844
05:01:41,730 --> 05:01:45,030
contract that will have the same
address forever. And I can just

27845
05:01:45,030 --> 05:01:49,260
point and route people to the
correct implementation contract

27846
05:01:49,260 --> 05:01:53,040
that has the logic, whenever I
want to upgrade, I just deploy a

27847
05:01:53,040 --> 05:01:57,090
new implementation contract and
point my proxy to that new

27848
05:01:57,090 --> 05:02:00,030
implementation. Now, whenever a
user calls a function on the

27849
05:02:00,030 --> 05:02:03,570
proxy contract, I'm going to
delegate call it to the new

27850
05:02:03,570 --> 05:02:07,200
contract, I can just call an
admin only function on my proxy

27851
05:02:07,200 --> 05:02:09,630
contract, let's call it upgrade
or something and I make all the

27852
05:02:09,630 --> 05:02:12,300
contract calls go to this new
contract. When we're talking

27853
05:02:12,300 --> 05:02:14,670
about proxies, there are four
pieces of terminology that we

27854
05:02:14,670 --> 05:02:17,550
want to keep in mind. First is
the implementation contract. The

27855
05:02:17,550 --> 05:02:20,400
implementation contract has all
of our logic and all the pieces

27856
05:02:20,400 --> 05:02:23,460
of our protocol. Whenever we
upgrade, we actually launch a

27857
05:02:23,460 --> 05:02:26,520
brand new implementation
contract, the proxy contract

27858
05:02:26,580 --> 05:02:29,940
proxy points to which
implementation is the correct

27859
05:02:29,940 --> 05:02:33,450
one. And routes everyone's calls
to the correct implementation

27860
05:02:33,450 --> 05:02:36,660
contract, you can think the
proxy contracts sits on top of

27861
05:02:36,900 --> 05:02:39,780
the implementations the user,
the user is going to be making

27862
05:02:39,810 --> 05:02:43,200
contract and function calls
through the proxy contract. And

27863
05:02:43,200 --> 05:02:46,080
then some type of admin, the
admin is the one who's going to

27864
05:02:46,080 --> 05:02:50,520
decide when to upgrade and which
contract to point to. In this

27865
05:02:50,520 --> 05:02:53,190
scenario, the other cool thing
about the proxy and delegate

27866
05:02:53,190 --> 05:02:56,100
call is that all my storage
variables are going to be stored

27867
05:02:56,130 --> 05:02:59,850
in the proxy contract and not in
the implementation contract.

27868
05:03:00,270 --> 05:03:04,260
This way, when I upgrade to a
new logic contract, all of my

27869
05:03:04,260 --> 05:03:07,410
data will stay on the proxy
contract. So whenever I want to

27870
05:03:07,410 --> 05:03:10,320
update my logic, just point to a
new implementation contract, if

27871
05:03:10,320 --> 05:03:12,870
I want to add a new storage
variable or a new type of

27872
05:03:12,870 --> 05:03:16,440
storage, I just add it in my
logic contract and the proxy

27873
05:03:16,440 --> 05:03:19,530
contract will pick it up. Now,
using proxies has a couple of

27874
05:03:19,530 --> 05:03:21,690
gotchas. And we're gonna talk
about the gotchas. And then

27875
05:03:21,690 --> 05:03:23,820
we're going to talk about the
different proxy contract

27876
05:03:23,820 --> 05:03:26,790
methodologies, because yes,
there are many proxy contract

27877
05:03:26,790 --> 05:03:29,400
methodologies as well. And this
is why trilobites doesn't really

27878
05:03:29,400 --> 05:03:31,800
recommend using upgradable
proxies for your smart

27879
05:03:31,800 --> 05:03:34,290
contracts. Because they're
fraught with a lot of these

27880
05:03:34,290 --> 05:03:37,410
potential issues. Not to
mention, again, you do still

27881
05:03:37,410 --> 05:03:40,170
have some type of admin who's
going to be upgrading your smart

27882
05:03:40,170 --> 05:03:43,170
contracts. Now, if this is a
governance protocol, then great,

27883
05:03:43,200 --> 05:03:45,690
you're decentralized. But if
this is a single group or

27884
05:03:45,690 --> 05:03:50,640
entity, then we have a problem.
The two biggest gotchas are

27885
05:03:50,640 --> 05:03:55,740
storage, clashes, and function
selector clashes. Now, what does

27886
05:03:55,740 --> 05:03:58,950
this mean? When we use delegate
call, remember, we do the logic

27887
05:03:58,950 --> 05:04:03,690
of contract B inside contract a.
So if contract B says we need to

27888
05:04:03,690 --> 05:04:07,680
set value to two, we go ahead
and set value to what these

27889
05:04:07,680 --> 05:04:11,040
smart contracts are actually
kind of dumb, we actually set

27890
05:04:11,040 --> 05:04:14,040
the value of whatever is in the
same storage location on

27891
05:04:14,040 --> 05:04:17,490
contract as contract B. So if
our contract looks like this,

27892
05:04:17,490 --> 05:04:20,850
and we have two variables and
contract a, we're still going to

27893
05:04:20,850 --> 05:04:24,060
set the first storage spot on a
contract a to the new value.

27894
05:04:24,090 --> 05:04:26,940
This is really important to know
because this means we can only

27895
05:04:26,970 --> 05:04:30,150
append new storage variables and
new implementation contracts.

27896
05:04:30,360 --> 05:04:33,990
And we can't reorder or change
old ones. This is called storage

27897
05:04:33,990 --> 05:04:36,360
clashing. And in the
implementations we're going to

27898
05:04:36,360 --> 05:04:39,810
talk about, they all address
this issue. The next one is

27899
05:04:39,810 --> 05:04:42,510
called function select or
clashes. When we tell our

27900
05:04:42,510 --> 05:04:45,690
proxies to delegate call to one
of these implementations, it

27901
05:04:45,690 --> 05:04:48,930
uses what's called a function
selector to find a function. A

27902
05:04:48,930 --> 05:04:52,290
function selector is a four byte
hash of the function name and

27903
05:04:52,290 --> 05:04:54,510
the function signature. Don't
worry about the function

27904
05:04:54,510 --> 05:04:58,170
signature for now. Now, it's
possible that a function in the

27905
05:04:58,170 --> 05:05:02,520
implementation contract has the
same function selector as an

27906
05:05:02,580 --> 05:05:05,580
admin function in the proxy
contract, which may cause you to

27907
05:05:05,580 --> 05:05:08,730
do accidentally a whole bunch of
weird stuff. For example, in

27908
05:05:08,730 --> 05:05:11,430
this sample code in front of you
even though All these functions

27909
05:05:11,430 --> 05:05:13,980
are totally different, they
actually have the same function

27910
05:05:13,980 --> 05:05:17,040
selector. So yes, we can run
into an issue where some

27911
05:05:17,040 --> 05:05:21,600
harmless function like get price
has the same function selector

27912
05:05:21,600 --> 05:05:25,320
as upgrade proxy or destroy
proxy or something like that.

27913
05:05:25,380 --> 05:05:28,530
This leads to our first of the
three implementations of the

27914
05:05:28,530 --> 05:05:32,220
proxy contracts. This is called
the transparent proxy pattern.

27915
05:05:32,370 --> 05:05:34,080
And it's actually going to be
the pattern that we're gonna be

27916
05:05:34,080 --> 05:05:37,530
demoing to you today. In this
methodology, admins are only

27917
05:05:37,530 --> 05:05:40,440
allowed to call admin functions.
And they can't call any

27918
05:05:40,440 --> 05:05:44,160
functions in the implementation
contract. And users can only

27919
05:05:44,160 --> 05:05:46,740
call functions in the
implementation contract and not

27920
05:05:46,740 --> 05:05:50,220
any admin contracts. This way,
you can't ever accidentally have

27921
05:05:50,220 --> 05:05:53,490
one of the two swapping, and
having a function selector clash

27922
05:05:53,490 --> 05:05:55,860
and you running into a big issue
where you call a function, you

27923
05:05:55,860 --> 05:05:57,870
probably shouldn't have, if
you're an admin, you're calling

27924
05:05:57,870 --> 05:06:00,480
admin functions. If your user
you're calling implementation

27925
05:06:00,480 --> 05:06:02,850
functions. So if you're an
admin, and you build some crazy,

27926
05:06:02,850 --> 05:06:05,340
awesome defi protocol, you
better come up with a new wallet

27927
05:06:05,340 --> 05:06:07,740
address because you can't
participate. The second type of

27928
05:06:07,740 --> 05:06:10,110
proxy we're going to talk about
is the universal upgradeable

27929
05:06:10,110 --> 05:06:11,070
proxy, or the

27930
05:06:11,640 --> 05:06:18,870
op amps. This version of
upgradable contracts actually

27931
05:06:18,870 --> 05:06:22,950
puts all the logic of upgrading
in the implementation itself

27932
05:06:22,980 --> 05:06:26,220
this way, the solidity compiler
will actually kick out and say,

27933
05:06:26,220 --> 05:06:29,100
Hey, we got two functions in
here that have the same function

27934
05:06:29,100 --> 05:06:31,860
selector. This is also
advantageous because we have one

27935
05:06:31,860 --> 05:06:35,220
less read that we have to do, we
no longer have to check in the

27936
05:06:35,220 --> 05:06:39,120
proxy contract if someone is an
admin or not. This saves on gas,

27937
05:06:39,120 --> 05:06:41,730
of course, and the proxy is also
a little bit smaller. Because of

27938
05:06:41,730 --> 05:06:44,460
this, the issue is that if you
deploy an implementation

27939
05:06:44,460 --> 05:06:47,070
contract, without any
upgradeable functionality,

27940
05:06:47,580 --> 05:06:51,090
you're stuck. And it's back to
the Eat method with you. And the

27941
05:06:51,090 --> 05:06:53,940
last pattern or methodology that
we're going to talk about is the

27942
05:06:53,940 --> 05:06:56,940
diamond pattern, which does a
number of things. But one of the

27943
05:06:56,940 --> 05:06:59,940
biggest things that it does, it
actually allows for multiple

27944
05:06:59,940 --> 05:07:02,790
implementation contracts. This
addresses a couple of different

27945
05:07:02,790 --> 05:07:05,820
issues. For example, if your
contract is so big, and it

27946
05:07:05,820 --> 05:07:08,880
doesn't fit into the one
contract maximum size, you can

27947
05:07:08,880 --> 05:07:11,460
just have multiple contracts
through this multi

27948
05:07:11,460 --> 05:07:14,400
implementation method. It also
allows you to make more granular

27949
05:07:14,400 --> 05:07:17,820
upgrades, like you don't have to
always deploy and upgrade your

27950
05:07:17,820 --> 05:07:20,160
entire smart contract, you can
just upgrade little pieces of

27951
05:07:20,160 --> 05:07:22,650
it. If you've chunked them out.
All the proxies mentioned here

27952
05:07:22,680 --> 05:07:25,650
have some type of Aetherium
improvement proposal, and most

27953
05:07:25,650 --> 05:07:27,540
of them are in the draft phase.
And at the end of this

27954
05:07:27,540 --> 05:07:30,780
explainer, we will do a demo of
showing you how the delegate

27955
05:07:30,780 --> 05:07:35,520
call function works. And the end
of the demo is right now. So

27956
05:07:35,520 --> 05:07:36,750
let's look at delegate call.

27957
05:07:39,390 --> 05:07:42,000
Now, we're going to learn about
how to actually build these

27958
05:07:42,000 --> 05:07:45,270
proxies how to build these
upgradable smart contracts. And

27959
05:07:45,300 --> 05:07:48,240
to do this, we first need to
learn about this delegate call

27960
05:07:48,240 --> 05:07:51,090
function. And it's going to be
really similar to the call

27961
05:07:51,090 --> 05:07:53,700
function, which we learned much
earlier. If you haven't seen

27962
05:07:53,700 --> 05:07:56,280
that, be sure to go back to our
Harnett. And if T's we have a

27963
05:07:56,280 --> 05:08:00,120
sub lesson in there, about EVM,
opcodes, and coding and calling

27964
05:08:00,120 --> 05:08:03,630
and we'll give you all the
context for delegate call. Like

27965
05:08:03,630 --> 05:08:06,600
I said, in the explainer, it's
very similar to call however,

27966
05:08:06,600 --> 05:08:10,080
the way that I think about it is
one contract says Oh, I really

27967
05:08:10,080 --> 05:08:13,230
like your function, I'm going to
borrow it myself. And we're

27968
05:08:13,230 --> 05:08:15,270
going to be looking at solidity
by example. I'll leave a

27969
05:08:15,270 --> 05:08:18,960
description in the GitHub. And
all the code for this will be in

27970
05:08:19,050 --> 05:08:22,050
the GitHub associated with this
lesson as well. Now we have two

27971
05:08:22,050 --> 05:08:25,140
contracts, we have this contract
B that we're going to be

27972
05:08:25,140 --> 05:08:28,320
deploying on remix and it looks
like a real minimalistic real

27973
05:08:28,320 --> 05:08:30,870
simple contract. We have a
couple of storage variables

27974
05:08:30,870 --> 05:08:33,150
here. And then we have a
function that updates our

27975
05:08:33,150 --> 05:08:36,480
values, we have a function
called Set VARs and updates are

27976
05:08:36,750 --> 05:08:40,530
you into public num? Now as we
learned before, whenever we have

27977
05:08:40,560 --> 05:08:43,620
some type of contract with
storage variables they get

27978
05:08:43,620 --> 05:08:47,430
stored in, in this storage data
structure that's index starting

27979
05:08:47,430 --> 05:08:51,390
from zero, right now are you
into public num is that index

27980
05:08:51,420 --> 05:08:55,680
zero, or sender's at index one,
our values and index two etc.

27981
05:08:55,860 --> 05:09:00,000
Now we're going to deploy a
contract a and now this contract

27982
05:09:00,030 --> 05:09:03,150
is actually going to use the
delegates call function. Now a

27983
05:09:03,150 --> 05:09:05,760
contract a this is going to look
a little bit different, but it's

27984
05:09:05,760 --> 05:09:08,610
still going to have this set
bars functions, except it's

27985
05:09:08,610 --> 05:09:12,180
going to make a delegate call
function call to our contract B.

27986
05:09:12,390 --> 05:09:16,500
Now in our lesson 14 with NF TS
we learned about call API dot

27987
05:09:16,500 --> 05:09:19,500
encode with signature API dot
encode etc. So if you're

27988
05:09:19,500 --> 05:09:21,780
unfamiliar with function
selectors, if you're unfamiliar

27989
05:09:21,780 --> 05:09:24,750
with if you're unfamiliar with
this syntax, be sure to go back

27990
05:09:24,750 --> 05:09:28,680
to lesson 14 To understand ABI
dot encode with signature and

27991
05:09:28,710 --> 05:09:32,010
contract dot call. The
difference here is we're doing

27992
05:09:32,010 --> 05:09:36,450
contract dot delegate call. What
this call does is something very

27993
05:09:36,450 --> 05:09:40,590
similar to call. Normally, if we
did contract dot call on this

27994
05:09:40,590 --> 05:09:43,410
contract, we would just call
this, we would just be calling

27995
05:09:43,410 --> 05:09:46,980
this function set VARs, which
would update contracts B's

27996
05:09:47,010 --> 05:09:50,400
storage, but instead we're
saying Hey, call that set VARs

27997
05:09:50,400 --> 05:09:54,450
function, and then pass this as
an input parameter, but call it

27998
05:09:54,630 --> 05:09:58,350
in our contract, call it on
contract a, we're kind of

27999
05:09:58,350 --> 05:10:02,460
borrowing a function for our
contract. And so instead, what

28000
05:10:02,460 --> 05:10:05,610
we're going to do, is we're
going to borrow this set bars

28001
05:10:05,610 --> 05:10:08,760
and run the set bars function
over here. Now the difference is

28002
05:10:08,760 --> 05:10:11,820
instead of num equals num The
variables could be named

28003
05:10:11,820 --> 05:10:15,510
different than the variables on
contract a. So instead of num

28004
05:10:15,510 --> 05:10:19,290
equals num, our contract is
going to say, hey, whatever that

28005
05:10:19,290 --> 05:10:23,280
storage of zero have that equal
to whatever we pass as an input

28006
05:10:23,280 --> 05:10:25,920
parameter. And if that's a
little bit confusing, just stay

28007
05:10:25,920 --> 05:10:28,650
with me. Let's go ahead and
let's see this in remix. So I'm

28008
05:10:28,650 --> 05:10:31,950
going to copy paste this code
into remix here. So we can kind

28009
05:10:31,950 --> 05:10:34,710
of test and see what this looks
like. Again, there's a link to

28010
05:10:34,710 --> 05:10:36,960
this in the GitHub repo
associated with this course,

28011
05:10:37,080 --> 05:10:40,290
feel free to pause the video to
grab this link. It's solidity,

28012
05:10:40,320 --> 05:10:44,220
hyphen, by hyphen,
example.org/delegate call, or

28013
05:10:44,220 --> 05:10:47,220
you can just grab the code
directly from lesson 16 Hardhead

28014
05:10:47,220 --> 05:10:49,920
upgrades. So let's compile this
code. And let me show you what I

28015
05:10:49,920 --> 05:10:52,800
mean. So I'm going to compile
it, and we'll go to the Run tab.

28016
05:10:53,220 --> 05:10:56,370
And first let's deploy this
contract beam, we'll hit Deploy,

28017
05:10:56,880 --> 05:11:00,150
we now have a contract, num,
center and value are all blank,

28018
05:11:00,270 --> 05:11:03,090
we'll update the number to
something like 777, we'll hit

28019
05:11:03,090 --> 05:11:08,850
Set VARS. Set VARs will change
the storage variable num to 777.

28020
05:11:09,180 --> 05:11:11,850
And then we're changing the
sender and the value, sender,

28021
05:11:12,000 --> 05:11:16,170
and value is zero. Now let's
deploy contract a. So we'll

28022
05:11:16,170 --> 05:11:19,590
scroll back up contract a
deploy, of course, we're on the

28023
05:11:19,590 --> 05:11:23,520
JavaScript VM. Now we have this
contract a with num value in

28024
05:11:23,520 --> 05:11:27,630
Cinder are also all blank. But
when we call set VARs, it's

28025
05:11:27,630 --> 05:11:32,220
going to borrow this set VARs
function from contract B and run

28026
05:11:32,220 --> 05:11:37,380
it in contract a, you can almost
think of it as if we're copying,

28027
05:11:37,410 --> 05:11:42,990
set VARs and pasting it into our
contract a just for one run, and

28028
05:11:42,990 --> 05:11:45,660
then immediately deleting ADM,
that's what this delegate call

28029
05:11:45,660 --> 05:11:48,420
function does. So when I call
set VARs, we're going to pass it

28030
05:11:48,420 --> 05:11:51,990
this contract address as an
input parameter. So it knows to

28031
05:11:51,990 --> 05:11:55,860
call this contract said virus
function. When I pass it the

28032
05:11:55,860 --> 05:12:00,120
address, and I pass 987. Since
we're borrowing the function,

28033
05:12:00,150 --> 05:12:03,930
we're not going to update this
num. On contract B, we're going

28034
05:12:03,930 --> 05:12:08,940
to update the num on contract a.
So when I hit Set VARs, we see

28035
05:12:08,940 --> 05:12:12,150
num now has 19. Seven, we see
Senator and we see value still

28036
05:12:12,150 --> 05:12:14,790
being zero here, because again,
we're borrowing this function

28037
05:12:14,790 --> 05:12:18,180
and running it here. Now the way
that this works, is it actually

28038
05:12:18,180 --> 05:12:22,740
doesn't look at the names of our
stored variables, it looks at

28039
05:12:22,740 --> 05:12:26,970
the storage slots. So when we
borrow this function using

28040
05:12:26,970 --> 05:12:29,940
delegate call, so we could have
this these variables we named

28041
05:12:29,940 --> 05:12:33,840
anything instead of num, we
could call this first value.

28042
05:12:34,260 --> 05:12:38,790
Senator, we could call something
else. And then value we could

28043
05:12:38,790 --> 05:12:43,560
call foo, or whatever you want
here. And when we borrow this

28044
05:12:43,560 --> 05:12:47,100
function using delegate call,
instead of grabbing the actual

28045
05:12:47,100 --> 05:12:49,830
names of the variables, our
contract will swap out these

28046
05:12:49,830 --> 05:12:53,640
variable names with the storage
slot. So it says oh, okay, well,

28047
05:12:53,910 --> 05:12:57,360
in contract B, you're accessing
the num variable, which is,

28048
05:12:57,390 --> 05:13:01,410
which is at storage slot zero.
So when we borrow set bars and

28049
05:13:01,410 --> 05:13:07,470
contract a with Delegate call,
we'll say storage slot

28050
05:13:08,820 --> 05:13:14,190
zero is going to equal that
underscore num. Which are this

28051
05:13:14,190 --> 05:13:18,840
contract storage slot zero is
first value. So we'll say first

28052
05:13:18,840 --> 05:13:23,430
value equals underscore Now,
something else is going to be

28053
05:13:23,460 --> 05:13:26,460
stored slot two, so it's gonna
say okay, storage slot two,

28054
05:13:27,060 --> 05:13:29,850
we're gonna update storage slot
two to message that sender.

28055
05:13:30,270 --> 05:13:35,550
Okay? value here is storage slot
three. So whatever's in storage,

28056
05:13:35,580 --> 05:13:39,330
slot three, will update with
message dot value like this. So

28057
05:13:39,330 --> 05:13:42,420
that's essentially what's going
on behind the scenes. So let's

28058
05:13:42,420 --> 05:13:46,200
go ahead and let's delete those
and redeploy. redeploy them. So

28059
05:13:46,200 --> 05:13:50,040
we'll deploy contract be
deployed contract a, right now

28060
05:13:50,040 --> 05:13:55,200
in B, once again, if we do 1234,
set VARs, we have 123. And then

28061
05:13:55,200 --> 05:13:59,700
contract a. Now even though
these variables have different

28062
05:13:59,700 --> 05:14:04,530
names, we could grab contract
B's address, paste it in, do

28063
05:14:04,860 --> 05:14:10,050
654, hit Set VARS. And first
value is now six by four. So

28064
05:14:10,050 --> 05:14:13,260
delegate call allows us to
borrow functions, and then just

28065
05:14:13,260 --> 05:14:17,730
transposes whatever is in here
to the storage location

28066
05:14:17,760 --> 05:14:20,670
equivalents. And the other thing
that's interesting is even if

28067
05:14:20,670 --> 05:14:24,780
you don't have variables, it'll
still save to storage slots. So

28068
05:14:24,780 --> 05:14:27,450
in contract a, if we didn't have
any of those variable names,

28069
05:14:27,480 --> 05:14:30,990
storage slot, 01, and two would
still get updated. Now here's

28070
05:14:30,990 --> 05:14:33,750
where things can get really
interesting. Let's delete our

28071
05:14:33,750 --> 05:14:38,760
contract again. And let's change
the type of our contract A's

28072
05:14:38,790 --> 05:14:43,830
first value to from a UNT to a
Boolean. Let's save that. And

28073
05:14:43,830 --> 05:14:48,750
now let's deploy contract a. Now
when we call set VARs, on our

28074
05:14:48,750 --> 05:14:53,760
contract a, it's still going to
use the Set VARs function of

28075
05:14:53,760 --> 05:14:57,540
contract B, which takes a
Yewande and assigns the first

28076
05:14:57,540 --> 05:15:01,470
storage slot that number we pass
it, but our first storage slot

28077
05:15:01,500 --> 05:15:04,440
is now a Boolean was so what do
you think's going to happen now?

28078
05:15:04,590 --> 05:15:08,220
Well, let's try it out. Let's
copy contract B's address, paste

28079
05:15:08,220 --> 05:15:12,990
it in here. We'll pass we'll do
tu tu, tu as our input

28080
05:15:12,990 --> 05:15:17,070
parameter, we'll hit Set VARS.
Our transaction actually does go

28081
05:15:17,070 --> 05:15:21,780
through. And now when we look at
first value, it says true. Hmm,

28082
05:15:22,260 --> 05:15:26,040
that's really weird. What if we
change set VARs to zero, and hit

28083
05:15:26,040 --> 05:15:31,500
Set VARS. And now, first value
is false. In storage here, when

28084
05:15:31,500 --> 05:15:34,950
we add a number with set VARs,
it's going through because it's

28085
05:15:34,950 --> 05:15:39,780
just setting the storage slot of
the boolean to a number. And

28086
05:15:39,780 --> 05:15:43,620
when solidity reads it, it goes,
Oh, well, first value is a

28087
05:15:43,620 --> 05:15:46,620
Boolean. So if it's anything
other than zero, it's going to

28088
05:15:46,620 --> 05:15:49,140
be true. So this is how you can
actually get some really weird

28089
05:15:49,140 --> 05:15:52,110
results. If your typings are
different, or if your stored

28090
05:15:52,110 --> 05:15:55,290
variants are different. What if
we made this an address. So this

28091
05:15:55,290 --> 05:15:58,200
is where working with Delegate
call can get really weird and

28092
05:15:58,200 --> 05:16:00,060
really tricky, really fast.

28093
05:16:05,520 --> 05:16:09,120
All right. Now, with all this
being said, let's turn up the

28094
05:16:09,120 --> 05:16:12,360
heat. And let me show you a
small proxy, a minimal proxy

28095
05:16:12,360 --> 05:16:16,740
example, that shows how a
contract can be used as a

28096
05:16:16,740 --> 05:16:20,490
singular address, but the
underlying code can actually

28097
05:16:20,490 --> 05:16:23,580
change. And all the code we're
gonna be working with, once

28098
05:16:23,580 --> 05:16:28,650
again, in the hardhat upgrades,
FCC sub lesson, small proxy dot

28099
05:16:28,650 --> 05:16:31,680
Sol, and you can go ahead and
copy paste this code if you want

28100
05:16:31,680 --> 05:16:34,650
to follow along. So you don't
have to code along with me here.

28101
05:16:34,680 --> 05:16:37,830
But you absolutely can if we
want. Now, I will say this is

28102
05:16:37,830 --> 05:16:41,250
going to be one of the most, if
not the most advanced section of

28103
05:16:41,250 --> 05:16:44,760
the entire course. So feel free
to go ahead and skip over this

28104
05:16:44,790 --> 05:16:47,580
sub lesson. If you want to just
move on to learning how to

28105
05:16:47,580 --> 05:16:50,130
actually build these proxies,
without really understanding

28106
05:16:50,130 --> 05:16:52,470
what's going on behind the
scenes. However, it is still

28107
05:16:52,470 --> 05:16:54,660
really powerful if you do
understand what's going on

28108
05:16:54,660 --> 05:16:57,420
behind the scenes. So I have
this minimalistic starting

28109
05:16:57,420 --> 05:17:01,740
position right here. I have
small proxy is proxy. And I'm

28110
05:17:01,740 --> 05:17:04,980
importing this proxy dot sole
thing from up in Zeplin.

28111
05:17:05,160 --> 05:17:08,400
openzeppelin has this
minimalistic proxy contract that

28112
05:17:08,400 --> 05:17:11,490
we can use to actually start
working with this delegate call.

28113
05:17:11,700 --> 05:17:14,220
Now this contract uses a lot of
assembly or what's something

28114
05:17:14,220 --> 05:17:17,100
called you'll. And it's an
intermediate language that can

28115
05:17:17,100 --> 05:17:20,580
be compiled to bytecode for
different backends. It's a sort

28116
05:17:20,580 --> 05:17:24,480
of inline assembly inside
solidity and allows you to write

28117
05:17:24,480 --> 05:17:28,020
really, really low level code
close to the opcodes. Now we're

28118
05:17:28,020 --> 05:17:30,630
not going to go over you'll but
I'll leave some links to the

28119
05:17:30,630 --> 05:17:33,870
you'll documentation if you want
to learn more. Even if you're a

28120
05:17:33,870 --> 05:17:37,980
really advanced user, you really
want to try to use as little

28121
05:17:37,980 --> 05:17:41,970
EULA as possible. Because since
it is so much lower level, it is

28122
05:17:42,000 --> 05:17:45,510
much easier to screw things up.
However, like I said, for this

28123
05:17:45,510 --> 05:17:48,840
example, we are going to be
using a little bit of you'll now

28124
05:17:48,840 --> 05:17:51,420
in this proxy that we're going
to be doing, we have this

28125
05:17:51,450 --> 05:17:55,680
delegate function, which inside
this inline assembly, which is

28126
05:17:55,680 --> 05:17:59,280
you'll, it does a whole lot of
really low level stuff. But the

28127
05:17:59,280 --> 05:18:01,680
main thing that it does is it
goes ahead and it does this

28128
05:18:01,680 --> 05:18:05,730
delegate call functionality. If
we look here, we can see it's

28129
05:18:05,730 --> 05:18:09,750
using a fallback function and a
receive function. So whenever it

28130
05:18:09,750 --> 05:18:13,740
receives a function that doesn't
recognize it'll call fallback,

28131
05:18:14,070 --> 05:18:19,380
and fallback calls our delegate
function. So anytime a proxy

28132
05:18:19,380 --> 05:18:23,250
contract receives data for a
function it doesn't recognize it

28133
05:18:23,250 --> 05:18:26,700
sends it over to some
implementation to some

28134
05:18:26,730 --> 05:18:30,090
implementation contract where it
will call it with Delegate call.

28135
05:18:30,240 --> 05:18:34,140
In our minimalistic example
here, we have a function called

28136
05:18:34,170 --> 05:18:37,710
Set implementation, which will
change where those delegate

28137
05:18:37,710 --> 05:18:40,620
calls are going to be sending.
This can be equivalent to like

28138
05:18:40,650 --> 05:18:43,980
upgrading your smart contract.
And then we have implementation

28139
05:18:44,010 --> 05:18:48,450
here to read where that
implementation contract is. Now

28140
05:18:48,480 --> 05:18:51,420
to work with proxies, we really
don't want to have anything in

28141
05:18:51,420 --> 05:18:54,270
storage, because if we do
delegate call, and that delegate

28142
05:18:54,270 --> 05:18:56,970
call changes, some storage,
we're going to screw up our

28143
05:18:56,970 --> 05:19:00,450
contract storage. The one caveat
though to this, we do still need

28144
05:19:00,450 --> 05:19:03,780
to store that implementations
address somewhere, so we can

28145
05:19:03,780 --> 05:19:08,520
call it so ERP 1976. It's called
the standard proxy storage slot,

28146
05:19:08,820 --> 05:19:11,670
which is an Aetherium
improvement proposal for having

28147
05:19:11,670 --> 05:19:15,630
certain storage slots
specifically used for proxies.

28148
05:19:15,750 --> 05:19:19,560
And in our minimalistic example
here, we set bytes 32, private

28149
05:19:19,560 --> 05:19:24,660
constant implementation slot to
that location in storage. And

28150
05:19:24,660 --> 05:19:28,590
we'll say, okay, whatever is
that this storage slot is going

28151
05:19:28,590 --> 05:19:32,820
to be the location of the
implementation address. So the

28152
05:19:32,820 --> 05:19:36,060
way our proxy is going to work
is any contract that calls this

28153
05:19:36,060 --> 05:19:39,300
proxy contract. If it's not this
set implementation function,

28154
05:19:39,330 --> 05:19:42,210
it's going to pass it over to
whatever is inside the

28155
05:19:42,270 --> 05:19:44,910
implementation slot address.
That's what we're going to build

28156
05:19:44,910 --> 05:19:49,350
here. So we have the small proxy
is proxy. And we'll create a

28157
05:19:49,350 --> 05:19:53,340
real minimalistic contract. So
we'll say contract employee,

28158
05:19:54,150 --> 05:20:00,210
mentation A, and we'll just give
it a U and 256. public value and

28159
05:20:00,210 --> 05:20:07,170
then function set value, you add
256 new value, public will say

28160
05:20:07,170 --> 05:20:12,030
value equals new value So this
is going to be our

28161
05:20:12,030 --> 05:20:16,740
implementation. So now anytime
somebody calls small proxy, or

28162
05:20:16,740 --> 05:20:20,940
small proxy contract, it's going
to delegate, call it over to our

28163
05:20:21,090 --> 05:20:26,340
implementation, a, and then save
the storage in our small proxy

28164
05:20:26,340 --> 05:20:30,990
address. So we're going to call
our small proxy with the data to

28165
05:20:30,990 --> 05:20:34,290
use this set value function
selector. So let's make it a

28166
05:20:34,290 --> 05:20:37,200
little easier just to figure out
how to get that data by creating

28167
05:20:37,200 --> 05:20:42,600
a new helper function, do
function, get data to transact.

28168
05:20:45,330 --> 05:20:48,630
And we can get the data using
the API dot encode with

28169
05:20:48,630 --> 05:20:52,380
signature that we learned in an
earlier lesson. So function get

28170
05:20:52,380 --> 05:20:58,080
data to transact, we'll pass it
a un 256 number to update. So

28171
05:20:58,080 --> 05:21:02,220
we'll give this the number we
want to call a new value. We'll

28172
05:21:02,220 --> 05:21:07,110
have this be public pure, that's
going to return a bytes.

28173
05:21:08,430 --> 05:21:14,250
Memory. And we'll just say
return ABI dot ENCODE. With

28174
05:21:14,760 --> 05:21:23,580
signature set value, you went to
56, comma, number to update.

28175
05:21:24,930 --> 05:21:28,260
So you'll remember this from our
call anything section. And if

28176
05:21:28,260 --> 05:21:30,420
you don't remember how to do
that, remember to refer back to

28177
05:21:30,420 --> 05:21:34,170
our NFT section to learn how to
call anything and use ABI dot

28178
05:21:34,170 --> 05:21:38,130
encode ABI dot encode with a
signature and call anything with

28179
05:21:38,130 --> 05:21:42,270
its raw bytes bring and get the
data to transact. And we know

28180
05:21:42,300 --> 05:21:46,770
that when we call implementation
a, from our small proxy, we're

28181
05:21:46,770 --> 05:21:49,950
going to update our small
proxies storage. So we'll create

28182
05:21:49,950 --> 05:21:52,860
a little function in solidity
just to read our storage in

28183
05:21:52,860 --> 05:21:57,690
small proxy. We're gonna say
function, read storage. And this

28184
05:21:57,690 --> 05:22:04,080
will just be a public view, will
do returns, returns you into

28185
05:22:04,080 --> 05:22:11,460
256, value at storage slot,
zero. And we are going to use a

28186
05:22:11,460 --> 05:22:13,950
little bit of assembly here
since we are doing all this low

28187
05:22:13,950 --> 05:22:18,510
level stuff. And we're going to
call the s load up code to read

28188
05:22:18,540 --> 05:22:21,900
the value at storage slot zero,
we'll say value at storage slot

28189
05:22:21,900 --> 05:22:25,440
zero, and we're going to set it
and then in assembly, this is

28190
05:22:25,440 --> 05:22:29,280
how we set things, we're going
to set it equal to s load of

28191
05:22:29,280 --> 05:22:33,060
storage slot zero, and then it
will return this value here. So

28192
05:22:33,060 --> 05:22:36,300
we're reading directly from
storage. Oops, and then we need

28193
05:22:36,300 --> 05:22:40,200
a little parenthese here. Sorry.
So now, let's go ahead and

28194
05:22:40,200 --> 05:22:43,680
deploy our small proxy. And
let's deploy our implementation

28195
05:22:43,680 --> 05:22:47,490
A. Now our small proxy has a
function called Set

28196
05:22:47,490 --> 05:22:51,300
implementation. So we're saying,
okay, anytime we call this proxy

28197
05:22:51,300 --> 05:22:55,170
contract, we're going to
delegate call the functions over

28198
05:22:55,170 --> 05:22:58,380
to here. So we're going to grab
current implementations A's

28199
05:22:58,380 --> 05:23:04,290
address, paste it into set
implementation 77. So this is

28200
05:23:04,290 --> 05:23:08,670
the data of set value you in
256, with that number to update

28201
05:23:08,880 --> 05:23:13,590
encoded in it. So if we call our
small proxy, with this data, our

28202
05:23:13,590 --> 05:23:18,030
proxy contract is gonna go, oh,
okay, this is a function. I

28203
05:23:18,030 --> 05:23:21,030
don't I don't see that function
here. We're going to call our

28204
05:23:21,030 --> 05:23:25,380
fallback, right, which again, is
coming from open Zeplin. And our

28205
05:23:25,380 --> 05:23:28,200
Fallback is going to do this
delegate, which is this low

28206
05:23:28,200 --> 05:23:30,630
level stuff, but it's basically
just doing a delegate call,

28207
05:23:30,750 --> 05:23:33,330
we're gonna call our fallback
function, and then we're gonna

28208
05:23:33,330 --> 05:23:36,930
get the function in the
implementation A, we're gonna

28209
05:23:36,930 --> 05:23:40,590
borrow this function, and we're
gonna use it on our on

28210
05:23:40,590 --> 05:23:44,520
ourselves. So if I copy this,
the implementation has been set

28211
05:23:44,550 --> 05:23:47,040
to being this address down here.
So all the logic is going to be

28212
05:23:47,040 --> 05:23:50,790
done here. So when I go ahead,
and I grabbed this, and paste it

28213
05:23:50,790 --> 05:23:53,340
into call data, and I hit
transact looks like it went

28214
05:23:53,340 --> 05:23:57,120
successfully went through. If I
read storage, now, we see that

28215
05:23:57,120 --> 05:24:01,740
it is indeed 777, which is
incredibly exciting. Now, this

28216
05:24:01,740 --> 05:24:04,380
is incredibly beneficial,
because now let's say we want to

28217
05:24:04,380 --> 05:24:07,230
go and update our code, right?
We don't like contract

28218
05:24:07,230 --> 05:24:10,320
implementation anymore. So let's
go ahead copy contract

28219
05:24:10,320 --> 05:24:14,430
implementation A. And we'll make
a new one called implementation

28220
05:24:14,700 --> 05:24:19,050
B. Now, let's say whenever
somebody calls set value, we do

28221
05:24:19,080 --> 05:24:24,360
value equals new value, plus
one, or plus two. Let's go

28222
05:24:24,360 --> 05:24:29,010
ahead, let's save this. Let's
compile this. And let's deploy

28223
05:24:29,040 --> 05:24:33,180
implementation B, we'll grab
implementation B's contract

28224
05:24:33,180 --> 05:24:37,800
address, we'll call it onset
implementation in our proxy. And

28225
05:24:37,830 --> 05:24:41,370
essentially, we have now
upgraded from implementation a

28226
05:24:41,730 --> 05:24:46,440
to implementation B. Now, if we
use this same data here, we're

28227
05:24:46,440 --> 05:24:51,360
still going to call set value
was 777. But instead, we're now

28228
05:24:51,390 --> 05:24:54,600
delegate calling to
implementation B, instead of

28229
05:24:54,600 --> 05:24:59,250
implementation A. So if I call
if I put this data into the low

28230
05:24:59,250 --> 05:25:02,100
level call data, and I hit
transact, it looks like it went

28231
05:25:02,100 --> 05:25:07,620
through. Now I read storage and
now is 779 since doing value

28232
05:25:07,650 --> 05:25:12,300
equals new value plus two so
this is a minimalistic example

28233
05:25:12,360 --> 05:25:15,720
of how upgrading actually works.
Now, this is incredibly

28234
05:25:15,720 --> 05:25:18,780
beneficial, because we can
always just tell people, Hey,

28235
05:25:18,810 --> 05:25:22,140
make all your function calls to
small proxy, and you'll be good

28236
05:25:22,140 --> 05:25:25,830
to go. But like I said before,
this also means that the

28237
05:25:25,830 --> 05:25:29,190
developers of this protocol can
essentially change the

28238
05:25:29,190 --> 05:25:32,550
underlying logic at any time.
This is why it is so important

28239
05:25:32,760 --> 05:25:36,180
to be sure to read contracts and
check to see who has the

28240
05:25:36,180 --> 05:25:39,180
developer keys. And if a
contract can be updated, if a

28241
05:25:39,180 --> 05:25:41,820
contract can be updated, and a
single person can update it,

28242
05:25:41,910 --> 05:25:44,370
well guess what, you have a
single centralized point of

28243
05:25:44,370 --> 05:25:46,650
failure. And technically the
contract isn't even

28244
05:25:46,650 --> 05:25:49,740
decentralized. Now, something
else I was talking about in the

28245
05:25:49,740 --> 05:25:54,240
video is function clashes
function selector clashes. Right

28246
05:25:54,240 --> 05:25:57,570
now, whenever we call set
implementation, the proxy

28247
05:25:57,600 --> 05:26:00,180
function sedimentation gets
called because we don't trigger

28248
05:26:00,180 --> 05:26:02,880
the fallback because we can see
the function is here. However,

28249
05:26:02,910 --> 05:26:05,610
if I have a function called Set
implementation, in our

28250
05:26:05,610 --> 05:26:08,970
implementation, this one can
never be called, whenever we

28251
05:26:08,970 --> 05:26:12,570
send a function signature of set
implementation, it's always

28252
05:26:12,570 --> 05:26:15,060
going to call the one on the
proxy. This is where the

28253
05:26:15,060 --> 05:26:17,190
transparent proxy that we're
going to be working with can

28254
05:26:17,190 --> 05:26:20,100
help us out here and the
universal upgradable proxy can

28255
05:26:20,100 --> 05:26:22,800
help us to, and I'm not going to
go too much deeper into these

28256
05:26:22,800 --> 05:26:26,190
now. But we've left some links
in the GitHub repository to

28257
05:26:26,190 --> 05:26:29,370
teach you more about these
selector clashes. And how those

28258
05:26:29,370 --> 05:26:32,130
two proxy patterns that I just
mentioned, the transparent and

28259
05:26:32,130 --> 05:26:35,370
universal upgradable can get
around these, if you're confused

28260
05:26:35,370 --> 05:26:37,770
by anything in here, go into
this discussion thread and make

28261
05:26:37,770 --> 05:26:41,100
a new discussion about proxies
make a new discussion about the

28262
05:26:41,100 --> 05:26:44,100
Assembly about the you'll set
implementation, this is a great

28263
05:26:44,100 --> 05:26:47,190
time to connect with other
people taking the course and ask

28264
05:26:47,220 --> 05:26:49,860
questions here, because I know
that this is a really advanced

28265
05:26:49,860 --> 05:26:53,460
section, and requires you
haven't gone through a lot of

28266
05:26:53,460 --> 05:26:55,980
those sub lessons that we've
gone before. And if it takes you

28267
05:26:55,980 --> 05:26:58,890
a couple times of playing around
with solidity and playing around

28268
05:26:58,890 --> 05:27:02,160
with remix, I definitely
recommend you do so this is the

28269
05:27:02,160 --> 05:27:04,950
section we're seeing really is
believing. And I want you to

28270
05:27:04,950 --> 05:27:07,500
jump into remix. And I want you
to test this. And I want you to

28271
05:27:07,500 --> 05:27:10,320
play around with this and see
what you can break and fiddle

28272
05:27:10,320 --> 05:27:13,140
with. But with all that being
said, we finally have all the

28273
05:27:13,140 --> 05:27:16,500
knowledge that we need to build
our hardhat project that deals

28274
05:27:16,500 --> 05:27:19,680
with upgrades. So let's go ahead
and jump into it.

28275
05:27:22,740 --> 05:27:26,370
Your new terminal, we're going
to do MK dir, hard hat,

28276
05:27:26,940 --> 05:27:32,370
upgrades, FCC, CD, hard hat,
upgrades, FCC, and then code

28277
05:27:32,370 --> 05:27:37,740
period, or file, open folder,
this folder here, now I'm going

28278
05:27:37,740 --> 05:27:40,350
to grab that same yarn add we've
been grabbing from less than

28279
05:27:40,350 --> 05:27:43,260
nine, we're gonna paste it in,
we're going to add all of these

28280
05:27:43,260 --> 05:27:46,320
different parameters. And once
again, we're going to copy over

28281
05:27:46,350 --> 05:27:48,630
our hard hat config from
previous sections, we're going

28282
05:27:48,630 --> 05:27:51,480
to copy over prettier. And we're
just going to get our basic

28283
05:27:51,480 --> 05:27:54,750
default setup. At this point,
you might have a setup that

28284
05:27:54,780 --> 05:27:57,660
works best for you and that you
like better. And feel free to

28285
05:27:57,660 --> 05:28:00,180
grab that as well. So I'm going
to paste the prettier is in

28286
05:28:00,180 --> 05:28:03,450
here. And I'm going to paste the
hard hat.config.js that we've

28287
05:28:03,450 --> 05:28:06,330
been using, instead of running
yarn hard hat. And now we should

28288
05:28:06,330 --> 05:28:11,130
be good to go. So let's create a
new folder called contracts. And

28289
05:28:11,130 --> 05:28:14,970
in here, we're going to create a
new file called Box dot soul.

28290
05:28:15,330 --> 05:28:17,220
And then it's this contract,
that's going to be our

28291
05:28:17,250 --> 05:28:21,510
implementation or our logic
contract. So it will say pragma,

28292
05:28:21,900 --> 05:28:28,380
solidity carrot zero point 8.7
contract box will say you into

28293
05:28:28,380 --> 05:28:36,090
256 internal value will do event
value changed you into 256 new

28294
05:28:36,090 --> 05:28:43,290
value, do function store, you
went to 36 value, this will be a

28295
05:28:43,290 --> 05:28:48,660
public function will say value
equals new value. So this store

28296
05:28:48,660 --> 05:28:52,590
function is going to update our
variable at storage slot zero,

28297
05:28:52,800 --> 05:29:00,150
internal, and then we'll just
omit value changed that new

28298
05:29:00,150 --> 05:29:06,150
value. And then we'll just
create function retrieve, which

28299
05:29:06,150 --> 05:29:11,760
will be a public view returns a
UNT 256 We'll just do return

28300
05:29:11,880 --> 05:29:16,080
value. And then we're going to
create a new function called

28301
05:29:16,710 --> 05:29:21,630
version. And this will be a
public door. And that returns a

28302
05:29:21,630 --> 05:29:26,610
un 256. And we're just going to
have this return one. So our box

28303
05:29:26,610 --> 05:29:29,550
contract here is going to be
version one. Now we're going to

28304
05:29:29,550 --> 05:29:33,930
copy all this code, paste it
into a box v two dot soul and

28305
05:29:34,200 --> 05:29:37,290
rename it to contract box v two,
we're going to update the

28306
05:29:37,290 --> 05:29:40,710
version to version two here. And
we're going to create a new

28307
05:29:40,710 --> 05:29:46,080
function called increment. And
this will be a public function.

28308
05:29:46,800 --> 05:29:51,810
And we'll say value equals value
plus one. And then we will emit

28309
05:29:52,140 --> 05:29:57,750
a value changed event with
value. We're going to have one

28310
05:29:57,750 --> 05:30:01,920
contract address originally use
the logic in box and then we're

28311
05:30:01,920 --> 05:30:05,550
going to upgrade it to the logic
in box V two. And we're going to

28312
05:30:05,550 --> 05:30:07,920
learn how to use all the tools
that we've been working with

28313
05:30:07,920 --> 05:30:11,160
here to add this logic and
create this logic And let's just

28314
05:30:11,160 --> 05:30:16,110
make sure this works, we'll do
yarn, or that compile.

28315
05:30:17,430 --> 05:30:22,170
So let's make a readme.md, we'll
say, one, we're going to upgrade

28316
05:30:22,530 --> 05:30:28,890
box to box V two. So we're going
to make a proxy contract, that's

28317
05:30:28,890 --> 05:30:32,550
gonna point to box. And then
later on, we're going to update

28318
05:30:32,550 --> 05:30:37,650
it to point to box V two. Right,
so we're going to start it up

28319
05:30:37,650 --> 05:30:40,380
pointing to box, then we're
going to have it point to box V

28320
05:30:40,380 --> 05:30:42,960
two. And that's how we're going
to upgrade it, one of the first

28321
05:30:42,960 --> 05:30:46,200
things we're going to need to do
is deploy a proxy, we can deploy

28322
05:30:46,200 --> 05:30:49,980
a proxy manually ourselves, and
we can build the proxy contracts

28323
05:30:49,980 --> 05:30:52,650
and do all that stuff. That's
our first option. Hardhead

28324
05:30:52,650 --> 05:30:57,000
deploy also comes built in with
deploying and upgrading proxies

28325
05:30:57,030 --> 05:31:00,270
itself, where we can just
specify that we want to use a

28326
05:31:00,270 --> 05:31:03,180
proxy. And we could specify the
type of proxy that we want to

28327
05:31:03,180 --> 05:31:06,870
use. So number two is just
saying using hard hat deploys,

28328
05:31:07,110 --> 05:31:11,340
built in proxies. And then
number three is open Zeppelin

28329
05:31:11,370 --> 05:31:14,370
actually has an upgrades plugin,
which allows you to write some

28330
05:31:14,370 --> 05:31:16,890
really simple scripts that
allows you to have a really

28331
05:31:16,890 --> 05:31:20,700
simple API like upgrades dot
deploy proxy, and then upgrades

28332
05:31:20,700 --> 05:31:24,510
that upgrade proxy. Now for this
section, we're going to be doing

28333
05:31:24,540 --> 05:31:28,110
the hard hat deploys built in
proxies. However, in the GitHub

28334
05:31:28,110 --> 05:31:31,920
repo associated with this, if
you go to scripts, there's other

28335
05:31:31,920 --> 05:31:34,860
upgrade examples that will show
you how to use the opens up and

28336
05:31:34,890 --> 05:31:37,740
upgrades plugin. And we're not
going to do deploy a proxy

28337
05:31:37,740 --> 05:31:40,620
manually manually, because we
essentially just showed you how

28338
05:31:40,620 --> 05:31:44,280
to do that in our sub lesson. So
we're going to show you this,

28339
05:31:44,310 --> 05:31:46,110
we're going to show you the
Hardhead deploys built in

28340
05:31:46,110 --> 05:31:48,870
proxies, and if you want to use
the openzeppelin upgrades

28341
05:31:48,870 --> 05:31:52,620
plugin, that is available in the
GitHub repo as well. So let's go

28342
05:31:52,620 --> 05:31:55,230
ahead and do this. So we're
going to go ahead and we're

28343
05:31:55,230 --> 05:31:58,680
going to make a new folder, or
deploy folder. And first, we're

28344
05:31:58,680 --> 05:32:03,660
going to make a new file called
a one, deploy box dot j s. And

28345
05:32:03,660 --> 05:32:05,760
this is going to look really
similar to everything we've been

28346
05:32:05,760 --> 05:32:10,710
doing so far. So module dot
exports, equals async function,

28347
05:32:11,460 --> 05:32:15,630
we're going to get named
accounts and deployments. The

28348
05:32:15,630 --> 05:32:20,730
arrow function will say const
deploy COMM A log equals

28349
05:32:20,730 --> 05:32:27,450
deployments const deployer
equals await, get named.

28350
05:32:29,490 --> 05:32:34,920
Accounts, do a little logging,
like this, and then we'll say

28351
05:32:34,920 --> 05:32:41,760
const, box equals await, loi,
box, comma, we'll say from

28352
05:32:42,150 --> 05:32:49,920
Deployer, comma, args like this,
we'll say weight con formations

28353
05:32:49,950 --> 05:32:56,010
is going to be network dot
config dot block confirmations

28354
05:32:56,010 --> 05:33:02,430
for Masons. And yep, we got to
grab const from hard hat. And

28355
05:33:02,430 --> 05:33:06,120
then we can add the parameter in
here for proxies. And this is

28356
05:33:06,120 --> 05:33:10,140
where we can add a ton of
information. So like I said,

28357
05:33:10,140 --> 05:33:12,450
we're going to use the
transparent upgradable proxy

28358
05:33:12,480 --> 05:33:15,330
from open Zeppelin, which if we
want to use it, we're going to

28359
05:33:15,330 --> 05:33:20,940
have to add open Zeppelin. So
we'll do yarn, add dash dash dev

28360
05:33:21,060 --> 05:33:26,220
at open Zeppelin slash
contracts. And we can tell our

28361
05:33:26,220 --> 05:33:31,200
hard hat to deploy this box
contract behind a proxy will say

28362
05:33:31,200 --> 05:33:39,510
the proxy contract is going to
be the open Zeppelin transparent

28363
05:33:39,780 --> 05:33:45,060
proxy. And we're also going to
do a via admin contract. So

28364
05:33:45,090 --> 05:33:49,020
instead of having an admin
address, for the proxy contract,

28365
05:33:49,140 --> 05:33:52,170
we're going to have the proxy
contract owned by an admin

28366
05:33:52,170 --> 05:33:55,020
contract. And doing it this way
is considered a best practice

28367
05:33:55,020 --> 05:33:58,740
for a number of reasons. But
we'll name this admin contract,

28368
05:33:59,310 --> 05:34:08,370
box proxy admin and the artifact
for this box proxy admin. So

28369
05:34:08,370 --> 05:34:12,450
we'll need to create a box proxy
admin contract to be the admin

28370
05:34:12,480 --> 05:34:17,310
of our box. So in our contracts
folder, create a new folder

28371
05:34:17,760 --> 05:34:23,880
called proxy. And in here, a new
file called Box proxy admin that

28372
05:34:23,880 --> 05:34:26,580
saw and this is going to be the
admin contract we're going to

28373
05:34:26,580 --> 05:34:30,990
have for controlling the proxy
of our box so inbox proxy admin

28374
05:34:30,990 --> 05:34:40,710
dot Saul will do SP DX license.
I then to fire MIT pragma

28375
05:34:41,040 --> 05:34:44,400
solidity, carrot zero, point
8.7,

28376
05:34:45,840 --> 05:34:51,330
say contract, box proxy admin,
like this, right? And once

28377
05:34:51,330 --> 05:34:55,230
again, we're going to use one of
the open Zetland tools in the

28378
05:34:55,230 --> 05:34:59,190
transparent folder. They have a
proxy admin dot Saul, which is

28379
05:34:59,190 --> 05:35:01,920
going to be essentially what our
box proxy admin is going to be.

28380
05:35:02,280 --> 05:35:05,130
It has some functionality, it
has some functions in here like

28381
05:35:05,130 --> 05:35:09,840
change, proxy admin, upgrade,
upgrade and call for dealing

28382
05:35:09,840 --> 05:35:12,960
with upgrades. All contracts. So
we're going to import it will do

28383
05:35:12,960 --> 05:35:18,780
import at open Zeppelin slash
contracts slash proxy slash

28384
05:35:18,780 --> 05:35:24,210
transparent, slash proxy admin,
dot soul. And we'll say our

28385
05:35:24,210 --> 05:35:30,720
Brock's box proxy admin is proxy
admin, like this. And to have

28386
05:35:30,720 --> 05:35:34,140
this box proxy admin work with
the heart at deploy plugin, our

28387
05:35:34,140 --> 05:35:37,170
constructor needs to take an
address owner as an input

28388
05:35:37,170 --> 05:35:39,990
parameter, but we're just going
to leave that blank. And then,

28389
05:35:40,140 --> 05:35:42,450
and then we need to do the proxy
admin, which is just going to be

28390
05:35:42,450 --> 05:35:45,870
blank as well. And that's it.
That's all we're going to do box

28391
05:35:45,870 --> 05:35:49,500
proxy admin contract, which just
has all of the functionalities

28392
05:35:49,500 --> 05:35:52,680
to do upgrades and change proxy
admin and all this stuff. We're

28393
05:35:52,680 --> 05:35:56,940
going to deploy our box contract
behind a proxy and opens up and

28394
05:35:56,940 --> 05:36:00,540
transparent proxy that is owned
by our Brock's proxy admin

28395
05:36:00,540 --> 05:36:04,350
contract in the template
Aetherium contracts. GitHub repo

28396
05:36:04,800 --> 05:36:08,610
is actually an examples slash
opens up on proxies branch that

28397
05:36:08,610 --> 05:36:12,120
will show you how to work with
different types of proxies. And

28398
05:36:12,120 --> 05:36:14,700
there will be a link to this in
the GitHub repo associated with

28399
05:36:14,700 --> 05:36:20,040
this course. And then we'll do
our verification, say, chains

28400
05:36:20,070 --> 05:36:24,060
dot includes. And we'll go
ahead, I'm going to copy paste

28401
05:36:24,120 --> 05:36:27,540
our hard hat helper config from
our last project, which has

28402
05:36:27,630 --> 05:36:31,110
development chains, hard hat and
local host that we export, will

28403
05:36:31,110 --> 05:36:36,240
import this as well. const
development chains equals

28404
05:36:36,240 --> 05:36:42,120
require dot slash helper hard
hat config. If development

28405
05:36:42,120 --> 05:36:48,330
chains dot includes network dot
name, and process dot env dot

28406
05:36:48,750 --> 05:36:54,960
ether scan API key log,
verifying that the same as we've

28407
05:36:54,960 --> 05:36:59,430
done a way to verify last, we're
going to copy over our utils

28408
05:36:59,430 --> 05:37:03,900
folder. So just copy, paste, we
now have verify, which will

28409
05:37:03,900 --> 05:37:11,040
import it in here. So we'll do
const verify equals require dot

28410
05:37:11,040 --> 05:37:17,370
dot slash utils, slash verify,
await verify box dot address.

28411
05:37:17,580 --> 05:37:20,640
And then args is going to be
blank. So we'll just do blank

28412
05:37:20,640 --> 05:37:25,350
here, and boom. And that's going
to be it for our box deployment.

28413
05:37:25,620 --> 05:37:28,770
So we can test this out by
running yarn Hardhead deploy,

28414
05:37:29,850 --> 05:37:33,180
see if everything works here.
And that's it done. And then we

28415
05:37:33,180 --> 05:37:37,350
should do actually, we should
add log beach true as well.

28416
05:37:38,130 --> 05:37:41,370
Let's run this again, much
better. So you can see we

28417
05:37:41,400 --> 05:37:44,700
actually deploy a couple of
contracts. So we deploy our box

28418
05:37:44,700 --> 05:37:48,600
proxy admin, which is going to
be our admin contract, then we

28419
05:37:48,600 --> 05:37:53,400
deploy box implementation. So
hard hat deploy, went ahead and

28420
05:37:53,400 --> 05:37:56,820
took our box contract and
renamed it to box implementation

28421
05:37:57,150 --> 05:38:02,610
and then deployed it, then it
deployed our box proxy here. So

28422
05:38:02,610 --> 05:38:05,940
anytime we call this address, it
actually will point to the logic

28423
05:38:05,970 --> 05:38:10,500
of our box. Now what we can do
is we can write a deploy script

28424
05:38:10,530 --> 05:38:14,220
to deploy box, the box v2
implementation, and then upgrade

28425
05:38:14,220 --> 05:38:18,900
our box to box V to create a new
deploy script called Zero to

28426
05:38:19,710 --> 05:38:25,050
deploy box v2 dot j s or deploy
box two dot j s. And we'll do

28427
05:38:25,050 --> 05:38:28,140
something really similar here.
Right, so I'm just going to copy

28428
05:38:28,440 --> 05:38:33,570
pretty much of this, paste it in
here. Now we're going to do

28429
05:38:34,320 --> 05:38:44,610
const box v two equals await,
deploy. Box v two, comma, from

28430
05:38:44,880 --> 05:38:53,430
Deployer. Log True RMS blank,
weights confirmations, it's

28431
05:38:53,430 --> 05:38:57,390
going to be network dot config
dot lock.

28432
05:38:59,550 --> 05:39:04,350
Or masons, then I'm going to
copy the verification code, copy

28433
05:39:04,350 --> 05:39:08,910
this, paste it here, server,
this is going to be box v2 dot

28434
05:39:08,910 --> 05:39:13,320
address. Okay, great. So we now
have some code where we can

28435
05:39:13,320 --> 05:39:17,730
deploy box and box v2. Now let's
go ahead and write a script to

28436
05:39:17,730 --> 05:39:23,310
actually upgrade these. So we'll
do a new folder, scripts. New

28437
05:39:23,310 --> 05:39:28,500
File, and we'll call it upgrade
box dot j s. Now we're going to

28438
05:39:28,500 --> 05:39:30,960
do it the manual way here. And
the reason we're going to do it

28439
05:39:30,960 --> 05:39:33,450
the manual way is because I want
to show you exactly the

28440
05:39:33,450 --> 05:39:36,480
functions that we're calling to
do this upgrade process.

28441
05:39:36,870 --> 05:39:40,590
However, hard hat deploy also
comes with an API to make it

28442
05:39:40,590 --> 05:39:43,980
really easy to actually just
upgrade your box contracts. This

28443
05:39:43,980 --> 05:39:47,160
is gonna be script. So we'll
start off with async function

28444
05:39:47,160 --> 05:39:52,080
main. And then we'll copy paste
our traditional script, main dot

28445
05:39:52,080 --> 05:39:54,840
then process exit blah, blah,
blah, that whole thing. We're

28446
05:39:54,840 --> 05:39:59,370
first gonna get the box proxy
admin contract. We'll say box

28447
05:39:59,370 --> 05:40:06,480
const. Box, proxy admin equals
await ethers dot get contract,

28448
05:40:07,260 --> 05:40:11,520
box proxy admin and we got to
import you Here's from Hardhead,

28449
05:40:11,880 --> 05:40:14,640
then we're going to get the
actual proxy, which is our

28450
05:40:14,640 --> 05:40:20,370
transparent proxy. So we'll say
const transparent proxy equals

28451
05:40:20,370 --> 05:40:26,340
await ethers dot get contract,
box underscore proxy. Since hard

28452
05:40:26,340 --> 05:40:28,350
hat deploy, we'll just name the
proxy the name of the

28453
05:40:28,350 --> 05:40:32,250
implementation underscore proxy.
And then of course, we're going

28454
05:40:32,250 --> 05:40:37,950
to need our box V to contract.
So say const. Box v two equals

28455
05:40:37,950 --> 05:40:44,310
await ethers dot get contract,
box V two. Now we can say const,

28456
05:40:44,340 --> 05:40:50,670
upgrade TX equals a weight box
proxy admin, that upgrade. And

28457
05:40:50,670 --> 05:40:54,090
we're going to call the upgrade
function on our box proxy admin,

28458
05:40:54,120 --> 05:40:56,640
which calls it on our
transparent proxy, which will

28459
05:40:56,640 --> 05:41:01,260
change the implementation from
box one to box two. So box proxy

28460
05:41:01,260 --> 05:41:05,280
admin, that upgrade, we're going
to upgrade the transparent proxy

28461
05:41:05,820 --> 05:41:14,250
dot address to our box B to that
address, it will look in our box

28462
05:41:14,250 --> 05:41:18,210
proxy, a box proxy has an
upgrade function which calls

28463
05:41:18,240 --> 05:41:21,870
upgrade to on our transparent
upgradeable proxy will do a

28464
05:41:21,870 --> 05:41:26,130
weight upgrade TX dot wait one.
And now to work with the

28465
05:41:26,130 --> 05:41:31,020
functions on our box v two,
we're gonna say const proxy box

28466
05:41:31,080 --> 05:41:38,340
equals await ethers dot get
contract. At box v two, we're

28467
05:41:38,340 --> 05:41:42,540
going to get the box v two ABI
however, we're going to load it

28468
05:41:42,900 --> 05:41:48,480
at the transparent proxy
address. This way ethers knows

28469
05:41:48,510 --> 05:41:51,570
okay, we're going to call all of
our functions on the transparent

28470
05:41:51,570 --> 05:41:55,830
proxy address. But this proxy
box is going to have the ABI of

28471
05:41:55,830 --> 05:42:00,090
box v2, which is what we want.
Now we can say const version

28472
05:42:00,150 --> 05:42:05,820
equals await proxy box dot
version. And we'll say console

28473
05:42:05,820 --> 05:42:10,830
dot log version. And if we want
to compare this to its original

28474
05:42:10,830 --> 05:42:14,100
implementation, before we
upgrade, we can do the same

28475
05:42:14,100 --> 05:42:18,900
thing. We can say const proxy
box v1, let's actually call this

28476
05:42:18,930 --> 05:42:23,970
proxy box V to say cost proxy
box v one is going to be this

28477
05:42:23,970 --> 05:42:25,020
exact same thing

28478
05:42:26,280 --> 05:42:34,320
equals this call box here. And
we'll do const version equals

28479
05:42:34,710 --> 05:42:41,370
weight, right proxy box v1 dot
version, console dot log

28480
05:42:41,910 --> 05:42:47,850
version, or version v1, version
v1. We'll call this version v

28481
05:42:47,850 --> 05:42:53,400
two, version v two, and proxy
box V two. So we'll get our

28482
05:42:53,400 --> 05:42:57,660
version v one will upgrade. And
then we'll see at that same

28483
05:42:57,660 --> 05:43:01,530
address what the version
function now returns. So let's

28484
05:43:01,530 --> 05:43:07,020
open our terminal. If I run
yarn, our head node will spin up

28485
05:43:07,020 --> 05:43:12,030
a node will have deployed our
admin our implementation, our

28486
05:43:12,030 --> 05:43:17,100
proxy, and then our box V to
implementation. I'll make a new

28487
05:43:17,100 --> 05:43:23,010
terminal. And I'll run yarn,
hard hat run scripts upgrade box

28488
05:43:23,010 --> 05:43:28,260
that J S dash dash network,
local host. And we should see

28489
05:43:28,290 --> 05:43:31,350
that box actually update. And
that's exactly what we see. And

28490
05:43:31,350 --> 05:43:34,770
then let's do well, it's I
forgot to do.to string in here.

28491
05:43:34,890 --> 05:43:38,130
But it goes from version one to
version two on that exact same

28492
05:43:38,130 --> 05:43:41,970
address. And with that little
code, we have successfully

28493
05:43:42,000 --> 05:43:45,360
learned how to upgrade our smart
contracts programmatically. Now,

28494
05:43:45,360 --> 05:43:49,230
like I said, in the GitHub repo
associated with this lesson, you

28495
05:43:49,230 --> 05:43:53,040
can also check out the upgrades
plugin from open Zeppelin. So to

28496
05:43:53,040 --> 05:43:56,610
work with that, you would just
do upgrades dot deploy proxy

28497
05:43:56,790 --> 05:44:01,350
proxy to call the Prepare
upgrade function, and then

28498
05:44:01,350 --> 05:44:05,340
upgrade upgrade proxy just like
that. They also have an upgrade

28499
05:44:05,370 --> 05:44:07,890
tutorial, step by step for
hardhat that you can follow

28500
05:44:07,890 --> 05:44:10,830
along with as well. Now I know
this was an advanced section.

28501
05:44:10,950 --> 05:44:14,100
And I know we went a little bit
quick here. But honestly, if you

28502
05:44:14,100 --> 05:44:16,800
just finish this section, not
only have you completed all

28503
05:44:16,800 --> 05:44:19,260
these other sections that make
you a really powerful smart

28504
05:44:19,260 --> 05:44:22,860
contract developer. But you've
learned some really advanced

28505
05:44:22,860 --> 05:44:26,190
stuff here. We've gone into low
level code like delegate call,

28506
05:44:26,190 --> 05:44:29,070
we've gotten to assembly we've
gotten to you'll we've gotten to

28507
05:44:29,070 --> 05:44:33,360
these proxy patterns, which can
really make you a an incredible

28508
05:44:33,360 --> 05:44:37,980
stand out developer in the smart
contract space. So if you just

28509
05:44:37,980 --> 05:44:40,230
finished this section, you
should be so so proud of

28510
05:44:40,230 --> 05:44:42,540
yourself because we went really
fast and because there's a lot

28511
05:44:42,540 --> 05:44:46,920
of advanced information here.
Now, like I said, 100 percent, be sure

28512
05:44:46,920 --> 05:44:50,520
to go into the discussions tab
and ask questions and connect

28513
05:44:50,520 --> 05:44:53,610
and talk to other people in the
area. Maybe look at the already

28514
05:44:53,610 --> 05:44:57,090
running discussions and jump in
and start asking other students

28515
05:44:57,270 --> 05:45:00,570
and start asking other people
about what they've learned and

28516
05:45:00,570 --> 05:45:02,940
how their proxies are going. And
if they made anything really

28517
05:45:02,940 --> 05:45:05,460
cool. If you're just excited and
you want to go to the show and

28518
05:45:05,460 --> 05:45:07,830
tell section, make a show and
tell me like hey, here's my

28519
05:45:07,830 --> 05:45:11,370
GitHub repo for doing this
upgrade section. going here and

28520
05:45:11,370 --> 05:45:14,610
be excited with that being said
go and take that coffee break go

28521
05:45:14,610 --> 05:45:18,750
take that walk go to the gym go
get excited Go tell your friends

28522
05:45:18,990 --> 05:45:22,800
we are almost done we have two
lessons left and then you're

28523
05:45:22,800 --> 05:45:23,640
home free

28524
05:45:26,900 --> 05:45:30,980
All right, welcome back to
lesson 17 For hardhat. Douse,

28525
05:45:30,980 --> 05:45:34,580
you're almost done. Now for this
section, I've actually already

28526
05:45:34,580 --> 05:45:37,910
made a video on how to code a
dowel with TypeScript and

28527
05:45:37,910 --> 05:45:41,330
solidity in JavaScript. So we're
actually just going to play this

28528
05:45:41,330 --> 05:45:43,430
video for this section. The
reason we're going to display

28529
05:45:43,430 --> 05:45:45,980
this one is because I did a lot
of work to make this one look

28530
05:45:45,980 --> 05:45:49,700
really good. And it's still
incredibly up to date. So this

28531
05:45:49,700 --> 05:45:52,700
is going to be in TypeScript and
solidity. However, we're going

28532
05:45:52,700 --> 05:45:56,150
to have the JavaScript edition
of the code base in this code

28533
05:45:56,150 --> 05:45:58,790
from the video section. If you
want the most up to date version

28534
05:45:58,820 --> 05:46:02,090
of this delta template code, you
can use, you can select this up

28535
05:46:02,090 --> 05:46:05,300
to date code, which goes to this
doubt template repo. I'll be

28536
05:46:05,300 --> 05:46:09,500
updating this repo periodically
with new Dao examples and new

28537
05:46:09,530 --> 05:46:11,930
ways to create doubts or
decentralized autonomous

28538
05:46:11,930 --> 05:46:14,840
organizations. Now, before we
learn how to code a doubt, we

28539
05:46:14,840 --> 05:46:17,720
should learn what the DAO is.
And again, I've already made a

28540
05:46:17,720 --> 05:46:19,340
video that I've put a lot of
work into. So we're going to

28541
05:46:19,340 --> 05:46:22,280
watch what a Dow is from a high
level first, then we're going to

28542
05:46:22,280 --> 05:46:25,460
learn how to code a Dow. And
then our last section is going

28543
05:46:25,460 --> 05:46:27,710
to be security and auditing. And
we're going to finish this out.

28544
05:46:27,710 --> 05:46:32,450
So Bucklin, let's learn what a
Dow is. And then let's go ahead

28545
05:46:32,480 --> 05:46:39,860
and build a Dow, let's do it.
Now, daos for decentralized

28546
05:46:39,890 --> 05:46:43,400
autonomous organizations is a
bit of an overloaded term. But

28547
05:46:43,400 --> 05:46:46,490
it typically describes any group
that is governed by a

28548
05:46:46,490 --> 05:46:49,520
transparent set of rules found
on a blockchain or smart

28549
05:46:49,520 --> 05:46:53,210
contract. And I say overloaded
because some people say bitcoin

28550
05:46:53,210 --> 05:46:55,880
is down because the miners can
choose whether or not to upgrade

28551
05:46:55,880 --> 05:46:58,550
their software. Other people
think that Dows must use

28552
05:46:58,550 --> 05:47:01,160
transparent smart contracts,
which have the rules ingrained

28553
05:47:01,160 --> 05:47:03,710
right into them. And then other
people think Tao is just a

28554
05:47:03,710 --> 05:47:06,530
buzzword, so they just slap the
name relay on to any

28555
05:47:06,530 --> 05:47:08,900
organization so that they can
get some clout. And this makes

28556
05:47:08,900 --> 05:47:14,030
for sad, Patrick. And it's not
to be confused with the Dow,

28557
05:47:14,060 --> 05:47:17,900
which was an implementation of a
Dow back in 2016, which set the

28558
05:47:17,900 --> 05:47:20,750
record for the largest hack at
that time. So there's a lot of

28559
05:47:20,750 --> 05:47:23,090
different ways to think about
and the Dow term is used in a

28560
05:47:23,090 --> 05:47:25,880
lot of different ways. But in
essence, imagine if all of the

28561
05:47:25,880 --> 05:47:29,720
users of Google were given
voting power into what Google

28562
05:47:29,720 --> 05:47:32,960
should do next. And the rules of
the voting was immutable,

28563
05:47:32,990 --> 05:47:37,010
transparent, and decentralized.
This solves an age old problem

28564
05:47:37,040 --> 05:47:40,010
of trust, centrality and
transparency, and giving the

28565
05:47:40,010 --> 05:47:43,610
power to the users of different
protocols and applications

28566
05:47:43,700 --> 05:47:46,610
instead of everything happening
behind closed doors. And this

28567
05:47:46,610 --> 05:47:49,460
voting piece is a cornerstone of
how these operate this

28568
05:47:49,490 --> 05:47:52,250
Decentralized Governance, if you
will, and it can be summarized

28569
05:47:52,250 --> 05:47:56,030
by company or organization
operated exclusively through

28570
05:47:56,030 --> 05:47:58,940
code. And to really understand
all this, we're going to look

28571
05:47:58,970 --> 05:48:02,060
under the hood of the protocol
that's setting the precedent for

28572
05:48:02,060 --> 05:48:05,300
all other doubts and compound,
then once we look at compound,

28573
05:48:05,330 --> 05:48:08,300
we'll understand what goes into
building one of these and all

28574
05:48:08,300 --> 05:48:10,850
the trade offs, all the
different architectural choices

28575
05:48:10,940 --> 05:48:14,360
mean for your group. And then in
my next video, I'm gonna have a

28576
05:48:14,360 --> 05:48:17,270
full coat along tutorial for
developers looking to build one

28577
05:48:17,270 --> 05:48:19,820
of these themselves. But be
absolutely sure to watch the

28578
05:48:19,820 --> 05:48:21,830
rest of this video because it's
going to give you all the

28579
05:48:21,830 --> 05:48:24,530
architectural fundamentals. So
you can make intelligent

28580
05:48:24,530 --> 05:48:27,200
decisions when you get to that
section. And be sure that you

28581
05:48:27,200 --> 05:48:29,840
and your Dow friends smash the
like and subscribe button. So we

28582
05:48:29,840 --> 05:48:33,950
can keep giving you the best
engineer first content on the

28583
05:48:33,950 --> 05:48:34,280
planet when

28584
05:48:34,280 --> 05:48:37,280
it comes to smart contracts.
Let's get into it. So here we

28585
05:48:37,280 --> 05:48:40,280
have the compound protocol. It's
a borrowing and lending

28586
05:48:40,280 --> 05:48:43,940
application that allows users to
borrow and lend their assets.

28587
05:48:44,090 --> 05:48:46,970
And everything about this
application is built in smart

28588
05:48:46,970 --> 05:48:49,850
contracts. Now, oftentimes,
they're gonna want to do a lot

28589
05:48:49,850 --> 05:48:52,490
of new things, maybe they want
to add a new token to allow

28590
05:48:52,490 --> 05:48:54,830
borrowing and lending, maybe
they're gonna want to change

28591
05:48:55,010 --> 05:48:57,200
some of the API parameters,
maybe they're gonna want to

28592
05:48:57,200 --> 05:48:59,840
block certain coins, there's a
lot of different things that

28593
05:48:59,840 --> 05:49:02,300
they might want to do. So that's
where we're gonna go ahead to

28594
05:49:02,570 --> 05:49:07,040
governance, this is where you
can find a user interface for

28595
05:49:07,040 --> 05:49:10,190
list of all the proposals and
all the different ballots that

28596
05:49:10,190 --> 05:49:13,520
came to be. So here's a list of
some of the governance proposals

28597
05:49:13,550 --> 05:49:16,460
that this protocol has actually
been making to improve. And

28598
05:49:16,460 --> 05:49:18,740
let's look at one of these
proposals that's currently

28599
05:49:18,800 --> 05:49:21,770
actually in process. So if we
click on the proposal, we

28600
05:49:21,770 --> 05:49:25,220
actually see everything about
this proposal, who voted for who

28601
05:49:25,220 --> 05:49:28,760
voted against and the proposal
history here. Now, the first

28602
05:49:28,760 --> 05:49:30,980
thing to one of these proposals
is somebody has to actually

28603
05:49:30,980 --> 05:49:33,980
create the proposal in a
proposed transaction. And we

28604
05:49:33,980 --> 05:49:37,010
actually see that proposed
transaction right here. If we

28605
05:49:37,010 --> 05:49:40,370
click on this, and we scroll
down, we can actually see the

28606
05:49:40,370 --> 05:49:44,000
exact parameters they used to
make this proposal. Let's go

28607
05:49:44,000 --> 05:49:47,030
ahead and decode the input data.
And we can see this is exactly

28608
05:49:47,030 --> 05:49:49,790
what this proposal looks like.
The way that they're typically

28609
05:49:49,820 --> 05:49:53,120
divided is they have a list of
addresses and the list of

28610
05:49:53,120 --> 05:49:55,940
functions to call on those
addresses. And then obviously,

28611
05:49:55,940 --> 05:49:59,840
the parameters to pass those
addresses. So this proposal is

28612
05:49:59,840 --> 05:50:03,470
saying, Hey, I would like to
call Support Market on this

28613
05:50:03,470 --> 05:50:07,640
address, set reserve factor on
this address. Here are the

28614
05:50:07,640 --> 05:50:10,130
parameters we're going to pass.
They're obviously encoded with

28615
05:50:10,130 --> 05:50:13,580
bytes. And then here's the
description string of what this

28616
05:50:13,580 --> 05:50:16,280
is doing and why we're actually
doing this. The reason we have

28617
05:50:16,280 --> 05:50:19,400
to do this proposal governance
process is that these contracts

28618
05:50:19,430 --> 05:50:22,370
likely have access controls
where only the owner of these

28619
05:50:22,370 --> 05:50:25,250
contracts can actually call
these Do functions, and the

28620
05:50:25,250 --> 05:50:28,460
owner of these two contracts is
likely going to be this

28621
05:50:28,460 --> 05:50:31,730
governance style. And values.
Zero just means that we're not

28622
05:50:31,730 --> 05:50:34,520
going to send any eath along
with these transactions, once a

28623
05:50:34,520 --> 05:50:38,240
proposal has been created, after
a short delay to becomes active,

28624
05:50:38,330 --> 05:50:40,850
and this is when people can
actually start voting on them,

28625
05:50:41,000 --> 05:50:44,180
this delay between a proposal
and an act of vote can be

28626
05:50:44,180 --> 05:50:47,510
changed or modified, depending
on your doubt, then people have

28627
05:50:47,510 --> 05:50:50,780
some time to start voting on
them. And if it passes, which

28628
05:50:50,780 --> 05:50:54,800
this one overwhelmingly did, it
reaches succeeded, we click on

28629
05:50:54,800 --> 05:50:57,770
this transaction again, and we
go to the compound governance

28630
05:50:57,770 --> 05:51:02,900
contract. And we scroll down to
contract, right as proxy, we can

28631
05:51:02,900 --> 05:51:07,820
actually see the exact function
that the people call to vote,

28632
05:51:08,180 --> 05:51:12,770
namely cast by vote, cast, vote
by signature and cast vote with

28633
05:51:12,770 --> 05:51:15,530
reason. We'll talk a little bit
about the exact differences

28634
05:51:15,530 --> 05:51:18,380
between these in our next video.
But these are the functions that

28635
05:51:18,380 --> 05:51:22,730
they're actually calling. And if
you go to the compound app, and

28636
05:51:22,730 --> 05:51:25,820
we go over to vote, this is a
user interface you can actually

28637
05:51:25,820 --> 05:51:29,390
vote through to make it easier
if you're not as tech savvy. So

28638
05:51:29,390 --> 05:51:32,810
you can vote right through this
app dot compound at finance. Or

28639
05:51:32,810 --> 05:51:35,180
you can just send the
transaction yourself. Once all

28640
05:51:35,180 --> 05:51:39,620
those votes happen. It reaches
this queued stage. Now what is

28641
05:51:39,620 --> 05:51:43,250
queued mean? Well, before a
proposal actually becomes

28642
05:51:43,280 --> 05:51:47,450
active, there's a minimum delay
between a proposal passing and a

28643
05:51:47,450 --> 05:51:51,230
proposal being executed. So
somebody has to call this cute

28644
05:51:51,230 --> 05:51:55,160
function. And it only can be
called if a vote passes. And it

28645
05:51:55,160 --> 05:51:58,760
says, OK, that postal ID has
been cued, and we're going to

28646
05:51:58,760 --> 05:52:03,140
execute it soon. Now, if we go
to a different proposal, like

28647
05:52:03,140 --> 05:52:05,810
this one, for example, we can
see it has been executed, we can

28648
05:52:05,810 --> 05:52:10,790
see somebody called this
executed function. And they

28649
05:52:10,790 --> 05:52:13,820
executed Proposal A detail. So
this is going to be a full

28650
05:52:13,820 --> 05:52:17,810
example of the lifecycle of a
proposal going through this

28651
05:52:17,810 --> 05:52:21,140
process. Now there are a couple
that even failed, a whole bunch

28652
05:52:21,140 --> 05:52:23,810
of people voted against this.
And if you scroll down, you can

28653
05:52:23,810 --> 05:52:26,360
see it was created, it was
active, and the majority of

28654
05:52:26,360 --> 05:52:30,260
people voted against. So that's
where it stops. Now oftentimes,

28655
05:52:30,290 --> 05:52:32,750
just putting one of these
proposals through isn't enough

28656
05:52:32,750 --> 05:52:36,830
to really garner some votes for
it, you generally want a forum

28657
05:52:36,830 --> 05:52:40,130
or some type of discussion place
to talk about these proposals

28658
05:52:40,130 --> 05:52:42,860
and why you liked them or don't
like them. Oftentimes, a

28659
05:52:42,860 --> 05:52:45,860
discourse is one of the main
places that people are going to

28660
05:52:45,890 --> 05:52:48,980
argue for why something is good,
or why something is bad. So

28661
05:52:48,980 --> 05:52:52,040
people can vote on these
changes. And again, snapshot

28662
05:52:52,040 --> 05:52:54,830
might be one of these tools that
you use to figure out if your

28663
05:52:54,830 --> 05:52:57,920
community even wants something
before it even goes to vote, you

28664
05:52:57,920 --> 05:53:01,070
can join one of these, and with
your tokens actually vote on

28665
05:53:01,070 --> 05:53:03,080
things without them being
executed just to get the

28666
05:53:03,080 --> 05:53:06,080
sentiment or like I said before,
you could build your protocol in

28667
05:53:06,080 --> 05:53:08,180
a way that snapshot actually
helps you with the voting

28668
05:53:08,180 --> 05:53:11,510
process. All right, now you've
seen the protocol that has been

28669
05:53:11,510 --> 05:53:14,300
influencing all the other
details on how to vote. Now, you

28670
05:53:14,300 --> 05:53:17,210
know, now that we know what a
doubt looks like,

28671
05:53:17,240 --> 05:53:19,400
let's talk about the
architecture and tools that go

28672
05:53:19,400 --> 05:53:21,890
into building one of these and
additionally the trade offs that

28673
05:53:21,890 --> 05:53:24,590
they have. And the first thing
to talk about here is going to

28674
05:53:24,590 --> 05:53:27,650
be the voting mechanism. Now
voting in Decentralized

28675
05:53:27,650 --> 05:53:31,340
Governance is critical to these
days, because sometimes they do

28676
05:53:31,340 --> 05:53:34,370
need to update and change to
keep up with the times. Not all

28677
05:53:34,370 --> 05:53:37,220
protocols need to have a Dow,
but those that do need to have a

28678
05:53:37,220 --> 05:53:40,430
doubt need a way for the
participants to engage. This is

28679
05:53:40,430 --> 05:53:43,580
one of the most important
questions to ask him to tell

28680
05:53:43,580 --> 05:53:47,420
your communities. How do I
participate? How do I engage in

28681
05:53:47,420 --> 05:53:51,320
this doubt? How do I help make
decisions and you'll find this

28682
05:53:51,320 --> 05:53:55,430
is a bit of a tricky problem to
solve. Now, an easy approach to

28683
05:53:55,430 --> 05:53:58,880
this problem is going to be
using an ERC 20 or an NFT token

28684
05:53:59,090 --> 05:54:02,480
as voting power. Similar to what
we saw with compound use the

28685
05:54:02,480 --> 05:54:06,230
comp token to vote for different
proposals seems simple enough,

28686
05:54:06,230 --> 05:54:09,770
right? Boom, problem solved
gray. Now, this actually might

28687
05:54:09,770 --> 05:54:12,440
be the right approach for
certain doubts. But it also runs

28688
05:54:12,440 --> 05:54:15,830
the risk of actually being less
fair. Because when you tokenize

28689
05:54:15,830 --> 05:54:18,530
the voting power, you're
essentially auctioning off this

28690
05:54:18,530 --> 05:54:21,860
voting power to whoever's got
the deepest pockets, whoever has

28691
05:54:21,860 --> 05:54:25,040
the most money gets to pick the
changes. So if it's only the

28692
05:54:25,040 --> 05:54:28,160
rich people who get to vote,
then it's highly likely that all

28693
05:54:28,160 --> 05:54:31,880
the changes in the protocol are
going to benefit the rich, which

28694
05:54:31,880 --> 05:54:34,610
doesn't really seem like that
great of an improvement over our

28695
05:54:34,640 --> 05:54:37,190
current world. And if T's are
interesting, because they have

28696
05:54:37,190 --> 05:54:41,060
this non fungible component, but
yet, even they still run into

28697
05:54:41,060 --> 05:54:43,730
this issue. Additionally, if you
buy a whole bunch of votes, you

28698
05:54:43,730 --> 05:54:47,000
make a bad decision and then
sell all your votes. You as an

28699
05:54:47,000 --> 05:54:49,730
individual don't really get
punished, you just punish the

28700
05:54:49,730 --> 05:54:52,760
group as a whole. But you being
malicious, you can get away with

28701
05:54:52,760 --> 05:54:55,400
pretty scot free now again, this
voting mechanism is going to be

28702
05:54:55,400 --> 05:55:00,260
correct for some groups, but for
other groups, maybe not. It

28703
05:55:00,260 --> 05:55:02,930
really just depends on what your
down community setup is going to

28704
05:55:02,930 --> 05:55:04,760
look like. Now the next one
we're going to talk about is

28705
05:55:04,790 --> 05:55:07,910
skin in the game. Now metallic
has actually written a lot about

28706
05:55:07,910 --> 05:55:10,640
this and I highly recommend you
read his article, link in the

28707
05:55:10,640 --> 05:55:13,640
description to see that the skin
in the game method means that

28708
05:55:13,640 --> 05:55:16,970
whenever you make a decision,
your vote is recorded. And if

28709
05:55:16,970 --> 05:55:21,470
that decision leads to a bad
outcome, your tokens are axed.

28710
05:55:21,500 --> 05:55:25,220
You get punished for making evil
or bad decisions for your Dao

28711
05:55:25,220 --> 05:55:27,560
and your protocol. I like this
mentality because even if you

28712
05:55:27,560 --> 05:55:30,380
buy a ton of tokens and decide
to be ill with it, you can be

28713
05:55:30,380 --> 05:55:33,530
held accountable for your bad
decisions. Now, the hardest part

28714
05:55:33,530 --> 05:55:37,190
about this, though, is gonna be
how do we decide as a community?

28715
05:55:37,220 --> 05:55:40,100
What is bad outcome? How do we
actually punish these people?

28716
05:55:40,160 --> 05:55:45,740
And that's easy, because the
answer is, I'm not sure. Now,

28717
05:55:45,740 --> 05:55:48,620
the third method of this voting
mechanism is probably one of the

28718
05:55:48,620 --> 05:55:51,710
most interesting ones, but also
the hardest ones to implement.

28719
05:55:51,980 --> 05:55:55,940
And this is proof of personhood,
or participation. Imagine that

28720
05:55:55,970 --> 05:55:58,880
all users of the compound
protocol were given a single

28721
05:55:58,880 --> 05:56:02,540
vote simply because they use the
protocol. And even if they had

28722
05:56:02,540 --> 05:56:06,410
1000 wallets, they use the
protocol. One human being means

28723
05:56:06,440 --> 05:56:09,350
one vote, this would be amazing,
and a far more fair

28724
05:56:09,350 --> 05:56:11,810
implementation where votes
couldn't actually just be

28725
05:56:11,810 --> 05:56:14,810
bought. The issue, however,
comes in something known as

28726
05:56:14,840 --> 05:56:19,100
civil resistance, how can we be
sure that it's one vote equals

28727
05:56:19,130 --> 05:56:22,070
one participant and not one
participant pretending to be

28728
05:56:22,070 --> 05:56:25,100
1000s of different people, so
they get more votes. This method

28729
05:56:25,130 --> 05:56:27,710
hasn't really been solved yet.
But I'm willing to bet some very

28730
05:56:27,710 --> 05:56:30,530
clever engineer will do some
amazing chainlink integration,

28731
05:56:30,530 --> 05:56:33,860
because proof of personhood is
basically just off chain data

28732
05:56:33,920 --> 05:56:36,050
that can be delivered on chain.
And that's exactly where

28733
05:56:36,050 --> 05:56:39,380
channeling shines. Now, as you
can see all of these methods and

28734
05:56:39,380 --> 05:56:42,050
even more that you probably
think of aren't that far

28735
05:56:42,050 --> 05:56:45,020
fetched. And we actually see
these exact same methods

28736
05:56:45,020 --> 05:56:48,110
happening in the real world.
Proof of personhood or proof of

28737
05:56:48,110 --> 05:56:51,200
participation might just be the
exact same as kind of the

28738
05:56:51,200 --> 05:56:54,080
regular government voting that
we see every day. In the United

28739
05:56:54,080 --> 05:56:57,590
States, at least one person gets
to vote for one president, you

28740
05:56:57,590 --> 05:57:00,470
can't go around making a whole
bunch of fake people and voting

28741
05:57:00,470 --> 05:57:03,710
for president. But in companies
the ERC 20 voting standard kind

28742
05:57:03,710 --> 05:57:06,950
of applies, the more shares of a
company you have maybe the more

28743
05:57:07,010 --> 05:57:09,170
voting power you have in that
company. So we can draw

28744
05:57:09,170 --> 05:57:11,990
parallels between the real world
and how voting and governance is

28745
05:57:11,990 --> 05:57:14,330
going to work in our smart
contracts. And in fact, you

28746
05:57:14,330 --> 05:57:17,090
should draw parallels and look
for inspiration from the web to

28747
05:57:17,090 --> 05:57:19,760
space. Now when it comes to
implementation of the voting, I

28748
05:57:19,760 --> 05:57:22,970
put them into two categories on
chain voting and off chain

28749
05:57:22,970 --> 05:57:25,550
voting on chain voting is
exactly what we saw with

28750
05:57:25,550 --> 05:57:29,600
compound, the smart contract on
chain, your voter, you call some

28751
05:57:29,600 --> 05:57:32,030
function called vote with your
meta mask your ledger or

28752
05:57:32,030 --> 05:57:36,110
whatever, send a transaction and
vote, you voted Congrats, you

28753
05:57:36,110 --> 05:57:38,660
can wear your little sticker now
call that function and you send

28754
05:57:38,660 --> 05:57:43,100
a transaction, you send a
transaction, what are the

28755
05:57:43,100 --> 05:57:45,950
transactions use that are kind
of annoying and kind of costly?

28756
05:57:47,300 --> 05:57:49,880
Oh, that's right gas, I imagine
you have 10,000 people in your

28757
05:57:49,880 --> 05:57:53,540
community and it costs $100 To
vote per person, you're now

28758
05:57:53,540 --> 05:57:57,560
costing your community $1
million. Anytime you want to

28759
05:57:57,560 --> 05:57:59,840
change anything. This is
obviously insane, and not very

28760
05:57:59,840 --> 05:58:02,000
sustainable for your community
pro here is that the

28761
05:58:02,000 --> 05:58:04,310
architecture is really easy.
Everything's going to be

28762
05:58:04,310 --> 05:58:06,560
transparent, everything's going
to be on chain. And that's

28763
05:58:06,560 --> 05:58:09,110
really good. But yes, the con is
that you're going to break the

28764
05:58:09,110 --> 05:58:11,930
bank account for a lot of people
potentially. Now there are a lot

28765
05:58:11,930 --> 05:58:14,540
of variations of this to help
solve some of these problems,

28766
05:58:14,540 --> 05:58:17,480
especially the gas problem. One
of the ones that I'm incredibly

28767
05:58:17,480 --> 05:58:20,480
excited for is this one called
governor's seat, where they use

28768
05:58:20,480 --> 05:58:23,840
some random sampling to do some
quadratic voting to help reduce

28769
05:58:23,840 --> 05:58:26,450
costs while increasing civil
resistance. You want to learn

28770
05:58:26,450 --> 05:58:28,850
more about that one to be sure
to read about it in the

28771
05:58:28,850 --> 05:58:31,970
description. So on chain voting
is the simplest one here. But

28772
05:58:31,970 --> 05:58:36,530
let's talk about off chain
voting. To cast the vote off to

28773
05:58:36,620 --> 05:58:39,980
decentralized context, relax,
relax, you can vote off chain

28774
05:58:39,980 --> 05:58:42,590
and still have the 100%
decentralized, you can actually

28775
05:58:42,590 --> 05:58:46,910
sign a transaction and sign a
vote without actually sending to

28776
05:58:46,910 --> 05:58:49,340
a blockchain and therefore
without actually spending any

28777
05:58:49,340 --> 05:58:53,180
gas. Instead, what you can do is
send that signed transaction to

28778
05:58:53,180 --> 05:58:57,140
a decentralized database like
IPFS, count up all the votes in

28779
05:58:57,140 --> 05:59:01,130
IPFS. And then when time comes,
deliver the result of that data

28780
05:59:01,220 --> 05:59:03,560
through something like an Oracle
like chain link to the

28781
05:59:03,560 --> 05:59:06,830
blockchain all in a single
transaction. Alternatively, what

28782
05:59:06,830 --> 05:59:10,190
you could do is you could replay
all the same transactions in a

28783
05:59:10,190 --> 05:59:13,400
single transaction to save gas,
this can reduce the voting cost

28784
05:59:13,400 --> 05:59:16,910
by up to 99%. Right now, this is
an implementation and one of the

28785
05:59:16,910 --> 05:59:20,360
most popular ways to do this is
through snapshot. And I'm just

28786
05:59:20,450 --> 05:59:23,000
dying for someone to make a
chain link integration because

28787
05:59:23,000 --> 05:59:26,030
it's going to be so much safer,
more secure and better and blah,

28788
05:59:26,030 --> 05:59:28,940
blah, blah, die for it. This is
your call to action go build

28789
05:59:28,940 --> 05:59:31,700
this thing. This option. voting
mechanism obviously saves a ton

28790
05:59:31,700 --> 05:59:35,030
of gas to the community and can
be a more efficient way to store

28791
05:59:35,030 --> 05:59:37,280
these transactions anyways,
however, it needs to be

28792
05:59:37,280 --> 05:59:40,010
implemented very carefully. If
you run your entire Dow through

28793
05:59:40,010 --> 05:59:43,340
a centralized Oracle, you are
essentially reintroducing a

28794
05:59:43,370 --> 05:59:45,950
centralized intermediary and
ruining the decent quality of

28795
05:59:45,950 --> 05:59:48,230
your application. So don't do
that. And if you made it to this

28796
05:59:48,230 --> 05:59:50,390
point of the video, give
yourself a little pat on the

28797
05:59:50,390 --> 05:59:53,720
back. You're doing fantastic.
Fantastic. Like I said, I have a

28798
05:59:53,720 --> 05:59:56,570
video coming out after this one
it's going to show you end to

28799
05:59:56,570 --> 05:59:59,090
end how to build one of these
from scratch let's learn about

28800
05:59:59,090 --> 06:00:02,180
some of the tools that you can
use to help get you up to speed

28801
06:00:02,180 --> 06:00:04,940
quicker. Now there are a number
of no code solutions that can go

28802
06:00:04,940 --> 06:00:10,760
into building one of these
dowels Tao stack Aragon. Just

28803
06:00:10,760 --> 06:00:13,730
kidding, this is Aragon, colony
and Tao house are all

28804
06:00:13,730 --> 06:00:16,910
alternatives that can actually
help you with the upside of

28805
06:00:16,910 --> 06:00:19,610
running a Dao and building a
doubt. However, if you want more

28806
06:00:19,610 --> 06:00:21,920
granular control and you don't
want to have to pay any the fees

28807
06:00:21,920 --> 06:00:24,320
associated with these protocols,
you might want to Do it from

28808
06:00:24,320 --> 06:00:26,840
scratch. Now let's talk about
some of the more Cody solutions

28809
06:00:26,870 --> 06:00:29,390
that you can use snapshot is one
of the most popular tools out

28810
06:00:29,390 --> 06:00:32,900
there for both getting the
sentiment of a Dao. And actually

28811
06:00:32,900 --> 06:00:35,930
performing that execution, users
can vote through this protocol

28812
06:00:35,960 --> 06:00:39,200
with their actual tokens, those
transaction gets stored in IPFS.

28813
06:00:39,200 --> 06:00:42,110
But none of it actually gets
executed. Unless the doubt

28814
06:00:42,110 --> 06:00:46,250
chooses to, this can be a great
way to get a feel for what your

28815
06:00:46,280 --> 06:00:50,060
Dow wants to do. And Optionally,
you can send the transactions

28816
06:00:50,060 --> 06:00:53,330
and execute the votes as well
highly recommend checking out

28817
06:00:53,360 --> 06:00:56,630
Zodiac which is a suite of
database tools for you to

28818
06:00:56,630 --> 06:00:59,210
implement into your Dallas as
well tally is another one of

28819
06:00:59,210 --> 06:01:02,240
these UIs that allows people to
see and actually vote and

28820
06:01:02,270 --> 06:01:04,430
interact with these smart
contracts through user

28821
06:01:04,430 --> 06:01:06,680
interface. So those of you who
don't know about Gnosis safe,

28822
06:01:06,710 --> 06:01:10,100
you absolutely should know Safe
is a multi SIG wallet. And the

28823
06:01:10,100 --> 06:01:12,620
reason I put this on the list,
even though it's adds kind of

28824
06:01:12,620 --> 06:01:15,260
this centrality component is
that most dowels in the

28825
06:01:15,260 --> 06:01:18,470
beginning, are probably going to
start with some type of

28826
06:01:18,470 --> 06:01:20,900
centrality, it's much easier to
be fast when you don't have

28827
06:01:20,930 --> 06:01:23,870
1000s of people to wait for a
vote. And in the beginning, any

28828
06:01:23,870 --> 06:01:26,060
protocol is going to be
centralized to some degree

28829
06:01:26,060 --> 06:01:29,060
anyways, using a multisig, we're
voting happens through only a

28830
06:01:29,150 --> 06:01:32,660
few key members can be good in
the beginning for your dials,

28831
06:01:32,720 --> 06:01:36,230
and often emergencies as well.
But just keep in mind, when you

28832
06:01:36,230 --> 06:01:39,170
add one of these, you are adding
this level of centrality, and

28833
06:01:39,170 --> 06:01:41,840
then of course opens up and
contracts we love opens up and

28834
06:01:41,840 --> 06:01:43,640
contracts. These are the
contracts that we're going to be

28835
06:01:43,640 --> 06:01:46,610
basing our Dao code along.
Alright, so that's all the

28836
06:01:46,610 --> 06:01:49,610
tools. That's the architecture.
One more thing before I let you

28837
06:01:49,610 --> 06:01:53,000
go legality, the future of Dows
is interesting for all these

28838
06:01:53,000 --> 06:01:55,820
reasons we just talked about,
but especially on a legal front,

28839
06:01:55,880 --> 06:01:58,640
does it make sense for a doubt
to live by the same regulation

28840
06:01:58,640 --> 06:02:01,070
as another company? Why would
you even force it down to do

28841
06:02:01,070 --> 06:02:03,530
something, you'd have to enforce
them to all vote a certain way

28842
06:02:03,530 --> 06:02:07,100
if the government tells you to,
it's a little gray, it's hard to

28843
06:02:07,100 --> 06:02:09,950
nail down who to even keep
accountable for these days and

28844
06:02:09,950 --> 06:02:12,710
the United States at least you
can actually form your own Dow

28845
06:02:12,710 --> 06:02:15,860
and have it legally recognized
in the state of Wyoming. This is

28846
06:02:15,860 --> 06:02:18,110
something I want to do. So we'll
just have to see what happens

28847
06:02:18,110 --> 06:02:22,190
there. Oh, at this point, you
have been injected with all the

28848
06:02:22,190 --> 06:02:25,970
Dow knowledge you need to
succeed and thrive with this new

28849
06:02:26,000 --> 06:02:29,360
amazing technology and these new
amazing concepts. And I found

28850
06:02:29,360 --> 06:02:32,570
them kill baby. All right, well,
you heard him it's time to

28851
06:02:32,570 --> 06:02:36,260
build. Like we said, All the
code is going to be located in

28852
06:02:36,260 --> 06:02:38,270
less than 17 Here, let's jump
in.

28853
06:02:44,120 --> 06:02:46,700
In this video, we're going to
show you how to build your own

28854
06:02:46,700 --> 06:02:51,320
doubt inspired by compound now
this is going to be 100% on

28855
06:02:51,320 --> 06:02:53,750
chain voting and on chain
governance. We're going to show

28856
06:02:53,750 --> 06:02:57,710
you the easiest way to spin up
an NFT or ERC 20 voting type

28857
06:02:57,710 --> 06:03:00,830
down all using solidity and
hardhat. Now if you haven't

28858
06:03:00,830 --> 06:03:03,710
watched my last video going over
the architecture of Dows, what

28859
06:03:03,710 --> 06:03:05,660
goes into one of these be
absolutely sure to watch that

28860
06:03:05,660 --> 06:03:08,300
video first and then come to
this video. Because that video

28861
06:03:08,300 --> 06:03:10,940
explains all the philosophy
behind what we're doing here

28862
06:03:10,970 --> 06:03:13,520
we're going to be using opens up
and contracts and a hard hat

28863
06:03:13,520 --> 06:03:16,040
framework to build this all in
solidity. If you want to see a

28864
06:03:16,040 --> 06:03:18,410
brand new or Pythonic version of
doing this, check the link in

28865
06:03:18,410 --> 06:03:20,810
the description because we did a
video over at the chainlink

28866
06:03:20,810 --> 06:03:23,630
hackathon recently. And
additionally, additionally, we

28867
06:03:23,630 --> 06:03:27,410
know that because we're doing
this 100% on chain gas fees are

28868
06:03:27,410 --> 06:03:30,110
going to be expensive. So I'm
really looking forward to

28869
06:03:30,110 --> 06:03:33,890
somebody doing a chain link plus
IPFS plus snapshot integration

28870
06:03:33,920 --> 06:03:36,830
so that we can do all this off
chain. And once that exists, you

28871
06:03:36,830 --> 06:03:38,900
already know I'm gonna make a
tutorial on that. And if you

28872
06:03:38,900 --> 06:03:41,180
like this style of content, be
sure to smash that like button,

28873
06:03:41,180 --> 06:03:43,640
subscribe and leave a comment in
the comment section to let me

28874
06:03:43,640 --> 06:03:45,650
know what you want to see. Next,
let me know how you want to

28875
06:03:45,650 --> 06:03:48,740
supercharge your smart contract
developer experience. So let's

28876
06:03:48,740 --> 06:03:52,070
jump in. Right, so here's what
we're going to be building,

28877
06:03:52,130 --> 06:03:55,700
we're gonna have a very basic
smart contract here, right, it's

28878
06:03:55,700 --> 06:03:59,990
called box and all it can do is
store a value and then retrieve

28879
06:04:00,020 --> 06:04:04,370
a value. But the thing is, its
ownable. And only the owner of

28880
06:04:04,370 --> 06:04:07,370
this contract can call the store
function and guess who the owner

28881
06:04:07,370 --> 06:04:10,310
is going to be the owner is
going to be the doubt. So only

28882
06:04:10,340 --> 06:04:14,030
through a process of governance,
can anyone store a different

28883
06:04:14,030 --> 06:04:16,640
function here. And once we're
done, we're going to go through

28884
06:04:16,640 --> 06:04:20,960
the entire process of proposing
voting queueing and then

28885
06:04:20,990 --> 06:04:25,310
executing a transaction in a Dao
to update our Bach contract. And

28886
06:04:25,310 --> 06:04:27,350
that's one of the beautiful
things about these these Dao

28887
06:04:27,350 --> 06:04:30,320
setups is that they're
completely modular, right. And

28888
06:04:30,320 --> 06:04:33,830
so when I go through the whole
process, I'll do Hardhead tests

28889
06:04:33,830 --> 06:04:36,020
here, which my tests right now
are set up to just do

28890
06:04:36,020 --> 06:04:40,340
everything, we're going to see
every single step that this Dow

28891
06:04:40,340 --> 06:04:44,060
is going to take. So we see box
starting value is going to be

28892
06:04:44,060 --> 06:04:47,450
zero. And then all of this stuff
is going to the governance

28893
06:04:47,450 --> 06:04:49,880
process. These are just some
some notes. Basically people are

28894
06:04:49,880 --> 06:04:53,840
voting, queueing and executing.
And then at the end, we chained

28895
06:04:53,840 --> 06:04:58,190
the value of the box contract
through a voting process. And

28896
06:04:58,190 --> 06:05:00,620
that's exactly what we're gonna
show you how to do today. Now

28897
06:05:00,620 --> 06:05:03,290
remember all the code for what
we're going to be doing here is

28898
06:05:03,320 --> 06:05:06,830
in my doubt template GitHub repo
so if you ever get lost, feel

28899
06:05:06,830 --> 06:05:10,220
free to refer back to this to
get started. And additionally,

28900
06:05:10,220 --> 06:05:13,160
if you want to see the Pythonic
version of this, feel free to go

28901
06:05:13,160 --> 06:05:16,310
back to the downmix The main
thing is though that all the

28902
06:05:16,310 --> 06:05:19,460
contracts are going to be the
same no matter what brownie hard

28903
06:05:19,460 --> 06:05:22,490
hat, dab tools, foundry, it
doesn't matter. So the first

28904
06:05:22,490 --> 06:05:25,970
part of this section is gonna be
exactly the same. And here's our

28905
06:05:26,000 --> 06:05:29,090
agenda here. First, we're gonna
write the smart contract. So if

28906
06:05:29,090 --> 06:05:31,010
you're not familiar with
Hardhead, who cares, we're gonna

28907
06:05:31,010 --> 06:05:33,350
be doing the smart contracts
first, then we are going to

28908
06:05:33,350 --> 06:05:35,750
write deployment scripts. And
this is where your hard hat

28909
06:05:35,750 --> 06:05:38,030
knowledge is going to come into
play. We're going to be writing

28910
06:05:38,030 --> 06:05:40,460
our deployment scripts in
TypeScript here, because

28911
06:05:40,460 --> 06:05:42,590
TypeScript is phenomenal. If
you're unfamiliar with

28912
06:05:42,590 --> 06:05:45,890
TypeScript, I challenge you to
rewrite this in JavaScript and

28913
06:05:45,890 --> 06:05:47,750
make a JavaScript version. And
then finally, we're going to

28914
06:05:47,750 --> 06:05:51,110
write some scripts to interact
with our governance with our

28915
06:05:51,110 --> 06:05:54,740
deployed contracts. Now, a quick
note, this isn't how I

28916
06:05:54,740 --> 06:05:57,320
originally built this, I didn't
just read smart contracts, write

28917
06:05:57,320 --> 06:05:59,480
deployment scripts, write the
scripts, and then the tests and

28918
06:05:59,480 --> 06:06:02,570
boom, I was done, I had a back
and forth between tests, smart

28919
06:06:02,570 --> 06:06:05,420
contracts, deploy scripts, etc.
If you're thinking, Oh, my

28920
06:06:05,420 --> 06:06:07,400
goodness, that's so easy for him
to go through this. So

28921
06:06:07,400 --> 06:06:10,190
seamlessly. When I originally
wrote this code, it was a lot of

28922
06:06:10,190 --> 06:06:12,170
back and forth. And that's how
you should be developing, you're

28923
06:06:12,170 --> 06:06:14,450
going to be moving between tests
and smart contracts and stuff.

28924
06:06:14,630 --> 06:06:17,450
Additionally, in this tutorial,
we are going to show you some

28925
06:06:17,450 --> 06:06:20,660
sick Hardhead skills. So you are
not only gonna learn how to

28926
06:06:20,660 --> 06:06:23,660
build a Dow, but you're gonna
learn some really advanced

28927
06:06:23,690 --> 06:06:28,070
Hardhead skills. So let's jump
in. Let's do this. So the code

28928
06:06:28,070 --> 06:06:30,530
editor I'm using is Visual
Studio code. So make sure you

28929
06:06:30,530 --> 06:06:34,250
have a code editor up and ready
to go. And you'll need a couple

28930
06:06:34,250 --> 06:06:38,030
of prerequisites here. Again,
the prerequisites are in the

28931
06:06:38,120 --> 06:06:41,870
GitHub repository, we're going
to need Git, no J, s. And yarn,

28932
06:06:41,900 --> 06:06:44,450
if you want to just clone this
repo and follow the instructions

28933
06:06:44,450 --> 06:06:47,180
here to get started, you
absolutely 100% can and then you

28934
06:06:47,180 --> 06:06:49,010
don't even need to build this
from scratch. But we're going to

28935
06:06:49,010 --> 06:06:51,980
want to learn to build this from
scratch. So let's just start git

28936
06:06:51,980 --> 06:06:55,850
dash dash version. Great, we
have Git no dash dash version.

28937
06:06:56,120 --> 06:06:59,480
Great, we have node, and then
yarn dash dash version. Great,

28938
06:06:59,480 --> 06:07:01,640
we have yarn, we can get
started. So everything that

28939
06:07:01,640 --> 06:07:04,280
we're going to be installing
here for packages is going to be

28940
06:07:04,310 --> 06:07:07,340
a dev dependency. So the first
thing we need to do is do yarn,

28941
06:07:07,520 --> 06:07:10,040
add dash dash Dev, hard hat,

28942
06:07:10,220 --> 06:07:13,790
if you'd haven't already. And
now in our folder, we're gonna

28943
06:07:13,790 --> 06:07:17,360
have node modules package dot
JSON readme and a lock. Of

28944
06:07:17,360 --> 06:07:20,840
course, now that we have that we
can run yarn RDAP, we're gonna

28945
06:07:20,840 --> 06:07:23,330
get the hard hat CLI up. And
we're going to have all this

28946
06:07:23,330 --> 06:07:25,850
stuff in here, we're just going
to create an empty hardhat dot

28947
06:07:25,850 --> 06:07:28,190
config dot j s, and we're going
to turn it to TypeScript. The

28948
06:07:28,190 --> 06:07:30,350
advanced sample TypeScript
project has a bunch of stuff

28949
06:07:30,350 --> 06:07:32,270
that I don't like. So we're just
going to create an empty

28950
06:07:32,270 --> 06:07:35,690
hardhead.config.js. And perfect,
we've got a little hard

28951
06:07:35,690 --> 06:07:39,560
hat.config.js. Now let's go
ahead and create a folder, or

28952
06:07:39,560 --> 06:07:42,920
contracts folder. And this is
where we're going to add all of

28953
06:07:42,920 --> 06:07:44,870
our contracts. So the first
thing contract that we're going

28954
06:07:44,870 --> 06:07:48,560
to need is the contracts we want
to have govern, which in our

28955
06:07:48,560 --> 06:07:52,490
case is going to be box dot
soul. Now, I am actually just

28956
06:07:52,490 --> 06:07:55,430
going to copy paste my box, that
soul here, because it's not

28957
06:07:55,430 --> 06:07:58,790
particularly interesting. But
you could really code whatever

28958
06:07:58,790 --> 06:08:01,280
you want here. So feel free to
pause the video, copy paste from

28959
06:08:01,280 --> 06:08:04,070
my GitHub repo, create your own
governance contract that you

28960
06:08:04,070 --> 06:08:06,380
want to play with, or do
whatever you want here. But for

28961
06:08:06,380 --> 06:08:09,320
us, we just have a store
function, and retrieve function,

28962
06:08:09,530 --> 06:08:12,740
and an event, and then a private
value that we're going to be

28963
06:08:12,740 --> 06:08:16,280
storing and retrieving. And
that's it. So of course, we want

28964
06:08:16,280 --> 06:08:19,190
to fix this. We're importing
from openzeppelin contracts

28965
06:08:19,190 --> 06:08:23,360
opens up is amazing. We're gonna
want to add this we'll do yarn,

28966
06:08:23,390 --> 06:08:27,800
add dash dash Dev, at opens up
on contracts. And that should

28967
06:08:27,800 --> 06:08:32,000
get rid of the box. That's all.
let's reopen box. And boom,

28968
06:08:32,060 --> 06:08:34,820
looks like we did a detour to
that perfect. And for

28969
06:08:34,820 --> 06:08:38,660
extensions, I'm using the
solidity, the one Blonko, slit

28970
06:08:38,660 --> 06:08:40,580
extension. And that's what we
get this wonderful linting

28971
06:08:40,580 --> 06:08:43,460
things here. Great. So now we
want to check to see if this

28972
06:08:43,460 --> 06:08:46,430
compiles if using remix, you can
compile with remix hard hat,

28973
06:08:46,460 --> 06:08:49,010
you're gonna see how we compile
here. Or if you're using you

28974
06:08:49,010 --> 06:08:52,070
know, Browning, we just want to
see if this compiles correctly.

28975
06:08:52,130 --> 06:08:55,820
So run yarn had a hard hit
Compile. Looks like we ran into

28976
06:08:56,150 --> 06:08:59,210
some compilation errors, because
we need to update this, let's

28977
06:08:59,210 --> 06:09:02,720
use these 8.8 of solidity we'll
try to compile again. And

28978
06:09:02,720 --> 06:09:05,330
perfect looks like we're
compiling successfully. Look

28979
06:09:05,330 --> 06:09:08,720
here, we do indeed have our
contract in here. Okay, perfect,

28980
06:09:09,050 --> 06:09:12,020
easy part out of the way.
Already. That was so quick. Now

28981
06:09:12,050 --> 06:09:14,870
let's start creating the next
part. Let's create the

28982
06:09:14,870 --> 06:09:17,510
governance part. So what we're
going to be working with to

28983
06:09:17,510 --> 06:09:21,080
build this governance platform
is we're gonna be building it

28984
06:09:21,080 --> 06:09:24,500
off of the ERC. 20 standard, so
you're gonna get an ERC 20

28985
06:09:24,500 --> 06:09:27,650
token. And that's going to be
the token that you get to vote.

28986
06:09:27,710 --> 06:09:32,420
So let's create a new file
called governance token. That's

28987
06:09:32,420 --> 06:09:36,620
all governance token dot Sol.
And this is gonna be the code

28988
06:09:36,650 --> 06:09:38,780
for the token that we use to
actually vote. Now we're going

28989
06:09:38,780 --> 06:09:42,230
to create a normal ERC 20 token.
And then we're going to extend

28990
06:09:42,230 --> 06:09:44,900
it to make it governance a bowl
and you'll understand what I

28991
06:09:44,900 --> 06:09:48,980
mean in a second. So let's go
ahead and make this spdx license

28992
06:09:49,640 --> 06:09:55,940
identifier. It's going to be MIT
pragma solidity we'll do zero

28993
06:09:56,720 --> 06:10:01,130
point 8.8. And then we'll do
contract governance token, and

28994
06:10:01,130 --> 06:10:04,280
then we'll say is ERC 20 I'm
just gonna go ahead and import

28995
06:10:04,310 --> 06:10:07,130
openzeppelin Because open
Zeppelin has a package where

28996
06:10:07,160 --> 06:10:10,070
basically has everything we need
for an ERC 20 token. So we're

28997
06:10:10,070 --> 06:10:13,670
gonna say import at open
Zeppelin slash contracts slash

28998
06:10:13,670 --> 06:10:19,430
token slash ERC 20x We can go to
their github openzeppelin

28999
06:10:20,060 --> 06:10:25,760
contracts token, your C 20 And
we'll do ERC 20 Dotto, we'll do

29000
06:10:25,760 --> 06:10:26,450
this for now.

29001
06:10:27,080 --> 06:10:31,280
token, use your C 20 ditzel.
We're gonna change this, but

29002
06:10:31,280 --> 06:10:34,970
don't worry about that yet. Now
we're going to do a un 256

29003
06:10:35,030 --> 06:10:39,590
Public Storage Max supply, it's
the best practice, but it's

29004
06:10:39,590 --> 06:10:42,500
fine, we'll give this a max
supply this much was going to be

29005
06:10:42,500 --> 06:10:48,290
1-234-567-8910 12345678. So it's
gonna be 1 million, we're gonna

29006
06:10:48,290 --> 06:10:50,870
do 1 million of these tokens.
And then we're gonna create the

29007
06:10:50,870 --> 06:10:57,020
constructor construct or your C
20. Give it governance token as

29008
06:10:57,020 --> 06:11:00,290
a name, and then our symbol is
going to be GT. And for those

29009
06:11:00,290 --> 06:11:04,010
who who don't know, when you
inherit another contract in your

29010
06:11:04,010 --> 06:11:07,820
constructor, you can use that
inherited contracts constructor

29011
06:11:07,820 --> 06:11:10,910
as well. In fact, I think you
have to So governance token G

29012
06:11:10,910 --> 06:11:14,960
team, and then we'll even call
one of these ERC 20 functions

29013
06:11:14,960 --> 06:11:18,170
called mint. And we'll mint to
message dot sender, so whoever

29014
06:11:18,170 --> 06:11:21,170
deploys this ERC 20 contract
will just meant them everything,

29015
06:11:21,590 --> 06:11:24,560
the whole Max supply. Now
normally, if this was a normal

29016
06:11:24,560 --> 06:11:28,730
ERC 20 token, you'd be all done.
But this isn't a normal ERC 20

29017
06:11:28,730 --> 06:11:31,850
token. See, when we do votes, we
need to make sure that it's

29018
06:11:31,850 --> 06:11:36,770
fair, imagine this for a second,
someone knows a hot proposal is

29019
06:11:36,770 --> 06:11:42,110
coming up, they want to vote on.
So they just buy a ton of

29020
06:11:42,110 --> 06:11:47,360
tokens. And then they dump it
after the votes over. We want to

29021
06:11:47,360 --> 06:11:50,360
avoid this. We want to avoid
people just buying and selling

29022
06:11:50,360 --> 06:11:53,810
tokens to get in on governance.
So what we do is we actually

29023
06:11:53,810 --> 06:11:57,440
create a snapshot of how many
tokens people have at a certain

29024
06:11:57,440 --> 06:12:04,190
block snapshot of tokens people
have at a certain block. And we

29025
06:12:04,190 --> 06:12:06,260
want to make sure once a
proposal goes through, we

29026
06:12:06,260 --> 06:12:09,650
actually pick a snapshot from
the past that we want to use

29027
06:12:09,710 --> 06:12:12,620
this kind of incentivizes people
to not just jump in when it's a

29028
06:12:12,620 --> 06:12:16,580
proposal and jump out because
once a proposal hits, it uses a

29029
06:12:16,580 --> 06:12:19,520
block snapshot from the past. So
we're actually going to need to

29030
06:12:19,520 --> 06:12:23,000
change this a little bit. We're
gonna change this from ERC 20 to

29031
06:12:23,000 --> 06:12:27,380
an ERC 20 votes, and we can
actually see this in open

29032
06:12:27,380 --> 06:12:32,270
Zeppelin and the extensions
slash ERC 20 votes that soul

29033
06:12:32,300 --> 06:12:37,580
contract. If we go back to IRS
to their GitHub, we can see ERC

29034
06:12:37,580 --> 06:12:39,770
20 votes, they also have a
snapshot, which is pretty

29035
06:12:39,770 --> 06:12:42,920
similar. And some of the main
functions are it has these

29036
06:12:42,950 --> 06:12:46,040
checkpoints. So these
checkpoints are basically Hey,

29037
06:12:46,070 --> 06:12:49,670
what is the snapshot? There's a
number of checkpoints, you can

29038
06:12:49,670 --> 06:12:52,850
also delegate your tokens to
different people. So maybe

29039
06:12:52,850 --> 06:12:54,860
you're not going to be available
to actually vote. So you say,

29040
06:12:54,860 --> 06:12:57,980
Hey, I'm gonna give my tokens to
somebody else. You can get how

29041
06:12:57,980 --> 06:13:02,300
many votes somebody has passed,
votes get passed, or was apply

29042
06:13:02,300 --> 06:13:06,500
it has all these functions that
make this token, much better as

29043
06:13:06,500 --> 06:13:09,650
a voting tool. Right makes it
much much better. So we're gonna

29044
06:13:09,650 --> 06:13:12,560
say our contracts governance
token is ERC 20 votes and we

29045
06:13:12,560 --> 06:13:17,240
just have to add additional
constructor, this ERC 20 permit,

29046
06:13:17,510 --> 06:13:20,150
I'm sorry, I kind of copied
pasted that. So ERC 20 permit

29047
06:13:20,480 --> 06:13:24,470
governance token. And right now
we have a governance token that

29048
06:13:24,470 --> 06:13:27,560
is a little bit more capable of
doing actual voting, right,

29049
06:13:27,560 --> 06:13:31,280
because as the snapshot has this
delegating functionality, it has

29050
06:13:31,280 --> 06:13:34,700
these checkpoints, it's going to
be much better for doing votes

29051
06:13:34,700 --> 06:13:37,880
in a fair way. The only thing
that we need to do though, is we

29052
06:13:37,880 --> 06:13:40,700
need to add some overrides,
right. And we're just gonna say

29053
06:13:40,700 --> 06:13:46,730
the functions below our
overrides required by solidity.

29054
06:13:47,480 --> 06:13:50,450
And this part is a little bit
boring. So I'm just going to

29055
06:13:50,450 --> 06:13:54,200
copy paste it, feel free to copy
paste it from my GitHub. But

29056
06:13:54,200 --> 06:13:58,280
what we're doing is anytime we
do this after token transfer,

29057
06:13:58,490 --> 06:14:02,180
and the time we transfer a
token, we want to make sure that

29058
06:14:02,180 --> 06:14:05,450
we call the after token transfer
of the ERC 20 votes. And the

29059
06:14:05,450 --> 06:14:08,300
reason that we do this is
because we want to make sure

29060
06:14:08,390 --> 06:14:11,630
that the snapshots are updated,
right, we want to make sure that

29061
06:14:11,630 --> 06:14:15,350
we know how many people have how
many tokens at each block. Same

29062
06:14:15,350 --> 06:14:18,230
thing with the mint. Same thing
with burning, we want to make

29063
06:14:18,230 --> 06:14:21,230
sure we always know how many
tokens people have at different

29064
06:14:21,230 --> 06:14:24,170
blocks or can be at different
checkpoints I should say. And

29065
06:14:24,170 --> 06:14:26,930
that's the most important bit at
which checkpoint Are you going

29066
06:14:26,930 --> 06:14:29,390
to use for your token voting. So
cool. Feel free to copy that,

29067
06:14:29,390 --> 06:14:32,180
again, from a GitHub or if you
want you can even just try the

29068
06:14:32,180 --> 06:14:35,510
rest of the tutorial without
this and see how you fare. But

29069
06:14:35,510 --> 06:14:38,840
cool. So now we have a
governance token and ERC 20

29070
06:14:38,840 --> 06:14:41,480
token that we can use for
governance. So let's try to

29071
06:14:41,480 --> 06:14:45,170
compile it. Yarn Hardhead
compile. Great, looks like

29072
06:14:45,170 --> 06:14:48,020
things are compiling
successfully. Perfect. So our

29073
06:14:48,020 --> 06:14:52,160
governance token looks good. Our
box looks good. Let's actually

29074
06:14:52,160 --> 06:14:56,900
now start creating our
governance contracts. Now we're

29075
06:14:56,900 --> 06:15:00,230
actually going to make a folder
called governance standard

29076
06:15:00,260 --> 06:15:03,080
because this is going to be the
standard governance model. This

29077
06:15:03,080 --> 06:15:06,380
is going to be this on chain ERC
20 and I plan on updating this

29078
06:15:06,380 --> 06:15:09,050
in the future with no a
governance off chain or

29079
06:15:09,050 --> 06:15:11,120
something right. So for now,
we're calling a governance

29080
06:15:11,120 --> 06:15:13,640
standard because this is the
quote unquote standard way to do

29081
06:15:13,640 --> 06:15:16,160
governance, but in the air,
we're going to need two

29082
06:15:16,160 --> 06:15:19,400
contracts actually, we're gonna
need a government work, contract

29083
06:15:19,430 --> 06:15:23,570
that soul and then we're also
going to need a time lock that

29084
06:15:23,570 --> 06:15:28,280
soul and this will make sense in
a second. So our gov contract

29085
06:15:28,280 --> 06:15:30,920
dot soul, this is going to be
the contract that has all the

29086
06:15:30,920 --> 06:15:34,700
voting code, all the voting
logic that our governance token

29087
06:15:34,700 --> 06:15:37,760
is going to use, the Time Lock
is actually going to be an

29088
06:15:37,760 --> 06:15:41,450
additional contract that is
actually the owner. So the Time

29089
06:15:41,450 --> 06:15:44,780
Lock and the governor contract
are sort of one in the same, but

29090
06:15:44,780 --> 06:15:47,120
the difference is the Time Lock
is actually going to be the

29091
06:15:47,120 --> 06:15:50,060
owner of the box contract. And
this is important because

29092
06:15:50,060 --> 06:15:54,890
whenever we propose or cue
something to a proposal to go

29093
06:15:54,890 --> 06:16:00,500
through, we want to wait, right?
We want to wait for a new vote

29094
06:16:00,800 --> 06:16:05,780
to be executed. Now, why do we
want to do that, let's say some

29095
06:16:05,810 --> 06:16:08,060
proposal goes through, that's
bad. So like, let's say we have

29096
06:16:08,060 --> 06:16:10,250
a box contract. And then a
proposal goes through that says,

29097
06:16:10,280 --> 06:16:16,700
Everyone who holds the
governance token has to pay five

29098
06:16:16,700 --> 06:16:19,670
tokens, or something like that,
right, or whatever, or who

29099
06:16:19,670 --> 06:16:21,830
knows, right? Maybe that's
something that you don't really

29100
06:16:21,830 --> 06:16:25,700
want to be a part of. So all of
these governance contracts give

29101
06:16:25,700 --> 06:16:32,870
time to give time to users to
get out, if they don't like a

29102
06:16:32,870 --> 06:16:36,230
governance update. So we always
want to have some type of

29103
06:16:36,230 --> 06:16:40,100
timeline. So once a proposal
passes, it won't go in effect

29104
06:16:40,130 --> 06:16:43,220
right away, it'll have to wait
some duration, and then go in

29105
06:16:43,220 --> 06:16:45,170
effect. So that's what the
timeline is gonna be for.

29106
06:16:45,500 --> 06:16:48,350
Governor contract is going to
have all of our actual code. Now

29107
06:16:48,350 --> 06:16:49,250
we can cheat a little bit.

29108
06:16:50,840 --> 06:16:53,510
Actually, we can cheat a lot of
a little bit. So opens up one

29109
06:16:53,510 --> 06:16:56,270
has a thing called the contracts
wizard, and there'll be a link

29110
06:16:56,270 --> 06:16:59,240
to this in the description as
well. And this opens up when

29111
06:16:59,240 --> 06:17:04,400
wizard is a way for us to write
really basic boilerplate code

29112
06:17:04,460 --> 06:17:06,650
right in there wizard. So right,
so if we go to the wizard

29113
06:17:06,650 --> 06:17:12,890
contract here, we can see we can
make an ERC 20 and NFT 1155. And

29114
06:17:12,890 --> 06:17:16,190
then finally, this gov thing
here. So we can call it give it

29115
06:17:16,190 --> 06:17:20,930
a name, we're going to call Rs.
Gov contract, during explain

29116
06:17:20,930 --> 06:17:24,170
what all this means, and give it
a voting delay, which is the

29117
06:17:24,170 --> 06:17:26,780
delay since a proposal is
created until voting starts. So

29118
06:17:26,780 --> 06:17:28,880
once you create a proposal, you
gotta wait a little bit, the

29119
06:17:28,880 --> 06:17:32,690
voting period, how long votes
should go for. And the reason

29120
06:17:32,690 --> 06:17:36,230
that this audio is important is
because they actually do votes,

29121
06:17:36,770 --> 06:17:39,890
voting period in terms of
blocks. So it's an anti pattern

29122
06:17:39,890 --> 06:17:42,800
to actually do timed based
things in smart contracts, it's

29123
06:17:42,800 --> 06:17:45,230
much better to do block based
things. So we're saying one

29124
06:17:45,230 --> 06:17:48,710
week, but it's that's going to
be you know, if if the average

29125
06:17:48,710 --> 06:17:51,290
block time is 13.2 seconds,
we're gonna figure out the weak

29126
06:17:51,380 --> 06:17:53,960
proposal threshold is going to
be the minimum number of votes

29127
06:17:53,960 --> 06:17:57,590
and account must have to create
a proposal. So maybe you only

29128
06:17:57,590 --> 06:18:01,130
want people who have a lot of
your governance token to make

29129
06:18:01,130 --> 06:18:04,910
votes quorum percentage, it's
what percentage of people need

29130
06:18:04,910 --> 06:18:08,210
to vote it all. So we're saying
4% of all token holders need to

29131
06:18:08,210 --> 06:18:11,060
vote or we could say you know,
exactly 100 tokens need to vote

29132
06:18:11,060 --> 06:18:13,580
whatever we want to do here. We
also have some updatable

29133
06:18:13,580 --> 06:18:17,480
settings we have Bravo
compatible Bravo is the compound

29134
06:18:17,510 --> 06:18:20,150
type contract. So if you want to
make it integratable, with

29135
06:18:20,150 --> 06:18:23,720
compound you can do that. Votes
comp like or ERC 20 votes, we're

29136
06:18:23,720 --> 06:18:26,450
working with this ERC 20 votes,
we always want to do a time

29137
06:18:26,450 --> 06:18:29,060
lock, we're gonna do the open
Zeplin implementation of a time

29138
06:18:29,060 --> 06:18:31,970
lock, you could also do a
compound implementation, we

29139
06:18:31,970 --> 06:18:35,030
aren't going to do upgradability
here, however, I have a number

29140
06:18:35,030 --> 06:18:37,940
of fantastic resources on how to
actually do upgradability. And

29141
06:18:37,940 --> 06:18:40,430
if we did want to do
upgradability, it adds all this

29142
06:18:40,430 --> 06:18:43,280
other stuff. We're not going to
do that for now because it makes

29143
06:18:43,280 --> 06:18:45,650
it so much longer video, and
then you can add some stuff like

29144
06:18:45,650 --> 06:18:49,160
this, but Oh, so that's pretty
much it. And I know this feels

29145
06:18:49,160 --> 06:18:51,230
like you're cheating, or we're
just going to copy this whole

29146
06:18:51,230 --> 06:18:54,230
thing, right? Copy all that
stuff that we put in copy to

29147
06:18:54,230 --> 06:18:57,230
clipboard, and we're going to
paste it in. Don't worry, I'm

29148
06:18:57,230 --> 06:19:00,200
gonna explain what's going on
now. So we have our government

29149
06:19:00,200 --> 06:19:03,230
contract. And this is governor
Governor setting Governor

29150
06:19:03,230 --> 06:19:06,200
counting simple Governor votes,
Governor votes, quorum Franco,

29151
06:19:06,260 --> 06:19:09,440
all this stuff. All these are
just implementations to make it

29152
06:19:09,440 --> 06:19:12,020
easier to be governor, Governor
counting simple is a way of

29153
06:19:12,020 --> 06:19:14,780
counting votes, Governor votes
is a way of integrating with

29154
06:19:14,780 --> 06:19:18,470
that year's 20 contract. Quorum
fraction is is a way to

29155
06:19:18,500 --> 06:19:21,080
understand quorum time lock.
Obviously, it's time lock. This

29156
06:19:21,080 --> 06:19:22,970
is going to be the base
contract. That's gonna be some

29157
06:19:22,970 --> 06:19:25,010
settings. And we're gonna talk
about this in a minute. But

29158
06:19:25,010 --> 06:19:27,170
let's go over what are the
functions here so we have voting

29159
06:19:27,170 --> 06:19:30,020
delay. This is exactly the
voting delay, which we're gonna

29160
06:19:30,020 --> 06:19:33,350
do superdad voting gelei, we're
gonna get from this governor

29161
06:19:33,350 --> 06:19:35,360
settings contract that we're
going to set in a minute your

29162
06:19:35,360 --> 06:19:38,090
voting period that we're going
to set in our gov settings,

29163
06:19:38,090 --> 06:19:40,160
which is this one right here.
And again, if you want to like

29164
06:19:40,190 --> 06:19:42,770
look at all these contracts, you
absolutely can, right, if we go

29165
06:19:42,770 --> 06:19:47,900
to contracts, governance,
extensions, we have all these in

29166
06:19:47,900 --> 06:19:50,630
here, right? So if we look at
governance settings, we can see

29167
06:19:50,630 --> 06:19:53,720
it has voting delay voting
period, proposal threshold, and

29168
06:19:53,720 --> 06:19:56,300
those are right in its
constructor. And that's exactly

29169
06:19:56,300 --> 06:19:59,000
what we're setting, right. We're
setting voting delay voting

29170
06:19:59,000 --> 06:20:01,370
period, and then the proposal
threshold, and then we're also

29171
06:20:01,370 --> 06:20:04,130
going to make this customizable
as well. And the rest of these

29172
06:20:04,130 --> 06:20:06,800
that's exactly what doing
calling the quorum from the

29173
06:20:06,800 --> 06:20:10,580
super get votes. And then again,
the super is those inherited

29174
06:20:10,580 --> 06:20:13,790
contracts, get the state and
then we have some interesting

29175
06:20:13,910 --> 06:20:16,640
functions we have proposed. This
is what we're actually going to

29176
06:20:16,640 --> 06:20:20,720
do to propose new governance we
have proposal threshold, and

29177
06:20:20,720 --> 06:20:24,140
then we have execute which
executes a cued proposal. To

29178
06:20:24,470 --> 06:20:27,890
cancel, we have executor which
we're is going to be who can

29179
06:20:27,890 --> 06:20:30,110
actually execute stuff, we're
actually going to make it

29180
06:20:30,110 --> 06:20:33,470
anybody and then supports
interface, you can basically

29181
06:20:33,470 --> 06:20:36,830
ignore. But let's make this a
little bit more customizable. So

29182
06:20:36,830 --> 06:20:39,320
we have Iboats token, this is
going to be our governance

29183
06:20:39,320 --> 06:20:41,780
token, the timeline controller
timeline, this is going to be

29184
06:20:41,780 --> 06:20:44,660
the timeline controller that we
make an amended. And again, we

29185
06:20:44,660 --> 06:20:47,990
need this because we don't want
to let any proposal just go

29186
06:20:47,990 --> 06:20:50,570
through once it passes, we want
to give people time to get out.

29187
06:20:50,630 --> 06:20:56,930
But let's add the UN 256 voting
delay as a parameter here. And

29188
06:20:57,290 --> 06:21:00,620
for voting delay, we're going to
do this, we're going to set it

29189
06:21:00,620 --> 06:21:05,630
as our governor settings, we're
going to do a UNT 256 voting

29190
06:21:05,630 --> 06:21:09,260
period. And we're going to add
that right here. And this means

29191
06:21:09,260 --> 06:21:14,330
45,000 blocks is approximately
one week. And that's what that

29192
06:21:14,330 --> 06:21:17,030
means we're going to leave
proposal threshold to zero

29193
06:21:17,030 --> 06:21:18,950
because we don't really want to
change that we want to let

29194
06:21:18,950 --> 06:21:22,340
anyone make a proposal. And then
we're just going to add you in

29195
06:21:22,340 --> 06:21:24,980
256 underscore core

29196
06:21:26,060 --> 06:21:30,590
percentage to this. So Governor
votes quorum percentage

29197
06:21:30,590 --> 06:21:33,770
corporate senators. So now this
is completely customizable, for

29198
06:21:33,770 --> 06:21:36,860
voting, delay voting period,
core percentage for whatever you

29199
06:21:36,860 --> 06:21:39,680
want it to be. And believe it or
not, that's it. Now you have a

29200
06:21:39,680 --> 06:21:42,350
simple governance contract.
Thank you, openzeppelin, for

29201
06:21:42,350 --> 06:21:46,280
doing 99% of the work for us. So
that's it. So this contract,

29202
06:21:46,310 --> 06:21:48,410
it's going to have all these
functions that we're going to go

29203
06:21:48,410 --> 06:21:52,910
over for proposing for executing
and for queuing, different

29204
06:21:52,910 --> 06:21:57,800
proposals. Right. Now we got to
make a time lock contract here.

29205
06:21:57,830 --> 06:22:00,140
And this contract is actually
going to be a lot easier. So

29206
06:22:00,140 --> 06:22:02,780
we're just going to do it from
scratch. So we're going to spdx

29207
06:22:02,960 --> 06:22:09,260
license I then to fire, my team,
do pragma solidity and let's

29208
06:22:09,260 --> 06:22:12,110
just do this your point a point
zero, and then we're going to

29209
06:22:12,110 --> 06:22:15,110
import from open Zeppelin, a
contract called the Time Lock

29210
06:22:15,140 --> 06:22:18,470
controller. So if we look at the
governance here, if this time

29211
06:22:18,470 --> 06:22:21,470
lock controller dot soul
contract, and this has all this

29212
06:22:21,470 --> 06:22:24,440
functionality in here for
creating roles, who can actually

29213
06:22:24,440 --> 06:22:28,340
propose who can execute, who's
the Time Lock admin, but it also

29214
06:22:28,340 --> 06:22:31,400
has these execute stuff in here
as well. It's gonna work in

29215
06:22:31,400 --> 06:22:34,250
tandem with our governance
contract, right? This is the

29216
06:22:34,250 --> 06:22:38,060
contract that says that makes
sure our governance contract

29217
06:22:38,060 --> 06:22:41,060
doesn't just push stuff through
willy nilly. So we're gonna say

29218
06:22:41,180 --> 06:22:45,020
we're gonna first import that
import at open Zeppelin slash

29219
06:22:45,020 --> 06:22:52,490
contracts slash governance slash
Time Lock controller. That's all

29220
06:22:52,940 --> 06:22:57,320
and then we're gonna say
contract, I'm lock is Time Lock

29221
06:22:57,440 --> 06:23:00,560
controller like that. And we'll
create our little constructor

29222
06:23:00,560 --> 06:23:05,360
here, and truck door. And this
because this takes a couple

29223
06:23:05,360 --> 06:23:09,260
different parameters, we're
gonna take a un 256 Min delay,

29224
06:23:09,560 --> 06:23:14,180
which are min delay, Min delay
is going to be along you have to

29225
06:23:14,180 --> 06:23:18,980
wait before executing. So this
is Hey, once proposal passes,

29226
06:23:19,010 --> 06:23:21,890
great, we gotta wait this
minimum delay, then we're going

29227
06:23:21,890 --> 06:23:27,170
to do a list of proposers, an
address array memory of

29228
06:23:27,170 --> 06:23:31,490
proposers. And then the
proposers is the list of

29229
06:23:31,490 --> 06:23:34,910
addresses that can propose for
us, we're just gonna say

29230
06:23:34,910 --> 06:23:38,000
everyone's gonna be able to
propose. And then last, an

29231
06:23:38,000 --> 06:23:42,830
address array, memory of
executors who can execute

29232
06:23:42,890 --> 06:23:46,970
everything, and we're just gonna
say executors who can execute

29233
06:23:47,330 --> 06:23:51,560
when a probe posle passes. And
again, we're just gonna say

29234
06:23:51,560 --> 06:23:53,780
everybody, and the reason we
need these is because we need to

29235
06:23:53,780 --> 06:23:56,930
pass these to our time lock
controller, this constructor is

29236
06:23:56,930 --> 06:24:00,800
expecting three parameters. So
we'll just do Tama controller,

29237
06:24:01,610 --> 06:24:09,260
delay, pro posers, X EQ, tours.
And that's it. So this is going

29238
06:24:09,260 --> 06:24:13,310
to be what owns everything, it's
the timelog, that's going to be

29239
06:24:13,310 --> 06:24:15,950
owning our box. It's not the
government contract, the

29240
06:24:15,950 --> 06:24:18,020
government contracts is where
we're going to send our votes

29241
06:24:18,020 --> 06:24:20,780
and stuff. But at the time lock
that actually everything needs

29242
06:24:20,780 --> 06:24:23,240
to flow through in order for
governance to actually happen,

29243
06:24:23,240 --> 06:24:26,090
because we want to make sure we
have this min delay, we go

29244
06:24:26,090 --> 06:24:28,670
through the right process and
everything. And believe it or

29245
06:24:28,670 --> 06:24:31,670
not, that's everything. That is
all the code you're going to

29246
06:24:31,670 --> 06:24:35,180
need as far as the solidity
goes, to create a governance to

29247
06:24:35,180 --> 06:24:39,470
create a Dao. So even do your
own hard hat compile, make sure

29248
06:24:39,470 --> 06:24:43,250
everything's compiled. And tada,
we've done it, you've done most

29249
06:24:43,250 --> 06:24:45,530
of the hard work. Now we're
going to flip over to actually

29250
06:24:45,530 --> 06:24:48,410
writing the scripts to deploy
and to interact with everything

29251
06:24:48,620 --> 06:24:51,980
using TypeScript here. At this
point, if you're like, Oh, I

29252
06:24:51,980 --> 06:24:54,380
already learned everything that
I wanted, I don't use hard hat,

29253
06:24:54,410 --> 06:24:57,560
I use some other tools. This is
where I challenge you to go out

29254
06:24:57,560 --> 06:24:59,750
and I challenge you to try
something else. Now if you've

29255
06:24:59,750 --> 06:25:01,820
reached this point, I just want
to give you a huge congrats,

29256
06:25:01,970 --> 06:25:05,000
because you have taken the steps
to build your own doubt build

29257
06:25:05,000 --> 06:25:07,940
your own governance model.
That's all the solidity that you

29258
06:25:07,940 --> 06:25:10,970
really need. You can take that
deploy that and you're good to

29259
06:25:10,970 --> 06:25:13,910
go. But of course, we know that
there's more to being a smart

29260
06:25:13,910 --> 06:25:16,550
contract developer than just the
solidity you got to do the

29261
06:25:16,550 --> 06:25:19,220
tooling right to let's go ahead
and we'll jump into writing

29262
06:25:19,220 --> 06:25:21,590
those TypeScript scripts to
actually do this. And again, if

29263
06:25:21,590 --> 06:25:24,020
you want to see a Python version
of this, go check out a link up

29264
06:25:24,050 --> 06:25:26,690
description to see the Pythonic
version of this. And of course,

29265
06:25:26,750 --> 06:25:29,600
don't forget to smash that like
button, subscribe, leave a

29266
06:25:29,600 --> 06:25:32,570
comment on how you're doing so
far. And, of course, give

29267
06:25:32,570 --> 06:25:34,910
yourself a pat in the back.
Great job. You're doing amazing

29268
06:25:34,910 --> 06:25:37,010
getting this far. Congrats,
let's jump in.

29269
06:25:38,180 --> 06:25:41,150
Alright, so we're back here,
we've written our smart

29270
06:25:41,150 --> 06:25:44,300
contracts already, check wasn't
that easy, right, this was way

29271
06:25:44,300 --> 06:25:46,490
easier than I thought it would
be. Now we're just gonna write

29272
06:25:46,490 --> 06:25:48,590
our deployment scripts, and then
we're gonna write our scripts to

29273
06:25:48,590 --> 06:25:52,550
interact with them. Again, my
full repo also has tests, but

29274
06:25:52,550 --> 06:25:54,860
we're just gonna write some
scripts. And then feel free to

29275
06:25:54,860 --> 06:25:57,620
check out the tests yourself. So
let's write those deployment

29276
06:25:57,620 --> 06:26:00,140
scripts to we're actually going
to be using a package for

29277
06:26:00,140 --> 06:26:03,620
deployment called Hard Hat
deploy. It is absolutely

29278
06:26:03,620 --> 06:26:06,110
phenomenal for hard hat for
making your deployments much,

29279
06:26:06,140 --> 06:26:08,780
much easier. We're gonna scroll
down to installation, and we're

29280
06:26:08,780 --> 06:26:11,030
actually gonna go ahead and
install this. So typically, you

29281
06:26:11,030 --> 06:26:13,970
could install it like this.
Well, we're gonna use yarn, but

29282
06:26:13,970 --> 06:26:16,970
we're gonna do kind of the more
safe way which looks a little

29283
06:26:16,970 --> 06:26:19,160
wonky, but I'm explaining it
right. So instead of NPM

29284
06:26:19,160 --> 06:26:22,490
install, we're gonna do yarn,
add dash dash Dev, and then this

29285
06:26:22,490 --> 06:26:26,090
whole thing right here. So we're
gonna do yarn, add dash dash

29286
06:26:26,090 --> 06:26:28,790
Dev, and then just paste that in
here. So this is gonna be at

29287
06:26:28,910 --> 06:26:33,380
nomic, labs slash hard hat,
hyphen ethers at NPM, colon,

29288
06:26:33,380 --> 06:26:35,960
hard hat, deploy ethers. And
what this is doing is we're

29289
06:26:35,960 --> 06:26:40,160
basically saying hard hat deploy
ethers is going to be overriding

29290
06:26:40,160 --> 06:26:42,590
this hardened ether thing. And
we're also going to add ethers

29291
06:26:42,590 --> 06:26:46,580
as well. And then once we add
this in, check our package json,

29292
06:26:46,730 --> 06:26:50,150
we can see we have hard hats. We
have hard hat ethers, which is

29293
06:26:50,150 --> 06:26:53,750
being overwritten by this hard
hat, deploy ethers. And then

29294
06:26:53,750 --> 06:26:58,250
additionally, we're going to
want to add on a deploy. So do

29295
06:26:58,250 --> 06:27:03,230
yarn, add dash dash Dev, hard
hat hyphen, deploy. And what

29296
06:27:03,230 --> 06:27:05,660
this is going to allow us to do
is instead of having to write

29297
06:27:05,660 --> 06:27:08,840
scripts, and do all this stuff,
that kind of makes it hard to

29298
06:27:08,840 --> 06:27:11,990
save your deployments and
everything, we're going to just

29299
06:27:11,990 --> 06:27:14,870
create a deploy folder, where
we're going to add all of our

29300
06:27:14,870 --> 06:27:17,360
deploy scripts in here. So I
absolutely love this package.

29301
06:27:17,390 --> 06:27:20,660
It's makes deployment really,
really easy. So in here, we're

29302
06:27:20,660 --> 06:27:22,850
gonna create new file, it's
going to do oh one, we're gonna

29303
06:27:22,850 --> 06:27:24,680
go step by step deploying
everything, we're gonna call

29304
06:27:24,680 --> 06:27:29,990
this deploy, govern or token dot
TypeScript, that's gonna be the

29305
06:27:29,990 --> 06:27:33,050
first thing we're going to do.
Also, we're gonna change this to

29306
06:27:33,050 --> 06:27:37,010
TypeScript. Tada, we now have
TypeScript. Yay. Now the one

29307
06:27:37,010 --> 06:27:40,070
thing that is kind of nice about
doing kind of that advanced

29308
06:27:40,100 --> 06:27:42,230
TypeScript thing at the heart
had kind of gives it the

29309
06:27:42,230 --> 06:27:45,230
beginning, is you don't have to
install all the TypeScript stuff

29310
06:27:45,230 --> 06:27:48,830
yourself. But we do. So we're
going to do yarn, add TypeScript

29311
06:27:49,310 --> 06:27:57,170
type chain, vs node at type
chain slash ethers, V five, this

29312
06:27:57,170 --> 06:28:00,890
is a lot of stuff, don't worry
type chain slash hard hat, at

29313
06:28:00,890 --> 06:28:05,570
type slash Chai, at type slash
node. And then we'll make sure

29314
06:28:05,570 --> 06:28:09,590
this is all Dev, dash dash Dev,
I know there's a lot of stuff.

29315
06:28:10,070 --> 06:28:12,080
There's all this stuff to make
it TypeScript D.

29316
06:28:12,260 --> 06:28:15,260
You can absolutely do this in
JavaScript if you want. You just

29317
06:28:15,260 --> 06:28:18,620
have to do JS files and ignore
the typing. So But feel free to

29318
06:28:18,620 --> 06:28:20,990
do whatever you want to do.
Alright, cool. And we should be

29319
06:28:20,990 --> 06:28:24,620
okay here. Let's go into our
governor token here. And we'll

29320
06:28:24,620 --> 06:28:28,550
create a deploy script. So the
Hardhead deploy GitHub repo has

29321
06:28:28,550 --> 06:28:31,880
a little demo boilerplate code
for you actually do your deploy

29322
06:28:31,880 --> 06:28:34,490
script. So feel free to
reference here if you lost or

29323
06:28:34,490 --> 06:28:37,190
confused. So what we're going to
do is we're going to import the

29324
06:28:37,400 --> 06:28:44,180
hard hat runtime environments,
from our enhanced slash types.

29325
06:28:44,240 --> 06:28:46,310
And you'll see why we need this
in just a second. And then we're

29326
06:28:46,310 --> 06:28:50,540
also going to import deploy
function from Hardhead. Deploy

29327
06:28:50,600 --> 06:28:53,270
slash types. And these are the
two main things you need to

29328
06:28:53,270 --> 06:28:56,000
create a deploy function with
pothead deploy, we're going to

29329
06:28:56,000 --> 06:29:00,530
create our function, we're going
to call it const ploy governance

29330
06:29:00,560 --> 06:29:04,460
token, it's going to be of type
deploy function. So in order for

29331
06:29:04,460 --> 06:29:06,710
these to actually work, we just
create a whole bunch of deploy

29332
06:29:06,710 --> 06:29:08,930
functions that we run with heart
hub. And this is going to be an

29333
06:29:08,960 --> 06:29:12,680
async function. That's going to
take the hard hat runtime

29334
06:29:12,680 --> 06:29:15,380
environment as an input
parameter that we're going to

29335
06:29:15,380 --> 06:29:19,250
call HRV. So when we run hard
hat deploy, which you'll see in

29336
06:29:19,250 --> 06:29:22,820
a second, we're actually passing
our fake hard hat chain that

29337
06:29:22,820 --> 06:29:25,100
gets spun up in the background
for us, right, we can even do

29338
06:29:25,100 --> 06:29:30,170
like console dot log Hello. And
if we do yarn, hard hat deploy.

29339
06:29:30,230 --> 06:29:32,270
Actually, before we even do
that, if we do yarn, hard hat

29340
06:29:32,270 --> 06:29:35,630
dash dash help, you'll see,
since we imported hard hat

29341
06:29:35,630 --> 06:29:39,950
deploy up excuse me, we need to
add this to our config. First in

29342
06:29:39,950 --> 06:29:44,840
our config, we're gonna need to
do top imports, hard hat deploy

29343
06:29:45,140 --> 06:29:49,610
top Roscoe need to import at
nomic labs slash hard hat

29344
06:29:49,640 --> 06:29:53,840
ethers, we're also going to need
to import at type chain slash

29345
06:29:53,840 --> 06:29:56,660
hard hat. And then we'll leave
it there for now. We'll have to

29346
06:29:56,660 --> 06:29:59,570
import more stuff in a second
but literally like that. Now, if

29347
06:29:59,570 --> 06:30:03,230
we do yarn hard hat that should
help we should see a new task in

29348
06:30:03,230 --> 06:30:06,380
here. And we do we actually see
a ton of new tasks right? Filled

29349
06:30:06,380 --> 06:30:10,370
with tasks, check clean compile,
console deployed. And this is

29350
06:30:10,370 --> 06:30:13,010
the new task that we have that
actually deploys all of our

29351
06:30:13,010 --> 06:30:16,010
contracts, anything that's in
this deploy folder, our head

29352
06:30:16,010 --> 06:30:19,250
will go ahead and run right now
in our deploy folder. All we

29353
06:30:19,250 --> 06:30:23,150
have is this console dot log
Hello. So if we run yarn, or hit

29354
06:30:23,150 --> 06:30:26,720
Deploy, we should See, it just
prints out hello. It'll spin up

29355
06:30:26,720 --> 06:30:29,420
a new blockchain background,
while all of our projects and

29356
06:30:29,420 --> 06:30:33,020
everything, do some type type
chain stuff, and it says you'll

29357
06:30:33,020 --> 06:30:36,170
see this a lot deploy script dot
func is not a function. And

29358
06:30:36,170 --> 06:30:38,930
that's because we actually need
to export this now. So we'll do

29359
06:30:38,930 --> 06:30:44,060
export default, deploy
governance token. That's why

29360
06:30:44,060 --> 06:30:46,850
it's getting mad at us. Now
we'll run yarn had her hard hat

29361
06:30:46,850 --> 06:30:50,690
deploy. And boom, we say hello.
So this is how we can actually

29362
06:30:50,690 --> 06:30:53,990
deploy all of our scripts. And
we can run everything that's in

29363
06:30:53,990 --> 06:30:57,350
this deploy folder in one go,
which is really helpful. So

29364
06:30:57,350 --> 06:31:00,230
let's go ahead and deploy our
governance token first. And this

29365
06:31:00,230 --> 06:31:02,870
will get a lot faster as we go
along. Don't worry, so delete

29366
06:31:02,870 --> 06:31:05,570
this. And first we're gonna do
it, we're gonna say const. We

29367
06:31:05,570 --> 06:31:08,840
need an account to deploy this
first. So we'll say const, get

29368
06:31:08,840 --> 06:31:13,790
named accounts, deployments, and
network equals HRA. And this is

29369
06:31:13,790 --> 06:31:15,680
going to be a little bit more
advanced. This is hard stuff.

29370
06:31:15,680 --> 06:31:18,410
This is this is the slick stuff
we're doing here, we're getting

29371
06:31:18,410 --> 06:31:21,680
these from our hard hat runtime
environment, which is being

29372
06:31:21,680 --> 06:31:25,070
updated from hard hat deploy. So
get named accounts is way for us

29373
06:31:25,070 --> 06:31:29,120
to actually import accounts from
our hard hat config, right into

29374
06:31:29,120 --> 06:31:31,640
our deploy script. So we're
gonna go to our hard hat config.

29375
06:31:31,820 --> 06:31:34,190
And we're gonna create a new
config that's a little bit nicer

29376
06:31:34,190 --> 06:31:37,190
than this. So first, we need to
import the hard hat config type.

29377
06:31:37,220 --> 06:31:39,680
Since we're using type scripts,
we're going to import hard hat

29378
06:31:39,710 --> 06:31:43,670
user config from hard hat slash
config. And we're going to

29379
06:31:43,670 --> 06:31:46,970
create a config. So I'm just
gonna comment this out. For now

29380
06:31:47,000 --> 06:31:50,570
we're gonna say const. Config,
it's gonna be type hard hat user

29381
06:31:50,570 --> 06:31:53,660
config. Equals, and this is
where we can add a whole bunch

29382
06:31:53,660 --> 06:31:56,930
of stuff. So let's say our
default network is going to be

29383
06:31:56,930 --> 06:32:00,500
hard hat, which is kind of our
local fake blockchain. And then

29384
06:32:00,500 --> 06:32:05,810
we're gonna say solidity is
zero, point 8.8, then we're

29385
06:32:05,810 --> 06:32:08,480
going to do this thing called
named accounts, which is what we

29386
06:32:08,480 --> 06:32:11,120
came here in the first place
for. So this is just a list of

29387
06:32:11,120 --> 06:32:14,240
accounts that we can use. So for
accounts, we'll say Deployer,

29388
06:32:14,450 --> 06:32:17,120
this will be the name of our
account that does all the

29389
06:32:17,120 --> 06:32:21,860
deploying, and we'll just say,
default, is going to be zero. So

29390
06:32:21,860 --> 06:32:26,420
whenever we run an any chain,
our zero with account is going

29391
06:32:26,420 --> 06:32:29,810
to be named Deployer. What other
thing that we need to do is we

29392
06:32:29,810 --> 06:32:32,270
need to add our networks here.
And there's actually two

29393
06:32:32,270 --> 06:32:33,770
networks that we're going to
have, we're gonna have a hard

29394
06:32:33,770 --> 06:32:39,440
hat with a chain ID of 313337.
And we're also going to have

29395
06:32:39,470 --> 06:32:44,600
local hosts of chain ID 31337.
Now, these look like they're

29396
06:32:44,600 --> 06:32:48,860
pretty much the same. And I
understand that, but they're

29397
06:32:48,860 --> 06:32:51,410
not. And you'll understand why
in a second, but we need them

29398
06:32:51,410 --> 06:32:55,550
for now. Just to tell Hardhead
hey, here are the development

29399
06:32:55,670 --> 06:32:59,060
fake blockchains that we're
working with? Okay. So this is

29400
06:32:59,060 --> 06:33:02,120
kind of our basic setup here.
Okay. I know that was kind of a

29401
06:33:02,120 --> 06:33:04,880
lot. But now that we have get
named accounts, we have network,

29402
06:33:04,880 --> 06:33:06,950
right? Because anytime you
deploy something, it's going to

29403
06:33:06,950 --> 06:33:10,520
be on a network. And when we
deploy something, if you run

29404
06:33:11,090 --> 06:33:14,450
yarn, hard hat node, what hard
hat is going to do, it's going

29405
06:33:14,450 --> 06:33:17,150
to spin up a fake blockchain in
the background. Oh, it's gonna

29406
06:33:17,150 --> 06:33:18,470
be mad at me for a second. Oh,

29407
06:33:18,500 --> 06:33:22,580
I forgot to add export, default
config, right, we need to export

29408
06:33:22,580 --> 06:33:26,090
the config. Hell hard hat that
we're using this version of

29409
06:33:26,090 --> 06:33:29,090
sling. Now if you're on a hard
hat node, you'll see why we

29410
06:33:29,090 --> 06:33:31,970
added these two networks up here
hard hat on localhost, we

29411
06:33:31,970 --> 06:33:34,250
actually get spun up our own
fake blockchain, we get

29412
06:33:34,280 --> 06:33:37,340
accounts, we get private keys,
we get everything right. This is

29413
06:33:37,340 --> 06:33:41,510
a hard hat Node running in this
terminal, right? When you run

29414
06:33:41,510 --> 06:33:44,870
hard hat node, oddly enough,
it's actually the local host

29415
06:33:44,900 --> 06:33:47,210
network. It's not the Hard Hat
Network. When using hard hat

29416
06:33:47,210 --> 06:33:50,300
deploy, it's gonna be the local
host network. Or excuse me, when

29417
06:33:50,300 --> 06:33:52,520
you use hard hat node, it's
actually going to be the local

29418
06:33:52,520 --> 06:33:55,130
host network, not the Hard Hat
Network. The Hard Hat Network is

29419
06:33:55,130 --> 06:33:58,490
what it uses when it runs tests.
localhost is when you run this

29420
06:33:58,490 --> 06:34:02,150
hard hat node and have this kind
of fake blockchain running in

29421
06:34:02,150 --> 06:34:05,180
your terminal. So that's what
the localhost is. Cool. Well,

29422
06:34:05,180 --> 06:34:08,690
Ctrl C will kill that. Alright,
great. So now stuff is actually

29423
06:34:08,690 --> 06:34:11,120
working. So get them to count
deployments is going to be a

29424
06:34:11,120 --> 06:34:12,860
whole bunch of stuff from
deployments, you'll see in a

29425
06:34:12,860 --> 06:34:14,870
second and network is the
network that we're on. Okay,

29426
06:34:14,870 --> 06:34:19,730
great. So now we're gonna grab
const deploy log equals

29427
06:34:19,730 --> 06:34:22,640
deployments, this deployments
object comes with this deploy

29428
06:34:22,640 --> 06:34:25,250
function. And this log function,
this log function is kind of

29429
06:34:25,250 --> 06:34:30,110
nice for doing logging. And then
we're gonna grab const, employer

29430
06:34:30,560 --> 06:34:35,630
equals await, get named
accounts. So we're grabbing from

29431
06:34:35,630 --> 06:34:40,760
our config, this deployer
account, right? And it's always

29432
06:34:40,760 --> 06:34:44,090
going to be the zero with index.
So it's defaulted to the zero

29433
06:34:44,180 --> 06:34:47,270
index for whatever accounts that
were with. Great. So we now have

29434
06:34:47,420 --> 06:34:49,760
an account to deploy stuff from
we have a deploy function, we

29435
06:34:49,760 --> 06:34:52,430
have all this stuff, we're
looking pretty good. Cool. So

29436
06:34:52,430 --> 06:34:58,130
sometimes they'll do like a log,
flying governance token, dot,

29437
06:34:58,250 --> 06:35:03,320
and we'll say const governance
token equals await, deploy, and

29438
06:35:03,320 --> 06:35:06,170
then the name of the contract
which is governance token,

29439
06:35:06,410 --> 06:35:08,810
comma, and these are all the
parameters that we're going to

29440
06:35:08,810 --> 06:35:13,190
pass to it. So we're gonna say
from deployer doesn't take any

29441
06:35:13,190 --> 06:35:16,790
arguments. So args is just going
to be blank. We're going to do

29442
06:35:17,030 --> 06:35:20,600
log to be true so we'll get some
logs printed out for us. And

29443
06:35:20,600 --> 06:35:24,050
then I have this wait
confirmations attribute set in

29444
06:35:24,050 --> 06:35:27,050
GitHub repo. For now we're going
to ignore this. But if you

29445
06:35:27,050 --> 06:35:29,930
follow along with my repo and
you want to auto verify stuff,

29446
06:35:29,960 --> 06:35:31,880
this is something that you're
going to want to use. So you

29447
06:35:31,880 --> 06:35:35,300
need to wait some amount of
blocks for this contract to be

29448
06:35:35,300 --> 06:35:38,120
deployed before you can actually
go ahead and verify it, right.

29449
06:35:38,120 --> 06:35:40,850
Because if you're using ether
scan or something, you're gonna

29450
06:35:40,850 --> 06:35:43,010
need to wait like, yeah, you're
gonna need to wait a few

29451
06:35:43,010 --> 06:35:45,290
minutes. So check out my GitHub
repo for this wait confirmation

29452
06:35:45,290 --> 06:35:48,290
stuff, I'm just going to ignore
it for now. Additionally, in my

29453
06:35:48,290 --> 06:35:51,560
GitHub repo, I have this verify
function, where we check to see

29454
06:35:51,560 --> 06:35:54,680
if it's on a development chain.
And if it is, we don't verify

29455
06:35:54,680 --> 06:35:56,840
it. But if it's on like ether
scan or something, we go ahead

29456
06:35:56,840 --> 06:35:59,240
and verify it. So be sure to
check the GitHub repo to learn

29457
06:35:59,240 --> 06:36:02,330
how to just auto verify without
having to do anything. Now if we

29458
06:36:02,330 --> 06:36:07,340
just do this part. And then we
can even do Floyd, governance

29459
06:36:07,370 --> 06:36:15,410
token to address governance
token dot address. And we'll do

29460
06:36:16,040 --> 06:36:24,470
yarn hardhat. Deploy. Boom. So
we spin up on a fake Hard Hat

29461
06:36:24,470 --> 06:36:27,620
Network, we do deploy governance
token to address boom. And this

29462
06:36:27,620 --> 06:36:30,950
is how we deploy a fake has
deployed this to our own little

29463
06:36:30,950 --> 06:36:34,310
network here. Great. So this
tokens been deployed, we have

29464
06:36:34,310 --> 06:36:37,040
our deploy script. Yeah, zoom
out a little bit. Let's zoom out

29465
06:36:37,040 --> 06:36:39,200
a little bit. Great. That's the
whole thing. Now we're going to

29466
06:36:39,200 --> 06:36:41,300
add one more thing here, we're
going to add something called

29467
06:36:41,480 --> 06:36:44,660
delegate function. Now, when you
actually deploy this contract,

29468
06:36:44,690 --> 06:36:47,960
nobody has voting power yet. The
reason is, because nobody has

29469
06:36:47,990 --> 06:36:51,830
the token delegated to them, we
want to delegate this token to

29470
06:36:51,830 --> 06:36:53,930
our Deployer. Right, so we're
going to call this delegate

29471
06:36:53,930 --> 06:36:56,510
function. So we're going to
create a new function called

29472
06:36:56,510 --> 06:37:01,100
const. delegate. And it's going
to be an async function. It's

29473
06:37:01,100 --> 06:37:05,450
going to take a governance token
address as a string, it's going

29474
06:37:05,450 --> 06:37:08,630
to take a delegated account,
also as a string, so we're

29475
06:37:08,630 --> 06:37:14,180
racing and say, who do we want?
Delegate? Who do we want to be

29476
06:37:14,180 --> 06:37:17,960
able to vote with our token?
Okay, so we have created this

29477
06:37:17,960 --> 06:37:20,720
async function called delegate.
And how do we do this? Well, we

29478
06:37:20,720 --> 06:37:29,240
say Kant's over its token equals
token equals await ethers dot

29479
06:37:29,450 --> 06:37:32,000
get contract at.

29480
06:37:33,260 --> 06:37:36,530
And probably for two ethers for
us from hardheaded Otto did

29481
06:37:36,530 --> 06:37:38,780
that, which is great. That's
what we want. Once it's like

29482
06:37:38,810 --> 06:37:43,370
ethers. Thank you vs. Code away.
Ether is like a contract at. And

29483
06:37:43,370 --> 06:37:47,990
we're going to say we want our
governance token, which is at

29484
06:37:47,990 --> 06:37:53,000
contract, governance token
address. And I have auto format

29485
06:37:53,000 --> 06:37:55,610
unsaved, which is why it keeps
formatting like that. This

29486
06:37:55,610 --> 06:37:58,820
should be delegated account.
Okay, cool. We have our

29487
06:37:58,820 --> 06:38:02,720
governance token contract. Now
we can do const TX or

29488
06:38:02,720 --> 06:38:06,950
transaction equals await,
governance token dot delegate

29489
06:38:07,070 --> 06:38:11,420
delegate this delegated account
here. And then we can do a wait,

29490
06:38:11,570 --> 06:38:16,160
we'll wait for this transaction
to be confirmed by one block.

29491
06:38:16,580 --> 06:38:21,560
And then we'll just do console
dot log checkpoints, wait,

29492
06:38:21,830 --> 06:38:28,280
governance token dot num
checkpoints delegated account?

29493
06:38:28,610 --> 06:38:31,520
So what is this doing? So we
have this num checkpoints

29494
06:38:31,520 --> 06:38:35,630
function which we can go check
to see on that ERC 20 token what

29495
06:38:35,630 --> 06:38:37,640
this is actually doing. But
basically what this whole thing

29496
06:38:37,640 --> 06:38:40,130
is doing, we have this delegate
function that we haven't used

29497
06:38:40,130 --> 06:38:43,220
it. But when somebody calls us,
we're saying, Hey, you can use

29498
06:38:43,220 --> 06:38:45,800
my vote, take my votes and vote
however you want. And that's

29499
06:38:45,800 --> 06:38:48,710
what these this delegate does.
Now, if we look at this token,

29500
06:38:48,890 --> 06:38:53,480
here, see 20 extensions, your
see 20 votes, we look at number

29501
06:38:53,510 --> 06:38:57,470
checkpoints, we can see how many
checkpoints that account

29502
06:38:57,470 --> 06:39:00,830
actually has reason this is so
important is because once again,

29503
06:39:00,830 --> 06:39:03,230
like I was saying when people do
a vote, they do it based off

29504
06:39:03,230 --> 06:39:06,410
some checkpoints. And anytime
you transfer a token, or

29505
06:39:06,410 --> 06:39:09,770
delegate a token, basically call
this function move voting power,

29506
06:39:09,860 --> 06:39:12,200
which happens with the back end,
which writes the checkpoint and

29507
06:39:12,200 --> 06:39:16,610
says, Hey, at checkpoint x,
here's what everybody has for

29508
06:39:16,610 --> 06:39:19,370
voting powers. And that's what
these are so important. And I

29509
06:39:19,370 --> 06:39:21,890
know I said before, it's every
block, but it's actually just

29510
06:39:21,890 --> 06:39:24,410
every checkpoint, whenever these
checkpoints are updated, that's

29511
06:39:24,410 --> 06:39:26,690
gonna be a lot cheaper on gas
than if we just did every single

29512
06:39:26,690 --> 06:39:30,830
block, right? That'd be kind of
insane. So the checkpoint for

29513
06:39:30,830 --> 06:39:33,560
this governance checkpoint, and
we'll see what that actually is

29514
06:39:33,560 --> 06:39:37,790
in just a second. So we'll even
do a wait, delegate, governance

29515
06:39:37,790 --> 06:39:44,570
token dot address, and Deployer.
And we'll say log delegated.

29516
06:39:44,990 --> 06:39:47,180
Now, when we're on this
function, John Howard hit

29517
06:39:47,180 --> 06:39:51,800
Deploy. We have one checkpoint,
which makes sense, right?

29518
06:39:51,830 --> 06:39:55,280
Because this was just deployed,
it was just delegated. This

29519
06:39:55,280 --> 06:39:58,130
address has one checkpoint.
That's it. And the reason I

29520
06:39:58,130 --> 06:40:00,860
checked for this is because if
you see zero checkpoints here,

29521
06:40:00,860 --> 06:40:03,410
it means you haven't delegated
correctly. So be sure to check

29522
06:40:03,410 --> 06:40:06,440
for checkpoints. But that's it.
We have our deployed governance

29523
06:40:06,440 --> 06:40:09,890
token contract done. Bravo.
Let's move on to the next one.

29524
06:40:10,010 --> 06:40:12,890
So what do we want to do after
we deploy our governance token?

29525
06:40:13,220 --> 06:40:17,570
Well, let's deploy that timelock
or timelock.ts. And we're going

29526
06:40:17,570 --> 06:40:20,030
to copy a lot of this stuff over
from here, so I'm actually going

29527
06:40:20,030 --> 06:40:23,150
to Oh, and then sometimes you'll
get some weird linting errors

29528
06:40:23,150 --> 06:40:26,900
here. I just do det TS ignore
there. And sometimes you'll get

29529
06:40:26,900 --> 06:40:29,810
it here too. Oh, actually, we
don't even need network. Okay,

29530
06:40:29,810 --> 06:40:32,240
cool. Yeah, you don't even need
network loops. Sometimes we get

29531
06:40:32,240 --> 06:40:35,060
some weird linting errors.
Sometimes Vyas code has a hard

29532
06:40:35,060 --> 06:40:38,930
time telling understanding like
this, this overwrite thing that

29533
06:40:38,930 --> 06:40:41,870
we did. So just run that TS
ignore if if it gives you some,

29534
06:40:42,170 --> 06:40:45,500
some engineers, anyways, yes, we
have this Oh, to deploy time

29535
06:40:45,500 --> 06:40:47,960
lock here, we're going to deploy
our time lock contract. And

29536
06:40:47,960 --> 06:40:49,790
we're going to borrow a lot of
the things that we did from

29537
06:40:49,790 --> 06:40:52,310
here, so I'm just going to come
back here are actually going to

29538
06:40:52,700 --> 06:40:56,090
copy paste these two top bits.
Again, we're gonna do const

29539
06:40:56,120 --> 06:40:59,810
deploy timelock is going to be a
deploy function, it's going to

29540
06:40:59,810 --> 06:41:04,160
be an async function that takes
the heart at runtime environment

29541
06:41:04,340 --> 06:41:08,180
as a parameter, and cool, nearly
exactly the same sorry. And then

29542
06:41:08,180 --> 06:41:10,910
we're going to grab these first
three lines, or first four

29543
06:41:10,910 --> 06:41:14,120
lines, I guess, pesos, then
we're going to be getting those

29544
06:41:14,150 --> 06:41:16,460
exact same things here. And
we're going to be doing nearly

29545
06:41:16,460 --> 06:41:20,840
the exact same thing. So we'll
do log deploying. Time Lock,

29546
06:41:21,140 --> 06:41:27,320
point time lock, will do const.
Mark equals await, deploy,

29547
06:41:28,280 --> 06:41:31,430
unlock. We'll add some
parameters in here, we'll say

29548
06:41:31,430 --> 06:41:36,230
from Deployer. Now does this
take some arguments? It

29549
06:41:36,230 --> 06:41:39,470
absolutely does. Right, we can
take a look at the Time Lock,

29550
06:41:39,770 --> 06:41:43,040
Min delay proposers and
executors. So what do we want

29551
06:41:43,040 --> 06:41:46,190
our min delay to be? Well, this
is a value that we're actually

29552
06:41:46,190 --> 06:41:49,760
going to use a lot. So what I
usually like to do is I create a

29553
06:41:49,760 --> 06:41:56,510
new file called helper. hardhats
config.ts. And right at the top,

29554
06:41:56,510 --> 06:42:01,310
I'll say Export const min.
Delay, and I'll have this delay

29555
06:42:01,310 --> 06:42:04,040
be whatever I want it to be. So
let's just go ahead and do 3600,

29556
06:42:04,040 --> 06:42:06,050
which is going to be
approximately an hour, right,

29557
06:42:06,050 --> 06:42:08,900
you gotta wait this many
seconds, I think that's an hour.

29558
06:42:09,200 --> 06:42:12,920
Without the old calculator.
There's 60 seconds, in 60

29559
06:42:12,920 --> 06:42:16,730
minutes. Great. That's gonna be
one hour. So wait 30 minutes.

29560
06:42:16,970 --> 06:42:18,890
And we're gonna go ahead and
import that here. We'll say

29561
06:42:18,920 --> 06:42:23,120
import, Min delay. Wow,
autocomplete for being great.

29562
06:42:23,330 --> 06:42:27,200
From helper from, you know, it's
down directory, helper Hardhead

29563
06:42:27,200 --> 06:42:30,470
config. And that's gonna be our
first argument here. Our second

29564
06:42:30,470 --> 06:42:32,510
argument is going to be a list
of proposals. Now we're going to

29565
06:42:32,510 --> 06:42:35,870
leave it blank for now. And also
the list of executors we're also

29566
06:42:35,870 --> 06:42:38,300
going to leave it blank for now,
we're going to update this in a

29567
06:42:38,300 --> 06:42:41,840
minute. And you'll see why once
we get there, we'll do log true.

29568
06:42:42,350 --> 06:42:44,600
This also has a wait
confirmations thing in my

29569
06:42:44,600 --> 06:42:47,420
GitHub, but we're going to skip
that for now. It also has an

29570
06:42:47,420 --> 06:42:50,540
auto verify, we're also gonna
skip that for now. Then we just

29571
06:42:50,540 --> 06:42:55,340
need to export default, deploy
timelock. And boom, we should be

29572
06:42:55,340 --> 06:42:59,360
good. So let's try to run this
on hard hat deploying. So now

29573
06:42:59,360 --> 06:43:03,650
this should run both of these
great deployed governance token

29574
06:43:03,680 --> 06:43:04,820
deployed timelock.

29575
06:43:04,880 --> 06:43:08,330
Perfect, we are cruising now
what we want to deploy that

29576
06:43:08,360 --> 06:43:10,640
governance contract now. So
let's go ahead and do that.

29577
06:43:10,850 --> 06:43:18,260
We're gonna do Oh, three LOI.
Gov, nor contract.ts. And you

29578
06:43:18,260 --> 06:43:21,260
guessed it, this is going to
look pretty similar to what we

29579
06:43:21,260 --> 06:43:24,560
just did. Right. So in our
deployed time lock, let's go

29580
06:43:24,560 --> 06:43:27,260
ahead and just grab those top
two things. We'll paste it in

29581
06:43:27,260 --> 06:43:33,020
here. We'll do const deploy,
govern or contract, there's

29582
06:43:33,020 --> 06:43:35,750
going to be an apply function,
it's going to be an async

29583
06:43:35,750 --> 06:43:40,430
function, taking a part at
runtime environment, save and

29584
06:43:40,430 --> 06:43:43,820
close this for now. And we can
even go back and grab these

29585
06:43:43,850 --> 06:43:46,850
three lines from our Oh, to
deploy time lock, paste that

29586
06:43:46,850 --> 06:43:48,590
right in here, because we're
going to need to get the exact

29587
06:43:48,590 --> 06:43:51,590
same things. And additionally,
for this, we're going to need to

29588
06:43:51,590 --> 06:43:55,100
get the governance token and the
Time Lock contract. So we'll do

29589
06:43:55,100 --> 06:44:01,010
const governance, token equals
await. Get which actually, we

29590
06:44:01,010 --> 06:44:03,710
have this, this get function
that comes from these

29591
06:44:03,710 --> 06:44:06,920
deployments, which literally
just goes out and gets these

29592
06:44:06,920 --> 06:44:10,850
deployments. So we'll say get
Gover Nance token. And then we

29593
06:44:10,850 --> 06:44:17,900
also need to get the Time Lock.
So await, get m lock. And we

29594
06:44:17,900 --> 06:44:22,640
need these to pass as parameters
for our governor contract.

29595
06:44:22,850 --> 06:44:27,080
Right? Because if we open up the
governor contract that soul, we

29596
06:44:27,080 --> 06:44:29,690
look at the constructor, it
takes the token, the Time Lock

29597
06:44:29,720 --> 06:44:33,050
voting, delay voting period and
quorum percentage as input

29598
06:44:33,050 --> 06:44:39,290
parameters. So we'll do a quick
log deploying go burn nor ello.

29599
06:44:39,440 --> 06:44:44,030
And they will do const govern
nor contract equals await,

29600
06:44:44,300 --> 06:44:48,620
deploy, and will deploy the
govern nor contract I'm not sure

29601
06:44:48,620 --> 06:44:51,440
if I'm spelling this right
always, but that's fine. And

29602
06:44:51,440 --> 06:44:54,080
we'll do the parameters once
again. So it's gonna be from

29603
06:44:54,650 --> 06:44:58,610
Deployer. args are going to be
this list of args. What's the

29604
06:44:58,610 --> 06:45:02,540
first thing that it needs? It
needs the token first and the

29605
06:45:02,540 --> 06:45:06,500
Time Lock. So we'll do
governance token dot address,

29606
06:45:06,740 --> 06:45:09,650
then it's going to need the Time
Lock that address. And it's

29607
06:45:09,650 --> 06:45:13,700
going to need a vote on voting
delay voting period and quorum

29608
06:45:13,700 --> 06:45:17,240
percentage. So these are also
values that we're going to make

29609
06:45:17,240 --> 06:45:20,750
a lot. So let's open back up
that helper Hardhead config, and

29610
06:45:20,750 --> 06:45:24,380
let's create those as well. So
we'll say Export const just

29611
06:45:24,620 --> 06:45:28,580
voting period. And we'll say
this is going to be five blocks,

29612
06:45:28,850 --> 06:45:32,870
we'll do export const voting
delay, this is going to be just

29613
06:45:32,870 --> 06:45:36,110
one block, which I know is
really quick. And then we're

29614
06:45:36,110 --> 06:45:42,050
gonna need export const Orem
percentage, which we're gonna

29615
06:45:42,050 --> 06:45:47,330
say is four 4% of voters always
need to be voting. Excuse me, 4%

29616
06:45:47,330 --> 06:45:51,140
of voters need to have voted for
a vote to pass. Great. So we're

29617
06:45:51,140 --> 06:45:55,370
going to do voting delay voting
percentage quorum percentage. So

29618
06:45:55,370 --> 06:46:03,860
we'll import those so to import
voting delay voting period, or

29619
06:46:05,030 --> 06:46:08,210
quorum percentage from helper
Hardhead config. And now that we

29620
06:46:08,210 --> 06:46:12,440
have those delay period
percentage, we can just do kind

29621
06:46:12,440 --> 06:46:16,670
of a voting delay, voting
period, farm percentage, and

29622
06:46:16,670 --> 06:46:20,810
then we'll say log is true.
Again, this one as well. It has

29623
06:46:20,810 --> 06:46:23,330
a wait confirmations and auto
verification that we're going to

29624
06:46:23,330 --> 06:46:27,050
totally ignore. And then we'll
export default, blood Governor

29625
06:46:27,050 --> 06:46:30,230
contract. Oh, Carrie, we're
getting spicy. Let's just make

29626
06:46:30,230 --> 06:46:33,950
sure this works. Yarn hardhat
deploy. We should see three

29627
06:46:33,950 --> 06:46:37,700
contracts deployed here. I think
to compile governance, token

29628
06:46:37,700 --> 06:46:40,640
deployed timelock deployed
governance contract deployed.

29629
06:46:40,640 --> 06:46:45,320
Let's go. Alright. Now, we're
not done yet. We have two more

29630
06:46:45,320 --> 06:46:47,870
deploy scripts to do. The first
one, we're going to call setup

29631
06:46:47,870 --> 06:46:51,530
governance contracts. Okay. And
this one's really important. The

29632
06:46:51,530 --> 06:46:55,730
right now our time lock contract
has no proposers and no

29633
06:46:55,730 --> 06:46:59,120
executors. Right. So we want to
change that we want to only

29634
06:46:59,120 --> 06:47:02,810
allow for the proposer to be the
governor, the governor contract

29635
06:47:02,810 --> 06:47:05,390
should be the only one that
proposes things the Time Lock,

29636
06:47:05,420 --> 06:47:07,820
and then anybody should be able
to execute the way that this

29637
06:47:07,820 --> 06:47:10,460
works. We say the governance
contract proposes something to

29638
06:47:10,460 --> 06:47:13,760
the Time Lock once it's in the
Time Lock, and it waits that

29639
06:47:13,760 --> 06:47:17,780
period. Anybody can go ahead and
execute it. So Governor contract

29640
06:47:17,810 --> 06:47:20,660
everybody votes and everything.
Once a vote passes, Governor

29641
06:47:20,660 --> 06:47:23,900
says hey, Time Lock, can you
please propose this? Tom like

29642
06:47:23,900 --> 06:47:26,510
goes yeah, sure. But we got to
wait, this minimum delay, once

29643
06:47:26,510 --> 06:47:29,120
it's been in delay happens,
anybody can execute it. Now this

29644
06:47:29,120 --> 06:47:30,980
would be really cool to do an
integration with chain link

29645
06:47:30,980 --> 06:47:33,140
keepers, by the way, for the
chain link keepers to

29646
06:47:33,140 --> 06:47:36,410
automatically execute. And I
should build the next anyways.

29647
06:47:36,440 --> 06:47:39,230
So we have to set this up so
that these work as such, so

29648
06:47:39,230 --> 06:47:42,320
we're gonna create a new deploy
thing called Oh, four, setup,

29649
06:47:42,350 --> 06:47:46,310
governance contracts dot
TypeScript. And this is going to

29650
06:47:46,310 --> 06:47:49,100
be the code that does all the
setting up. And this is gonna

29651
06:47:49,100 --> 06:47:51,560
look really similar once again,
to all of our other deploy

29652
06:47:51,560 --> 06:47:55,820
functions. So we'll go head back
from oh three, we'll paste these

29653
06:47:55,820 --> 06:47:59,840
two top ones in here, of course,
we're gonna do const setup

29654
06:47:59,840 --> 06:48:03,860
contracts, is it going to be a
deploy function, going to be an

29655
06:48:03,890 --> 06:48:08,150
async function, it's going to
take HRV art at runtime

29656
06:48:08,150 --> 06:48:11,570
environment as parameters, and
then that's the winner right

29657
06:48:11,570 --> 06:48:15,020
there. Cool. And we're gonna be
grabbing those same three from

29658
06:48:15,020 --> 06:48:17,990
the top, as you can see, that
gets a little bit easier,

29659
06:48:17,990 --> 06:48:20,360
because it's kind of repetitive,
right, we're gonna grab that bit

29660
06:48:20,360 --> 06:48:22,940
right here. And now we're gonna
get those contracts so that we

29661
06:48:22,940 --> 06:48:25,760
can interact with them. And this
is another reason why a hard hat

29662
06:48:25,760 --> 06:48:29,420
deploy is so nice, because we
can just do const timelock

29663
06:48:29,630 --> 06:48:33,410
equals await ethers that get in
the next let's go ahead and

29664
06:48:33,440 --> 06:48:37,640
import ethers from hard hat
imports. Ethers

29665
06:48:38,120 --> 06:48:44,060
from Red Hat will even drop a
little TS ignore here. Ethers

29666
06:48:44,060 --> 06:48:47,480
dot get contract, we want that
time lock contract. And we say

29667
06:48:47,480 --> 06:48:50,180
we want to attach it to the
Deployer. So whenever we call a

29668
06:48:50,180 --> 06:48:52,850
function on it, it'll be the
deployer calling that function

29669
06:48:52,970 --> 06:48:57,140
and we want to do const Governor
equals await ethers dot get

29670
06:48:57,140 --> 06:49:01,370
contract, Governor contract,
this is all going to be attached

29671
06:49:01,370 --> 06:49:05,600
to the Deployer. Right. Now,
we're gonna do log setting up

29672
06:49:05,600 --> 06:49:09,740
roles. And we're going to set up
the roles right, again, we're

29673
06:49:09,740 --> 06:49:12,980
setting it up so that only the
governor can send things to this

29674
06:49:12,980 --> 06:49:15,530
time lock, because the Time Lock
is going to be you can almost

29675
06:49:15,530 --> 06:49:17,960
think of the Time Lock as like
the president. Right. So

29676
06:49:17,960 --> 06:49:20,180
everything goes to the Senate,
the House representative, which

29677
06:49:20,180 --> 06:49:23,120
is the governor and then the
President just says yeah, sure.

29678
06:49:23,120 --> 06:49:26,150
We just got to wait this minimum
delay, but the President will be

29679
06:49:26,150 --> 06:49:27,890
the one to actually execute
everything which I'm not

29680
06:49:27,890 --> 06:49:30,620
actually sure that's how it
really works in in politics, but

29681
06:49:30,650 --> 06:49:33,590
for for now, that's that's where
we're protecting the president

29682
06:49:33,590 --> 06:49:36,770
or the time like is the only one
that can actually do anything

29683
06:49:36,770 --> 06:49:40,040
here. So the way that this works
is we're actually going to get

29684
06:49:40,070 --> 06:49:43,490
the byte codes of different
roles, right? So if you look at

29685
06:49:43,520 --> 06:49:49,190
these time locks here, so we'll
do ones up on contracts. And we

29686
06:49:49,190 --> 06:49:53,210
go to the governance here. We go
to Tama controller has these

29687
06:49:53,210 --> 06:49:57,680
things called proposal roll,
executor roll time, like admin,

29688
06:49:57,680 --> 06:50:01,700
etc. And these are just hashes
of these strings here. But these

29689
06:50:01,700 --> 06:50:05,240
are these are bytes 32 saying,
Hey, anybody who has this this

29690
06:50:05,240 --> 06:50:08,690
byte 32 is a proposer, anybody
who has this byte 32 is an

29691
06:50:08,690 --> 06:50:10,850
executor. Anybody has this byte
there and soon as time like

29692
06:50:10,850 --> 06:50:14,810
admin, etc. Right now, our
Deployer account is the time

29693
06:50:14,810 --> 06:50:17,480
like admin, and that's bad. We
don't want that we don't want

29694
06:50:17,630 --> 06:50:20,060
anyone to be a time like admin,
right? We don't want anyone to

29695
06:50:20,060 --> 06:50:23,870
have power over this time lock.
We don't want any centralized

29696
06:50:24,050 --> 06:50:26,570
force here. So what we're going
to do is we're going to const

29697
06:50:26,570 --> 06:50:30,890
we're going to get those roles.
proposer, proposer role, it's

29698
06:50:30,890 --> 06:50:35,780
going to be a weight, unlock
that row pole sir role. And if

29699
06:50:35,780 --> 06:50:38,210
you're familiar with multi call,
this would be a great time to do

29700
06:50:38,210 --> 06:50:44,180
multi call and copy paste that
whole line x EQ tour role at x

29701
06:50:44,180 --> 06:50:50,060
EQ tour roll, we're gonna copy
this whole line admin role. And

29702
06:50:50,060 --> 06:50:54,500
this is going to be on lock
admin role. So these are these

29703
06:50:54,530 --> 06:50:58,220
three roles that we need to fix,
right, and let's go ahead and

29704
06:50:58,220 --> 06:51:00,560
fix them. So the first thing
we're gonna need to do is we're

29705
06:51:00,560 --> 06:51:06,230
gonna need to do const row poser
dx equals await Time Lock dot

29706
06:51:06,230 --> 06:51:10,730
grant roll, propose a roll to
our governor dot address. So

29707
06:51:10,730 --> 06:51:14,120
saying, okay, Governor, you're
the only one who can actually do

29708
06:51:14,120 --> 06:51:17,570
anything once you tell the Time
Lock to do something. We'll wait

29709
06:51:17,660 --> 06:51:20,030
for the Time Lock period to be
over. And then we'll be done.

29710
06:51:20,360 --> 06:51:24,800
And then we'll just do an await
posit TX dot wait one block just

29711
06:51:24,800 --> 06:51:29,930
to make sure. Now we're gonna do
the const executor, TX equals

29712
06:51:29,960 --> 06:51:36,620
await Time Lock dot grant roll
executor role to nobody, we're

29713
06:51:36,620 --> 06:51:39,170
going to execute this we're
gonna give this to nobody, we're

29714
06:51:39,170 --> 06:51:41,810
going to say address zero which
is going to be something that

29715
06:51:41,810 --> 06:51:45,140
we're going to want to add if we
go to our helper or head config

29716
06:51:45,380 --> 06:51:51,500
will say Export const address
zero equals zero by you can just

29717
06:51:51,500 --> 06:51:53,720
copy paste this if you want.
There's a couple other ways you

29718
06:51:53,720 --> 06:51:56,900
can do this with ethers as well.
We're just gonna do like this. I

29719
06:51:56,900 --> 06:52:00,470
like having my conflict this and
then we just import it say

29720
06:52:00,500 --> 06:52:05,780
import at zero from dot dot
slash helper Harnett config. So

29721
06:52:05,780 --> 06:52:08,810
we're giving the executor role
to nobody, which means

29722
06:52:08,810 --> 06:52:12,530
everybody. So once a proposers
thing has gone through, anybody

29723
06:52:12,530 --> 06:52:16,850
can execute it. So we'll say
executor, TX That wait one wait

29724
06:52:16,850 --> 06:52:21,080
a block. And then got one more
to do here, we need to revoke

29725
06:52:21,080 --> 06:52:25,760
role right now our Deployer
count owns that time lock

29726
06:52:25,760 --> 06:52:28,310
controller, right. And that's
how we can actually do these

29727
06:52:28,310 --> 06:52:31,370
transactions, we can actually
grant role because our Deployer

29728
06:52:31,370 --> 06:52:34,550
account owns it now that we've
given everybody access. And

29729
06:52:34,550 --> 06:52:37,010
given all the decentralized
access we need, we want to

29730
06:52:37,010 --> 06:52:41,210
revoke that role. So const
revoke TX equals await. I'm

29731
06:52:41,210 --> 06:52:48,500
locked up revoke role, admin
role from Deployer will do Rotex

29732
06:52:48,500 --> 06:52:51,320
that wait, now guess what
anything that's um, like, wants

29733
06:52:51,320 --> 06:52:54,650
to do has to go through
governance, and nobody owns the

29734
06:52:54,650 --> 06:52:57,410
time I controller, it's
currently after this runs, it's

29735
06:52:57,410 --> 06:53:00,440
impossible for anyone to do
anything with the Time Lock

29736
06:53:00,680 --> 06:53:03,170
without governance happening.
And then of course, when the

29737
06:53:03,170 --> 06:53:07,850
export default set of contracts,
great. And then the last step

29738
06:53:07,880 --> 06:53:11,090
that we need to do here is we
need to deploy the contract that

29739
06:53:11,090 --> 06:53:14,810
we actually want to govern over
write that box contract, that

29740
06:53:14,810 --> 06:53:17,780
real basic contract. So we're
gonna create a new 105, deploy

29741
06:53:17,780 --> 06:53:21,500
box.ts. And we're gonna do some
of the same exact stuff we've

29742
06:53:21,500 --> 06:53:24,890
done right, so we're gonna grab
these two, these two here, paste

29743
06:53:24,890 --> 06:53:29,120
it in, os deploy box is going to
be a deploy function equals

29744
06:53:29,150 --> 06:53:33,590
async function, Ah, sorry, hard
hat runtime environment,

29745
06:53:34,070 --> 06:53:38,240
we're gonna grab those first
three lines, the TS ignore, just

29746
06:53:38,240 --> 06:53:41,720
like that. And now we're going
to deploy this box. So log,

29747
06:53:42,320 --> 06:53:46,850
deploying bucks, and we're going
to do const box equals await,

29748
06:53:47,090 --> 06:53:53,360
deploy box, give us some values
from our Deployer. args does

29749
06:53:53,360 --> 06:53:56,540
this have any args so open a box
dot soul, I don't see a

29750
06:53:56,540 --> 06:53:59,750
constructor. And while this is
the easiest contract out of all

29751
06:53:59,750 --> 06:54:02,750
these though, no constructor,
and then we'll just say log,

29752
06:54:03,050 --> 06:54:06,140
it's going to be true. And
again, if you want to check out

29753
06:54:06,140 --> 06:54:09,080
my GitHub repo for that
confirmations, but feel free to

29754
06:54:09,080 --> 06:54:13,760
do so it's coming here. And
right now, our deployer has

29755
06:54:13,760 --> 06:54:16,970
actually deployed this right,
not our time lock. So we want to

29756
06:54:16,970 --> 06:54:21,380
give the boxes ownership over to
our governance process. So now

29757
06:54:21,380 --> 06:54:24,260
we're going to do say const
timelock, is going to be a

29758
06:54:24,260 --> 06:54:28,340
weight ethers dot get contract.
The same thing as before.

29759
06:54:28,340 --> 06:54:33,560
timelock. We're going to grab
ethers from hardhat import

29760
06:54:33,650 --> 06:54:38,240
ethers from hard hat. And we're
gonna do a little TLS ignore,

29761
06:54:38,480 --> 06:54:42,320
it's being finicky. And then
we're going to transfer the

29762
06:54:42,320 --> 06:54:46,430
ownership of our box to this
time lock, okay, and now so this

29763
06:54:46,430 --> 06:54:49,400
is actually what's known as a
box deployment. So before we do

29764
06:54:49,400 --> 06:54:51,710
that, we have to get the box
contract. So this is a box

29765
06:54:51,710 --> 06:54:54,680
deployment object, which doesn't
have contract functions we want

29766
06:54:54,680 --> 06:54:58,640
to get the box contract object
so we to box or const box

29767
06:54:58,640 --> 06:55:06,110
contract equals await ethers dot
get contract at box and then

29768
06:55:06,110 --> 06:55:09,380
we'll just do you know box that
address. You could also do get

29769
06:55:09,380 --> 06:55:12,470
contract. Actually both of these
pretty much if you have the

29770
06:55:12,470 --> 06:55:15,230
address, you can just do box
that address. You could also do

29771
06:55:15,230 --> 06:55:17,840
get contract here. Either one
works now that we have the box

29772
06:55:17,840 --> 06:55:24,050
contract, we do const transfer
owner, dx equals await by

29773
06:55:24,050 --> 06:55:30,740
contract dot transfer TX or
schema dot transfer ownership to

29774
06:55:30,770 --> 06:55:36,110
our timelock dot address, time
walk dot address, then we just

29775
06:55:36,110 --> 06:55:43,790
do a weight transfer ownership
TX dot weight one, do a log, you

29776
06:55:43,790 --> 06:55:51,950
done it. Those are export
default. Deploy box. Oh, let's

29777
06:55:51,950 --> 06:55:56,090
see if this works. So we just
did everything. We're deploying

29778
06:55:56,690 --> 06:55:59,960
the GOV token, deploying the
timelock, which owns the

29779
06:55:59,960 --> 06:56:02,570
governance process, we're
deployed the governance process,

29780
06:56:02,870 --> 06:56:05,600
we're setting up the governance
process so that it's totally

29781
06:56:05,600 --> 06:56:08,660
decentralized. And then we
deployed and set up our box so

29782
06:56:08,660 --> 06:56:13,040
that it only can be updated
through a governance process.

29783
06:56:13,070 --> 06:56:18,170
Let's see if it works. Yarn,
hard hat deploy. Let's see if it

29784
06:56:18,170 --> 06:56:23,360
works. Bada boom, you've done
it. So you've just set up a

29785
06:56:23,360 --> 06:56:27,350
script to set this entire
governance process up so you can

29786
06:56:27,350 --> 06:56:31,160
build your own doubt. Are you
still here? Well, hell yeah, you

29787
06:56:31,160 --> 06:56:35,210
are, congratulations on getting
this far, we have one more piece

29788
06:56:35,210 --> 06:56:37,430
to go, we just got to write
those scripts. So we can

29789
06:56:37,430 --> 06:56:40,370
actually interact with this, we
can actually do a governance, we

29790
06:56:40,370 --> 06:56:42,680
can actually see exactly what
the governance process looks

29791
06:56:42,680 --> 06:56:45,800
like. Now again, if you didn't
watch my last video on Dows, be

29792
06:56:45,800 --> 06:56:47,930
sure to watch that, because
that's going to give you all the

29793
06:56:47,930 --> 06:56:51,770
context for this part here. And
if you're still watching 100%,

29794
06:56:51,800 --> 06:56:54,650
smash the like button, hit the
subscribe, leave a comment in

29795
06:56:54,650 --> 06:56:57,290
the comment section below, it
really helps the channel out. So

29796
06:56:57,290 --> 06:56:59,690
proud of you for getting this
far. We're almost there, you're

29797
06:56:59,690 --> 06:57:02,690
getting now one more to go. And
then you are home free on

29798
06:57:02,690 --> 06:57:05,060
building your doubt. Let's get
back into it.

29799
06:57:06,289 --> 06:57:08,149
Alright, so now we're going to
make some scripts to actually

29800
06:57:08,179 --> 06:57:13,639
interact with propose Q and vote
on anything that happens in our

29801
06:57:13,669 --> 06:57:16,189
Dao. And these are the scripts,
these are kind of the things

29802
06:57:16,189 --> 06:57:18,379
that you would do on your front
end when you build this when you

29803
06:57:18,379 --> 06:57:20,209
build your doubt on the front
end. Or you could do an

29804
06:57:20,209 --> 06:57:23,089
integration with snapshot or
tally or something like that.

29805
06:57:23,149 --> 06:57:26,089
And again, if you want to see
come to full functionality on

29806
06:57:26,089 --> 06:57:29,419
the GitHub, I have this test
flow.ts It's not the greatest

29807
06:57:29,419 --> 06:57:31,759
test here. But you can also
check this out, because it also

29808
06:57:31,759 --> 06:57:35,479
does a soup to nuts
demonstration of going through

29809
06:57:35,509 --> 06:57:37,909
this exact process. So let's go
ahead and start making some

29810
06:57:37,909 --> 06:57:40,909
scripts. So we're gonna create a
new folder called scripts. And

29811
06:57:40,909 --> 06:57:43,729
this is where we're going to put
all of our scripts. Now the

29812
06:57:43,729 --> 06:57:47,419
process for this is going to be
we're first going to propose

29813
06:57:47,479 --> 06:57:50,569
something right? You know, maybe
we're going to propose that our

29814
06:57:50,569 --> 06:57:55,159
box contract stores the value
77, right? Because when it first

29815
06:57:55,159 --> 06:57:57,679
gets initialized, it's going to
start with zero. So maybe we'll

29816
06:57:57,709 --> 06:58:02,419
we'll propose it could start at
77. Once proposing is done, we

29817
06:58:02,449 --> 06:58:04,909
are voting on it. Right once
proposals it and we're going to

29818
06:58:04,909 --> 06:58:07,339
vote on whether or not we want
the proposal to go through right

29819
06:58:07,339 --> 06:58:11,929
yes or no. And then if it
passes, we go to queue and

29820
06:58:12,079 --> 06:58:15,919
execute, we queue first. And
then we execute, I'm just

29821
06:58:15,919 --> 06:58:18,169
putting them both in the same
script to make it easier. So

29822
06:58:18,559 --> 06:58:21,079
let's start with propose here,
because it's going to be the

29823
06:58:21,079 --> 06:58:23,809
first thing that we're going to
do. So let's create a new

29824
06:58:23,809 --> 06:58:27,199
function. We'll call it async
function, and then we'll

29825
06:58:27,199 --> 06:58:30,679
actually export it to export
async function propose. And

29826
06:58:30,679 --> 06:58:32,809
we're going to be in here for a
little bit. So let's clear

29827
06:58:32,809 --> 06:58:35,779
everything out. And okay, cool.
So this is where we're actually

29828
06:58:35,779 --> 06:58:38,899
going to propose on our governor
contract, right? So we're going

29829
06:58:38,899 --> 06:58:40,579
to propose a new governor
contract. So the first thing

29830
06:58:40,579 --> 06:58:42,499
we're gonna need, of course, is
gonna be the governor. So you

29831
06:58:42,499 --> 06:58:49,219
can't govern nor equals await
ethers dot get contract, govern

29832
06:58:49,219 --> 06:58:52,159
or contract, right? Since we're
doing ethers, we're gonna have

29833
06:58:52,159 --> 06:58:57,049
to do import ethers from heart
app. And then we're still

29834
06:58:57,049 --> 06:59:01,069
getting that fundamental thing.
We'll do a little AT Ts ignore

29835
06:59:01,069 --> 06:59:03,589
here. Cool. So we have the
governor contract here, we're

29836
06:59:03,589 --> 06:59:06,469
going to need the box contract,
we're gonna say hey, we want to

29837
06:59:06,469 --> 06:59:10,279
propose the box contract changes
the store value. So we'll do

29838
06:59:10,279 --> 06:59:16,069
const box equals await ethers
dot get this is a gift contract,

29839
06:59:16,069 --> 06:59:19,669
we want get contract, get
contracts at box. And those are

29840
06:59:19,699 --> 06:59:22,039
the two main ones that we're
going to need just to start.

29841
06:59:22,429 --> 06:59:26,089
Now, if we look at the proposed
function, right, if we go to

29842
06:59:26,209 --> 06:59:29,179
governance, we go to Governor,
and we look at that proposed.

29843
06:59:29,389 --> 06:59:31,849
This is what it looks like. Now,
I explained this proposed

29844
06:59:31,849 --> 06:59:34,819
function in my last video. So if
you haven't seen it, be sure to

29845
06:59:34,819 --> 06:59:37,009
go back and watch it right
because it'll give you

29846
06:59:37,039 --> 06:59:39,829
everything that you need to know
here are basically we pick a

29847
06:59:39,829 --> 06:59:42,979
list of targets, which our list
is just going to be just our box

29848
06:59:42,979 --> 06:59:45,469
contract. These are the targets
that we want to call functions

29849
06:59:45,469 --> 06:59:48,409
on, we do values like how much
needed ether we want to send,

29850
06:59:48,409 --> 06:59:51,319
which we're not going to send
anything, we have bytes, a array

29851
06:59:51,319 --> 06:59:55,129
called data. So this is going to
be our encoded parameters for

29852
06:59:55,129 --> 06:59:58,309
the function that we want to
call and then a description. So

29853
06:59:58,309 --> 07:00:00,979
that's exactly what we're going
to do here. So first, we need to

29854
07:00:01,009 --> 07:00:03,499
figure out what we're going to
do. So look at Box, we're going

29855
07:00:03,499 --> 07:00:06,829
to call this store function with
this new value here. So we need

29856
07:00:06,829 --> 07:00:10,519
to encode we need to encode this
socks here. And we also need to

29857
07:00:10,519 --> 07:00:13,879
encode what we want to upgrade
it to right so we have to code

29858
07:00:13,879 --> 07:00:17,479
all the function parameters. So
we'll do const encoded function

29859
07:00:17,479 --> 07:00:21,469
call equals box and the way we
can get this box that interface

29860
07:00:21,529 --> 07:00:25,369
that encode function data and
This is what actually turns it

29861
07:00:25,369 --> 07:00:29,659
to being this bytes call data,
right? So we're encoding

29862
07:00:29,779 --> 07:00:32,599
everything and this encoded
function, you can find this in

29863
07:00:32,599 --> 07:00:36,139
the ethers documentation, we
have to pass it the function to

29864
07:00:36,139 --> 07:00:38,869
call, and then the arguments we
want to pass, right, and this is

29865
07:00:38,869 --> 07:00:42,169
how we actually get that. So
let's get these arguments here.

29866
07:00:42,229 --> 07:00:44,899
So we're gonna say args, we're
going to make our proposed

29867
07:00:44,899 --> 07:00:47,359
function a little bit modular.
So we're gonna say args is going

29868
07:00:47,359 --> 07:00:50,479
to be an array of anything, and
then we're gonna say function to

29869
07:00:50,479 --> 07:00:53,599
call is just going to be a
string, right, and then right at

29870
07:00:53,599 --> 07:00:56,839
the bottom, we're actually gonna
call this, this proposed

29871
07:00:56,839 --> 07:01:00,109
function. So we're gonna say
propose, and let's say we want

29872
07:01:00,109 --> 07:01:02,959
to give it 77, the function is
going to be what it's going to

29873
07:01:02,959 --> 07:01:06,829
be store, store. And that's a
string. And this needs to be a

29874
07:01:06,829 --> 07:01:09,679
list. So we're going to do like
this. Now, we're actually going

29875
07:01:09,679 --> 07:01:12,679
to use this all over the place.
So since we're gonna be using

29876
07:01:12,679 --> 07:01:16,099
this all over the place, we want
to stick them in this part head

29877
07:01:16,099 --> 07:01:18,679
helper config. So what we're
going to do is we're gonna say,

29878
07:01:18,709 --> 07:01:23,899
export const, new store value
equals 77. And we're gonna do

29879
07:01:23,929 --> 07:01:29,449
export const funk equals store.
And I propose, we're just going

29880
07:01:29,449 --> 07:01:33,889
to import those. So we'll do
import, new store value, and

29881
07:01:33,889 --> 07:01:38,209
also funk from helper Hardhead
dot config, and it added it in

29882
07:01:38,209 --> 07:01:41,209
for us, which is great. So we'll
just put new store value in

29883
07:01:41,209 --> 07:01:44,989
here. And then we'll put funk in
here. And I know this might look

29884
07:01:44,989 --> 07:01:46,609
a little confusing, but
basically, the first thing we're

29885
07:01:46,609 --> 07:01:48,919
gonna do is we're gonna call
this proposed function which

29886
07:01:48,919 --> 07:01:51,559
calls you know, post function up
here. Now we're going to do some

29887
07:01:51,559 --> 07:01:56,479
fun little then process that
exit zero. And then we're going

29888
07:01:56,479 --> 07:02:00,499
to do a dot catch error, which
if there's an error, basically,

29889
07:02:00,499 --> 07:02:05,269
we'll just do console dot log
error, then process that makes

29890
07:02:05,269 --> 07:02:10,189
it. And this is pretty typical
setup for a really any script

29891
07:02:10,189 --> 07:02:13,429
you work with, and hardhat. So
great. So we have constant coded

29892
07:02:13,429 --> 07:02:16,369
function call, which has this
function to call an arc. So

29893
07:02:16,369 --> 07:02:19,219
we're basically combining these
into this bytes thing. And we

29894
07:02:19,219 --> 07:02:21,319
can even print this out, you can
see what this looks like. So you

29895
07:02:21,319 --> 07:02:24,559
do console dot log, you see that
this is like this, this crazy

29896
07:02:24,559 --> 07:02:28,069
bytes thing here. And the way we
can kind of test this, we'll do

29897
07:02:28,069 --> 07:02:33,079
yarn hardhat node, which will
spin up again, our fake

29898
07:02:33,079 --> 07:02:35,209
blockchain. But additionally,
with Hardhead deploy, it will

29899
07:02:35,209 --> 07:02:39,829
deploy all of our contracts
here, right, we can see timelog

29900
07:02:39,829 --> 07:02:43,549
governance, you know, everything
that we need for testing locally

29901
07:02:43,579 --> 07:02:46,789
has already been done. So once
we have that up, we can then do

29902
07:02:46,909 --> 07:02:52,159
yarn hardhat, run scripts,
propose that TS dash dash

29903
07:02:52,159 --> 07:02:55,159
network, local host, this is
important to do, again, because

29904
07:02:55,159 --> 07:02:57,529
when you're working with a node
that's running locally, you're

29905
07:02:57,529 --> 07:02:59,599
going to be working with local
host, we'll see what it prints

29906
07:02:59,599 --> 07:03:00,079
out here.

29907
07:03:01,820 --> 07:03:05,450
Contract named Governor
contracts, Governor contract.

29908
07:03:05,480 --> 07:03:09,050
Let's try that again. And cool,
you can see this is what that

29909
07:03:09,050 --> 07:03:13,010
encoded function call and
arguments looks like is this

29910
07:03:13,010 --> 07:03:16,940
really long byte string. But if
you were to decode this, using

29911
07:03:16,940 --> 07:03:19,490
the box interface, you would get
the function call and the

29912
07:03:19,490 --> 07:03:22,040
arguments, which is really
exciting. So cool, we've encoded

29913
07:03:22,070 --> 07:03:25,040
it to bytes. And now what we
want to do, we encourage the

29914
07:03:25,040 --> 07:03:27,230
bytes, and now we're going to
create that proposal

29915
07:03:27,230 --> 07:03:32,120
transaction. So we'll do console
dot log will say pro posing, and

29916
07:03:32,120 --> 07:03:37,610
say, function to call on box
that address with args. And then

29917
07:03:37,610 --> 07:03:41,270
we also need to pass a proposal
description. So we're gonna say

29918
07:03:41,270 --> 07:03:46,220
pro pose, all description, we
would do it on new line, why

29919
07:03:46,220 --> 07:03:50,330
not? Pro pulls all this option,
which we don't have yet.

29920
07:03:50,390 --> 07:03:52,880
Alright, we're gonna get it. So
we also need to pass a proposal

29921
07:03:52,880 --> 07:03:56,450
description, right, because we
have down here, description. So

29922
07:03:56,450 --> 07:03:59,450
let's add another parameter to
our propose here. So we'll say

29923
07:03:59,450 --> 07:04:04,340
proposal description, and this
will be also a string. Down at

29924
07:04:04,340 --> 07:04:07,040
the bottom, we're going to need
a proposal description as well.

29925
07:04:07,280 --> 07:04:11,060
So we'll create a proposal or
export const proposal

29926
07:04:11,060 --> 07:04:13,520
description, there's just going
to be some string. So we'll say

29927
07:04:13,520 --> 07:04:19,790
proposal number one, door 77 In
the box, that's the description

29928
07:04:19,790 --> 07:04:22,760
here, comma proposal
description. And then we import

29929
07:04:22,760 --> 07:04:25,970
this or a helper config. Okay,
perfect. So now we have the new

29930
07:04:25,970 --> 07:04:29,060
store value, the function the
proposal description, and we can

29931
07:04:29,060 --> 07:04:32,990
now call that propose that we
were just looking at so here's

29932
07:04:32,990 --> 07:04:38,360
what we're going to do const
propose TX equals await. gov dot

29933
07:04:38,360 --> 07:04:42,080
propose. And we need to pass
those lists. So first is going

29934
07:04:42,080 --> 07:04:44,360
to be a list of targets, which
for us is just a box that

29935
07:04:44,360 --> 07:04:47,090
address right only one target.
And again, these these little

29936
07:04:47,090 --> 07:04:49,580
brackets, make it a list of
values, which is just going to

29937
07:04:49,580 --> 07:04:54,260
be zero, a list of encoded
function calls or our bytes

29938
07:04:54,290 --> 07:04:58,220
data, basically, and then the
proposal description, and then

29939
07:04:58,220 --> 07:05:02,660
we're going to do propose, TX
dot wait one. Now, if you

29940
07:05:02,660 --> 07:05:06,020
remember, from compound, this is
going to be the exact same if we

29941
07:05:06,020 --> 07:05:10,970
go back to compound back to
governance, this transaction is

29942
07:05:10,970 --> 07:05:13,970
literally going to be the same
as this created thing here.

29943
07:05:14,180 --> 07:05:17,750
Right? And if we scroll down,
like more, we can see the code

29944
07:05:17,750 --> 07:05:20,690
input data, those exact same
things on a compound proposal,

29945
07:05:20,690 --> 07:05:24,230
right? We have targets values
signatures, well okay, this CES

29946
07:05:24,230 --> 07:05:26,750
is a little bit more, this a
little bit more advanced here,

29947
07:05:27,020 --> 07:05:29,690
using signatures, but it's got
the same thing called data and

29948
07:05:29,690 --> 07:05:33,650
then a description here, okay.
Now since we have a voting

29949
07:05:33,650 --> 07:05:36,890
delay, people actually can't
vote until the voting delay

29950
07:05:36,890 --> 07:05:39,920
passes. Now, with a local
blockchain, nobody's actually

29951
07:05:39,920 --> 07:05:43,010
processing blocks and time
doesn't really pass as quick as

29952
07:05:43,010 --> 07:05:46,400
we want. And so we're just going
to speed things up for our own

29953
07:05:46,400 --> 07:05:49,520
testing purposes. So the way I
normally do this is I create

29954
07:05:49,520 --> 07:05:53,360
this this variable, all
development, exports, on

29955
07:05:53,630 --> 07:05:59,210
development chains, and I'll add
hard hat and local host. Because

29956
07:05:59,210 --> 07:06:01,760
we can actually do things with
our own local blockchain, we can

29957
07:06:01,760 --> 07:06:04,190
actually speed up time, we can
speed up blocks, we can do all

29958
07:06:04,190 --> 07:06:07,670
this crazy stuff. So usually,
I'll actually import this in

29959
07:06:07,670 --> 07:06:10,520
here. And then we'll do a quick
F. And I'll say, if we're on a

29960
07:06:10,520 --> 07:06:12,950
development chain, let's just go
ahead and speed things up for

29961
07:06:12,950 --> 07:06:18,320
us. Right. So I'll say if
development chains that includes

29962
07:06:18,350 --> 07:06:22,250
network dot name, and then we
can import network from from

29963
07:06:22,280 --> 07:06:24,590
ethers, as well. And this is
what I was talking about those

29964
07:06:24,590 --> 07:06:26,720
super six skills that you're
gonna learn. If it includes

29965
07:06:26,720 --> 07:06:29,270
network dot name, then we're
gonna go ahead and move the

29966
07:06:29,270 --> 07:06:31,370
blocks forward, right, because
if we're not on development

29967
07:06:31,370 --> 07:06:34,220
chain, we can't actually move
blocks. So what we'll do here is

29968
07:06:34,220 --> 07:06:37,340
actually I'll create a new
folder called utilities, you

29969
07:06:37,340 --> 07:06:41,480
folder, you are utils. And in
here, I'll create a script

29970
07:06:41,570 --> 07:06:46,490
called Move blocks.ts. And we're
just going to create this little

29971
07:06:46,490 --> 07:06:49,040
function called move blocks,
which moves blocks for us. And

29972
07:06:49,040 --> 07:06:51,470
you'll see how we do this. So
we're going to import network

29973
07:06:51,590 --> 07:06:54,380
from heart app, because we want
to speed up that voting delay,

29974
07:06:54,590 --> 07:06:58,280
we'll do export async function,
we'll call it move blocks. And

29975
07:06:58,280 --> 07:07:01,790
it'll take an amount, which will
be a number, so how many blocks

29976
07:07:01,820 --> 07:07:04,220
that we actually want to move.
And then we'll just do console

29977
07:07:04,220 --> 07:07:09,800
dot log moving blocks. And we'll
say for let index equals zero,

29978
07:07:10,310 --> 07:07:15,110
index is less than amount. index
plus plus, or we're going to do

29979
07:07:15,110 --> 07:07:19,670
is we're going to do a weight
network DAP provider dot request

29980
07:07:19,730 --> 07:07:25,670
request. And we're going to
request method EVM. Mine. So

29981
07:07:25,700 --> 07:07:30,500
basically, we're mining for our
local blockchain, right, so you

29982
07:07:30,500 --> 07:07:33,680
can find these docks in the hard
hat docks in the ethers docks,

29983
07:07:34,760 --> 07:07:36,620
there's a couple different
places you can find these. But

29984
07:07:36,860 --> 07:07:40,130
this is kind of this really cool
hack that we can use to actually

29985
07:07:40,130 --> 07:07:42,710
move blocks forward on our local
chain. Now, obviously, this

29986
07:07:42,710 --> 07:07:45,320
won't work on an actual chain,
because you'd actually have to

29987
07:07:45,320 --> 07:07:47,570
do the mining but on our local
chains, we can absolutely do

29988
07:07:47,570 --> 07:07:51,140
this. So we've exported this
move blocks function, and we're

29989
07:07:51,140 --> 07:07:54,620
actually gonna grab that Mark
propose, we're going to import

29990
07:07:55,010 --> 07:08:01,190
move box from utils blocks. And
we're going to say down here, if

29991
07:08:01,190 --> 07:08:04,700
we're on this development chain,
and do a weight move blocks, and

29992
07:08:04,700 --> 07:08:07,130
then we'll move blocks by that
voting delay that we were

29993
07:08:07,130 --> 07:08:09,320
talking about, right? Because we
need to wait that voting delay

29994
07:08:09,350 --> 07:08:12,200
in order to move and it looks
like an auto import it for us

29995
07:08:12,230 --> 07:08:14,150
from our helper hardware config.
I told you, we were gonna use

29996
07:08:14,150 --> 07:08:16,430
that a couple of times, but
we're gonna move blocks by that

29997
07:08:16,430 --> 07:08:19,760
voting delay. Now, this proposed
transaction does some stuff that

29998
07:08:19,760 --> 07:08:22,580
we actually want, right? So one
of the big things that it wants

29999
07:08:22,580 --> 07:08:25,910
is, is it has this proposal ID.
And if we scroll down to the

30000
07:08:25,970 --> 07:08:29,990
event that it emits, it ends up
emitting this proposal ID, we

30001
07:08:29,990 --> 07:08:33,260
actually need the proposal ID
for later on when we actually go

30002
07:08:33,260 --> 07:08:35,660
to vote. So what we're going to
do is we're actually going to do

30003
07:08:35,660 --> 07:08:41,750
const propose receipt equals
proposed text dot weight. And

30004
07:08:41,750 --> 07:08:44,600
we're going to get those events
from this proposed receipt. So

30005
07:08:44,600 --> 07:08:49,700
we're gonna say const. Proposal,
id equals proposed receipt, that

30006
07:08:49,700 --> 07:08:52,640
events, the zero with event
because that first event is the

30007
07:08:52,640 --> 07:08:56,780
only one we care about that are
your stop proposal ID. This is

30008
07:08:56,780 --> 07:09:00,830
how we get this proposal ID from
this omit also created event. A

30009
07:09:00,830 --> 07:09:03,110
couple other ways to get
proposals to get events in

30010
07:09:03,110 --> 07:09:05,540
hardhat. And I got a video on it
on my YouTube, if you want to go

30011
07:09:05,540 --> 07:09:08,330
check that out. Something else
that we want to do is maybe we

30012
07:09:08,330 --> 07:09:11,030
want to see what the deadline is
with a snapshot, you can go

30013
07:09:11,030 --> 07:09:13,850
ahead and check my GitHub to
kind of see what the snapshot

30014
07:09:13,850 --> 07:09:16,160
looks like or the deadline,
basically, how long we have to

30015
07:09:16,160 --> 07:09:18,590
vote, you know what snapshot
you're working with, and all

30016
07:09:18,590 --> 07:09:20,150
these different things. But for
now, we're just gonna stick with

30017
07:09:20,150 --> 07:09:22,670
the proposal Id be sure to check
out the GitHub for more stuff.

30018
07:09:22,700 --> 07:09:25,160
Now we want to save this
proposal ID, we want to save it

30019
07:09:25,160 --> 07:09:27,980
somewhere so that our other
scripts so that our vote and our

30020
07:09:27,980 --> 07:09:31,310
queue and execute know what this
proposal ID is going to be when

30021
07:09:31,310 --> 07:09:33,800
we run those. So what we're
going to do is we're going to

30022
07:09:33,830 --> 07:09:36,500
create this file called
proposals dot JSON. And it's

30023
07:09:36,500 --> 07:09:38,780
going to store all of our
proposals. So we're gonna say

30024
07:09:38,780 --> 07:09:42,440
pro poll, souls dot JSON, it's
going to have all of our

30025
07:09:42,440 --> 07:09:45,020
proposals in here. So what we're
going to do and we're going to

30026
07:09:45,050 --> 07:09:48,380
add this to our helper Hardhead
config, and do export const,

30027
07:09:48,380 --> 07:09:52,850
proposals, file equals proposals
dot JSON. And we're going to

30028
07:09:52,850 --> 07:09:56,510
import this at the top as well
as proposals file. And then once

30029
07:09:56,510 --> 07:09:59,480
we get this proposal ID, we're
going to do is we're going to

30030
07:09:59,480 --> 07:10:02,630
read all the current proposals.
So we're gonna say let proposals

30031
07:10:02,960 --> 07:10:08,420
equals JSON dot parse, and we're
gonna do Fs dot read file sync

30032
07:10:08,720 --> 07:10:13,520
from this probe proposals file,
and we're going to pass it to

30033
07:10:13,790 --> 07:10:18,200
UTF eight. Now, this Fs we don't
have yet, so we're going to need

30034
07:10:18,200 --> 07:10:23,630
to import Fs. So we're going to
do yarn add Fs like that. If

30035
07:10:23,630 --> 07:10:26,930
we're looking at package dot
JSON. Oops, I should have saved

30036
07:10:26,930 --> 07:10:31,010
that as Dev, but I didn't Oh,
well, doesn't really matter. Now

30037
07:10:31,010 --> 07:10:33,050
that we have that we can
actually import this into our

30038
07:10:33,050 --> 07:10:38,030
TypeScript. So we're just going
to say, import star as Fs from

30039
07:10:38,060 --> 07:10:42,770
Fs. And now we can actually use
Fs F as a way to kind of read

30040
07:10:42,770 --> 07:10:45,740
from files. Now we can get this
list of proposals. So we got two

30041
07:10:45,740 --> 07:10:48,620
proposals that JSON right now
we're just making a blank JSON.

30042
07:10:48,620 --> 07:10:51,410
So the first time we run it,
it'll just be blank. But later

30043
07:10:51,410 --> 07:10:54,050
on, it'll have stuff in it. And
the way that we're going to save

30044
07:10:54,050 --> 07:10:58,640
these proposals is we're going
to say pro proposals of network

30045
07:10:58,940 --> 07:11:02,900
dot config dot chain ID, and
this little bank to say, yes,

30046
07:11:02,900 --> 07:11:06,170
there will be a chain id.to
string, we're going to store

30047
07:11:06,170 --> 07:11:09,290
them by their chain IDs, right.
So for each network that we have

30048
07:11:09,290 --> 07:11:12,020
a proposal to we'll we'll start
like that. And then we'll do dot

30049
07:11:12,020 --> 07:11:17,060
push proposal, id.to string, and
then we'll write it back. We'll

30050
07:11:17,060 --> 07:11:23,390
do Fs dot right, file sync,
proposals file. JSON does string

30051
07:11:23,420 --> 07:11:28,280
phi, proposals, and awesome. And
that's all we need to do. So

30052
07:11:28,280 --> 07:11:30,260
let's go ahead and actually run
this. And then I have some

30053
07:11:30,260 --> 07:11:32,630
console dot logs in here saying,
Hey, here's what the proposal

30054
07:11:32,630 --> 07:11:35,930
state is, is it open? Is it
voting is it canceled, you know,

30055
07:11:35,930 --> 07:11:38,900
etc. What the proposal snapshot
is, you know, again, check my

30056
07:11:38,900 --> 07:11:42,020
GitHub for that. But what we can
do, now this is done, we can do

30057
07:11:42,020 --> 07:11:46,100
yarn, Hardhead node, spin up our
little note here. And all the

30058
07:11:46,100 --> 07:11:50,570
contracts are deployed. And then
we'll do yarn, run scripts,

30059
07:11:50,630 --> 07:11:54,500
proposed that TS dash dash
network, local host scripts

30060
07:11:54,500 --> 07:12:01,130
proposed that TS is not found.
Pro pose, yarn, hard hat, run

30061
07:12:01,130 --> 07:12:06,020
scripts, pose IDs, oops, dash
dash network, local hosts. Try

30062
07:12:06,020 --> 07:12:09,950
this again. Now you found it.
Yay. Oh, I ran into an issue.

30063
07:12:10,400 --> 07:12:12,950
Although description Moviebox
Cannot read property zero of

30064
07:12:12,950 --> 07:12:16,160
undefined. Let's see where it
got mad at me. Poser sheet dot

30065
07:12:16,160 --> 07:12:20,270
event. It is events, not event
shots again, on the localhost.

30066
07:12:20,390 --> 07:12:23,900
There we go running ran into
another issue. Posle already

30067
07:12:23,900 --> 07:12:27,590
exists. Okay, so great. So the
proposal already exists, let's

30068
07:12:27,590 --> 07:12:30,500
go ahead and just like kill the
node, restart the node, so you

30069
07:12:30,500 --> 07:12:33,110
can't have two proposals that
are exactly the same, basically,

30070
07:12:33,170 --> 07:12:35,840
right. So we can't do that, we
would need to change the

30071
07:12:35,840 --> 07:12:37,550
description or something. So
we're just going to kill the

30072
07:12:37,550 --> 07:12:39,710
node and restart. Now we're
going to run this proposal

30073
07:12:39,710 --> 07:12:44,060
again. And hopefully this one
should work this time. Community

30074
07:12:44,060 --> 07:12:49,490
Property zero of undefined owes
receipt. This needs to be await

30075
07:12:49,520 --> 07:12:52,790
because it is a promise, kill
this one more time we run it

30076
07:12:53,150 --> 07:12:56,000
once all these get deployed. And
we're gonna go ahead and run

30077
07:12:56,000 --> 07:12:58,190
this. Now you can see how much
quicker this is than if you were

30078
07:12:58,190 --> 07:13:00,980
to actually send this to a test
net right to an event a lot of

30079
07:13:00,980 --> 07:13:06,500
waiting, which is no bueno. And
we run into one more Cannot read

30080
07:13:06,500 --> 07:13:09,410
property, push them undefined.
That makes a lot of sense, too.

30081
07:13:09,410 --> 07:13:13,880
Because proposals dot JSON as
nothing for chain IDs. So

30082
07:13:13,970 --> 07:13:18,800
231337. And we'll put a little
list in here. Right now it's an

30083
07:13:18,800 --> 07:13:21,800
empty list. Now we're going to
kill this one more time, kill

30084
07:13:21,800 --> 07:13:22,040
it.

30085
07:13:23,419 --> 07:13:25,159
And then once this goes, then
we're gonna go ahead and do

30086
07:13:25,159 --> 07:13:29,809
this. Perfect. Now we're going
to run this and now it should

30087
07:13:29,809 --> 07:13:34,729
save and everything should be
peachy hunky dory. Awesome.

30088
07:13:34,789 --> 07:13:38,119
proposal number one store in the
box, we move the blocks. And if

30089
07:13:38,119 --> 07:13:41,179
we look at proposal dot JSON, we
now see there's a list of

30090
07:13:41,179 --> 07:13:44,239
proposals. And this is the
proposal ID of that one we just

30091
07:13:44,239 --> 07:13:47,659
created. Oh, okay, we made a
proposal. Awesome. Nice work,

30092
07:13:47,659 --> 07:13:50,329
we'll leave that Node running.
And hopefully we'll just do

30093
07:13:50,329 --> 07:13:54,199
things right for the voting. So
let's create this vote script

30094
07:13:54,199 --> 07:13:58,189
now. Okay, so now we proposed
it's time to vote, let's do a

30095
07:13:58,189 --> 07:14:00,889
little voting. So this is going
to look pretty similar to that

30096
07:14:00,889 --> 07:14:03,439
script, we just we just created
right. So we're in New async

30097
07:14:03,469 --> 07:14:08,479
function, we'll call this main
proposal index number, and we're

30098
07:14:08,479 --> 07:14:11,569
calling this main because we're
going to have the vote function

30099
07:14:11,569 --> 07:14:13,489
be a little bit different.
You'll see why. And at the

30100
07:14:13,489 --> 07:14:17,419
bottom, of course, we're going
to do main index dot then

30101
07:14:17,659 --> 07:14:24,109
process dot exit zero, catch
error arrow function, console

30102
07:14:24,109 --> 07:14:30,049
dot error, error, and then
process that exit. One main

30103
07:14:30,079 --> 07:14:34,219
index, we're gonna say our index
zero cost index zero. We'll do

30104
07:14:34,219 --> 07:14:36,829
like this cost index is your
postal index. So we're gonna get

30105
07:14:36,859 --> 07:14:39,589
we're gonna get that bit zero
with index, right, the first

30106
07:14:39,589 --> 07:14:42,949
index in our proposals dot JSON.
So whatever is the first one in

30107
07:14:42,949 --> 07:14:44,779
this list is what we're gonna
use, right? And that's what we

30108
07:14:44,779 --> 07:14:46,909
want right now. There's only one
so it's easy. So we're gonna get

30109
07:14:46,909 --> 07:14:49,909
that first one in here. So first
thing we're gonna need to do is

30110
07:14:49,909 --> 07:14:52,279
we're gonna need to grab the
list of proposals. So we're

30111
07:14:52,279 --> 07:14:57,439
gonna do const proposals equals
JSON dot parse, FS dot read,

30112
07:14:57,769 --> 07:15:02,599
file sync proposals file, UTF,
eight. So of course, we're going

30113
07:15:02,599 --> 07:15:05,209
to need to import a bunch of
stuff. We're going to import

30114
07:15:05,269 --> 07:15:10,639
proposals file from that a slash
a Bernhard config. And then

30115
07:15:10,639 --> 07:15:16,459
we're going to do import star as
Fs from us. Great. We have Fs,

30116
07:15:16,489 --> 07:15:19,699
we can read stuff, and we can
get those boats. Okay, cool. So

30117
07:15:19,699 --> 07:15:22,789
we have a list of proposal IDs.
Now let's get our proposal idea

30118
07:15:22,789 --> 07:15:28,459
we'll do const probo. also ID
equals proposals of network dot

30119
07:15:28,459 --> 07:15:32,329
config. And then that's not what
we want. We want to actually

30120
07:15:32,329 --> 07:15:37,189
import network, import network
from hard hat, network dot

30121
07:15:37,189 --> 07:15:42,979
config, that chain ID,
exclamation mark of proposal

30122
07:15:43,039 --> 07:15:45,529
index, which for us is going to
be zero, right? We're getting

30123
07:15:45,529 --> 07:15:48,289
that first proposal in the list
of proposals. Now we're gonna

30124
07:15:48,289 --> 07:15:52,129
choose how we want to vote. So
zero equals against one equals

30125
07:15:52,159 --> 07:15:55,639
four, and then two is abstain. I
don't know why you'd ever

30126
07:15:55,639 --> 07:15:58,879
abstain abstaining costs gas,
you could just not vote, but

30127
07:15:58,879 --> 07:16:01,399
we're gonna say const vote way
and the way we're gonna vote

30128
07:16:01,429 --> 07:16:05,719
equals one. And we can also do a
reason. So if we go back to our

30129
07:16:05,749 --> 07:16:07,939
governor, there's a couple
different functions we get to do

30130
07:16:07,939 --> 07:16:10,759
to vote, there's cast vote,
where we just cast a vote, cast,

30131
07:16:10,759 --> 07:16:14,359
vote with reason, and cast vote
with signature where we actually

30132
07:16:14,359 --> 07:16:17,419
do a signature. And I asked this
question, Hey, what is cast vote

30133
07:16:17,419 --> 07:16:19,999
by sick do on the opens up on
forum, I was like, hey, what's

30134
07:16:19,999 --> 07:16:22,909
the what is the purpose of this?
My hunch was that anyone could

30135
07:16:22,909 --> 07:16:25,009
then execute this vote on behalf
of me if I didn't send the

30136
07:16:25,009 --> 07:16:27,709
transaction. And that's exactly
what it is. This method

30137
07:16:27,709 --> 07:16:30,289
implements a meta transaction
and allows a project to

30138
07:16:30,289 --> 07:16:32,839
subsidize voting fees, the
voters can generate a signature

30139
07:16:32,839 --> 07:16:35,599
for free, and the project can
submit those and pay for the

30140
07:16:35,599 --> 07:16:38,989
gas. So this is incredibly
powerful. And this is the

30141
07:16:38,989 --> 07:16:43,339
function that allows this, this,
this cast vote by signature is

30142
07:16:43,339 --> 07:16:46,369
what allows that snapshot chain
link integration that you know,

30143
07:16:46,369 --> 07:16:49,879
hopefully one of you build, but
for us for this, since we're not

30144
07:16:49,909 --> 07:16:52,099
implementing these meta
transactions, these off chain

30145
07:16:52,099 --> 07:16:54,859
stuff, we're just going to do
cast a vote with reason why

30146
07:16:54,859 --> 07:16:57,199
because we want to give it a
reason. That's really it. So

30147
07:16:57,199 --> 07:17:02,869
we're gonna say const boat TX
response equals await. Gov nor

30148
07:17:03,109 --> 07:17:06,349
dot cast, excuse me, we need to
get the government contract. So

30149
07:17:06,349 --> 07:17:11,089
we'll do const. Gov nor equals
await ethers dot get contract.

30150
07:17:11,149 --> 07:17:14,809
Gov contract. And then if we
don't have ethers, we should get

30151
07:17:14,809 --> 07:17:18,349
ethers. Great. Let's get ethers.
And we'll ignore that. But now

30152
07:17:18,349 --> 07:17:21,649
we have the contract. So we'll
do a weight gov dot cast vote

30153
07:17:21,739 --> 07:17:25,789
with reason spell this right?
With reason. And we'll say

30154
07:17:25,789 --> 07:17:29,989
proposal ID that way. And then
the reason which we don't have a

30155
07:17:29,989 --> 07:17:33,199
reason here, so let's make a
reason. Let's say the reason is

30156
07:17:33,769 --> 07:17:39,829
reason, equals I like do cha
cha, if you know that film, you

30157
07:17:39,829 --> 07:17:41,899
should definitely comment it in
the description. We have a

30158
07:17:41,899 --> 07:17:45,349
reason so we're voting for we're
saying yes, we want we do indeed

30159
07:17:45,379 --> 07:17:49,489
want you to change the box to
77. And the reason is because I

30160
07:17:49,489 --> 07:17:52,909
like a do the Cha Cha makes
perfect sense if you don't think

30161
07:17:52,909 --> 07:17:56,299
about and then we'll do a wait,
Kotex response that wait. So I

30162
07:17:56,299 --> 07:17:59,599
do some stuff, again, checking
the state of the proposal where

30163
07:17:59,629 --> 07:18:02,239
different numbers mean, hey,
it's in process, it's voting,

30164
07:18:02,239 --> 07:18:04,759
etc, we could check on that. But
we're gonna skip that for now.

30165
07:18:04,819 --> 07:18:07,549
All we're going to do now, now
that we voted, we're going to be

30166
07:18:07,549 --> 07:18:09,919
the ones to vote. So we're just
going to once again move the

30167
07:18:09,919 --> 07:18:13,279
blocks along. Why because we
want to just get to the end of

30168
07:18:13,279 --> 07:18:16,069
that voting period. So we're
gonna do again, if velopment

30169
07:18:16,069 --> 07:18:20,839
chains, that includes network
dot name, then we're gonna do a

30170
07:18:20,839 --> 07:18:25,489
weight move blocks, voting
period, plus one. So we need to

30171
07:18:25,489 --> 07:18:28,519
import a whole bunch of stuff in
here. poses file development,

30172
07:18:28,699 --> 07:18:31,669
looks like those got auto
imported, we need to import this

30173
07:18:31,669 --> 07:18:37,459
move blocks. So import move
blocks from utils blocks, and

30174
07:18:37,459 --> 07:18:40,099
that network is in here. And
then we need voting period from

30175
07:18:40,099 --> 07:18:43,219
our helper config. voting
period. Okay, cool. And then

30176
07:18:43,219 --> 07:18:49,399
we'll do console dot log, voted,
ready to go. Now the reason that

30177
07:18:49,399 --> 07:18:52,939
I checked the proposal state is
because there's this state

30178
07:18:52,939 --> 07:18:55,789
function in the governor
contract. So if we look up

30179
07:18:55,789 --> 07:18:59,149
state, what this does is it
tells us what the state of the

30180
07:18:59,149 --> 07:19:02,599
proposals in right if it's been
executed, return that's been

30181
07:19:02,599 --> 07:19:05,419
executed, if it's been canceled,
return has been canceled. You

30182
07:19:05,419 --> 07:19:08,179
have the deadline, check to see
if it's active, check to see if

30183
07:19:08,179 --> 07:19:10,999
quorum reached all this stuff,
right? And what you're usually

30184
07:19:10,999 --> 07:19:14,479
looking for is worm reached and
vote succeeded, right? If both

30185
07:19:14,479 --> 07:19:17,389
of these happen, the proposal
state DOT succeeded, right?

30186
07:19:17,479 --> 07:19:20,419
Otherwise, it's defeated or it's
not there yet. I believe this is

30187
07:19:20,419 --> 07:19:23,209
a one and this is a zero. So if
you were to call that function

30188
07:19:23,209 --> 07:19:27,079
and get the state right, now we
should get a zero. Or excuse me,

30189
07:19:27,079 --> 07:19:29,839
we should get a one for this
having passed. If you want to do

30190
07:19:29,839 --> 07:19:32,389
that as a little extra credit,
feel free to do so. So let's see

30191
07:19:32,389 --> 07:19:34,489
if we did this right. Well,
actually, I guess we got to

30192
07:19:34,489 --> 07:19:37,459
change this just to vote. But I
just wrapped everything up into

30193
07:19:37,489 --> 07:19:40,459
main. So let's see if this
works. Yarn, hard hat run

30194
07:19:40,459 --> 07:19:44,479
scripts vote network, local
host. So we should get a little

30195
07:19:44,479 --> 07:19:48,289
console dot log at the bottom
that says voted ready to go. So

30196
07:19:48,289 --> 07:19:51,409
now we're voting. We didn't just
go to the Arctic Council, we

30197
07:19:51,409 --> 07:19:55,999
could do yarn, hard hat console,
dash dash network, local host.

30198
07:19:56,179 --> 07:19:58,699
And in here, you can actually
just check the state right in

30199
07:19:58,699 --> 07:20:02,509
here. Why not? We'll copy this
line as governor because we

30200
07:20:02,539 --> 07:20:06,139
either get contract Governor
contract. Now we can do a wait,

30201
07:20:06,319 --> 07:20:12,109
Governor, that's state of go to
the proposals dot JSON, grab

30202
07:20:12,109 --> 07:20:16,069
this, paste it in here. And we
get a for the state of this

30203
07:20:16,069 --> 07:20:19,399
right now is for I forget what
four means. It's like a proposal

30204
07:20:19,399 --> 07:20:22,639
state. The proposal state is
actually in the eye governor so

30205
07:20:22,639 --> 07:20:27,349
the interface of the governor We
can see, zero is pending, one is

30206
07:20:27,349 --> 07:20:30,469
active, two cancelled, three
defeated, and four have

30207
07:20:30,469 --> 07:20:34,129
succeeded. So we are in a
succeeded state, which is really

30208
07:20:34,129 --> 07:20:36,409
good. That's exactly what we
want. So let's go ahead and quit

30209
07:20:36,409 --> 07:20:41,149
now. Excuse me Ctrl. C, our
proposal is now in a succeeded

30210
07:20:41,149 --> 07:20:44,539
state. And we've actually moved
the blocks along the voting

30211
07:20:44,539 --> 07:20:47,809
period. So voting is now over
because we cheated. So now let's

30212
07:20:47,809 --> 07:20:52,039
go ahead and queue and execute
this to the last bit here. So

30213
07:20:52,099 --> 07:20:53,899
this is gonna look real similar
to what we've done already.

30214
07:20:53,929 --> 07:20:59,449
Right? Let's minimize this,
export async, function, Q, and

30215
07:20:59,509 --> 07:21:04,069
execute. And then at the bottom,
we'll just call queue, and

30216
07:21:04,069 --> 07:21:07,039
execute. And I'm just going to
copy paste, but it's that same

30217
07:21:07,039 --> 07:21:10,759
syntax here, then process exec
catch, blah, blah, blah, you get

30218
07:21:10,759 --> 07:21:14,029
the drill. So in order to queue
and execute, go back to the

30219
07:21:14,029 --> 07:21:16,099
governor contract, not the
governor, let's go to the

30220
07:21:16,099 --> 07:21:19,219
governor. First thing we're
going to do is call this queue.

30221
07:21:19,729 --> 07:21:24,019
Now this Q function is actually
in the governor time lock, which

30222
07:21:24,019 --> 07:21:27,169
is in this extensions here. So
we can find the governor Time

30223
07:21:27,169 --> 07:21:31,939
Lock controller here, and it
does exactly the same as propose

30224
07:21:31,939 --> 07:21:34,819
we take everything that we did
in the proposal, and then we

30225
07:21:34,819 --> 07:21:37,579
just queue it like so. So we
pass the exact same values here.

30226
07:21:37,669 --> 07:21:40,009
And that's so cute. So what
we're going to do is we're gonna

30227
07:21:40,009 --> 07:21:42,559
need to first get those exact
same values, which I told you

30228
07:21:42,559 --> 07:21:45,229
we're going to use a few times.
So we're going to import bunk,

30229
07:21:45,409 --> 07:21:51,319
new store value, proposal
description of our article

30230
07:21:51,319 --> 07:21:53,809
thing, right now that we have
all that stuff, we'll say const

30231
07:21:53,809 --> 07:21:56,629
args equals a new store value,

30232
07:21:56,989 --> 07:22:03,079
we'll do const box equals await
ethers dot get contract, let's

30233
07:22:03,079 --> 07:22:06,199
get that box contract again,
we're gonna have to import

30234
07:22:06,439 --> 07:22:10,879
ethers from our hat. And this is
going to be from we're gonna do

30235
07:22:11,119 --> 07:22:15,949
TS ignore, then we're once again
code this function call to const

30236
07:22:16,009 --> 07:22:21,229
encoded function call equals
Boxtop interface, encode

30237
07:22:21,649 --> 07:22:25,729
function data. Once again, we're
gonna do funk is the function we

30238
07:22:25,729 --> 07:22:28,789
want to call and args this is
like real similar to the our

30239
07:22:28,789 --> 07:22:31,729
proposed bit that we did. And
then we're gonna do content

30240
07:22:31,759 --> 07:22:38,779
description hash equals ethers
dot utils that get GAC 256

30241
07:22:38,989 --> 07:22:43,879
ethers dot utils, that to you,
TF eight bytes, this will make

30242
07:22:43,909 --> 07:22:47,299
sense in a second. We're also
description. So what's our

30243
07:22:47,299 --> 07:22:51,769
propose, all we did was pass our
proposal description, however,

30244
07:22:51,799 --> 07:22:54,769
it actually gets hashed on
chain, and that's what our view

30245
07:22:54,769 --> 07:22:56,749
and execute is gonna be looking
for, it's gonna be looking for

30246
07:22:56,749 --> 07:22:59,419
the description hash, instead of
just the pure description,

30247
07:22:59,449 --> 07:23:01,069
right, and it's gonna be a
little bit cheaper gas wise,

30248
07:23:01,069 --> 07:23:04,129
which is good. So now that we
have the description hash, now

30249
07:23:04,129 --> 07:23:06,679
that we have all the same
functions that we did for the

30250
07:23:06,709 --> 07:23:11,089
suppose it's time to queue them.
So do cost gov equals await

30251
07:23:11,179 --> 07:23:16,309
ethers dot get contract. Gov
contract, console dot log will

30252
07:23:16,309 --> 07:23:23,599
say we're queuing and then we'll
do cos Q, dx equals gov dot q.

30253
07:23:23,899 --> 07:23:26,029
And we're going to pass the
exact same parameters we did

30254
07:23:26,029 --> 07:23:28,489
with the pose except for what
the hash instead of the actual

30255
07:23:28,489 --> 07:23:32,839
proposal, so box that address
zero for eath, and pass that

30256
07:23:33,019 --> 07:23:38,839
code at function call. And then
the description hash rate. And

30257
07:23:38,839 --> 07:23:42,439
then we're going to do oops, is
going to be a weight here. And

30258
07:23:42,439 --> 07:23:46,129
then we're gonna do a wait. You
text Oh, wait, one, wait a block

30259
07:23:46,129 --> 07:23:50,179
there. And great, then we're all
queued up. Now we still have to

30260
07:23:50,179 --> 07:23:53,989
wait that minimum delay, right?
Remember, on our timeline, it's

30261
07:23:53,989 --> 07:23:56,449
got this min delay thing. It
says, Hey, once something gets

30262
07:23:56,449 --> 07:23:59,329
queued up, you can't just
execute it right away. You gotta

30263
07:23:59,329 --> 07:24:02,869
give people time to get out. So
we're going to speed up time

30264
07:24:02,869 --> 07:24:06,499
again, we're going to say if
development chains develop l

30265
07:24:06,559 --> 07:24:09,499
meant chains that includes and
then it looks like it auto

30266
07:24:09,499 --> 07:24:12,739
imported for me development
chains. Yes, it did. Amazing.

30267
07:24:13,039 --> 07:24:16,999
That includes network dot name.
Let's just make sure we import

30268
07:24:16,999 --> 07:24:20,929
network from Hardhead. That
includes our name, then, of

30269
07:24:20,929 --> 07:24:23,569
course, we're going to move
blocks. But we also actually

30270
07:24:23,569 --> 07:24:26,959
have to move time here as the
minimum delay is looking for

30271
07:24:26,959 --> 07:24:31,699
some time. So let's create a new
util called Move time. Okay,

30272
07:24:31,729 --> 07:24:36,139
move time that Yes. And this
util is going to allow us to

30273
07:24:36,139 --> 07:24:38,839
move time so you're learning all
the cool stuff. So we'll quickly

30274
07:24:38,839 --> 07:24:41,809
write a script to do this
important network from hard hat

30275
07:24:41,899 --> 07:24:47,029
export async function move time,
how much time will be a number

30276
07:24:47,029 --> 07:24:52,399
of Mount console dot log, moving
time, and let's say await

30277
07:24:52,459 --> 07:24:59,149
network dot provider dot send
EVM increase time and then just

30278
07:24:59,149 --> 07:25:03,079
by the amount, then we'll just
say console dot log, move

30279
07:25:03,079 --> 07:25:07,639
forward, amount seconds, it goes
forward and seconds. Cool. So

30280
07:25:07,639 --> 07:25:10,369
now we have this move time
function. That was pretty quick,

30281
07:25:10,369 --> 07:25:12,769
right? So first, we're going to
move time and we're gonna move

30282
07:25:12,769 --> 07:25:16,579
time by that min delay first,
plus one just to be safe. And

30283
07:25:16,579 --> 07:25:18,799
then we're also going to move
blocks. We're gonna do a weight

30284
07:25:18,799 --> 07:25:22,399
move time, and then a weight
move blocks. And we'll just move

30285
07:25:22,399 --> 07:25:26,839
on block. So got it Import move
blocks from utils. It imports

30286
07:25:27,169 --> 07:25:32,629
move time from those utils as
well, time. And then we also

30287
07:25:32,629 --> 07:25:35,659
have to import this min delay,
which we get from our helper.

30288
07:25:35,659 --> 07:25:38,899
Hardhead config. Great. So we
moved all that stuff. Again, if

30289
07:25:38,899 --> 07:25:41,209
this were a real chain, you just
have to wait. But since we're

30290
07:25:41,209 --> 07:25:43,879
not a real chain, we can do
whatever we want. Yes, love

30291
07:25:43,879 --> 07:25:46,489
doing whatever I want. Now that
it's all cued up, the voters

30292
07:25:46,489 --> 07:25:51,499
passed, we're looking spicy.
Let's drive this home. Xe cuting

30293
07:25:52,039 --> 07:25:56,989
do a little console dot log
executing the const execute TX

30294
07:25:57,019 --> 07:26:01,459
equals await. gov dot execute.
We're going to pass this the

30295
07:26:01,459 --> 07:26:05,299
exact same set of things we did
for the Q TX so I'm literally

30296
07:26:05,299 --> 07:26:08,989
gonna copy this. paste it down
here. And then we're just going

30297
07:26:08,989 --> 07:26:13,399
to do a weight SQ TX dot weight.
We're going to wait one block.

30298
07:26:13,699 --> 07:26:18,619
And then the final hour we'll
see if the governance updated

30299
07:26:18,799 --> 07:26:23,749
our box contract const box new
value equals await box dot

30300
07:26:23,779 --> 07:26:28,939
retrieve. And that will do
console dot log. New box value.

30301
07:26:30,230 --> 07:26:35,720
Box new value.to string Oh, so
if we did this right, it's new

30302
07:26:35,720 --> 07:26:39,830
box value to be updated. Let's
see if we did it right yarn hard

30303
07:26:39,830 --> 07:26:45,170
hat run grips Q and execute now
work localhost. Did we do it

30304
07:26:45,170 --> 07:26:49,910
right? Are we successfully done
governance? We did. That's okay.

30305
07:26:50,120 --> 07:26:52,490
We're gonna figure out what we
did wrong. Did you mean could

30306
07:26:52,490 --> 07:26:57,170
check 256 I spelt some stuff
wrong. It needs to be spelt like

30307
07:26:57,230 --> 07:27:01,700
no CK. Just just k. Okay, let's
try again. It failed before it

30308
07:27:01,700 --> 07:27:04,280
actually did. I think that's
good. Queuing moving time

30309
07:27:04,280 --> 07:27:08,870
provider EVM and crit cuz I
spelt increased time wrong. Oh,

30310
07:27:08,870 --> 07:27:15,020
no EVM increase time to just
double check. Make sure I'm

30311
07:27:15,020 --> 07:27:18,230
spelling this right T is
actually capital. So I totally

30312
07:27:18,260 --> 07:27:21,920
messed up. So it's actually
already been queued. It's been

30313
07:27:21,920 --> 07:27:25,880
queued right now on our little
node EVM increased team. So we

30314
07:27:25,880 --> 07:27:28,730
can either delete and kind of
restart, or I can just go ahead

30315
07:27:28,730 --> 07:27:31,370
and I'm just going to comment
out a bunch of stuff, we're just

30316
07:27:31,370 --> 07:27:34,370
going to skip the cueing here.
We're gonna run this one more

30317
07:27:34,370 --> 07:27:37,130
time, because it's already been
queued. And now should just

30318
07:27:37,130 --> 07:27:40,940
execute, we're gonna move time
again. But that's fine. Oh, my

30319
07:27:40,940 --> 07:27:43,760
goodness, we did it. Right. And
then normally, you would just do

30320
07:27:43,760 --> 07:27:46,430
it in one script. But this queue
would fail because it was

30321
07:27:46,430 --> 07:27:49,460
already queued. Right, you can't
queue twice, move forward. In

30322
07:27:49,460 --> 07:27:53,870
time, we move blocks we executed
and we got a new box value

30323
07:27:54,080 --> 07:27:58,910
completely using our Dow
completely decentralized voting

30324
07:27:58,910 --> 07:28:02,960
completely on chain, no third
party trust going in on here.

30325
07:28:03,050 --> 07:28:06,560
There's no voting booth, there's
no you know, spending 1000s of

30326
07:28:06,560 --> 07:28:10,370
dollars on staff, everything we
just voted on happened right in

30327
07:28:10,370 --> 07:28:13,700
front of our faces. Now, again,
I highly recommend go to my

30328
07:28:13,700 --> 07:28:16,400
GitHub repo, you take a look and
you see what's going on here.

30329
07:28:16,430 --> 07:28:18,530
Again, if you want to see
JavaScript stuff, feel free to

30330
07:28:18,530 --> 07:28:21,890
do some JavaScript stuff. But
this goes over how to just get

30331
07:28:21,890 --> 07:28:24,500
clone and get started if you
want to do that as well. But if

30332
07:28:24,500 --> 07:28:28,490
you walked with me here, if you
walked through this with me, you

30333
07:28:28,490 --> 07:28:31,310
have learned in the absolute
Khan, thank you so much for

30334
07:28:31,310 --> 07:28:32,930
being here. And I'll see you
next time.

30335
07:28:35,539 --> 07:28:40,219
All right. Now, welcome to the
final section of our course, the

30336
07:28:40,219 --> 07:28:44,269
security and auditing section,
this one is going to be a little

30337
07:28:44,269 --> 07:28:47,899
bit less coding and a little bit
more explaining. And most of

30338
07:28:47,899 --> 07:28:49,849
what we're going to be learning
about here is in this Hardhead

30339
07:28:49,849 --> 07:28:53,869
security FCC section. Throughout
this course, we've given you a

30340
07:28:53,869 --> 07:28:57,589
couple of tips about different
security features. One, we

30341
07:28:57,589 --> 07:29:00,499
talked about reentrancy, we
talked a little bit about Oracle

30342
07:29:00,499 --> 07:29:03,139
Tax, and we're going to talk
about those more. And some of

30343
07:29:03,139 --> 07:29:07,639
the tools we can use to make our
code more efficient, to look out

30344
07:29:07,639 --> 07:29:11,839
for bugs, and to make our code
more secure. So we're gonna go

30345
07:29:11,839 --> 07:29:15,499
ahead, we're gonna go over this
hard hat security FCC code base,

30346
07:29:15,529 --> 07:29:18,529
and we're going to walk through
it a little bit. So one of the

30347
07:29:18,529 --> 07:29:22,189
first things that we're going to
talk about is, what is an audit?

30348
07:29:22,339 --> 07:29:25,129
Well, an audit is going to be a
security focused code review,

30349
07:29:25,159 --> 07:29:29,119
looking for issues with your
code. So for example, let's say

30350
07:29:29,119 --> 07:29:31,849
we have some code that looks
like this, this should be a

30351
07:29:31,849 --> 07:29:34,969
little bit familiar, because we
talked about this in one of our

30352
07:29:34,969 --> 07:29:38,269
earlier sections with
reentrancy, our code, withdraw,

30353
07:29:38,389 --> 07:29:42,769
goes and sends ether and then
updates the balances, this code

30354
07:29:42,799 --> 07:29:45,979
is clearly vulnerable to a
reentrancy attack here. And this

30355
07:29:45,979 --> 07:29:48,199
is something that an auditor
would catch. Since when we

30356
07:29:48,199 --> 07:29:50,959
deploy our code, that code is
immutable. And that code will

30357
07:29:50,959 --> 07:29:54,169
always be there, it's really
important to have these security

30358
07:29:54,169 --> 07:29:57,259
reviews done before we deploy
our code to a main net, and

30359
07:29:57,259 --> 07:30:00,349
before we go live, so if you're
going to deploy some crazy,

30360
07:30:00,349 --> 07:30:02,509
massive defy protocol, and
you're gonna have billions of

30361
07:30:02,509 --> 07:30:05,419
dollars of people's money locked
into your protocol, you probably

30362
07:30:05,419 --> 07:30:07,969
want to make sure that the money
is going to go to the correct

30363
07:30:07,969 --> 07:30:12,379
places. So audits are incredibly
important for the lifecycle of

30364
07:30:12,409 --> 07:30:15,889
our projects. And we want people
to peer review, we want people

30365
07:30:15,889 --> 07:30:19,789
to review our code to make sure
that everything looks good. Now,

30366
07:30:19,849 --> 07:30:22,339
when we send our code to audit,
though, we shouldn't just say

30367
07:30:22,339 --> 07:30:24,859
hey, here's our code. Can you
check them Make sure it's good.

30368
07:30:25,309 --> 07:30:27,769
That's not going to give an
auditor enough information, they

30369
07:30:27,769 --> 07:30:30,859
need to be able to very easily
know what your code does, how to

30370
07:30:30,859 --> 07:30:34,099
work with it, and what you're
looking for. Because auditors

30371
07:30:34,099 --> 07:30:36,679
aren't going to be kind of this,
this failsafe, where if your

30372
07:30:36,679 --> 07:30:39,259
code is terrible, they're going
to catch everything. Auditors

30373
07:30:39,259 --> 07:30:42,289
are human beings too. They can
miss things as well, auditors.

30374
07:30:42,319 --> 07:30:45,619
Also, don't make sure that your
code is bug free. Like I said,

30375
07:30:45,649 --> 07:30:49,549
audits are security focused peer
reviews for your codebase. And

30376
07:30:49,549 --> 07:30:52,669
when you do send your code to
audit, you want to make sure you

30377
07:30:52,669 --> 07:30:56,419
help out your auditors as much
as possible. There's an amazing

30378
07:30:56,449 --> 07:30:59,599
tweet thread from Tinto and
previously was an open Zeplin

30379
07:30:59,599 --> 07:31:02,449
auditor with a ton of tips and
tricks for working with

30380
07:31:02,449 --> 07:31:06,169
auditors, I highly recommend you
pause the video, you click this

30381
07:31:06,169 --> 07:31:08,659
link and you read through his
tweets because they are

30382
07:31:08,689 --> 07:31:12,889
fantastic. openzeppelin has a
readiness guide to try to help

30383
07:31:12,889 --> 07:31:16,129
you make sure that you're even
ready for an audit in the first

30384
07:31:16,129 --> 07:31:18,799
place. And we've got a link to
this readiness guide in the

30385
07:31:18,799 --> 07:31:22,759
GitHub repository. The summary
of them are to add comments to

30386
07:31:22,759 --> 07:31:26,059
your code, use natspec, which we
learned about to document your

30387
07:31:26,059 --> 07:31:29,119
functions, document your
functions, document your

30388
07:31:29,119 --> 07:31:33,109
functions, test, be ready to
talk to your auditors, and be

30389
07:31:33,109 --> 07:31:36,859
prepared to give them plenty of
time. They are literally pouring

30390
07:31:36,889 --> 07:31:39,979
themselves over your code for
weeks on end to make sure

30391
07:31:39,979 --> 07:31:42,469
there's nothing wrong. If you
rush your auditors, you're gonna

30392
07:31:42,469 --> 07:31:45,829
get a rushed audit, and they're
going to miss things. So let's

30393
07:31:45,829 --> 07:31:48,829
talk about the auditing process.
In auditing process is going to

30394
07:31:48,829 --> 07:31:51,529
look like this. First, they're
going to run your tests. That's

30395
07:31:51,529 --> 07:31:54,499
the first step in order is
always going to take and right

30396
07:31:54,499 --> 07:31:56,899
there, they're gonna find okay,
do they have enough code

30397
07:31:56,899 --> 07:32:00,769
coverage? Is everything passing?
What do the tests do? What is

30398
07:32:00,769 --> 07:32:04,159
the optimal functionality, after
an auditor runs tests, they're

30399
07:32:04,159 --> 07:32:07,459
going to read specs or run your
docs. And then they're going to

30400
07:32:07,459 --> 07:32:11,029
run some fast tools like
Slither, linters and static

30401
07:32:11,029 --> 07:32:13,519
analysis. And that's going to be
one of the first things we're

30402
07:32:13,519 --> 07:32:17,839
going to talk about slither and
static analysis. So static

30403
07:32:17,839 --> 07:32:22,099
analysis is the process of just
running some program to read

30404
07:32:22,099 --> 07:32:25,279
over all your code and look for
commonly known bugs. One of the

30405
07:32:25,279 --> 07:32:28,489
most popular static analysis
tools is going to be this tool

30406
07:32:28,489 --> 07:32:31,159
called Slither. And that's going
to be one of the first things

30407
07:32:31,159 --> 07:32:34,279
we're going to do here. So let's
go ahead and open up our VS code

30408
07:32:34,279 --> 07:32:37,639
now. And we'll make a new
directory called hardhats

30409
07:32:37,969 --> 07:32:45,229
security, FCC. We'll cd into it.
We'll do code period. And we'll

30410
07:32:45,229 --> 07:32:49,099
open this up. Now what I want
you to do, instead of starting a

30411
07:32:49,099 --> 07:32:51,289
new folder, and everything is
we're going to get clone, my

30412
07:32:51,289 --> 07:32:56,419
heart had security FCC. So we'll
do git clone, our net security

30413
07:32:56,419 --> 07:33:00,859
FCC space, and then put a period
to clone it into this directory.

30414
07:33:00,949 --> 07:33:04,369
And we'll get everything like
this. Now in here, this comes

30415
07:33:04,369 --> 07:33:07,849
with a couple of different
contracts for us already, that

30416
07:33:07,879 --> 07:33:10,489
each have a different
vulnerability, one of them is

30417
07:33:10,489 --> 07:33:14,569
going to be bad RNG. This is a
contract that picks a random

30418
07:33:14,569 --> 07:33:18,439
winner of a raffle using block
difficulty and message dot

30419
07:33:18,439 --> 07:33:22,339
sender. This isn't truly random,
as the miners can influence the

30420
07:33:22,339 --> 07:33:25,339
block dot difficulty, and people
can cancel transactions. And

30421
07:33:25,339 --> 07:33:28,039
there's a ton of ton of
different vulnerabilities with

30422
07:33:28,039 --> 07:33:32,089
creating randomness in this way.
We also have this liquid pool as

30423
07:33:32,089 --> 07:33:35,389
an Oracle, the two most common
types of attacks are reentrancy,

30424
07:33:35,989 --> 07:33:38,959
which we've learned about an
Oracle manipulation attacks,

30425
07:33:39,199 --> 07:33:42,199
which luckily for you, we've
taught you about decentralized

30426
07:33:42,199 --> 07:33:44,659
Oracle's and working with chain
link, which should make you a

30427
07:33:44,659 --> 07:33:48,349
lot safer. And especially for
this section, I'm going to harp

30428
07:33:48,349 --> 07:33:51,349
on these, please, please,
please, if you taking this

30429
07:33:51,349 --> 07:33:55,129
course, please do not make a
protocol that falls victim to

30430
07:33:55,129 --> 07:33:57,949
one of these, I will feel like I
have failed you. If you build a

30431
07:33:57,949 --> 07:34:00,829
protocol where you use some
centralized oracle that gets

30432
07:34:00,829 --> 07:34:03,589
manipulated, or you build a
protocol that has a reentrancy

30433
07:34:03,589 --> 07:34:06,319
attack. The tools that I'm going
to show you right here are going

30434
07:34:06,319 --> 07:34:09,199
to help you with reentrancy. And
everything I've taught you about

30435
07:34:09,199 --> 07:34:12,439
chain link should hopefully
teach you how to not get Oracle

30436
07:34:12,439 --> 07:34:16,279
manipulated. So in this contract
here, we're using a liquidity

30437
07:34:16,279 --> 07:34:19,849
pool as an Oracle and this is
kind of some advanced defy stuff

30438
07:34:19,849 --> 07:34:23,419
here. This is a minimalistic
decentralized exchange example

30439
07:34:23,689 --> 07:34:27,139
where people can buy and sell
and swap different assets. Now

30440
07:34:27,139 --> 07:34:32,119
using this singular exchange, to
get the swap price is a terrible

30441
07:34:32,119 --> 07:34:36,229
idea. Because this is a single
protocol for a single price. The

30442
07:34:36,229 --> 07:34:39,619
price from this protocol is a
single centralized location, and

30443
07:34:39,619 --> 07:34:42,679
we don't want to get our price
from a single centralized

30444
07:34:42,679 --> 07:34:45,679
exchange. We want to get it from
many exchanges. Getting the

30445
07:34:45,679 --> 07:34:50,569
price of any asset from a single
decentralized exchange is not

30446
07:34:50,599 --> 07:34:53,359
decentralized, is somebody
manipulates the market doing

30447
07:34:53,359 --> 07:34:57,679
some crazy advanced defy things
that will ruin the price of your

30448
07:34:57,679 --> 07:35:01,099
assets. So getting the price of
your assets from a centralized

30449
07:35:01,099 --> 07:35:05,149
location is a terrible idea. We
have a metamorphic proxy here.

30450
07:35:05,329 --> 07:35:08,599
The issue here is that it's
initialized double, and we don't

30451
07:35:08,599 --> 07:35:11,989
guarantee that the contract has
been initialized. We have a

30452
07:35:11,989 --> 07:35:15,679
classic reentrancy issue here.
And then we have and then we

30453
07:35:15,679 --> 07:35:19,099
have a vault here where some
password is stored on chain and

30454
07:35:19,099 --> 07:35:22,489
we're crossing our fingers that
nobody reads this password to

30455
07:35:22,489 --> 07:35:25,789
unlock it. So we're going to run
some static analysis on these

30456
07:35:25,789 --> 07:35:29,089
contracts, see if that static
analysis can spot some of the

30457
07:35:29,089 --> 07:35:30,019
bad things in here.

30458
07:35:32,720 --> 07:35:35,300
To get started, we're going to
use a tool like I said called

30459
07:35:35,330 --> 07:35:40,100
slither slither tool was created
by this Crytek team, aka the

30460
07:35:40,100 --> 07:35:44,240
trilobites team. Now, trilobites
is one of my absolute favorite

30461
07:35:44,270 --> 07:35:47,600
auditors in the space. And I
absolutely love all the tools

30462
07:35:47,600 --> 07:35:49,940
that this team puts out, they
put up open source security

30463
07:35:49,940 --> 07:35:53,630
tools for any of us to use such
as slitter. Now to get started

30464
07:35:53,630 --> 07:35:57,740
with Slither, we actually need
to install Python first. So you

30465
07:35:57,740 --> 07:36:01,040
can also run it with Docker. But
I'm going to show you how to how

30466
07:36:01,040 --> 07:36:04,040
to work with Python first. So if
you haven't worked with Python,

30467
07:36:04,040 --> 07:36:07,130
before, you can come to
python.org/downloads and

30468
07:36:07,130 --> 07:36:09,800
download Python right from the
website, you'll know you've done

30469
07:36:09,800 --> 07:36:13,970
it right. And you can run python
three dash dash version, like

30470
07:36:13,970 --> 07:36:16,850
this. Or if you have an older
version of Python, you can run

30471
07:36:16,850 --> 07:36:19,880
Python dash dash version. Once
you install Python, you should

30472
07:36:19,880 --> 07:36:22,610
also have this tool called PIP
three installed and you can

30473
07:36:22,610 --> 07:36:27,620
check by running PIP three dash
dash version, or PIP dash dash

30474
07:36:27,620 --> 07:36:32,030
version. And we also want to
install this sock select package

30475
07:36:32,030 --> 07:36:35,210
just in case we're using weird
versions of solidity to install.

30476
07:36:35,210 --> 07:36:40,340
So select, we run PIP three,
install sock select, like that.

30477
07:36:40,910 --> 07:36:45,680
And then we can do sock, select,
use. And then we can choose the

30478
07:36:45,680 --> 07:36:49,130
version of solidity or slither
to work with. Once you have

30479
07:36:49,130 --> 07:36:52,010
those tools, you can just run
PIP three install slither

30480
07:36:52,070 --> 07:36:56,150
analyzer like so. And you can
install slither into your Python

30481
07:36:56,150 --> 07:36:59,000
environment. I'm not going to
run it because already have. You

30482
07:36:59,000 --> 07:37:01,130
can also learn how to do this
all with Docker and we'll learn

30483
07:37:01,130 --> 07:37:04,400
how to do this with Docker in a
little bit. Now in our package

30484
07:37:04,430 --> 07:37:08,930
json, we actually have command
script in our package. JSON for

30485
07:37:08,930 --> 07:37:11,510
running Slither, you'll know
you've installed slither

30486
07:37:11,510 --> 07:37:18,380
correctly. If you can run
Slither, dash dash help you get

30487
07:37:18,380 --> 07:37:21,980
an output like this. Now we can
use slither to run it on our

30488
07:37:21,980 --> 07:37:25,340
contracts folder by running this
big command here. So we'll say

30489
07:37:25,340 --> 07:37:29,510
Slither. And we want to run it
on dot slash contracts, we need

30490
07:37:29,510 --> 07:37:32,840
to tell it that it has some
psaltery mappings, and every

30491
07:37:32,840 --> 07:37:36,260
time it sees open Zeppelin, it
should use Node module slash

30492
07:37:36,260 --> 07:37:39,830
open Zeppelin and every time it
sees chain link introduced node

30493
07:37:39,830 --> 07:37:42,500
modules slash chain link. And
I'm just going to read from our

30494
07:37:42,500 --> 07:37:46,070
package json. And we're
excluding a couple of functions

30495
07:37:46,070 --> 07:37:49,070
that it runs and excluding
builder ignore, but don't worry

30496
07:37:49,070 --> 07:37:51,770
too much about that. We've
actually just run that by first

30497
07:37:51,770 --> 07:37:53,780
running yarn to install all of
our packages.

30498
07:38:03,289 --> 07:38:06,439
And after we've installed all of
our packages, we can run yarn

30499
07:38:06,529 --> 07:38:09,979
Slither. Or you can copy paste
that slither command and run it

30500
07:38:09,979 --> 07:38:14,059
directly. Now we'll get this
massive output that looks like

30501
07:38:14,059 --> 07:38:17,149
this with some red and some
green. Let's go through what's

30502
07:38:17,149 --> 07:38:20,149
actually happening here, the way
that we can read Slither, it'll

30503
07:38:20,149 --> 07:38:23,689
list out a number of lines that
have an issue and then a

30504
07:38:23,689 --> 07:38:26,629
reference to that issue. And
each one of these is separated

30505
07:38:26,629 --> 07:38:30,949
by a new line. So that's a
section that's exception, etc.

30506
07:38:31,339 --> 07:38:34,819
So if we get a red here, that
means that there is a high

30507
07:38:34,849 --> 07:38:38,449
impact issue that we definitely
should address. And it even

30508
07:38:38,449 --> 07:38:42,379
comes with a reference link that
we can copy paste and put into

30509
07:38:42,379 --> 07:38:45,799
our browser and see what the
issue is and more information

30510
07:38:45,829 --> 07:38:49,519
from the slither tool about what
that issue is and how to correct

30511
07:38:49,519 --> 07:38:54,559
it. We can see it catches our
metamorphic contract issue. It

30512
07:38:54,559 --> 07:38:57,949
says metamorphic contract is
never initialized. It is used

30513
07:38:57,949 --> 07:39:01,489
here in metamorphic dot kill.
The reason that this is a

30514
07:39:01,489 --> 07:39:05,749
massive issue, if we go to our
metamorphic contract outsole is

30515
07:39:05,749 --> 07:39:09,349
that if we deploy this contract,
somebody else could initialize

30516
07:39:09,349 --> 07:39:12,679
this code, become the owner, and
then automatically kill it

30517
07:39:12,709 --> 07:39:15,589
before we even have a chance.
This is actually something that

30518
07:39:15,589 --> 07:39:19,279
has happened in the past and has
caused a ton of issues. So if we

30519
07:39:19,279 --> 07:39:22,729
see red in the terminal, this
means Hey, massive issue, we

30520
07:39:22,729 --> 07:39:25,789
should absolutely check it out.
Now there's gonna be a ton of

30521
07:39:25,789 --> 07:39:28,819
green in here. These are
detectors that are probably low

30522
07:39:28,819 --> 07:39:31,969
impact, and they're probably
okay. And in fact, we can see,

30523
07:39:32,089 --> 07:39:35,389
it's even just calling out some
opens up on stuff here, saying,

30524
07:39:35,389 --> 07:39:38,839
Hey, we see some inline
assembly. Inline assembly is

30525
07:39:38,839 --> 07:39:41,749
kind of scary, maybe don't use
that. So you can think of green

30526
07:39:41,749 --> 07:39:44,269
as kind of a warning that
there's a low likelihood that

30527
07:39:44,269 --> 07:39:46,909
this will impact anything, but
you might want to check it out,

30528
07:39:47,029 --> 07:39:50,119
we get this different versions
of solidity used, which is just

30529
07:39:50,119 --> 07:39:52,369
saying, hey, there's a couple
different versions of solidity

30530
07:39:52,519 --> 07:39:54,739
that might be something you want
to keep in mind, maybe you

30531
07:39:54,739 --> 07:39:58,219
should use the same versions of
solidity. We have this allow old

30532
07:39:58,219 --> 07:40:00,739
versions. And this is actually
why throughout this whole

30533
07:40:00,739 --> 07:40:05,149
course, we've been using zero
point 8.7 Because zero point 8.4

30534
07:40:05,479 --> 07:40:08,869
and zero point 8.7 are
considered more stable versions

30535
07:40:08,869 --> 07:40:12,049
of solidity. So if you're using
versions outside of there, so

30536
07:40:12,049 --> 07:40:14,449
there will say hey, maybe you
want to work with a different

30537
07:40:14,449 --> 07:40:18,379
version. We have some flags in
here about maybe Hey, you should

30538
07:40:18,379 --> 07:40:21,349
make a variable constant because
it never changes which is great.

30539
07:40:21,619 --> 07:40:24,229
Uses literal with too many
digits saying hey, this Just

30540
07:40:24,229 --> 07:40:27,019
kind of hard to read, maybe you
screwed up some of the zeros,

30541
07:40:27,289 --> 07:40:31,879
loud old versions. And what's
this reentrancy in ether store

30542
07:40:31,879 --> 07:40:36,139
dot withdraw. So just by running
this slither tool, we can catch

30543
07:40:36,199 --> 07:40:39,379
a reentrancy vulnerability in
one of our contracts, which is

30544
07:40:39,379 --> 07:40:43,789
fantastic. So running the static
analysis caught at least two

30545
07:40:43,789 --> 07:40:47,719
huge vulnerabilities in our
metamorphic contract. And in our

30546
07:40:47,719 --> 07:40:50,659
reentrancy contract, it didn't
catch the issues involved at

30547
07:40:50,659 --> 07:40:55,219
sole liquidity pool, or bad RNG,
though, which is why we don't

30548
07:40:55,249 --> 07:40:57,829
only want to rely on slither
because it's not going to catch

30549
07:40:57,859 --> 07:41:02,239
everything, but it will catch a
lot of major vulnerabilities. So

30550
07:41:02,239 --> 07:41:05,029
that's how we can use Slither,
at least from a middle middle

30551
07:41:05,029 --> 07:41:08,629
stack point to get started. So
great, we just learned how to

30552
07:41:08,629 --> 07:41:11,809
work with Slither. That's one of
the first tools that are really

30553
07:41:11,809 --> 07:41:14,119
fantastic in our audit process.
And that's going to be

30554
07:41:14,119 --> 07:41:18,019
considered a fast tool for
static analysis, running tests,

30555
07:41:18,049 --> 07:41:21,949
linters, etc, are also types of
static analysis.

30556
07:41:24,619 --> 07:41:28,639
After we run a tool like that,
we enter some manual analysis

30557
07:41:28,669 --> 07:41:31,549
where we walk through the code
ourselves manually, and maybe we

30558
07:41:31,549 --> 07:41:35,509
do it in tangent with running
some slower tools, like a kitna

30559
07:41:35,749 --> 07:41:39,649
Manta Corp, and other symbolic
execution tools. Symbolic

30560
07:41:39,649 --> 07:41:43,909
Execution is where we simulate
executing transactions on the

30561
07:41:43,909 --> 07:41:46,609
blockchain. And one of these
symbolic execution tools that

30562
07:41:46,609 --> 07:41:49,969
we're going to work with is this
a kidmin tool. Again, this is a

30563
07:41:49,969 --> 07:41:52,699
trail of bits tool for doing
something called fuzz testing.

30564
07:41:52,729 --> 07:41:55,999
Now in programming, fuzzing or
fuzz testing is an automated

30565
07:41:55,999 --> 07:41:59,209
software testing technique that
involves providing invalid

30566
07:41:59,299 --> 07:42:03,289
unexpected or random data as
inputs to a computer program. In

30567
07:42:03,289 --> 07:42:06,139
a lot of our code, oftentimes,
we're going to get people

30568
07:42:06,139 --> 07:42:10,099
interacting with them in ways
that we will never think about.

30569
07:42:10,429 --> 07:42:13,669
So we want to be able to provide
random data and random

30570
07:42:13,669 --> 07:42:16,939
information to our test to see
if something weird happens that

30571
07:42:16,939 --> 07:42:20,269
we weren't expecting. So we can
actually build our own fuzz

30572
07:42:20,269 --> 07:42:24,019
tests in our hard hat projects
and run these fuzz tests, I've

30573
07:42:24,019 --> 07:42:27,199
actually created a sample of
fuzz tests, we write our fuzz

30574
07:42:27,199 --> 07:42:31,129
tests in solidity, actually, as
opposed to writing our tests in

30575
07:42:31,129 --> 07:42:34,249
JavaScript. So let's say for
example, we've built this vault

30576
07:42:34,249 --> 07:42:38,689
contract. And we think that at
first glance, hey, nobody should

30577
07:42:38,689 --> 07:42:41,209
ever be able to know the
password, and no one should ever

30578
07:42:41,209 --> 07:42:45,079
be able to unlock this contract.
Which obviously, we know is

30579
07:42:45,079 --> 07:42:48,619
ridiculous, because we know that
anybody can read anything in a

30580
07:42:48,619 --> 07:42:51,769
storage variable. So we know
that this should fail, but it

30581
07:42:51,769 --> 07:42:54,739
might be hard to write a test.
To catch that this actually

30582
07:42:54,739 --> 07:42:57,979
would fail. A good approach to
testing this would be to just

30583
07:42:58,009 --> 07:43:02,119
send a ton of random bytes 32
objects to this unlock function

30584
07:43:02,329 --> 07:43:05,659
to see if we can unlock it. We
can write a fuzz test to do

30585
07:43:05,659 --> 07:43:09,649
exactly that. So in my vault,
fuzz test dot Sol, we're

30586
07:43:09,649 --> 07:43:13,579
importing vault outsole. And so
we're saying vault fuzz test is

30587
07:43:13,579 --> 07:43:19,999
vault and we have a password of
123, ASD 123. And now we have a

30588
07:43:19,999 --> 07:43:24,079
function called a kid and a test
find password, where it's going

30589
07:43:24,079 --> 07:43:28,579
to send a ton of random data
into vault to try to make s

30590
07:43:28,579 --> 07:43:31,909
locked equal false. So we just
say s locked equals true here,

30591
07:43:32,089 --> 07:43:35,809
and our first test will try to
make s locked equals false. Now

30592
07:43:35,809 --> 07:43:38,989
we could install just the kitna,
but at this point, it's a good

30593
07:43:38,989 --> 07:43:43,459
idea to bring up our the
security toolbox from trail of

30594
07:43:43,459 --> 07:43:46,699
bits. So trail of bits has a
package called the eath security

30595
07:43:46,699 --> 07:43:50,089
toolbox, which has all their
security tools in one single

30596
07:43:50,089 --> 07:43:54,649
container kitna, Ethan o Manta
core, slither, rattle, and not

30597
07:43:54,649 --> 07:43:58,159
so smart contracts, it has all
these in the same exact package.

30598
07:43:58,399 --> 07:44:01,339
Now to work with this toolbox.
We're gonna need Docker

30599
07:44:01,339 --> 07:44:03,949
installed. So we're gonna do a
little bit of installation here.

30600
07:44:03,979 --> 07:44:06,589
And again, sometimes this can be
the hardest part of the course

30601
07:44:06,619 --> 07:44:09,859
is just installing these
packages. So we've left a link

30602
07:44:09,889 --> 07:44:13,549
to Doc's dot docker.com, get
Docker to install Docker, to

30603
07:44:13,549 --> 07:44:15,709
actually work with these tools,
you're just going to come you're

30604
07:44:15,709 --> 07:44:18,349
going to click whichever one of
these is appropriate for you to

30605
07:44:18,349 --> 07:44:21,349
install Docker, once we have
Docker installed, we can run the

30606
07:44:21,379 --> 07:44:25,429
E security toolbox by pulling it
down from the Docker equivalent

30607
07:44:25,459 --> 07:44:27,739
of GitHub. And we're going to
use a whole bunch of Docker

30608
07:44:27,739 --> 07:44:29,929
commands that I'm not going to
explain here because this isn't

30609
07:44:29,929 --> 07:44:32,689
a Docker course, if you're
looking to get into the security

30610
07:44:32,689 --> 07:44:34,909
stuff, I would definitely
recommend reading up on all

30611
07:44:34,909 --> 07:44:37,189
these commands afterwards. And
we're going to leave a ton of

30612
07:44:37,189 --> 07:44:40,279
links for you to learn more. And
in the package that JSON

30613
07:44:40,369 --> 07:44:44,389
associated with this lesson. We
even have the command to get set

30614
07:44:44,389 --> 07:44:47,929
up right in here. So we can just
run yarn toolbox, which will run

30615
07:44:47,959 --> 07:44:51,619
our Docker command like this. So
I'm just going to run yarn

30616
07:44:51,619 --> 07:44:54,559
toolbox. And if you get
something like this saying

30617
07:44:54,559 --> 07:44:57,049
cannot connect to the Docker
daemon is the Docker daemon

30618
07:44:57,049 --> 07:45:00,499
running, because I need to have
my Docker daemon running. Since

30619
07:45:00,499 --> 07:45:04,459
I installed Docker desktop. I
need to have my Docker engine

30620
07:45:04,459 --> 07:45:07,759
started and running for it to
actually be working. Again to

30621
07:45:07,759 --> 07:45:10,639
work with this. There's a lot of
Docker setup and configuration

30622
07:45:10,669 --> 07:45:13,249
that needs to happen, which I'm
going to leave a ton of

30623
07:45:13,249 --> 07:45:15,709
instructions on how to get
started with Docker. Once we

30624
07:45:15,709 --> 07:45:19,519
have Docker setup. Now we can
run yarn toolbox, which will

30625
07:45:19,549 --> 07:45:22,999
stick us into a new shell to
work with any of these tools

30626
07:45:22,999 --> 07:45:26,359
that trilobites has Out of the
box. Now our vault fuzz test

30627
07:45:26,479 --> 07:45:30,829
comes with a config as well.
This is in a Yamo file with all

30628
07:45:30,829 --> 07:45:34,429
our arguments for running a
kidnap. So it has a test limit,

30629
07:45:34,459 --> 07:45:37,459
which is how many different
runs, we should do a time delay,

30630
07:45:37,489 --> 07:45:40,909
block delay. And then of course,
some re mappings in here. This

30631
07:45:40,909 --> 07:45:43,579
darker shell will already have
the security tools already

30632
07:45:43,579 --> 07:45:50,179
installed like the Kidner test.
So we'll run a kinah test on SRC

30633
07:45:50,179 --> 07:45:58,009
slash contracts slash test slash
fuzzing slash fault fuzz test

30634
07:45:58,039 --> 07:46:05,239
dot Sol dash dash contract will
be vault fuzz test, dash dash

30635
07:46:05,239 --> 07:46:10,459
config will be SRC slash
contracts slash test slash

30636
07:46:10,789 --> 07:46:15,319
buzzing slash config dot Yamo.
And we'll go ahead and we'll hit

30637
07:46:15,319 --> 07:46:18,139
enter here, and it'll say
analyzing contract, it'll give

30638
07:46:18,139 --> 07:46:20,749
us an output like this, it will
give us an output that looks

30639
07:46:20,749 --> 07:46:24,499
like this. What it's saying is
it found a use case where it

30640
07:46:24,499 --> 07:46:28,969
could make s locked equals
false. And the use case was 123,

30641
07:46:29,179 --> 07:46:34,309
ASD 123. So when what seemed
like almost seconds, it found

30642
07:46:34,309 --> 07:46:37,789
the password to unlock our
contract. And this is why

30643
07:46:37,789 --> 07:46:41,089
running a fuzz tester can be so
powerful, we thought our

30644
07:46:41,089 --> 07:46:43,939
contract was secure, but it
immediately found the password,

30645
07:46:44,059 --> 07:46:47,209
which means anybody else could
immediately find the password.

30646
07:46:47,389 --> 07:46:49,729
And this would be an indicator
that what we're doing there is

30647
07:46:49,729 --> 07:46:53,419
not a good setup. So we'll hit
CTRL C to escape. And to leave

30648
07:46:53,449 --> 07:46:54,829
our Docker setup here,

30649
07:46:54,860 --> 07:46:58,130
we'll just write exit. Now
again, I'm going to leave a ton

30650
07:46:58,130 --> 07:47:00,290
of links to work with a
kidnapper and work with this

30651
07:47:00,290 --> 07:47:03,770
fuzz tester in the GitHub repo
associated with this lesson, so

30652
07:47:03,770 --> 07:47:09,380
that you can go ahead and learn
more. Now, if you take anything

30653
07:47:09,410 --> 07:47:13,280
away from this whole section, it
should be this right here. The

30654
07:47:13,280 --> 07:47:16,160
two most common tasks are
reentrant. See, and Oracle

30655
07:47:16,160 --> 07:47:19,190
manipulation. So if you're not
going to be an auditor, and you

30656
07:47:19,190 --> 07:47:22,700
just want to deploy things to
main net, always, always before

30657
07:47:22,700 --> 07:47:26,660
you deploy anything, the
absolute minimum that you should

30658
07:47:26,660 --> 07:47:29,930
be doing is always running
Slither. And then looking

30659
07:47:29,930 --> 07:47:33,920
manually for Oracle manipulation
and reentrancy attacks. If you

30660
07:47:33,920 --> 07:47:37,670
see in your code that you're
getting pricing information.

30661
07:47:37,970 --> 07:47:40,730
Price is a piece of data that we
as humans have assigned to

30662
07:47:40,730 --> 07:47:42,830
something if you're getting
pricing information from a

30663
07:47:42,830 --> 07:47:46,670
centralized location, rethink
that scenario, rethink what

30664
07:47:46,670 --> 07:47:49,250
you're doing there. If you're
getting a random number, if

30665
07:47:49,250 --> 07:47:51,500
you're doing any type of
automation from a centralized

30666
07:47:51,500 --> 07:47:54,980
location, rethink it and change
your strategy. The chain link

30667
07:47:54,980 --> 07:47:58,310
Oracle network has been created
for a reason to prevent getting

30668
07:47:58,310 --> 07:48:02,240
hacked like this. So please keep
these in mind before you deploy

30669
07:48:02,270 --> 07:48:05,720
anything to main that with any
type of security guarantees.

30670
07:48:05,930 --> 07:48:08,480
Okay, great. So we've learned
about the fast tools, we've

30671
07:48:08,480 --> 07:48:11,090
learned about some of the slow
tools. We didn't look into Manta

30672
07:48:11,090 --> 07:48:14,750
Corp or Mythix. But these are
also tools that you can use

30673
07:48:14,810 --> 07:48:17,780
Manta Corp is going to be
another tool from the trilobites

30674
07:48:17,780 --> 07:48:21,800
team. And Mythix is actually a
smart contract security service

30675
07:48:21,830 --> 07:48:24,830
from the consensus team, you
basically send a bot that they

30676
07:48:24,830 --> 07:48:27,260
have running in the cloud your
contracts and will do some

30677
07:48:27,290 --> 07:48:30,800
automated process to check for
security vulnerabilities. This

30678
07:48:30,800 --> 07:48:33,620
is a paid service. But if you're
going to be deploying a protocol

30679
07:48:33,620 --> 07:48:36,680
that's worth millions of
dollars, spending a few $1,000.

30680
07:48:36,770 --> 07:48:39,350
Spending a few $1,000 to make
sure it actually does. What it

30681
07:48:39,350 --> 07:48:41,840
says is going to do correctly is
definitely something that you

30682
07:48:41,840 --> 07:48:45,860
want to invest in. After you run
through this whole process. You

30683
07:48:46,130 --> 07:48:49,100
the smart contract developers
and the auditors should discuss

30684
07:48:49,100 --> 07:48:52,430
their findings. And if there's
any issues, repeat the steps,

30685
07:48:52,460 --> 07:48:56,270
repeat all the steps again after
changes are made. So this audit

30686
07:48:56,270 --> 07:48:59,660
process and making sure your
contracts are secure is a long

30687
07:48:59,660 --> 07:49:02,810
process. And then afterwards, an
auditor will finally write your

30688
07:49:02,810 --> 07:49:05,600
report with all security
vulnerabilities and everything

30689
07:49:05,600 --> 07:49:08,780
that they found in your
contracts. Typically, you'll

30690
07:49:08,780 --> 07:49:11,180
organize reports in a chart
that'll look something like

30691
07:49:11,180 --> 07:49:14,690
this, you'll label issues that
have a high chance of happening

30692
07:49:14,750 --> 07:49:17,870
and have a high impact as
critical things that have a high

30693
07:49:17,870 --> 07:49:22,430
impact, but a low likelihood as
medium, and etc. I'm also going

30694
07:49:22,430 --> 07:49:25,130
to leave some examples two
audits that have been done in

30695
07:49:25,130 --> 07:49:28,070
the past so that you can take a
look at them. And you can see

30696
07:49:28,100 --> 07:49:31,460
what a full audit looks like on
certain code. We'll be looking

30697
07:49:31,460 --> 07:49:34,880
at openzeppelin sigma prime, and
trilobites, because these are

30698
07:49:34,880 --> 07:49:37,490
three of what I think are some
of the best auditors in the

30699
07:49:37,490 --> 07:49:40,640
space. Now in the GitHub repo.
We also have a ton of other

30700
07:49:40,640 --> 07:49:44,780
tools that you can use Mythix,
mithril ethers play and

30701
07:49:44,780 --> 07:49:47,780
consensus security tools. If you
want to learn more about

30702
07:49:47,780 --> 07:49:51,290
security and auditing, I highly
recommend that after this course

30703
07:49:51,320 --> 07:49:54,770
you play the Ethernet game and
damn vulnerable Defy. These are

30704
07:49:54,770 --> 07:49:57,710
two games that will teach you a
ton about security. And we'll

30705
07:49:57,800 --> 07:50:00,530
test the chops and we'll test
everything that you've learned

30706
07:50:00,590 --> 07:50:03,650
in this course. There's also a
couple of security focused blogs

30707
07:50:03,680 --> 07:50:06,740
that I really like. One of them
in particular is wrecked dot

30708
07:50:06,740 --> 07:50:10,910
news. They keep a running list
of some of the largest hacks

30709
07:50:10,910 --> 07:50:14,120
that have ever happened in the
space and then retrospectives on

30710
07:50:14,150 --> 07:50:16,850
why those actually happened. And
they usually make it very

30711
07:50:16,850 --> 07:50:20,000
entertaining as well. We have
some articles in here as well.

30712
07:50:20,180 --> 07:50:23,510
One of the best places to look
at is this known attacks section

30713
07:50:23,690 --> 07:50:26,570
where they talk Talk about
reentrancy, Oracle manipulation,

30714
07:50:26,750 --> 07:50:30,260
front running and a ton of other
attacks that you should

30715
07:50:30,260 --> 07:50:32,930
absolutely be aware of when
writing your smart contracts,

30716
07:50:32,990 --> 07:50:35,510
we're not going to go over them
here because they do a great job

30717
07:50:35,540 --> 07:50:38,510
in these resources explaining
them, you should also check out

30718
07:50:38,540 --> 07:50:41,300
this article because I helped
write it. So definitely check

30719
07:50:41,300 --> 07:50:44,780
that out. And then we've got a
list to even more sections. So

30720
07:50:44,810 --> 07:50:48,110
this is going to be a living
section here. So please feel

30721
07:50:48,110 --> 07:50:50,870
free. If you find more things in
the future, please feel free to

30722
07:50:50,870 --> 07:50:54,260
make pull requests and update
this repository so that other

30723
07:50:54,260 --> 07:50:57,800
people can learn and know more
about security and auditing and

30724
07:50:57,800 --> 07:51:01,190
have contract examples on what
bad code looks like and how to

30725
07:51:01,190 --> 07:51:03,920
actually catch them. Even though
this was one of our quickest

30726
07:51:03,920 --> 07:51:06,890
sections. From a video
standpoint, this actually is

30727
07:51:06,890 --> 07:51:09,950
going to be one of the longest
sections of your career.

30728
07:51:10,190 --> 07:51:13,250
Security is something that is
always going to be on your mind.

30729
07:51:13,430 --> 07:51:16,520
And there's always going to be
new tools to help with security.

30730
07:51:16,520 --> 07:51:18,770
And there's always going to be
new things to think about. So

30731
07:51:18,770 --> 07:51:22,100
even though we went through this
very quickly, I would 100% want

30732
07:51:22,100 --> 07:51:25,580
you to pause this video, and
work with and try out some of

30733
07:51:25,580 --> 07:51:28,460
the tools we tried here. And
then maybe even try coming up

30734
07:51:28,460 --> 07:51:32,960
with your own vulnerabilities as
well. And with that being said,

30735
07:51:33,050 --> 07:51:38,180
you have just finished the last
section of this massive master

30736
07:51:38,180 --> 07:51:42,680
course on learning smart
contracts, solidity, web three

30737
07:51:42,740 --> 07:51:43,910
and blockchain development,

30738
07:51:44,539 --> 07:52:07,159
you should be incredibly proud
of yourself. Congratulations, I

30739
07:52:07,219 --> 07:52:11,119
and the web three community as a
whole want to congratulate you

30740
07:52:11,299 --> 07:52:16,849
for completing this absolutely
monstrosity of a tutorial, you

30741
07:52:16,849 --> 07:52:21,229
have done an amazing job to get
this far. And to watch me

30742
07:52:21,229 --> 07:52:24,139
talking to you right now. And if
you haven't finished the course,

30743
07:52:24,169 --> 07:52:28,639
go back and finish it before
coming here. We have learned so

30744
07:52:28,639 --> 07:52:33,469
much on this journey. And I can
say from the bottom of my soul

30745
07:52:33,619 --> 07:52:36,739
that I am so glad to have you in
the web three space, smart

30746
07:52:36,739 --> 07:52:40,279
contract space, the blockchain
space, the cryptocurrency space,

30747
07:52:40,579 --> 07:52:44,299
we are so excited that you're
here. I'm really looking forward

30748
07:52:44,329 --> 07:52:48,319
to seeing you in the web three
in the blockchain community. Now

30749
07:52:48,349 --> 07:52:52,009
a lot of people ask, Well, where
do I go? Now, I didn't have all

30750
07:52:52,009 --> 07:52:55,819
this newfound knowledge. I'm
armed with the intelligence of

30751
07:52:55,819 --> 07:52:59,779
the web three developer space.
Well, I've left some links in

30752
07:52:59,779 --> 07:53:03,289
the GitHub repository to lead
you to those next steps. But the

30753
07:53:03,289 --> 07:53:06,529
biggest thing that you can do
for yourself right now is go

30754
07:53:06,529 --> 07:53:10,639
take what you've learned, and
apply it somewhere. This is

30755
07:53:10,639 --> 07:53:14,029
going to be probably the most
thorough course you will ever go

30756
07:53:14,029 --> 07:53:17,959
through in this space. And you
can go tutorial to tutorial and

30757
07:53:17,959 --> 07:53:21,259
boot camp to bootcamp all you
want. But at some point, you

30758
07:53:21,259 --> 07:53:25,489
have to make that leap, and you
have to dive in. And that's

30759
07:53:25,519 --> 07:53:28,939
where the majority of the growth
is going to be anyways. So if

30760
07:53:28,939 --> 07:53:32,809
you're here, wondering where to
go next, go join a hackathon. Go

30761
07:53:32,809 --> 07:53:36,889
start jumping into issues on
GitHub repos, go start applying

30762
07:53:36,889 --> 07:53:40,099
for grants, go start applying
for jobs and say, I took

30763
07:53:40,099 --> 07:53:43,369
Patrick's massive course. Here's
my GitHub repo, work on a

30764
07:53:43,369 --> 07:53:47,029
personal project, work on
somebody else's project. Take

30765
07:53:47,029 --> 07:53:50,389
this knowledge and apply it, the
challenges that you'll run into

30766
07:53:50,389 --> 07:53:53,389
and the challenges that you'll
face. Really trying to do

30767
07:53:53,389 --> 07:53:56,959
something without me hand
holding you is where you're

30768
07:53:56,959 --> 07:54:00,679
going to learn 10 times as much
as what you've learned here.

30769
07:54:00,949 --> 07:54:03,529
I've walked through as deep down
this rabbit hole as I can take

30770
07:54:03,529 --> 07:54:08,149
you. Now it's up to you to go
out and do something with it. So

30771
07:54:08,149 --> 07:54:11,839
thank you, everybody who helped
me create this course. Thank you

30772
07:54:11,839 --> 07:54:15,649
for taking this course. And I'm
so excited to see you in the

30773
07:54:15,649 --> 07:54:20,539
community and see what you build
and see what we can create with

30774
07:54:20,599 --> 07:54:21,679
this technology.