20001
20:18:19,460 --> 20:18:22,910
we learned how to repay it back.
We learned about forking a

20002
20:18:22,910 --> 20:18:26,780
blockchain as opposed to using
our own main blockchain. Another

20003
20:18:26,780 --> 20:18:29,690
thing to know if you are using
an RPC URL like something from

20004
20:18:29,690 --> 20:18:32,780
alchemy so awesome you've
learned a ton about defy now

20005
20:18:32,780 --> 20:18:36,920
defi is an absolutely massive
powerhouse when it comes to the

20006
20:18:36,920 --> 20:18:39,260
blockchain. And it is one of the
most important things

20007
20:18:39,260 --> 20:18:42,410
blockchains can do. If you want
to learn more about defy and

20008
20:18:42,410 --> 20:18:46,760
read more on Defy. I've got some
more links in the GitHub here so

20009
20:18:46,760 --> 20:18:48,950
that you can learn more about
defy and one of them in

20010
20:18:48,950 --> 20:18:53,120
particular that I want to show
you is this one called speed run

20011
20:18:53,150 --> 20:18:56,930
Etherium. Not only does it give
you a ton of defy examples, but

20012
20:18:56,930 --> 20:18:59,870
it gives you a whole bunch of
other examples as well. And this

20013
20:18:59,870 --> 20:19:01,850
will be a good test of
everything that you've learned

20014
20:19:01,880 --> 20:19:04,970
after you pass this course. Or
even right now if you want to or

20015
20:19:04,970 --> 20:19:08,060
whenever you want and to talk
about it a little bit more, we

20016
20:19:08,060 --> 20:19:10,820
actually have Austin Griffiths
here to talk a little bit more

20017
20:19:10,820 --> 20:19:13,370
about speed run Aetherium
himself, I'll pass it over to

20018
20:19:13,370 --> 20:19:13,820
Austin.

20019
20:19:16,400 --> 20:19:18,830
Hey, what's up, I'm Austin
Griffith, I want to show you

20020
20:19:18,830 --> 20:19:21,800
speed run Aetherium. speed run
Aetherium is a great way to get

20021
20:19:21,800 --> 20:19:25,190
started in Aetherium. If you are
a developer, it's targeted at

20022
20:19:25,190 --> 20:19:28,700
web two developers becoming web
three developers speed run a

20023
20:19:28,700 --> 20:19:32,120
theory. m.com is the website. It
takes you through both getting

20024
20:19:32,120 --> 20:19:35,210
started and kind of getting
getting an idea for the language

20025
20:19:35,210 --> 20:19:39,080
and the syntax. But that's just
the start. Just understanding

20026
20:19:39,080 --> 20:19:42,020
the language is just the start,
you feel like you're you can do

20027
20:19:42,020 --> 20:19:44,420
anything. And you're on the top
of the world when you finally

20028
20:19:44,420 --> 20:19:46,610
get the syntax of solidity
together, and you can jam

20029
20:19:46,610 --> 20:19:49,580
through a smart contract. But
really getting context with the

20030
20:19:49,580 --> 20:19:52,370
space and figuring out what
works and what doesn't, that's a

20031
20:19:52,370 --> 20:19:55,670
whole nother battle. And that's
where speed run aetherium.com

20032
20:19:55,670 --> 20:20:01,220
comes in. So let's speed run the
speed run. First, you will get

20033
20:20:01,220 --> 20:20:05,210
scaffold e down speedrun
Aetherium kind of revolves

20034
20:20:05,210 --> 20:20:09,380
around scaffold eath and uses
scaffold eath as a base, you'll

20035
20:20:09,410 --> 20:20:12,620
want to tinker around with some
ideas within solidity. And let

20036
20:20:12,620 --> 20:20:16,160
me show you what I mean by that.
So with scaffold eath, you have

20037
20:20:16,190 --> 20:20:20,870
a front end and you have your
smart contract. So scaffold eath

20038
20:20:20,870 --> 20:20:24,500
comes with hard hat out of the
box. And you will use the

20039
20:20:24,500 --> 20:20:28,880
combination of hard hat and
react to build a DAP where

20040
20:20:28,880 --> 20:20:32,420
you'll deploy both the smart
contract and the front end. And

20041
20:20:32,420 --> 20:20:37,190
this, this ability to edit your
smart contract and have your

20042
20:20:37,370 --> 20:20:41,060
front end auto adapt to it is
kind of the key to scaffold

20043
20:20:41,060 --> 20:20:44,300
ease. I just added some extra
extra exclamation points. But

20044
20:20:44,300 --> 20:20:46,700
we'll see that show up over
here. Once this contract

20045
20:20:46,700 --> 20:20:50,210
deploys, there we go, there's
that. So just real quick, again,

20046
20:20:50,240 --> 20:20:55,610
if I create like a un 256 public
counter, and we set that equal

20047
20:20:55,610 --> 20:20:59,120
to five, and then I build a
function called increment,

20048
20:20:59,330 --> 20:21:04,640
that's public that does counter
public, there we go, that does

20049
20:21:04,640 --> 20:21:07,490
counter plus, plus, you can
imagine what's going to happen

20050
20:21:07,490 --> 20:21:11,450
here. So you, you edit a little
bit of solidity, you deploy your

20051
20:21:11,450 --> 20:21:14,870
contract, and then your front
end auto adjust to that. And it

20052
20:21:14,870 --> 20:21:19,400
gives you the ability as a
developer to call those

20053
20:21:19,400 --> 20:21:22,760
functions tinker with your smart
contract to play around, you can

20054
20:21:22,760 --> 20:21:26,930
even have a console log in
there, where it you know, sets

20055
20:21:27,020 --> 20:21:32,870
says the count now is there we
go something like this. And

20056
20:21:32,870 --> 20:21:35,720
let's go ahead and deploy that.
Notice I'm doing these quick

20057
20:21:35,720 --> 20:21:38,570
iterations, I'm making small
changes in solidity, and I'm

20058
20:21:38,570 --> 20:21:41,810
seeing those changes show up in
the front end. And I'm tinkering

20059
20:21:41,810 --> 20:21:45,110
with those in the front end and
testing my assumptions. Here, if

20060
20:21:45,110 --> 20:21:49,700
we go look at our hard hat node,
when I make this increment call,

20061
20:21:50,060 --> 20:21:53,780
we should see that nice console
log there, you know, this

20062
20:21:53,810 --> 20:21:58,280
address, set the count to eight,
right? Very, very cool. So this

20063
20:21:58,280 --> 20:22:01,100
is scaffold eath. This is what
speed run Aetherium is built on

20064
20:22:01,100 --> 20:22:04,310
top of, you'll get in here,
you'll edit your smart contract,

20065
20:22:04,430 --> 20:22:06,980
then you'll edit your front end,
you'll point your front end at

20066
20:22:06,980 --> 20:22:09,470
some particular network, you'll
deploy your smart contract,

20067
20:22:09,470 --> 20:22:12,680
you'll deploy your app, it just
gives you the ability to have a

20068
20:22:12,680 --> 20:22:16,220
front end along with your smart
contract. And you'll have that

20069
20:22:16,220 --> 20:22:19,910
as you're building your smart,
smart contract. So to have this

20070
20:22:19,910 --> 20:22:22,820
front end, to tinker with your
smart contract is going to help

20071
20:22:22,820 --> 20:22:25,520
you kind of figure out how you
want to write your solidity,

20072
20:22:25,520 --> 20:22:27,830
like, is this going to be a
mapping? Is this going to be an

20073
20:22:27,830 --> 20:22:31,520
array? How am I going to track
this struct, you can kind of do

20074
20:22:31,520 --> 20:22:34,730
this in an iterative process by
just throwing it in here into

20075
20:22:34,730 --> 20:22:36,980
your smart contract and
tinkering with it on the front

20076
20:22:36,980 --> 20:22:40,070
end and trying it out and seeing
what you need to build. So

20077
20:22:40,070 --> 20:22:43,220
that's scaffold eath. And that's
the base that you'll need to get

20078
20:22:43,220 --> 20:22:47,060
started with speed run Ethereum.
Once you've you're able to have

20079
20:22:47,060 --> 20:22:49,820
this all installed, you'll
you'll have your kind of react

20080
20:22:49,820 --> 20:22:52,340
front end here with yarn start,
you'll have yarn chain, which

20081
20:22:52,340 --> 20:22:54,890
will run your your hard hat
node, then you'll do yarn

20082
20:22:54,890 --> 20:22:59,330
deploy. Once you have that setup
locally, you're ready to go with

20083
20:22:59,330 --> 20:23:02,810
speed run Aetherium. And you can
also do this right here and

20084
20:23:02,810 --> 20:23:06,110
challenge zero. So challenge
zero, gotta go zero index,

20085
20:23:06,110 --> 20:23:09,890
right, we got to be nerdy
challenge zero sets you up with

20086
20:23:09,890 --> 20:23:13,220
just getting the environment
setup, you'll you'll quest on

20087
20:23:13,220 --> 20:23:17,630
building a simple NFT example.
It's going to come with an NFT

20088
20:23:17,630 --> 20:23:20,690
smart contract. And it's going
to come with an NFT front end a

20089
20:23:20,690 --> 20:23:24,800
little kind of like minting
view, it'll come with all of

20090
20:23:24,800 --> 20:23:27,440
this stuff to do that. And it'll
walk you through basically

20091
20:23:27,440 --> 20:23:29,900
challenge the row is going to
hold your hand, it's going to

20092
20:23:29,900 --> 20:23:32,930
take you through every step
you'll have to get get you have

20093
20:23:32,930 --> 20:23:37,070
to have a certain version of
node E, L some some correct

20094
20:23:37,070 --> 20:23:40,700
range of node and yarn
installed. Watch out yarn has an

20095
20:23:40,700 --> 20:23:44,030
executable on Linux, make sure
you have the yarn, the package

20096
20:23:44,030 --> 20:23:48,590
manager. But after you have get
your node and yarn, you'll run

20097
20:23:48,590 --> 20:23:53,090
through cloning down each
challenge. You'll do an install,

20098
20:23:53,180 --> 20:23:55,700
you'll fire up the chain and
you'll fire up your front end.

20099
20:23:55,880 --> 20:23:58,850
And you'll have a working app
that lets you interface with

20100
20:23:58,850 --> 20:24:02,210
your NFT smart contract. You'll
go through here and you'll learn

20101
20:24:02,210 --> 20:24:06,620
about wallets. Then you'll start
minting NF Ts and you'll send

20102
20:24:06,620 --> 20:24:09,860
those NF T's are Round. And
that's challenge zero, it's just

20103
20:24:09,860 --> 20:24:14,270
getting you started. Here even
in challenge zero, you'll deploy

20104
20:24:14,270 --> 20:24:18,470
this NFT to Rinkeby. And you'll
also deploy an app and allow

20105
20:24:18,470 --> 20:24:22,700
your friends to go to your app
and mint in FTS on Rinkeby. So

20106
20:24:22,700 --> 20:24:25,640
that's the first challenge, it
looks like we even like dive

20107
20:24:25,640 --> 20:24:28,160
into open see and play around
with some of those mechanics.

20108
20:24:28,700 --> 20:24:32,150
The second challenge challenge
number one challenge one of

20109
20:24:32,150 --> 20:24:36,170
speed runner theory is like
where it all really starts. This

20110
20:24:36,170 --> 20:24:40,010
really shows off the superpower
of Aetherium. It sets it up. So

20111
20:24:40,790 --> 20:24:44,750
you need to build an app where a
bunch of people that don't

20112
20:24:44,750 --> 20:24:49,340
necessarily trust each other,
can coordinate and stake into a

20113
20:24:49,340 --> 20:24:51,980
smart contract. And this is
like, this is the superpower of

20114
20:24:51,980 --> 20:24:55,130
Aetherium. The ability for you,
the developer to write a few

20115
20:24:55,130 --> 20:25:00,200
simple rules to allow jerks to
coordinate financially, and not

20116
20:25:00,200 --> 20:25:03,050
greet each other and steal each
other's money, right? You're

20117
20:25:03,080 --> 20:25:06,110
we're building these financial
systems, there's, you know, game

20118
20:25:06,110 --> 20:25:09,500
theory and economics and so many
other things going on here. But

20119
20:25:09,500 --> 20:25:12,620
you as the developer, you're
writing simple rules, and you're

20120
20:25:12,620 --> 20:25:15,650
building a system that allows
people to coordinate. So

20121
20:25:15,650 --> 20:25:19,220
challenge one, we'll take you
through how to get set up with

20122
20:25:19,220 --> 20:25:22,190
your steak or docile, smart
contract, you'll install

20123
20:25:22,190 --> 20:25:25,280
everything exactly the same way,
you'll fire everything up. And

20124
20:25:25,280 --> 20:25:27,590
then it's just going to walk you
through the kinds of things that

20125
20:25:27,590 --> 20:25:29,960
you will need in your smart
contract. But you'll have to

20126
20:25:29,960 --> 20:25:33,800
write the solidity yourself. So
this is this is not going to be

20127
20:25:33,830 --> 20:25:38,060
a handheld tutorial, hell thing,
you're going to have to write

20128
20:25:38,060 --> 20:25:41,300
the smart contract yourself. And
there's some guidelines and some

20129
20:25:41,300 --> 20:25:44,240
rails that kind of help you out,
but it's not going to do it for

20130
20:25:44,240 --> 20:25:47,780
you. Okay, so that's, that's
Quest One is or that's

20131
20:25:47,780 --> 20:25:51,980
challenge. One is building a
decentralized staking app. Then

20132
20:25:51,980 --> 20:25:55,850
challenge two is building a
token vendor this so in

20133
20:25:55,850 --> 20:25:58,250
challenge one, you'll learn
things like how to send money

20134
20:25:58,250 --> 20:26:01,070
into a contract, how to have a
contract, keep track of

20135
20:26:01,070 --> 20:26:04,850
mappings. In challenge two,
you're going to learn contract

20136
20:26:04,850 --> 20:26:08,660
to contract interaction, you're
going to learn about ERC 20s,

20137
20:26:08,810 --> 20:26:11,180
you're going to learn about
specifically the approved

20138
20:26:11,180 --> 20:26:14,600
pattern, which is kind of a
jerk, it's, it's hard, it's a

20139
20:26:14,600 --> 20:26:18,170
hard thing to deal with is the
approved pattern, you need to go

20140
20:26:18,170 --> 20:26:21,350
to your token contract and
approve the vendor to take some

20141
20:26:21,350 --> 20:26:23,990
money, then in a second
transaction, you need to go to

20142
20:26:23,990 --> 20:26:27,140
the vendor and have the vendor
grab the money from the token

20143
20:26:27,140 --> 20:26:31,100
contract and do something else.
So that's that's challenge two

20144
20:26:31,100 --> 20:26:35,540
is learning about tokens and
vendors, and is starting to

20145
20:26:35,540 --> 20:26:39,650
really like get you kind of
exposed to the idea of this like

20146
20:26:39,650 --> 20:26:43,430
massive multiplayer game that is
Aetherium. And also kind of like

20147
20:26:43,460 --> 20:26:46,100
how to build these vending
machines that anybody can get

20148
20:26:46,100 --> 20:26:49,880
to, then you'll build a Dex. Now
once you've once you're done

20149
20:26:49,880 --> 20:26:53,180
with 01. And two, you're really
kind of you have a license to

20150
20:26:53,180 --> 20:26:55,850
learn at this point, you're
you're ready to really like go

20151
20:26:55,850 --> 20:26:58,820
do some damage and build some
cool things, maybe go build a

20152
20:26:58,820 --> 20:27:01,880
couple other things, but come
back and come come hit challenge

20153
20:27:01,880 --> 20:27:04,910
three, challenge three is going
to be a little bit more open

20154
20:27:04,910 --> 20:27:08,570
ended, there's going to be a
cohort of other people that are

20155
20:27:08,570 --> 20:27:11,720
also building this. And you have
to get through the first three

20156
20:27:11,720 --> 20:27:14,360
challenges to even get to
challenge three to even get to

20157
20:27:14,360 --> 20:27:17,330
this chat room. But there's a
chat room where other developers

20158
20:27:17,420 --> 20:27:20,720
that are also building their own
decks are all there together,

20159
20:27:20,720 --> 20:27:23,300
and you can kind of learn with
them and chat with them. But

20160
20:27:23,300 --> 20:27:25,790
you're going to build an
exchange. And you're going to

20161
20:27:25,790 --> 20:27:28,550
build an exchange that works in
a smart contract in a

20162
20:27:28,550 --> 20:27:33,410
decentralized way with no
centralized breaking points. And

20163
20:27:33,410 --> 20:27:35,210
what that's going to mean is
you're going to have to have

20164
20:27:35,210 --> 20:27:37,730
reserves of both eath and tokens
and you're gonna have to have a

20165
20:27:37,730 --> 20:27:41,870
pricing function and LP tokens
and all sorts of other things

20166
20:27:41,870 --> 20:27:44,810
that you'll have to learn about
as you get to it. Then challenge

20167
20:27:44,810 --> 20:27:49,340
five is a multi SIG wallet. Such
a fundamental important thing

20168
20:27:49,340 --> 20:27:52,490
about how to store your eath
safely is going to be in a multi

20169
20:27:52,490 --> 20:27:55,340
SIG wallet and how you can have
multiple identities even even

20170
20:27:55,340 --> 20:27:59,630
like the the base of like what a
Dow is, is sort of like starting

20171
20:27:59,630 --> 20:28:02,060
with a multi SIG wallet. And
you'll need to build one of

20172
20:28:02,060 --> 20:28:05,690
those you'll need to understand
call data call data is super

20173
20:28:05,690 --> 20:28:08,480
weird and complex. And
everything's a transaction even

20174
20:28:08,480 --> 20:28:10,670
when you're just poking a
contract. It's a transaction,

20175
20:28:10,940 --> 20:28:15,140
and you have to craft that call
data correctly to say, I would

20176
20:28:15,140 --> 20:28:17,840
like to call this specific
function on this specific

20177
20:28:17,840 --> 20:28:21,620
contract. So that's multisig
wallets and then it kind of ends

20178
20:28:21,620 --> 20:28:23,870
up we've got more challenges in
the pipeline, but it kind of

20179
20:28:23,900 --> 20:28:28,520
ends on build an SVG NFT so much
fun to build an NF t that crafts

20180
20:28:28,520 --> 20:28:32,510
the actual drawing in the smart
contract and renders it. So

20181
20:28:32,510 --> 20:28:36,200
that's the speed run, go speed
run Aetherium checkout scaffold,

20182
20:28:36,200 --> 20:28:39,320
eat start building, build
something awesome on Aetherium.

20183
20:28:39,350 --> 20:28:41,540
hearts, hearts, hearts, go get
them.

20184
20:28:41,840 --> 20:28:45,350
Austin Griffith is one of the
OGS when it comes to helping

20185
20:28:45,350 --> 20:28:48,380
engineers get caught up and up
to speed in the blockchain world

20186
20:28:48,380 --> 20:28:51,380
so massive thank you to Austin
for all he's done so far.

20187
20:28:56,790 --> 20:29:01,350
All right now we're gonna get
into NF T's. Let's do this. Now,

20188
20:29:01,350 --> 20:29:04,290
I've already made a number of
videos on what NF T's are and

20189
20:29:04,440 --> 20:29:06,780
how to start working with NF
T's. So we're going to watch a

20190
20:29:06,780 --> 20:29:10,800
portion of the previous Python
edition of this course where I

20191
20:29:10,800 --> 20:29:13,260
explain and a piece from a high
level and then of course, we're

20192
20:29:13,260 --> 20:29:17,070
gonna get into the ultimate NFT
tutorial. So let's learn about

20193
20:29:17,070 --> 20:29:20,520
NF T's look, NF T's are hot
right now. Nf T's also known as

20194
20:29:20,550 --> 20:29:24,480
ERC 720 ones are a token
standard that was created on the

20195
20:29:24,480 --> 20:29:28,230
Ethereum platform. Nf T stands
for non fungible token is a

20196
20:29:28,230 --> 20:29:32,280
token standard similar to the
ERC 20. Again, ERC 20 is like

20197
20:29:32,460 --> 20:29:36,330
link of a maker, all those
goodies that are found on the

20198
20:29:36,330 --> 20:29:41,280
Etherium chain. An NF T or a non
fungible token is a token that

20199
20:29:41,280 --> 20:29:44,940
is non fungible, this means that
they are starkly unique from

20200
20:29:44,940 --> 20:29:48,240
each other. And one token isn't
interchangeable with any other

20201
20:29:48,240 --> 20:29:51,570
token of its class. A good way
to think about it is $1 is

20202
20:29:51,570 --> 20:29:54,330
interchangeable with any other
dollar $1 is going to have the

20203
20:29:54,330 --> 20:29:57,870
same value of another dollar.
Those are fungible tokens that's

20204
20:29:57,870 --> 20:30:01,620
like ERC 20s one link is always
going to be equivalent to one

20205
20:30:01,650 --> 20:30:05,040
other link, by contrast is going
to be NF T's those of you nerds

20206
20:30:05,040 --> 20:30:08,070
out there, we know like a
Pokemon would be a good example

20207
20:30:08,070 --> 20:30:11,400
of an NFT you're one Pokemon is
going to have different stats,

20208
20:30:11,400 --> 20:30:14,400
different moves, sets, and isn't
interchangeable with any other

20209
20:30:14,400 --> 20:30:16,770
Pokemon, or maybe a more
relatable one. It's like a

20210
20:30:16,770 --> 20:30:20,550
trading card, or unique piece of
art or the like. So that's what

20211
20:30:20,550 --> 20:30:24,600
these NF T's are there non
fungible, non interchangeable

20212
20:30:24,600 --> 20:30:28,050
tokens that for the moment are
best represented or thought

20213
20:30:28,050 --> 20:30:32,520
about as digital pieces of art
that are incorruptible and have

20214
20:30:32,520 --> 20:30:35,850
a permanent history of whose own
them who's deployed them, etc.

20215
20:30:35,880 --> 20:30:39,240
Now, like I said, NF T's are
just a token standard. So you

20216
20:30:39,240 --> 20:30:41,940
can actually make them do much
more than just be art. You can

20217
20:30:41,940 --> 20:30:44,490
give them stats, you can make
them battle, you can do really

20218
20:30:44,490 --> 20:30:47,010
unique things with them, you can
do pretty much whatever you want

20219
20:30:47,010 --> 20:30:49,170
with them. But right now, the
easiest way to think about it,

20220
20:30:49,200 --> 20:30:51,510
and the most popular way to
think about it is by calling

20221
20:30:51,510 --> 20:31:00,960
them ah, ah, ah it's odd, or
some type of collectible or just

20222
20:31:00,960 --> 20:31:03,450
anything that's unique. Now,
they've been getting a ton of

20223
20:31:03,450 --> 20:31:05,910
buzz recently, because we've
been seeing more and more of

20224
20:31:05,910 --> 20:31:09,780
these being sold at insane
prices, like we saw x infinity

20225
20:31:09,780 --> 20:31:13,080
sell nine plots of their land
nine plots of their unique land

20226
20:31:13,200 --> 20:31:18,600
for $1.5 million. We also saw
the original creator of the Nyan

20227
20:31:18,600 --> 20:31:19,650
Cat, you know, this cat

20228
20:31:22,980 --> 20:31:26,820
sold for like 300 eath. So
apparently people really value

20229
20:31:26,820 --> 20:31:29,250
these things. So like I said,
they're just tokens that are

20230
20:31:29,250 --> 20:31:32,220
deployed on a smart contract
platform, and you can view them

20231
20:31:32,250 --> 20:31:35,940
on different NFT platforms like
open sea or wearable. And these

20232
20:31:35,940 --> 20:31:38,730
are the NFT marketplaces that
let people buy and sell them.

20233
20:31:38,760 --> 20:31:41,040
You obviously can do that
without these marketplaces,

20234
20:31:41,040 --> 20:31:44,190
because it's a decentralized but
they're helping give a good user

20235
20:31:44,190 --> 20:31:46,620
interface. Now, like many of you
out there, my initial thought to

20236
20:31:46,620 --> 20:31:49,680
NF T's was okay, this sounds
pretty dumb. But I think that

20237
20:31:49,710 --> 20:31:52,530
that was dumb. I think art does
have a lot of value. And I think

20238
20:31:52,560 --> 20:31:55,800
that artists are not always paid
fairly for what they do. And

20239
20:31:55,800 --> 20:31:57,660
this is actually a huge issue
right now in the modern day

20240
20:31:57,660 --> 20:32:00,300
world where an artist can make
some type of art people just

20241
20:32:00,300 --> 20:32:03,060
copy paste it, you know,
everywhere and, and they never

20242
20:32:03,060 --> 20:32:06,690
get attribution for what they
make. So having a really easy

20243
20:32:06,720 --> 20:32:10,560
decentralized royalty mechanism,
or some type of mechanism where

20244
20:32:10,560 --> 20:32:13,200
these artists can get accurately
comped for what they're doing, I

20245
20:32:13,200 --> 20:32:16,260
think, is really important. I
love music. I love movies, those

20246
20:32:16,260 --> 20:32:19,680
are pieces of art that I digest.
And I really like and I think

20247
20:32:19,680 --> 20:32:22,170
it's fair for them to get comped
appropriately because they are

20248
20:32:22,170 --> 20:32:24,570
providing value to my life. I
think NF T's are a great way to

20249
20:32:24,570 --> 20:32:27,450
solve this issue as kind of
having these decentralized audit

20250
20:32:27,450 --> 20:32:30,660
trails and, and royalty trails
that we can set up and, and see

20251
20:32:30,660 --> 20:32:32,640
really transparently without
having to go through some

20252
20:32:32,640 --> 20:32:35,790
centralized service. So that's
the basic gist of it. Let's talk

20253
20:32:35,790 --> 20:32:40,230
some more about the standards
ERC 721 standard are the NFT

20254
20:32:40,230 --> 20:32:43,350
standard. This is the basis of
it all there is another standard

20255
20:32:43,350 --> 20:32:47,640
that's semi fungible tokens, the
1155 We're not going to talk

20256
20:32:47,640 --> 20:32:49,620
about that here. But you can
check it out the main

20257
20:32:49,620 --> 20:32:53,670
differences between a 721 and
the ERC 20 and ERC. 20 is they

20258
20:32:53,670 --> 20:32:56,580
have a really simple mapping
between an address and how much

20259
20:32:56,580 --> 20:33:00,420
that address holds. 720 ones
have unique token IDs, each

20260
20:33:00,420 --> 20:33:03,660
token ID has a unique owner. And
in addition, they have what's

20261
20:33:03,660 --> 20:33:06,750
called a token URI, which we'll
talk about in a minute. Each

20262
20:33:06,750 --> 20:33:11,130
token is unique. Each token ID
represents a unique asset. So

20263
20:33:11,130 --> 20:33:13,290
since these assets are unique,
and we want to be able to

20264
20:33:13,290 --> 20:33:15,660
visualize them and show what
they actually look like we need

20265
20:33:15,660 --> 20:33:18,480
to define those attributes of
the object. If it's a piece of

20266
20:33:18,480 --> 20:33:21,120
art, we needed a way to define
what that art looks like. If

20267
20:33:21,120 --> 20:33:24,000
it's some type of character in a
game, we need to wait define

20268
20:33:24,000 --> 20:33:28,080
that character stats in the NFT.
This is where metadata and token

20269
20:33:28,080 --> 20:33:30,720
URI has come in. So if you know
anything about Aetherium, you

20270
20:33:30,720 --> 20:33:33,420
know that sometimes gas prices
getting pretty high, especially

20271
20:33:33,420 --> 20:33:36,000
when it comes to storing a lot
of space, it can get really,

20272
20:33:36,000 --> 20:33:38,880
really expensive. So one of your
first questions might be Well,

20273
20:33:38,910 --> 20:33:42,540
are they storing these images?
And these are pieces on chain?

20274
20:33:42,570 --> 20:33:45,540
And the answer is sometimes back
when they were coming up with NF

20275
20:33:45,540 --> 20:33:48,300
T's and artists were deploying
stuff, the eath devs and the

20276
20:33:48,300 --> 20:33:50,940
artists were like yeah, art,
let's do that art. I'm just

20277
20:33:50,940 --> 20:33:54,150
gonna deploy This one megabyte
image onto the Etherium chain.

20278
20:33:54,450 --> 20:33:59,460
And Oh god, it's so much gas
expensive, delete button.

20279
20:34:00,390 --> 20:34:05,400
Otherwise, it's not, it's not
good. And they realized that if

20280
20:34:05,400 --> 20:34:07,350
they put all this art on chain,
it's going to be incredibly

20281
20:34:07,350 --> 20:34:10,080
expensive. So to get around
this, what they did is they put

20282
20:34:10,080 --> 20:34:12,810
in the standard, what's called
the token URI. This is a

20283
20:34:12,810 --> 20:34:16,710
universally unique indicator of
what that asset or what that

20284
20:34:16,710 --> 20:34:19,980
token looks like and what the
attributes of the token are, you

20285
20:34:19,980 --> 20:34:23,160
can use something like a
centralized API, or IPFS. To

20286
20:34:23,160 --> 20:34:26,550
actually get that token URI.
Typical token URI has to return

20287
20:34:26,550 --> 20:34:29,220
something in this format like
this, where it has the name, the

20288
20:34:29,220 --> 20:34:31,650
image, location, the
description, and then any

20289
20:34:31,650 --> 20:34:35,040
attributes below, there is often
this talk of on chain metadata

20290
20:34:35,040 --> 20:34:37,950
versus off chain metadata.
Because it is so much easier and

20291
20:34:37,950 --> 20:34:40,710
cheaper to store all your
metadata off chain, a lot of

20292
20:34:40,710 --> 20:34:44,130
people will use something like
IPFS that is decentralized, but

20293
20:34:44,280 --> 20:34:46,710
does take a little bit of
centrality to keep persisting,

20294
20:34:46,740 --> 20:34:49,440
but they can also use their own
centralized API. However,

20295
20:34:49,440 --> 20:34:52,080
obviously, if that goes down,
then you lose your image, you

20296
20:34:52,080 --> 20:34:54,690
lose everything associated with
your NFT. Because of this most

20297
20:34:54,690 --> 20:34:57,990
NFT marketplaces actually can't
and won't read off on chain

20298
20:34:57,990 --> 20:35:00,870
attributes or on chain metadata,
because they're so used to

20299
20:35:00,870 --> 20:35:03,930
looking for the token URI.
Obviously, if you do off chain

20300
20:35:03,930 --> 20:35:06,570
metadata, you can't do anything
really cool or really

20301
20:35:06,570 --> 20:35:09,180
interesting or have any gains
with your NF T's. For example,

20302
20:35:09,180 --> 20:35:11,880
if you wanted to create an on
chain Pokemon game, all your

20303
20:35:11,880 --> 20:35:14,760
attributes would need to be on
chain in order for your Pokemon

20304
20:35:14,760 --> 20:35:17,310
to interact with each other.
Because if it was off chain,

20305
20:35:17,370 --> 20:35:20,250
then that becomes a lot harder
to cryptographically prove. So

20306
20:35:20,280 --> 20:35:22,290
if you're new with NF T's and
you're like wait, this is kind

20307
20:35:22,290 --> 20:35:24,750
of a lot of information, I'll
make it easy for you. If you're

20308
20:35:24,750 --> 20:35:28,350
looking to render an image, I'm
an NFT, add your image to IPFS,

20309
20:35:28,380 --> 20:35:31,920
add a metadata file pointing to
that image file on IPFS. And

20310
20:35:31,920 --> 20:35:35,130
then grab that token URI and put
it and set it as your NFT. The

20311
20:35:35,130 --> 20:35:38,010
chain link DND article does a
great job of walking you through

20312
20:35:38,010 --> 20:35:40,500
this and showing you how to do
this. So be sure to read that if

20313
20:35:40,500 --> 20:35:42,540
you're looking to learn how to
do that we're not going to cover

20314
20:35:42,540 --> 20:35:45,390
that in this video, but we will
be deploying our first NFT with

20315
20:35:45,390 --> 20:35:48,810
some on chain attributes. Again,
having your attributes on chain

20316
20:35:48,840 --> 20:35:52,290
is really going to allow you to
build really creative NF T's

20317
20:35:52,470 --> 20:35:55,170
that build games or have
interesting properties and and

20318
20:35:55,170 --> 20:35:58,230
really makes the authenticity of
your NFT guaranteed because

20319
20:35:58,230 --> 20:36:00,240
those attributes are always
going to be on chain.

20320
20:36:02,970 --> 20:36:06,300
Alright, so now that we know the
basics of approximately what an

20321
20:36:06,300 --> 20:36:11,700
NF t is, and similar to the ERC
20 You can see the E IP 721 or

20322
20:36:11,700 --> 20:36:16,530
the ERC 721 non fungible token
standard on the Aetherium, ie

20323
20:36:16,530 --> 20:36:19,800
IPs. And once again, if you
scroll down, you can see all the

20324
20:36:19,800 --> 20:36:22,890
different events and the
different functions that come

20325
20:36:22,890 --> 20:36:26,010
with creating this token. And
now everything that we're going

20326
20:36:26,010 --> 20:36:30,000
to do is going to be available
at this GitHub repo. This hard

20327
20:36:30,000 --> 20:36:33,780
hat NFT FCC, we're going to
actually go through all the code

20328
20:36:33,780 --> 20:36:39,060
down to deploying and creating
our own customized NFT. And I've

20329
20:36:39,060 --> 20:36:42,720
labeled this the ultimate NFT
repo as part of this course,

20330
20:36:42,720 --> 20:36:45,600
because we're going to go
through a lot here, we're gonna

20331
20:36:45,600 --> 20:36:50,460
go through a basic NFT, a real
minimalistic NFT and then an

20332
20:36:50,460 --> 20:36:54,990
IPFS hosted NFT. That is
dynamic. And it uses randomness

20333
20:36:54,990 --> 20:36:59,430
to generate unique NF T's so
that we can have provably rare

20334
20:36:59,550 --> 20:37:03,660
and appease or provably rare
cards or provably rare tokens or

20335
20:37:03,660 --> 20:37:07,110
stats or whatever you want. And
then we're going to do what's

20336
20:37:07,110 --> 20:37:12,240
called an SVG NFT. These are
entities that are 100 percent hosted on

20337
20:37:12,240 --> 20:37:15,690
chain, so you don't need an off
chain. So you don't need IPFS,

20338
20:37:15,690 --> 20:37:18,630
you don't need an off chain
database. And this one's also

20339
20:37:18,630 --> 20:37:21,450
going to be dynamic, where it's
going to use price feeds in

20340
20:37:21,450 --> 20:37:24,780
order to fluctuate what the
image of the entity actually

20341
20:37:24,780 --> 20:37:27,690
looks like based off the price
of some asset. And here are the

20342
20:37:27,690 --> 20:37:30,030
images that we're going to be
using. And we obviously have

20343
20:37:30,030 --> 20:37:33,120
these three adorable doggies
here. If you want to follow

20344
20:37:33,120 --> 20:37:35,790
along with the Quickstart, you
absolutely can. And I'm going to

20345
20:37:35,790 --> 20:37:38,970
do a quick overview of just
running the code to show you

20346
20:37:38,970 --> 20:37:42,330
what it's going to look like at
the end. Basically, what we're

20347
20:37:42,330 --> 20:37:44,940
going to do is we're going to
have our code, we're going to

20348
20:37:44,940 --> 20:37:50,760
run hardhat deploy dash dash
network, rink B, dash dash tags

20349
20:37:50,760 --> 20:37:53,940
main. And this is going to
deploy all of our contracts and

20350
20:37:53,940 --> 20:37:57,990
everything. And then finally, if
we go to test nets dot open c.io

20351
20:37:58,200 --> 20:38:02,430
And we grab the address of one
of these NF T's we should be

20352
20:38:02,430 --> 20:38:06,420
able to put it in here see our
actual NFT as a collection with

20353
20:38:06,420 --> 20:38:10,410
an item. Or Additionally, we can
just go right to the contract.

20354
20:38:10,860 --> 20:38:14,550
We can read the contract, we can
get the token URI, and then we

20355
20:38:14,550 --> 20:38:18,750
can copy this token here, I
paste it into our browser or any

20356
20:38:18,750 --> 20:38:22,950
IPFS is into our browser, and
then grab the image attribute

20357
20:38:22,950 --> 20:38:26,190
and see what this actually looks
like on chain. So with all that

20358
20:38:26,190 --> 20:38:30,600
being said, let's learn how to
build this ultimate NFT repo and

20359
20:38:30,600 --> 20:38:34,290
build all of these different
customizable NF T's let's jump

20360
20:38:34,290 --> 20:38:39,450
in. So once again, we're in our
terminal I'm going to create a

20361
20:38:39,450 --> 20:38:43,800
new directory. We're gonna call
it hard hat and a T for FCC.

20362
20:38:44,400 --> 20:38:47,850
We're gonna cd into that. And if
T FCC and we're going to open

20363
20:38:47,850 --> 20:38:52,110
that up with code.or, you can
hit File, Open Folder At this

20364
20:38:52,110 --> 20:38:55,200
point, you'll have gotten pretty
familiar with the setup of our

20365
20:38:55,200 --> 20:38:58,320
code bases here, feel free to
copy over or do whatever you

20366
20:38:58,320 --> 20:39:02,040
want to do for our setup, we'll
do yarn, add dash dash dev hard

20367
20:39:02,040 --> 20:39:05,460
hat. And then while that's
loading, I'm going to copy over

20368
20:39:05,460 --> 20:39:08,370
my prettier files. Because I
want to use prettier, I'm going

20369
20:39:08,370 --> 20:39:12,900
to copy over my hard
hat.config.js. And I'm also

20370
20:39:12,900 --> 20:39:16,710
going to grab my package that
Jason copied over here, I'm

20371
20:39:16,710 --> 20:39:20,160
going to delete this old package
dot JSON. And I'm just going to

20372
20:39:20,280 --> 20:39:23,520
hit Enter on this and rename the
one I just copied over from

20373
20:39:23,520 --> 20:39:26,970
package copy to package json.
And the reason I'm doing this is

20374
20:39:26,970 --> 20:39:30,690
so that I can just go ahead and
run yarn and install all this

20375
20:39:30,690 --> 20:39:33,240
stuff for me. Or we can just
come back over here and just

20376
20:39:33,240 --> 20:39:36,540
grab this lesson nine hard hat,
smart contract lottery, all that

20377
20:39:36,540 --> 20:39:40,620
stuff, again, just run that
massive piece as well. Or you

20378
20:39:40,620 --> 20:39:43,590
can copy over your package json,
and then just run yarn that will

20379
20:39:43,590 --> 20:39:45,930
do the same thing. Now we don't
have to keep doing this

20380
20:39:45,930 --> 20:39:48,540
boilerplate over and over and
over again. And then while

20381
20:39:48,540 --> 20:39:51,030
that's loading, I'm also going
to grab my Dotty and v file that

20382
20:39:51,030 --> 20:39:53,100
we've been using on a past
couple of projects, the

20383
20:39:53,100 --> 20:39:56,310
readme.md. And we'll just do
what we're gonna be doing here.

20384
20:39:56,340 --> 20:39:58,740
So we're going to make three
different contracts. One is

20385
20:39:58,740 --> 20:40:03,720
going to be a basic NFT, using
that ERC 721 standard, then

20386
20:40:04,020 --> 20:40:08,850
we're gonna do a random IPFS
hosted NF t. And then finally,

20387
20:40:09,240 --> 20:40:15,840
we're going to do a dynamic S V
G NFT. So our random NF T is

20388
20:40:15,840 --> 20:40:18,450
going to be random at creation
time, this is going to give some

20389
20:40:18,450 --> 20:40:22,710
true scarcity and some true
randomness to our NF T. And it's

20390
20:40:22,710 --> 20:40:27,660
gonna be hosted on IPFS. Our
dynamic SVG NFT is going to be

20391
20:40:27,660 --> 20:40:32,430
hosted 100 percent on chain, and the
image of it's going to change

20392
20:40:32,580 --> 20:40:35,610
based off of some parameters.
That's what makes it a dynamic

20393
20:40:35,610 --> 20:40:36,720
SVG NFT.

20394
20:40:39,450 --> 20:40:41,760
Let's go ahead and we'll create
a new folder, we'll create our

20395
20:40:41,760 --> 20:40:45,900
contracts folder, and we will
create our first NF t this is

20396
20:40:45,900 --> 20:40:49,230
going to be our basic NFT. And
I'm going to go a little bit

20397
20:40:49,230 --> 20:40:52,380
quick here, because most of what
we're going to be doing is

20398
20:40:52,380 --> 20:40:55,170
actually things that we're
already familiar with. So we'll

20399
20:40:55,170 --> 20:40:59,730
do basic NF T dot soul in a new
file. And let's go ahead and

20400
20:40:59,730 --> 20:41:04,140
let's do it. Let's go ahead and
we'll do spdx license

20401
20:41:04,230 --> 20:41:09,750
identifier, it's gonna be MIT.
We'll do pragma, solidity,

20402
20:41:10,050 --> 20:41:15,090
carrot zero, point 8.7 pragma,
solidity, and then we'll do

20403
20:41:15,090 --> 20:41:21,870
contract, basic NF t. Let me
just basic, get a t.so, like

20404
20:41:21,870 --> 20:41:25,110
that. And we'll say contract
basic NF t. And then we'll just

20405
20:41:25,110 --> 20:41:28,290
run hard at compile or yarn
hard, hit compile, and it looks

20406
20:41:28,290 --> 20:41:31,500
like we're doing well here so
far. Okay, perfect. Based off of

20407
20:41:31,500 --> 20:41:35,700
that NFT token standard, we go
back that EIP, we're going to

20408
20:41:35,700 --> 20:41:38,040
need a whole bunch of different
functions here, we're going to

20409
20:41:38,040 --> 20:41:41,370
need transfer events, we're
going to need owner events

20410
20:41:41,370 --> 20:41:44,940
bounce up, we're going to all
these different functions. And

20411
20:41:44,940 --> 20:41:48,630
we could 100 percent implement these
and transfer them exactly like

20412
20:41:48,630 --> 20:41:53,400
the ERC 20 did, or once again,
so we can use, you guessed it,

20413
20:41:53,400 --> 20:41:56,160
we're gonna be using open
Zeppelin contracts for this as

20414
20:41:56,160 --> 20:41:58,620
well. So we come back over to
open Zeppelin, we go over to

20415
20:41:58,620 --> 20:42:01,920
contracts. And we're gonna go
ahead and add this with yarn,

20416
20:42:01,950 --> 20:42:07,380
add dash dash Dev. So yarn, add
dash dash dev at opens up on

20417
20:42:07,380 --> 20:42:11,070
contracts, like so. And while
that's going through, we can

20418
20:42:11,070 --> 20:42:16,110
look at the ERC 721 of this and
we can see what creating a

20419
20:42:16,110 --> 20:42:19,650
minimalist ERC 721 looks like.
Now there's a number of

20420
20:42:19,650 --> 20:42:23,700
extensions that come with its
ERC. 721 In this example that

20421
20:42:23,700 --> 20:42:28,200
they give us. They're using ERC
721 Uri storage, which we'll

20422
20:42:28,200 --> 20:42:31,170
talk about in a little bit. So
we've added it in here. And now

20423
20:42:31,170 --> 20:42:34,710
we can actually import that ERC
21 from opens up when in our

20424
20:42:34,710 --> 20:42:39,750
contract. So we'll do import at
open Zeppelin slash contracts

20425
20:42:39,750 --> 20:42:46,200
slash token slash your C 721
slash ERC. 721 does so they use

20426
20:42:46,200 --> 20:42:49,950
a different one in the demo, but
don't worry about that. And same

20427
20:42:49,950 --> 20:42:56,490
as the ERC. 20 we're gonna say
our basic NFT is ERC 721. So

20428
20:42:56,490 --> 20:43:00,000
we're doing this inheritance,
you find the constructor, we can

20429
20:43:00,000 --> 20:43:03,390
see this has a constructor,
where it takes a name and a

20430
20:43:03,390 --> 20:43:07,560
symbol. So we're gonna want to
use this constructor and our

20431
20:43:07,560 --> 20:43:11,340
contract. So we're gonna say,
construct door.

20432
20:43:12,630 --> 20:43:16,200
And our constructor is just
going to be blank. But we'll do

20433
20:43:16,350 --> 20:43:21,030
the ERC 721 constructor and
we'll call this a doggie. And

20434
20:43:21,030 --> 20:43:25,170
the symbol will be dog just like
that. Our basic NFT we're just

20435
20:43:25,170 --> 20:43:27,870
going to have it be this doggy
here, right so it's going to be

20436
20:43:27,870 --> 20:43:31,680
an NF T of just a purely this
dog here. The name is going to

20437
20:43:31,680 --> 20:43:34,830
be doggy and the symbol is going
to be dog. Now in order to

20438
20:43:34,830 --> 20:43:39,690
create new dogs. What we're
going to do is openzeppelin code

20439
20:43:39,690 --> 20:43:43,410
comes with something called a
mint function exactly the same

20440
20:43:43,770 --> 20:43:48,360
as the ERC 20 So we're going to
create a function called mint

20441
20:43:48,810 --> 20:43:53,220
NFT this will be a public file
function that's going to return

20442
20:43:53,310 --> 20:43:58,710
you activity six. And we'll use
the safe mint function of this

20443
20:43:58,710 --> 20:44:05,310
ERC 20 or underscore safe mint
message dot sender will mint the

20444
20:44:05,310 --> 20:44:09,810
token to whoever calls this mint
function. And then we need to

20445
20:44:09,810 --> 20:44:13,620
also give this a token ID, if
we're looking back at the code

20446
20:44:13,620 --> 20:44:17,010
for the ERC 721. And again, you
can see this on GitHub as well,

20447
20:44:17,100 --> 20:44:19,740
we're gonna look at this safe
mint function, it takes an

20448
20:44:19,740 --> 20:44:24,750
address to who is going to own
the NFT. And then a token ID,

20449
20:44:24,840 --> 20:44:28,950
what is the ID of the token
based off of this address. So if

20450
20:44:28,950 --> 20:44:32,280
you have a collection of tokens
on the same smart contract, each

20451
20:44:32,280 --> 20:44:35,370
one of them needs their own
unique token ID. So what we're

20452
20:44:35,370 --> 20:44:39,990
gonna do is we're gonna create a
un 256, private variable called

20453
20:44:39,990 --> 20:44:44,430
S underscore token counter, and
it's gonna get initialized in

20454
20:44:44,430 --> 20:44:47,400
our constructor to zero, but
we'll just be explicit and say

20455
20:44:47,400 --> 20:44:51,120
es token counter equals zero.
And then in here, we'll just

20456
20:44:51,120 --> 20:44:56,880
have the token ID of this new NF
t be that token counter. And

20457
20:44:56,880 --> 20:45:00,210
then of course, we'll say s
token counter equals s token

20458
20:45:00,210 --> 20:45:04,860
counter plus one. So every time
we meant a new NFT, we up the

20459
20:45:04,860 --> 20:45:08,550
token counter, and then we'll
just return, we'll just return

20460
20:45:08,550 --> 20:45:11,430
the new tab counter. Right. And
then obviously, at the bottom,

20461
20:45:11,430 --> 20:45:14,460
we could do like function, get
token counter, this would be a

20462
20:45:14,460 --> 20:45:19,110
public view returns you in 256.
And I'm gonna go a little quick

20463
20:45:19,110 --> 20:45:22,470
here, because you've seen this
before, return s underscore

20464
20:45:22,500 --> 20:45:26,220
token counter, right, since it's
a private variable up here, the

20465
20:45:26,220 --> 20:45:29,970
public function down here to get
that token counter. So this

20466
20:45:30,000 --> 20:45:33,510
technically, is it. This is
technically an NF T. But what

20467
20:45:33,510 --> 20:45:36,480
does this look like? Well, right
now, this NF T isn't going to

20468
20:45:36,480 --> 20:45:41,790
look like anything at all, in
this EIP token standard. It has

20469
20:45:41,790 --> 20:45:44,790
this thing called a token URI.
And this is the important

20470
20:45:44,790 --> 20:45:48,510
function that tells us exactly
what this token is going to look

20471
20:45:48,510 --> 20:45:52,260
like. Like what we said in the
mini lesson here. This token URI

20472
20:45:52,320 --> 20:45:56,400
returns some type of URL or
universal resource identifier

20473
20:45:56,790 --> 20:46:00,120
that returns some JSON that
looks like this. And in this

20474
20:46:00,120 --> 20:46:03,240
JSON, we're going to have this
image part. And this image is

20475
20:46:03,240 --> 20:46:07,050
going to be a URL that's going
to point to what this image

20476
20:46:07,050 --> 20:46:10,320
actually looks like. Now this
URL can be hosted on chain, it

20477
20:46:10,320 --> 20:46:13,740
can be hosted on IPFS, it can be
hosted really wherever. But

20478
20:46:13,740 --> 20:46:16,920
ideally, we're not going to use
a centralized server to host it.

20479
20:46:16,950 --> 20:46:19,710
If this is hosted on a Google
Cloud or a centralized server or

20480
20:46:19,710 --> 20:46:22,440
whatever, and our centralized
server goes down. Well guess

20481
20:46:22,440 --> 20:46:24,540
what this MC is gonna look like,
it's not gonna look like

20482
20:46:24,540 --> 20:46:27,960
anything. So we want to use some
type of decentralized storage,

20483
20:46:28,230 --> 20:46:32,430
to get a URL, or URI to store
what this looks like. To make

20484
20:46:32,430 --> 20:46:35,460
this section a little bit easier
for you, I've actually already

20485
20:46:35,460 --> 20:46:40,560
gone ahead and hosted an image
to IPFS. For you, it's going to

20486
20:46:40,560 --> 20:46:44,880
be at IPFS dot dot slash slash,
it's going to look like this,

20487
20:46:44,940 --> 20:46:47,490
this is going to be the image
that we're going to use for our

20488
20:46:47,490 --> 20:46:51,300
dog here. If you create just
this image, though, as the token

20489
20:46:51,300 --> 20:46:55,830
URI, that's not going to work,
we need a URI that returns this,

20490
20:46:56,220 --> 20:46:59,400
with the image inside of it. Now
for this first section, have

20491
20:46:59,400 --> 20:47:01,650
already gone ahead and done that
for you as well. And that's

20492
20:47:01,650 --> 20:47:05,040
going to be located here. This
is what our token URI function

20493
20:47:05,070 --> 20:47:07,740
needs to return. So it's going
to have the name, the

20494
20:47:07,740 --> 20:47:11,970
description, the image URI,
which then points to the dog,

20495
20:47:12,120 --> 20:47:15,690
and then some attributes, etc,
etc. Now, you'll notice that the

20496
20:47:15,690 --> 20:47:21,720
image here is pointing to HTTPS,
dot dot slash slash ipfs.io. The

20497
20:47:21,720 --> 20:47:24,360
reason I did this was again,
just in case you didn't have the

20498
20:47:24,360 --> 20:47:28,020
IPFS gateway, but this would be
a lot better if this was in its

20499
20:47:28,020 --> 20:47:33,330
IPFS form. Because if the
centralized server ipfs.io, goes

20500
20:47:33,360 --> 20:47:38,310
ever goes down, this NFT will
show what it'll show nothing. So

20501
20:47:38,340 --> 20:47:44,010
it would be much better. If it
was instead of ipfs.io. It was

20502
20:47:44,070 --> 20:47:49,680
IPFS, colon slash slash, like
that, instead of ipfs.io. But

20503
20:47:49,680 --> 20:47:51,840
for now, this is what we're
going to be using. And you can

20504
20:47:51,840 --> 20:47:56,250
just go to the GitHub for this,
just to grab this for this

20505
20:47:56,250 --> 20:48:00,870
section. Right? Just go to
contracts, basic NFT, you can

20506
20:48:00,870 --> 20:48:04,770
just grab this, this, this top
part, just copy it like that. So

20507
20:48:04,770 --> 20:48:09,120
we're going to paste that the
token URI up, up, up at the top,

20508
20:48:09,180 --> 20:48:14,700
like so. Oh, it should be
returns, return. There we go.

20509
20:48:14,760 --> 20:48:17,730
Okay, cool. So we're just going
to copy paste that in here like

20510
20:48:17,730 --> 20:48:22,080
this. Like I said, even though
the token URI here is pointing

20511
20:48:22,080 --> 20:48:26,220
directly to IPFS, which is good.
If you actually go to this file,

20512
20:48:26,370 --> 20:48:31,350
the file is actually pointing to
http.ipfs.io. Again, for your NF

20513
20:48:31,350 --> 20:48:35,730
T's don't do that for this NFT.
I just did that just in case,

20514
20:48:35,940 --> 20:48:38,220
but for your NF T's don't do
that. And we're going to make

20515
20:48:38,220 --> 20:48:42,240
this a public constant variable.
Why? Well, because this token

20516
20:48:42,240 --> 20:48:44,880
you write is never going to
change. We're going to make this

20517
20:48:44,880 --> 20:48:48,810
NFT so that everybody who meets
one will have this exact same

20518
20:48:48,870 --> 20:48:52,980
adorable little puck here. And
the way we do That now is we

20519
20:48:52,980 --> 20:48:56,850
need to identify the actual
token URI function. So I'm going

20520
20:48:56,850 --> 20:48:59,280
to do it above get token
counter, we're going to say

20521
20:48:59,280 --> 20:49:07,080
function, token URI. And these
always take a UNT 256 token ID,

20522
20:49:08,370 --> 20:49:14,010
we're going to make this a
public view, override returns

20523
20:49:14,670 --> 20:49:22,290
string memory. And this needs to
return the token URI. Now, this

20524
20:49:22,290 --> 20:49:26,040
is going to be the most basic
way to create this, right. And

20525
20:49:26,040 --> 20:49:29,160
if we wanted to make this
function a little nicer, we'd

20526
20:49:29,160 --> 20:49:32,700
comment out token ID as well,
since we're actually not using

20527
20:49:32,850 --> 20:49:38,610
token ID. But we're overriding
in our in the ERC 721 that we're

20528
20:49:38,610 --> 20:49:42,750
importing. This has a token ID
function or a token URI

20529
20:49:42,750 --> 20:49:46,410
function. And we're overriding
this, right, we're not using

20530
20:49:46,410 --> 20:49:48,960
this at all, we're saying, Hey,
we're just going to use our own

20531
20:49:48,960 --> 20:49:53,190
here. And that's all we need for
this to work. And now if you

20532
20:49:53,190 --> 20:49:55,830
were to deploy this to rink B,
if you were to jump over to open

20533
20:49:55,830 --> 20:49:59,460
C test net, and you would deploy
this, this dog, this adorable

20534
20:49:59,460 --> 20:50:03,960
little pop would be what shows
up for all the minutes. So let's

20535
20:50:03,960 --> 20:50:06,660
go ahead, and let's create a
little deploy function for this.

20536
20:50:06,840 --> 20:50:11,340
So we'll do a new folder, deploy
a new file, we'll call this a

20537
20:50:11,340 --> 20:50:17,400
one deploy basic NF T dot j s.
And this is going to look real

20538
20:50:17,400 --> 20:50:19,830
similar to everything that we've
done before. So I'm going to

20539
20:50:19,830 --> 20:50:25,860
move a little bit quicker here.
const network equals require

20540
20:50:25,980 --> 20:50:33,360
hard hats, const development
chains, equals require dot dot

20541
20:50:33,360 --> 20:50:38,250
slash helper, hard hats config.
And I don't think I added that.

20542
20:50:38,280 --> 20:50:42,150
So I'm going to copy paste my
helper Hardhead config from our

20543
20:50:42,150 --> 20:50:45,090
last project. And if you get
confused, you can always just

20544
20:50:45,090 --> 20:50:49,050
come to the GitHub here, and
just go to the helper Hardhead

20545
20:50:49,050 --> 20:50:52,590
config and grab it from here, we
have that const development

20546
20:50:52,590 --> 20:50:58,620
chains, or say const verify
equals require dot dot slash

20547
20:50:58,620 --> 20:51:03,090
utils. Slash verify. We're also
going to grab our utils, I'm

20548
20:51:03,090 --> 20:51:06,060
going to copy paste so utils
folder from alas project, once

20549
20:51:06,060 --> 20:51:09,330
again, you can copy paste from
your last project, or you can

20550
20:51:09,330 --> 20:51:12,600
just go straight to the repo,
grab the verified dot j s, we're

20551
20:51:12,600 --> 20:51:15,000
going to go over these two
functions a little bit later,

20552
20:51:15,000 --> 20:51:17,370
but at least grab the verified
for now. And then we're gonna

20553
20:51:17,370 --> 20:51:21,390
start the function. So we'll do
module that exports equals async

20554
20:51:21,390 --> 20:51:27,720
function. We're gonna get get
named accounts, and deployments.

20555
20:51:29,610 --> 20:51:34,620
And we're gonna say const.
Deploy, log equals deployments

20556
20:51:34,770 --> 20:51:41,610
against deployer equals await,
get named accounts. So we'll do

20557
20:51:41,610 --> 20:51:47,490
a little log here just to get
started to do our basic NFT

20558
20:51:47,610 --> 20:51:51,750
doesn't take any constructor
parameters. So we'll say const

20559
20:51:51,780 --> 20:51:58,140
args equals a little blank here.
Then we'll do const basic NFT

20560
20:51:58,170 --> 20:52:05,400
equals await, deploy basic NF T,
exactly what we've seen before a

20561
20:52:05,400 --> 20:52:10,350
number of times at this point,
we'll say from Deployer. args is

20562
20:52:10,350 --> 20:52:14,640
going to be args. And then log,
it's going to be true. And then

20563
20:52:14,640 --> 20:52:16,860
we'll also do weight
confirmations. It's going to be

20564
20:52:16,860 --> 20:52:25,620
network dot config dot block,
confirmations, or one. Then if

20565
20:52:25,620 --> 20:52:29,190
we want to verify this, we're
going to once again do if it's

20566
20:52:29,190 --> 20:52:37,320
not development chains, dot
includes network dot name, and

20567
20:52:37,470 --> 20:52:44,790
process that EMV dot ether scan
API key will say log verifying

20568
20:52:44,790 --> 20:52:51,930
dot the dot await, verify basic
NF T dot address arguments which

20569
20:52:51,930 --> 20:52:55,830
are going to be blank, grab this
little log here, stick it right

20570
20:52:55,830 --> 20:52:59,400
underneath. And then actually in
our basic NF T. This should be

20571
20:52:59,430 --> 20:53:03,180
args not arguments. Now we have
a deploy script. Now we have a

20572
20:53:03,180 --> 20:53:07,920
basic NFT here in test data
deploy script, or any hh deploy

20573
20:53:07,950 --> 20:53:12,450
or yarn Hardhead deploy. And
oops, let's go back to the basic

20574
20:53:12,450 --> 20:53:19,050
kind of tea or mint and have tea
needs to return a UNT 256. Try

20575
20:53:19,050 --> 20:53:23,820
again. Get token counter also
needs to return a UNT forget you

20576
20:53:23,820 --> 20:53:26,700
into anywhere else. Nope. Okay,
looking good. And looks like

20577
20:53:26,700 --> 20:53:30,930
we're compiling well compiled,
deploying Well, now if you want

20578
20:53:30,930 --> 20:53:35,100
to deploy this to rink B, you
can. I recommend holding off

20579
20:53:35,100 --> 20:53:37,530
though, because we're going to
do that at the end. Now that

20580
20:53:37,530 --> 20:53:40,350
we've written a deploy script.
We've written the contract, you

20581
20:53:40,350 --> 20:53:44,280
already know what's coming next.
Yes, neat. What's next is the

20582
20:53:44,280 --> 20:53:47,190
tests now because we're not
actually learning too much more

20583
20:53:47,190 --> 20:53:50,460
here. I'm not going to walk you
through writing this test. I'm

20584
20:53:50,460 --> 20:53:54,000
going to challenge you now. How
to pause the video and write the

20585
20:53:54,000 --> 20:53:57,480
test out yourself and see how
far in this test you can

20586
20:53:57,480 --> 20:54:00,510
actually get. Remember, to test
it, you're going to want to run

20587
20:54:00,540 --> 20:54:02,820
yarn, hard hat test,

20588
20:54:03,060 --> 20:54:05,640
right, let's see if you can
actually write the test

20589
20:54:05,640 --> 20:54:09,540
yourself, then come back to the
video, see if your tests were

20590
20:54:09,540 --> 20:54:13,440
just as good or not as good as
what we did here. And of course,

20591
20:54:13,680 --> 20:54:16,830
you can always go to the GitHub
repo test sections. And if you

20592
20:54:16,830 --> 20:54:21,360
get lost, you can look at the
basic nft.test.js To follow

20593
20:54:21,360 --> 20:54:33,060
along. All right, welcome back.
Hopefully, you wrote some

20594
20:54:33,090 --> 20:54:36,570
awesome tests, taking the time
to actually do some of those

20595
20:54:36,570 --> 20:54:40,260
exercises is really going to
make you a much better engineer.

20596
20:54:40,440 --> 20:54:43,350
Following along with me, it's
awesome. But tinkering yourself

20597
20:54:43,350 --> 20:54:46,020
and trying to do everything
yourself is really what's gonna

20598
20:54:46,020 --> 20:54:49,380
make this stick. So I hope you
did pause the video. And hope

20599
20:54:49,380 --> 20:54:51,570
you did go ahead and try to
write the test for this

20600
20:54:51,570 --> 20:54:54,330
yourself, you've technically
just created a really

20601
20:54:54,330 --> 20:54:55,530
minimalistic NFT.

20602
20:54:55,620 --> 20:55:02,670
Great job. Let's kick things up
a notch. Let's move now to a

20603
20:55:02,670 --> 20:55:07,470
random IPFS hosted NFT where
we're going to do everything

20604
20:55:07,470 --> 20:55:11,460
pretty much programmatically. So
let's jump in. In our contracts,

20605
20:55:11,490 --> 20:55:16,080
we're going to create a new file
random IPFS, NFT, dot soul. Same

20606
20:55:16,080 --> 20:55:24,180
thing. spdx license identifier,
gonna be MIT pragma, solidity

20607
20:55:24,630 --> 20:55:27,720
carrot zero, point 8.7, or
whatever version you want to

20608
20:55:27,720 --> 20:55:35,340
use, will do contract random
IPFS NF? T, like so. So what is

20609
20:55:35,340 --> 20:55:39,780
this one going to do? So instead
of just minting any NFT, when we

20610
20:55:39,780 --> 20:55:47,280
meant an NF t, we will trigger a
chainlink VRF call to get us a

20611
20:55:47,370 --> 20:55:52,560
random number. Using that
number, we will get get a random

20612
20:55:52,650 --> 20:55:56,280
NF t that we're going to decide
on. And the random n of t that

20613
20:55:56,280 --> 20:55:59,640
we're going to use, it's going
to be either a pug a Shiva in

20614
20:55:59,640 --> 20:56:04,590
you, or a St. Bernard. So
whenever anybody mints NF T,

20615
20:56:04,590 --> 20:56:06,750
they're gonna get one of these
random three dogs. And we're

20616
20:56:06,750 --> 20:56:09,450
going to make this so that each
one of these dogs have a

20617
20:56:09,450 --> 20:56:12,600
different rarity, we're going to
make these dogs rare by

20618
20:56:12,600 --> 20:56:16,560
different amounts, say we want
the pug to be super rare, the

20619
20:56:16,560 --> 20:56:20,970
Shiva to be sort of rare, and
then the St. Bernard to be

20620
20:56:20,970 --> 20:56:23,700
pretty common. So probably it's
gonna be super rare Shiva in us

20621
20:56:23,700 --> 20:56:27,000
is gonna be sort of rare, St.
Bernard is going to be pretty

20622
20:56:27,000 --> 20:56:30,270
common, right? Or the most
common, if you will. So let's go

20623
20:56:30,270 --> 20:56:32,490
ahead and start building this,
we're probably gonna have to

20624
20:56:32,490 --> 20:56:36,330
make a function called like
request NF t, because we're

20625
20:56:36,330 --> 20:56:38,400
going to know that we're gonna
need to kick off a channeling

20626
20:56:38,400 --> 20:56:41,460
VRF request, we're probably
gonna have to make a function

20627
20:56:41,460 --> 20:56:47,070
fulfill random words, that's
going to take a un 256 Request

20628
20:56:47,190 --> 20:56:53,670
ID and a un 256. Array, memory
random words, as we've seen

20629
20:56:53,670 --> 20:56:57,300
before, we've done fulfill
random words in the past. And

20630
20:56:57,300 --> 20:57:00,240
let's let's even go one step
further, we'll make it so that

20631
20:57:00,270 --> 20:57:06,390
users have to pay to mint an NF
t. So this is going to be they

20632
20:57:06,390 --> 20:57:10,230
have to pay a certain amount of
eath to get the NFT and then the

20633
20:57:10,260 --> 20:57:14,700
owner of the contract and
withdraw the eath. So we're

20634
20:57:14,700 --> 20:57:17,220
basically paying the artists
here, we're paying the artists

20635
20:57:17,220 --> 20:57:20,670
to create these NF T's. And then
they can be the ones actually

20636
20:57:20,700 --> 20:57:23,790
actually withdraw the payment
for all these NF T's. And we're

20637
20:57:23,790 --> 20:57:28,020
also going to need, of course, a
function, token URI, which takes

20638
20:57:28,020 --> 20:57:32,640
a un 256. And this is once
again, same as our basic NFT

20639
20:57:32,640 --> 20:57:35,190
gonna be what this token
actually looks like. So let's go

20640
20:57:35,190 --> 20:57:37,470
ahead and get started creating
this. Now, because these red

20641
20:57:37,470 --> 20:57:40,140
lines are going to draw me
crazy. We're going to add some

20642
20:57:40,140 --> 20:57:45,120
visibility here, we'll make this
request NFT public fulfill

20643
20:57:45,120 --> 20:57:48,570
random words, we actually know
from the past is going to be

20644
20:57:48,570 --> 20:57:52,020
internal token URI is going to
be public. Let's build this

20645
20:57:52,020 --> 20:57:57,240
request NFT. And again, to
request a random number, go back

20646
20:57:57,240 --> 20:58:01,020
to EVM. Chains, we go to using
randomness, we can follow along

20647
20:58:01,050 --> 20:58:04,860
with the Dr. chain link again,
to figure out how to get this

20648
20:58:04,860 --> 20:58:07,110
random number. So since we know
we're going to be working with

20649
20:58:07,110 --> 20:58:11,370
chain link, we want to add at
chain link slash contracts. So

20650
20:58:11,370 --> 20:58:16,860
back in in our code base, we'll
add that in yarn add dash dash

20651
20:58:16,860 --> 20:58:21,840
dev at chain link slash
contracts, like so which was

20652
20:58:21,840 --> 20:58:25,440
perfect. And we can go ahead,
and we're going to import that

20653
20:58:25,440 --> 20:58:30,360
VRF consumer base V two and the
VRF coordinator interface into

20654
20:58:30,360 --> 20:58:33,000
our code because we know we're
going to use both of these. If

20655
20:58:33,000 --> 20:58:36,360
you want to just copy paste from
the docs, you absolutely can go

20656
20:58:36,360 --> 20:58:39,510
to pause here. And since we're
going to be using this view of

20657
20:58:39,510 --> 20:58:43,530
consumer base, we want to
inherit it. We're going to say

20658
20:58:43,590 --> 20:58:48,930
random IPFS and f t is V RF
consumer base V two and this

20659
20:58:48,930 --> 20:58:51,840
little, little wiggly line will
show up here saying This seems

20660
20:58:51,840 --> 20:58:54,540
to be override. So I'm just
gonna go ahead and add override

20661
20:58:54,540 --> 20:58:57,630
here. And this little wiggly
line is gonna stay there for a

20662
20:58:57,630 --> 20:59:00,300
little bit until we implement
the rest of the functions. So

20663
20:59:00,360 --> 20:59:03,390
let's go ahead and implement the
rest of those functions. Request

20664
20:59:03,390 --> 20:59:07,080
NFT, of course, is going to be
public here. And in order for us

20665
20:59:07,080 --> 20:59:10,950
to request an NF T, we're going
to need to call the coordinator

20666
20:59:10,980 --> 20:59:14,160
dot request random words where
we pass all this stuff in.

20667
20:59:14,730 --> 20:59:18,900
Right, so let's go ahead and get
all this stuff for our V REF

20668
20:59:18,900 --> 20:59:21,330
coordinator in our constructor,
so let's create a new

20669
20:59:21,330 --> 20:59:25,650
constructor. struct door. And
we're going to use the VRF

20670
20:59:25,680 --> 20:59:30,570
consumer base, the two
constructor to use to create our

20671
20:59:30,570 --> 20:59:34,260
constructor, the VRF consumer
base V two needs an address in

20672
20:59:34,260 --> 20:59:37,920
here for the VRF consumer base.
So we'll go ahead and we'll do

20673
20:59:37,950 --> 20:59:44,490
address VRF. Or did Nate Torre b
two. And then we'll pass this to

20674
20:59:44,490 --> 20:59:48,060
the VRF consumer base
constructor here, just by adding

20675
20:59:48,060 --> 20:59:51,270
that that red squiggly line has
gone away from me perfect. And

20676
20:59:51,270 --> 20:59:55,380
we want to save that address to
a global variable. So we can

20677
20:59:55,380 --> 20:59:59,820
call request random words on it.
So we're gonna go ahead up here,

20678
21:00:00,510 --> 21:00:06,300
we're going to say I underscore
var F chord. To me, Tor, we're

20679
21:00:06,300 --> 21:00:09,180
going to make this immutable VRF
coordinator. And we're going to

20680
21:00:09,180 --> 21:00:13,800
do it by saying VRF v2
interface, it's gonna be

20681
21:00:13,800 --> 21:00:19,320
private, immutable, you have
coordinator and then in our

20682
21:00:19,320 --> 21:00:24,390
constructor here, we're gonna
say IVF coordinator equals VRF,

20683
21:00:24,390 --> 21:00:29,130
coordinator v2 interface wrapped
around this like so. So we know

20684
21:00:29,130 --> 21:00:31,320
we're going to need this, we
know we're actually gonna need a

20685
21:00:31,320 --> 21:00:34,020
ton of these. So let's just add
all these variables in here,

20686
21:00:34,530 --> 21:00:37,890
we're gonna need the
coordinator, we're gonna need a

20687
21:00:37,890 --> 21:00:45,540
UNT 64 private, immutable, I
underscore subscription ID,

20688
21:00:45,960 --> 21:00:50,520
we're gonna need a bytes 32,
private, immutable,

20689
21:00:50,580 --> 21:00:57,330
I underscore gas lane, we're
gonna need a you int 32 private,

20690
21:00:57,480 --> 21:01:02,100
mutable, I underscore callback
gas limit, we're gonna need a

20691
21:01:02,100 --> 21:01:10,140
UNT 16 Private constants,
request confirmations, we're

20692
21:01:10,140 --> 21:01:15,240
gonna say it's gonna be three,
and then a un 32. Private

20693
21:01:16,050 --> 21:01:22,980
constant equals num words, which
is going to be one, and we'll

20694
21:01:22,980 --> 21:01:26,100
get this red squiggly line
saying it's mad at our our

20695
21:01:26,100 --> 21:01:30,630
constructor here. So let's go
ahead and add all of our

20696
21:01:30,690 --> 21:01:33,660
immutable variables in our
constructor. So we'll get the

20697
21:01:33,660 --> 21:01:39,300
VRF coordinator v2 from our
constructor will get the UNT 64

20698
21:01:39,330 --> 21:01:45,390
subscription ID, we'll get the
bytes 32 Gas lane, aka the key

20699
21:01:45,390 --> 21:01:52,530
hash, we'll get the un 256.
We'll do a UNT 32 callback gas

20700
21:01:52,560 --> 21:01:58,200
limit, then we'll go ahead and
do I subscription ID equals

20701
21:01:58,200 --> 21:02:06,210
subscription ID will do I gas
Lane equals gas lane will do I

20702
21:02:06,240 --> 21:02:10,950
call back gas limit equals call
back.

20703
21:02:11,730 --> 21:02:12,720
Yes limit.

20704
21:02:13,020 --> 21:02:15,960
Okay, a lot of variables set up.
But those are the variables that

20705
21:02:15,960 --> 21:02:18,900
we're going to need for the
chainlink VRF. Now we have all

20706
21:02:18,900 --> 21:02:22,770
these variables down in our
request. And if t we can request

20707
21:02:22,830 --> 21:02:26,460
a random number to get for our
random n of t, we're going to

20708
21:02:26,460 --> 21:02:32,550
say and our returns a yuan
tivity six Request ID. So in

20709
21:02:32,550 --> 21:02:37,920
here, we'll say request, Id this
request ID that we just

20710
21:02:37,920 --> 21:02:44,280
initialized I underscore VRF.
Core didn't a Tor dot request.

20711
21:02:44,880 --> 21:02:48,390
random words. And this should
look pretty familiar to what we

20712
21:02:48,390 --> 21:02:54,120
did in our lottery. I underscore
gas Lane comma, I underscore

20713
21:02:54,120 --> 21:03:03,450
subscription ID, comma, request,
con for nations. I underscore

20714
21:03:03,450 --> 21:03:08,670
callback gas limit. And then of
course num words and we can just

20715
21:03:08,790 --> 21:03:12,150
literally copy paste this from
the documentation or from our

20716
21:03:12,150 --> 21:03:16,620
last project, whatever you want
to do. So we are requesting this

20717
21:03:16,650 --> 21:03:26,070
random NFT here. Now here's the
thing, though, we want whoever

20718
21:03:26,070 --> 21:03:30,180
called this request function it
to be there and have tea, right.

20719
21:03:30,180 --> 21:03:34,470
And if we saw in our basic NFT,
when we minted the NFT, we call

20720
21:03:34,470 --> 21:03:38,160
this safe mint which needed the
owner and the token counter.

20721
21:03:38,340 --> 21:03:41,250
When we request a random number
four are NFT. It's going to

20722
21:03:41,250 --> 21:03:43,710
happen in two transactions,
right? We're going to request

20723
21:03:44,130 --> 21:03:47,460
and then later on we're going to
fulfill and it's going to be the

20724
21:03:47,460 --> 21:03:51,480
chain link node that's calling
fulfill random words. So if it

20725
21:03:51,480 --> 21:03:54,990
In the fulfill function, we just
do this safe meant message that

20726
21:03:54,990 --> 21:03:58,800
sender, the owner of this NFT is
actually going to be the chain

20727
21:03:58,800 --> 21:04:03,270
link node that fulfilled our
random words. So we don't want

20728
21:04:03,270 --> 21:04:07,710
that, what we want to do is we
want to create a mapping between

20729
21:04:07,710 --> 21:04:12,210
request IDs. And whoever called
this so that when we call

20730
21:04:12,210 --> 21:04:15,210
fulfill random words, which
returns with that exact same

20731
21:04:15,210 --> 21:04:19,620
request, ID, we can say, Ah,
okay, your request ID X, you

20732
21:04:19,620 --> 21:04:23,310
belong to the person who called
this request and of team, we're

20733
21:04:23,310 --> 21:04:26,460
going to create a mapping
between people who call this and

20734
21:04:26,460 --> 21:04:29,490
their request IDs so that when
we fulfill random words, we can

20735
21:04:29,490 --> 21:04:33,630
properly assign the dogs to
them. So up at the top, right

20736
21:04:33,630 --> 21:04:36,540
underneath here, I'm going to
call them VRF helpers, we're

20737
21:04:36,540 --> 21:04:42,030
going to create a mapping of un
256. To an address, we'll make

20738
21:04:42,030 --> 21:04:44,670
this public which we should make
it private, but we'll just make

20739
21:04:44,670 --> 21:04:50,490
it public s underscore Request
ID to sender. And then when we

20740
21:04:50,490 --> 21:04:56,790
call this request, and F T, will
set the request ID to sender of

20741
21:04:56,790 --> 21:05:03,390
Request ID equals to message dot
sender. Now, when the chain link

20742
21:05:03,390 --> 21:05:07,530
node responds with fulfill
random words, what we can do is

20743
21:05:07,530 --> 21:05:12,510
we can say address dog owner or
the NFT dog owner is going to be

20744
21:05:12,510 --> 21:05:19,140
equal to s Request ID to sender
of Request ID. This way, it's

20745
21:05:19,140 --> 21:05:21,150
not going to be the chain link
nodes that are going to own the

20746
21:05:21,150 --> 21:05:26,130
dog, but it's gonna be whoever
actually called requests. NFT.

20747
21:05:26,430 --> 21:05:29,970
Okay, cool. So we have a way to
request a random number for our

20748
21:05:29,970 --> 21:05:34,260
random NF t. Now, let's go ahead
and mint this random dog, this

20749
21:05:34,260 --> 21:05:40,170
random NF T for this for this
user. So we have the user now

20750
21:05:40,200 --> 21:05:43,500
using this mapping, what else do
we need? Well, we're gonna need

20751
21:05:43,500 --> 21:05:46,860
the token counter here. Let's go
ahead and we'll create a token

20752
21:05:46,860 --> 21:05:49,320
counter variable. So we'll
scroll up and make a new

20753
21:05:49,320 --> 21:05:56,040
section. And we'll say, un 256.
And then again, we'll just make

20754
21:05:56,040 --> 21:05:58,860
a lot of these public just to
make it easier, but you might

20755
21:05:58,860 --> 21:06:01,170
want to make this private and
use that same syntax we were

20756
21:06:01,170 --> 21:06:04,830
doing before do s underscore
since this is a stored variable,

20757
21:06:05,550 --> 21:06:09,180
token counter. And we'll grab
this token counter. And we'll

20758
21:06:09,180 --> 21:06:15,540
say you went to 56. New token ID
equals as token counter, now

20759
21:06:15,540 --> 21:06:19,350
that we have the dog owner, and
the token ID, we can go ahead

20760
21:06:19,350 --> 21:06:21,690
and mint this MFT. So we'll do
safe mint.

20761
21:06:23,490 --> 21:06:30,120
Owner, new token, ID and then
safe man is going to be squiggly

20762
21:06:30,120 --> 21:06:34,380
because our code is gonna say,
what is this? What is the safe

20763
21:06:34,380 --> 21:06:37,140
mint function? Where did you get
this from? Well, we're gonna

20764
21:06:37,140 --> 21:06:39,300
need to get it from open
Zeppelin again. So we're going

20765
21:06:39,300 --> 21:06:44,190
to go ahead and do import at
open Zeppelin slash contracts

20766
21:06:44,220 --> 21:06:53,010
slash token slash ERC. 721 slash
ERC. 720 one.so We'll say a

20767
21:06:53,010 --> 21:06:58,950
random IPFS empty is Vera of
consumer base, and also ERC 721

20768
21:06:59,040 --> 21:07:02,820
In our constructor, right after
our V RF consumer base, we're

20769
21:07:02,820 --> 21:07:08,550
going to put the ERC 721. And
same thing, we need to give it a

20770
21:07:08,550 --> 21:07:15,420
name and a symbol. So we'll call
this random IPFS NF T. Comma,

20771
21:07:15,450 --> 21:07:19,530
we'll just do Rin for random
IPFS NF team. Now safe mint

20772
21:07:19,530 --> 21:07:22,140
actually works and then it's
gonna be mad at me for this. So

20773
21:07:22,140 --> 21:07:24,660
I'm gonna do override just let
it stop getting mad at me.

20774
21:07:24,900 --> 21:07:31,020
public view override turns
string memory. Just that

20775
21:07:31,380 --> 21:07:34,680
squiggly line goes way. Okay,
cool. So great. So now we can

20776
21:07:34,680 --> 21:07:43,890
safe mint to the dog owner this
new token ID Are we done with

20777
21:07:43,890 --> 21:07:47,880
this? Absolutely not. Why not?
Well, we don't know what this

20778
21:07:47,910 --> 21:07:51,120
token looks like. And what we
set above is we want to actually

20779
21:07:51,150 --> 21:07:54,930
make these dogs different
rarities. So how do we actually

20780
21:07:54,930 --> 21:07:58,950
create these dogs with different
rarities, all we could do is we

20781
21:07:58,950 --> 21:08:03,420
create a chance array an array
to show the different chances of

20782
21:08:03,420 --> 21:08:06,780
these different dogs here. So
down below, we're going to

20783
21:08:06,780 --> 21:08:12,060
create a function and it's going
to be a public pure function

20784
21:08:12,570 --> 21:08:20,010
called get chance array. And
this is going to return you went

20785
21:08:20,790 --> 21:08:26,190
to 46 of size three in memory.
And this chance array is going

20786
21:08:26,190 --> 21:08:29,130
to represent the different
chances of the different dogs.

20787
21:08:29,310 --> 21:08:35,610
So we're gonna say return
10 3100 Or we're gonna say Max

20788
21:08:35,820 --> 21:08:37,500
chance value.

20789
21:08:38,760 --> 21:08:42,090
And up at the top under empty
variables. We're gonna say you

20790
21:08:42,090 --> 21:08:48,840
went to 56 internal constant,
Max chance value equals 100. So

20791
21:08:48,840 --> 21:08:53,430
by making this array, we're
saying index Zero has a 10 percent

20792
21:08:53,430 --> 21:08:58,680
chance of happening. We're
saying index one has a 20 percent

20793
21:08:58,680 --> 21:09:03,300
chance of happening because it's
going to be 30 minus 10. And

20794
21:09:03,300 --> 21:09:07,290
then we're saying index two is
going to have a 60 percent chance of

20795
21:09:07,290 --> 21:09:12,150
happening, because it's going to
be 10 plus 30. minus this 100.

20796
21:09:12,390 --> 21:09:15,690
This array that identified the
percentages of the different

20797
21:09:15,690 --> 21:09:20,160
dogs. We're saying the pug is
going to have a 10 percent chance,

20798
21:09:20,490 --> 21:09:25,530
Shiva in you a 20 percent chance and
the St. Bernard a 70 percent chance,

20799
21:09:25,620 --> 21:09:29,100
we're going to use it to give
this token ID that we just

20800
21:09:29,100 --> 21:09:32,370
minted its dog breed. So we're
gonna create a new function

20801
21:09:32,370 --> 21:09:37,380
called Get breed from modded
RNG. And the reason we're

20802
21:09:37,380 --> 21:09:41,400
calling a get breed from modded
RNG is exactly the same way. In

20803
21:09:41,400 --> 21:09:44,190
our lottery. We got a random
number, we're gonna say you went

20804
21:09:44,190 --> 21:09:53,070
to 56 modded RNG equals random
words of zero mod Max chance

20805
21:09:53,070 --> 21:09:57,780
value, we're going to mod any
number we get by 100. Doing it

20806
21:09:57,780 --> 21:10:00,750
like this, we're always going to
get a number between zero and

20807
21:10:00,750 --> 21:10:04,710
99. If random words zero mod Max
Chin's value is going to be

20808
21:10:04,710 --> 21:10:08,940
seven. That means we're gonna
get a pug. If we get 88. That

20809
21:10:08,940 --> 21:10:14,310
means we're gonna get a St.
Bernard, if we get a 45. We're

20810
21:10:14,310 --> 21:10:19,170
gonna get a what? That's right,
a St. Bernard, if we got a 12

20811
21:10:19,830 --> 21:10:24,600
We're getting a Shiva in you. If
the mod ID number that we get by

20812
21:10:24,600 --> 21:10:29,580
modeling this random word is
between zero and 10. It's going

20813
21:10:29,580 --> 21:10:36,000
to be pug between 10 and 30.
shiba inu between 30 and 100 St.

20814
21:10:36,000 --> 21:10:39,480
Bernard and that's how we get
these randomness values. So now

20815
21:10:39,480 --> 21:10:42,510
that we have this modded RNG, we
have this mod ID number that's

20816
21:10:42,510 --> 21:10:46,500
going to be between zero and 99.
Okay, this function called Get

20817
21:10:46,500 --> 21:10:53,280
breed from modded RNG. And this
is going to take the UN 256 mod

20818
21:10:53,280 --> 21:10:57,090
ID RNG will make this a public
pure function, and it's going to

20819
21:10:57,090 --> 21:11:02,640
return the breed of the dog. Now
the breed of the dog is going to

20820
21:11:02,640 --> 21:11:05,880
be an email similar to raffle
state that we did before. We're

20821
21:11:05,880 --> 21:11:08,190
going to do this right at the
top since this is going to be

20822
21:11:08,190 --> 21:11:13,740
what a type declaration or say
enum. Read, we're going to say

20823
21:11:14,220 --> 21:11:18,000
the zero with number is going to
the pug. The ones number is

20824
21:11:18,000 --> 21:11:22,620
going to be the Shiva in you.
And then the second one is going

20825
21:11:22,620 --> 21:11:27,270
to be the St. Bernard. So we
have the pug which is zero to

20826
21:11:27,270 --> 21:11:33,360
10. Shiva in you 10 to 30 St
Bernard 30 to 100. So get breed

20827
21:11:33,360 --> 21:11:38,070
from modded RNG public pure
returns breed. So we're gonna

20828
21:11:38,070 --> 21:11:40,980
loop through this we're gonna
say you intuitive six cumulative

20829
21:11:40,980 --> 21:11:49,170
sum equals zero, we'll say you
went to 56. size three memory

20830
21:11:49,710 --> 21:11:58,050
chance array equals yet chance
array. So we're getting that

20831
21:11:58,050 --> 21:12:00,450
chance array. So we're going to
create a little for loop we're

20832
21:12:00,450 --> 21:12:06,510
gonna say for you went to 56 i
It's gonna start with zero is

20833
21:12:06,510 --> 21:12:11,670
going to be less than the chance
array dot length. i plus plus

20834
21:12:11,670 --> 21:12:16,200
ran through that for loop here.
And we're going to say if modded

20835
21:12:17,730 --> 21:12:26,280
RNG is greater than or equal to
this cumulative sum and modded

20836
21:12:26,310 --> 21:12:34,770
RNG is less than the cumulative
sum plus chance array plus

20837
21:12:34,770 --> 21:12:41,070
wherever we are on the chance
array, then return breed of AI.

20838
21:12:41,220 --> 21:12:44,700
And then outside of this, we're
gonna say cume cumulative sum

20839
21:12:44,760 --> 21:12:49,650
plus equals chance array of I,
let's say moderate orangey

20840
21:12:49,920 --> 21:12:53,760
equals 25. And if it's 25, it
should be a Shiva in you,

20841
21:12:54,030 --> 21:12:58,590
because that's between 10 and
30. So we're saying if mod RNG,

20842
21:12:58,650 --> 21:13:03,030
which is 25 is greater than or
equal to cumulative sum, which

20843
21:13:03,030 --> 21:13:07,860
right now is zero, and it's less
than n, the Moto G is less than

20844
21:13:07,860 --> 21:13:12,240
the cumulative sum plus the
chance array of I which is going

20845
21:13:12,240 --> 21:13:17,130
to be 10 Return breed of I
cumulative sum is currently zero

20846
21:13:17,220 --> 21:13:24,120
plus chance of I which is 10 is
going to be 10. And this is not

20847
21:13:24,120 --> 21:13:28,140
true because Morarji is 25. So
since this is not true, we're

20848
21:13:28,140 --> 21:13:31,170
going to move to the second step
which is just cumulative sum,

20849
21:13:31,530 --> 21:13:35,400
plus equals chance right? So
cumulative sum will now be equal

20850
21:13:35,400 --> 21:13:38,070
to 10. And then we reached the
end of the for loop. So we'll

20851
21:13:38,070 --> 21:13:42,840
restart i is now one, so let's
try this again mod RNG is

20852
21:13:42,840 --> 21:13:45,690
greater than or equal to
cumulative sum Okay, that is

20853
21:13:45,690 --> 21:13:52,770
true cumulative sum is 10. Mod
RNG is 25. And mod RNG is less

20854
21:13:52,770 --> 21:13:57,900
than cumulative sum plus chance
re of AI, which is 30. So we're

20855
21:13:57,900 --> 21:14:03,870
saying 25 is less than 10 plus
30, which is 40. Return breed of

20856
21:14:03,870 --> 21:14:08,880
AI, this is true. So breed of AI
would be true and AI at the

20857
21:14:08,880 --> 21:14:12,330
moment is one. And if we scroll
up, that's indeed the Shiva in

20858
21:14:12,330 --> 21:14:15,180
you. So that's how this function
is going to work, it's going to

20859
21:14:15,180 --> 21:14:19,260
get us the breed from that
modeling bit. And then if for

20860
21:14:19,260 --> 21:14:22,770
some reason, some really wacky
stuff happens here, we want to

20861
21:14:22,770 --> 21:14:25,470
just go ahead and add a revert,
right, because we should be

20862
21:14:25,470 --> 21:14:28,500
returning a breed. But if we
don't return a breed, we should

20863
21:14:28,500 --> 21:14:31,440
just revert. So we're going to
create a new error at the top,

20864
21:14:32,220 --> 21:14:38,700
random IPFS NFT underscore
underscore range out of bounds.

20865
21:14:39,840 --> 21:14:42,660
The down below, we're just going
to say if for some reason you

20866
21:14:42,660 --> 21:14:47,790
don't return anything, just do a
revert random IPFS NFT range out

20867
21:14:47,790 --> 21:14:51,210
of bounds. And now we have this
function. Okay, so now we can

20868
21:14:51,210 --> 21:14:54,900
get the brief from a modded RNG.
So pack in our fulfill random

20869
21:14:54,900 --> 21:14:59,370
words function. Let's go ahead,
and we'll say, we'll uncomment

20870
21:14:59,370 --> 21:15:05,880
this will say breed, dog breed,
equals get breed for modded RNG

20871
21:15:06,300 --> 21:15:10,830
pass the modded RNG here, and
let's move this safe mint down

20872
21:15:11,130 --> 21:15:15,120
below us getting the dog breeder
so we can mint and add the dog

20873
21:15:15,120 --> 21:15:17,490
breed at the same time. So we're
gonna go ahead and safe mint

20874
21:15:17,490 --> 21:15:17,850
here.

20875
21:15:23,040 --> 21:15:26,370
Now we can do a few things to
set this dog breed here, we

20876
21:15:26,370 --> 21:15:30,060
create a mapping between the dog
breed and the token URI, and

20877
21:15:30,060 --> 21:15:34,650
then have that reflected in this
token URI function. Or what we

20878
21:15:34,650 --> 21:15:38,220
could do is we could just call a
function called Set token URI

20879
21:15:38,250 --> 21:15:41,670
and the openzeppelin ERC 721 You
have to set this token your eye

20880
21:15:41,670 --> 21:15:44,880
function yourself. However,
there is an extension in the

20881
21:15:44,880 --> 21:15:50,520
open Zeppelin code called ERC.
721 Uri storage and this version

20882
21:15:50,520 --> 21:15:55,620
of the ERC. 721 comes with a
function called Set token URI

20883
21:15:55,680 --> 21:15:59,460
where we can just call set token
URI. And this will automatically

20884
21:15:59,490 --> 21:16:04,020
update that tokens token URI to
whatever you set it as. So we're

20885
21:16:04,020 --> 21:16:08,850
going to use this extension this
set token URI in our contract.

20886
21:16:09,150 --> 21:16:12,750
And the way that we do this is
instead of doing token ERC 721

20887
21:16:12,780 --> 21:16:21,210
Year C 721 that soul will do
token ERC 721 slash extensions

20888
21:16:21,240 --> 21:16:27,810
slash your C 721 Your arise
storage. That's all. And we'll

20889
21:16:27,810 --> 21:16:35,880
say random IPFS is ERC 721 your
rice storage. Now what's cool is

20890
21:16:35,880 --> 21:16:41,910
that our constructor will still
just use ERC. 721 Because ERC

20891
21:16:41,910 --> 21:16:48,240
721 Uri storage is extending ERC
721. And then this contract just

20892
21:16:48,240 --> 21:16:52,320
comes with some additional
functions like set token URI. So

20893
21:16:52,320 --> 21:16:56,700
right after safe meant, we're
actually going to call set token

20894
21:16:56,730 --> 21:17:03,330
URI with this new item ID. And
then we're going to give it that

20895
21:17:03,360 --> 21:17:08,280
breeds token URI, we're gonna
give it a string here that

20896
21:17:08,310 --> 21:17:11,730
relates to whatever breed that
we just got based off the dog

20897
21:17:11,730 --> 21:17:15,690
breed here. Now, to do this,
what we could do is right at the

20898
21:17:15,690 --> 21:17:19,920
top and our NFT variables, we
could create a string array,

20899
21:17:20,040 --> 21:17:25,170
internal, Alt S dog token, your
eyes, we're gonna make this

20900
21:17:25,170 --> 21:17:29,370
constant where it would just be
this array of all these strings

20901
21:17:29,370 --> 21:17:32,400
that we created. But maybe in
our code, we want to make this a

20902
21:17:32,400 --> 21:17:36,150
little bit more variable. And we
want to parameterize this. And

20903
21:17:36,150 --> 21:17:38,280
that's exactly what we're going
to do. So we're going to create

20904
21:17:38,280 --> 21:17:42,360
this string array, internal s
underscore dog token, your eyes,

20905
21:17:42,510 --> 21:17:47,400
which is just going to be a list
of these URLs are these URLs

20906
21:17:47,400 --> 21:17:50,250
that point to stuff like this,
we're going to do that in our

20907
21:17:50,250 --> 21:17:54,840
code so that when we upload any
image that we want to IPFS we

20908
21:17:54,840 --> 21:17:58,680
can then upload this s dog token
you arise accordingly. In our

20909
21:17:58,680 --> 21:18:00,720
constructor, we're actually
going to take in another

20910
21:18:00,720 --> 21:18:08,610
parameter called a a string of
size three, memory dog token you

20911
21:18:08,610 --> 21:18:12,840
our eyes, we're going to pass as
a constructor parameter, these

20912
21:18:12,840 --> 21:18:17,160
different dog token you arise.
So we're going to pass it this

20913
21:18:17,160 --> 21:18:21,240
list of dog token arise. Of
course zero is going to be the

20914
21:18:21,240 --> 21:18:24,300
token URI of the pug. One is
going to be the Shiva in you and

20915
21:18:24,300 --> 21:18:26,970
two, of course is going to be
the St. Bernard. So we're going

20916
21:18:26,970 --> 21:18:31,890
to pass it this list of dog
token your eyes, and then down

20917
21:18:31,890 --> 21:18:37,050
in set token your eye from that,
that list that we created. We're

20918
21:18:37,050 --> 21:18:40,590
going to set the token URI of
this token based off of that

20919
21:18:40,590 --> 21:18:48,150
array of the UN 256 version of
that breed are casting this dog

20920
21:18:48,150 --> 21:18:53,520
breed back into you and 256 to
get its index. With that we now

20921
21:18:53,520 --> 21:18:57,120
have a way to actually,
programmatically get a provably

20922
21:18:57,120 --> 21:19:00,630
random NFT with different
randomness for different one of

20923
21:19:00,630 --> 21:19:09,510
these NF T's. Now, let's go back
up to our little, our little

20924
21:19:09,510 --> 21:19:13,110
comments we made here, limited
NFT, we trigger a chain link or

20925
21:19:13,110 --> 21:19:16,890
a VRF. To call random number, we
got the rarities down, we got

20926
21:19:16,890 --> 21:19:20,160
the minting down. Awesome. Okay,
we don't have this part, though.

20927
21:19:20,760 --> 21:19:24,450
Users have to pay to Minton NF T
and the owner of the contract

20928
21:19:24,450 --> 21:19:26,910
can withdraw the eath. Okay,
this is stuff we've already done

20929
21:19:26,910 --> 21:19:29,250
before, this should be pretty
familiar here. So back in our

20930
21:19:29,250 --> 21:19:32,880
request NF t function, we'll
make this a public payable. And

20931
21:19:32,880 --> 21:19:38,520
all we'll need to do is we'll
just say if message dot value is

20932
21:19:38,520 --> 21:19:41,880
less than some mint fee, and
actually let's go back to our

20933
21:19:41,880 --> 21:19:46,560
constructor, we'll create a mint
fee, you int 256 Mint fee.

20934
21:19:48,060 --> 21:19:53,670
And then we'll do you in 256
internal I underscore mint fee,

20935
21:19:53,970 --> 21:19:56,880
we'll make this immutable. And
then we'll just say I'm

20936
21:19:56,880 --> 21:20:01,050
intervene equals mint fee. If
message of value is less than

20937
21:20:01,050 --> 21:20:06,000
mint fee, you already know we're
going to do a revert, need more

20938
21:20:06,360 --> 21:20:11,910
eath sent, we'll create a new
air called need more eath sent

20939
21:20:12,000 --> 21:20:16,920
and actually we'll do air random
IPFS and ft underscore

20940
21:20:16,920 --> 21:20:21,900
underscore need more II sent
like that, copy this, paste it

20941
21:20:21,900 --> 21:20:25,800
here and boom. So now just by
adding this line, this is now a

20942
21:20:25,800 --> 21:20:29,970
payable function. And people
have to pay some mint fee to

20943
21:20:30,000 --> 21:20:34,230
mint their randomized NF t. Now
we're also going to want a way

20944
21:20:34,230 --> 21:20:38,130
for owner to withdraw. So we'll
scroll down a little bit. We'll

20945
21:20:38,130 --> 21:20:43,110
scroll down to here, CREATE
FUNCTION withdraw, this will be

20946
21:20:43,110 --> 21:20:46,770
public. And we only want the
owner to do this. So we could

20947
21:20:46,770 --> 21:20:51,120
create our modifier, you know, a
modifier again only owner, or

20948
21:20:51,450 --> 21:20:53,520
what we could do is use
openzeppelin. Again,

20949
21:20:53,670 --> 21:20:58,380
openzeppelin also comes with
some access code, or one of

20950
21:20:58,380 --> 21:21:03,390
them's this ownable code, and in
here, it already has the only

20951
21:21:03,390 --> 21:21:06,270
owner modifier for us, we're
just gonna go ahead and import

20952
21:21:06,270 --> 21:21:12,030
that as well. We'll do import at
openzeppelin slash contracts

20953
21:21:12,060 --> 21:21:17,490
slash access slash ownable dot
som, and we'll say contract

20954
21:21:17,520 --> 21:21:23,160
random IPFS. And if t is this,
this come ownable. And then

20955
21:21:23,160 --> 21:21:26,640
we'll make our withdrawal
function only owner. And so

20956
21:21:26,640 --> 21:21:29,160
whoever deployed this contract
is going to be set to being the

20957
21:21:29,160 --> 21:21:32,430
owner, which is what we want.
And when here, same as what

20958
21:21:32,430 --> 21:21:39,210
we've done, we'll do u and 256.
amount equals address this dot

20959
21:21:39,210 --> 21:21:46,200
balance. And then we'll do bull
success comma equals payable,

20960
21:21:47,010 --> 21:21:53,010
message dot sender, but call
value is going to be a mount and

20961
21:21:53,010 --> 21:21:56,880
then we're going to call
nothing. And then we're going to

20962
21:21:56,880 --> 21:22:04,170
say if not success. And we're
going to revert with transfer

20963
21:22:04,170 --> 21:22:09,060
failed, then on top, we're going
to do error transfer failed. I'm

20964
21:22:09,060 --> 21:22:14,820
just going to copy this a little
quicker, like so and then come

20965
21:22:14,820 --> 21:22:18,600
back down to transfer failed
paste it here. So we're gonna

20966
21:22:18,600 --> 21:22:22,140
revert random IPFS. And if T
transfer failed, perfect, so now

20967
21:22:22,140 --> 21:22:25,740
we have a withdrawal function
and a way for people to pay for

20968
21:22:25,740 --> 21:22:30,360
art here. Now we don't need this
token URI anymore, because when

20969
21:22:30,360 --> 21:22:35,190
we call set token URI, this is
going to set the token URI for

20970
21:22:35,190 --> 21:22:39,750
us because in the back ERC 721
Uri storage already has that

20971
21:22:39,750 --> 21:22:42,840
function laid out. So our
contract will already have the

20972
21:22:42,840 --> 21:22:45,630
token URI function and we don't
have to explicitly set it

20973
21:22:45,660 --> 21:22:48,270
ourselves. But we do have to
explicitly set some other ones.

20974
21:22:48,750 --> 21:22:52,830
We are going to need function
get meant fee will be a public

20975
21:22:52,860 --> 21:23:01,290
view turns you went to 36 turn I
meant fee will need function get

20976
21:23:01,290 --> 21:23:06,300
dog token your eyes, you went to
36 index, this will be a public

20977
21:23:06,300 --> 21:23:10,980
view which will returns the
string memory return s

20978
21:23:10,980 --> 21:23:17,790
underscore dog token your eyes
index will need function get

20979
21:23:17,850 --> 21:23:24,180
token counter. This will be a
public view turns you into 56

20980
21:23:24,930 --> 21:23:29,730
Return s underscore token
counter. Alright, so we just

20981
21:23:29,730 --> 21:23:32,790
wrote a ton of code here. And of
course as we taught you before,

20982
21:23:32,790 --> 21:23:36,630
we also are going to need some
events. So when we request an NF

20983
21:23:36,630 --> 21:23:43,140
T, we're going to emit an event.
So we'll omit NF T requested and

20984
21:23:43,140 --> 21:23:47,460
then we'll pass it the request.
ID in the message dot sender. So

20985
21:23:47,460 --> 21:23:56,370
up at the top will say event NF
T requested. So pet, take a un

20986
21:23:56,370 --> 21:24:02,040
256 index Request ID, and then
an address requester. And then

20987
21:24:02,040 --> 21:24:05,070
we're also going to make an
event for NF T minted for when

20988
21:24:05,070 --> 21:24:09,120
it's finally minted. And it's
going to take a breed, dog

20989
21:24:09,120 --> 21:24:16,350
breed, and an address, mentor.
So write down when we fulfill,

20990
21:24:16,800 --> 21:24:19,080
we're going to emit NFT. minted.

20991
21:24:20,130 --> 21:24:24,360
And it's going to take that dog
breed and then the dog owner.

20992
21:24:29,970 --> 21:24:34,110
Okay, we've just written a lot
of code here. So let's go ahead

20993
21:24:34,110 --> 21:24:37,530
and see if we can compile this
with H H compile, or yarn

20994
21:24:37,530 --> 21:24:40,920
Hardhead, compile. And Wow,
looks like we went ahead and

20995
21:24:40,920 --> 21:24:44,280
compiled it. This is great. So
all of our code now looks good.

20996
21:24:44,310 --> 21:24:46,590
Now might be a good time to take
a quick breather, we've just

20997
21:24:46,590 --> 21:24:49,350
written a lot of code. And it
might be good to just go over

20998
21:24:49,350 --> 21:24:52,140
all the stuff that we just went
through. A lot of this is

20999
21:24:52,140 --> 21:24:55,080
familiar, but it's still really
good to redo some of this stuff

21000
21:24:55,080 --> 21:24:58,020
and really get that muscle
memory and for these credit, an

